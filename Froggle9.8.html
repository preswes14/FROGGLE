<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="apple-mobile-web-app-title" content="FROGGLE"/>
<meta name="theme-color" content="#14b8a6"/>
<link rel="manifest" href="manifest.json"/>
<link rel="apple-touch-icon" href="assets/tapo.png"/>
<link rel="icon" type="image/png" href="assets/tapo.png"/>
<title>FROGGLE v9.8 - BETA RELEASE</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body { font-family: -apple-system, sans-serif; background: #d9cab1; color: #1c1b19; position: fixed; width: 100%; height: 100%; overflow: hidden; }
.header { padding: 0.5rem; background: linear-gradient(#fff, #f7f1e3); border-bottom: 2px solid #bda; display: flex; justify-content: space-between; font-size: 0.8rem; }
.game-area { height: calc(100vh - 44px); overflow-y: auto; padding: 0.5rem; -webkit-overflow-scrolling: touch; }
.btn { padding: 1rem; border: 3px solid #000; border-radius: 8px; background: #2c63c7; color: white; font-weight: bold; font-size: 1.1rem; min-height: 56px; width: 100%; margin-bottom: 0.75rem; cursor: pointer; }
.btn:active { transform: scale(0.98); opacity: 0.9; }
.btn.safe { background: #22c55e; }
.btn.risky { background: #f59e0b; }
.btn.danger { background: #dc2626; }
.btn.secondary { background: #6b7280; }
.choice { border: 3px solid #000; padding: 1rem; margin-bottom: 0.75rem; border-radius: 8px; background: white; min-height: 60px; }
.choice:active { transform: scale(0.98); background: #f0f0f0; }
.neutral-container { background: white; border: 3px solid #000; border-radius: 8px; padding: 1.5rem; margin: 1rem auto; max-width: 500px; }
.neutral-title { font-size: 1.5rem; font-weight: bold; text-align: center; margin-bottom: 1rem; }
.neutral-desc { font-size: 0.95rem; line-height: 1.5; margin-bottom: 1.5rem; }
.neutral-outcome { font-size: 0.9rem; padding: 0.75rem; background: #f0f0f0; border-radius: 6px; margin-bottom: 1rem; }
.dice-roll { font-size: 1.2rem; font-weight: bold; text-align: center; padding: 1rem; background: #2c63c7; color: white; border-radius: 6px; margin: 1rem 0; }
/* Combat layout */
.combat-grid { display: flex; gap: 0.75rem; margin-bottom: 1rem; justify-content: center; }
.column { display: flex; flex-direction: column; gap: 0.5rem; align-items: center; }
.column.heroes { flex: 0 0 auto; }
.column.enemies { flex: 0 0 auto; }
.combat-lane {
  background: rgba(255,255,255,0.05);
  border-top: 3px solid rgba(0,0,0,0.3);
  border-bottom: 3px solid rgba(255,255,255,0.2);
  border-left: 2px solid rgba(0,0,0,0.2);
  border-right: 2px solid rgba(0,0,0,0.2);
  border-radius: 6px;
  padding: 0.75rem;
  margin-bottom: 0.75rem;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15), inset 0 -2px 4px rgba(255,255,255,0.1);
  position: relative;
}
.combat-lane:not(:last-child)::after {
  content: '';
  position: absolute;
  bottom: -0.75rem;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, rgba(0,0,0,0.3) 20%, rgba(0,0,0,0.3) 80%, transparent);
}
.card { width: 100%; max-width: 320px; border: 3px solid #000; border-radius: 8px; padding: 0.5rem; min-height: 70px; font-size: 0.85rem; transition: transform 0.1s ease; }
.card.hero { background: #2c63c7; color: white; }
.card.enemy { background: #b64141; color: white; }
.card.active { box-shadow: 0 0 0 4px gold; animation: pulse-glow 1s infinite; }
.card.selectable { cursor: pointer; box-shadow: 0 0 0 3px #22c55e; }
.card.selectable:active { transform: scale(0.98); }
.card.targetable { cursor: pointer; }
.card.targetable:active { transform: scale(0.98); }
.card.targeted { box-shadow: 0 0 0 4px lime; }
.card.acted { opacity: 0.6; }
.card.last-stand { border-color: #dc2626; box-shadow: 0 0 0 3px #dc2626; }
.card.hero.targetable { box-shadow: 0 0 0 3px #3b82f6; }
.card.enemy.targetable { box-shadow: 0 0 0 3px #dc2626; }
.card.hero.targeted { box-shadow: 0 0 0 4px #60a5fa; }
.card.enemy.targeted { box-shadow: 0 0 0 4px #ef4444; }
.card.hit-flash { animation: hit-animation 0.3s ease; }
@keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 0 4px gold; } 50% { box-shadow: 0 0 0 8px gold; } }
@keyframes hit-animation {
  0% { transform: translateX(0); filter: brightness(2); }
  25% { transform: translateX(-8px); }
  50% { transform: translateX(0); filter: brightness(1.5); }
  75% { transform: translateX(-4px); }
  100% { transform: translateX(0); filter: brightness(1); }
}
.sigil-row { display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; margin-top: 4px; }
.sigil-divider { width: 100%; height: 1px; background: rgba(255,255,255,0.3); margin: 4px 0; }
.sigil { border: 3px solid; border-radius: 6px; padding: 4px 8px; font-size: 0.85rem; display: inline-block; margin: 2px; min-height: 28px; font-weight: 900; background: transparent; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
.sigil.clickable { cursor: pointer; }
.sigil.clickable:active { transform: scale(0.95); }
.sigil.active-action { box-shadow: 0 0 12px #fbbf24; animation: pulse-action 0.8s infinite; }
.sigil.l0 { color: #666; border-color: #666; opacity: 0.6; }
.sigil.l1 { color: #1e40af; border-color: #1e40af; }
.sigil.l2 { color: #0d9488; border-color: #0d9488; }
.sigil.l3 { color: #9333ea; border-color: #9333ea; }
.sigil.l4 { color: #d97706; border-color: #d97706; text-shadow: 0 0 8px rgba(217,119,6,0.4); }
.sigil.l5 {
  background: linear-gradient(90deg, #ff0080, #ff8c00, #40e0d0, #ff0080);
  background-size: 300% 100%;
  animation: rainbow-shift 3s linear infinite;
  border: 2px solid;
  border-image: linear-gradient(90deg, #ff0080, #ff8c00, #40e0d0, #ff0080) 1;
  color: white;
  text-shadow: 0 0 12px rgba(255,255,255,0.8), 0 0 24px rgba(255,0,128,0.6);
  font-weight: bold;
}
@keyframes rainbow-shift {
  0% { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}
.sigil.engraved { color: #6b7280; border-color: #9ca3af; font-style: italic; opacity: 0.7; background: rgba(107,114,128,0.1); }
.sigil.asterisk-primed { box-shadow: 0 0 8px #fbbf24; animation: pulse-asterisk 1s infinite; }
@keyframes pulse-asterisk { 0%, 100% { box-shadow: 0 0 8px #fbbf24; } 50% { box-shadow: 0 0 16px #fbbf24; } }
@keyframes pulse-action { 0%, 100% { box-shadow: 0 0 12px #fbbf24; } 50% { box-shadow: 0 0 20px #fbbf24; } }
.toast { position: fixed; bottom: 20px; right: 20px; background: linear-gradient(#fff, #f7f1e3); border: 2px solid #bda; border-radius: 6px; padding: 1rem 1.5rem; font-weight: bold; box-shadow: 0 4px 12px rgba(0,0,0,0.2); opacity: 0; transform: translateY(20px); transition: all 0.3s; z-index: 10000; max-width: 80%; }
.toast.show { opacity: 1; transform: translateY(0); }
.turn-locked { pointer-events: none; opacity: 0.7; }
.tutorial-modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 20000; display: flex; align-items: center; justify-content: center; }
.tutorial-modal { background: linear-gradient(#fff, #f7f1e3); border: 4px solid #fbbf24; border-radius: 12px; padding: 2rem; max-width: 600px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); text-align: center; }
.tutorial-modal h2 { margin-top: 0; color: #6b4423; }
.tutorial-modal p { margin: 1rem 0; font-size: 1.1rem; line-height: 1.6; }
.tutorial-modal button { margin-top: 1.5rem; padding: 0.75rem 2rem; font-size: 1.1rem; font-weight: bold; background: #14b8a6; color: #fff; border: 2px solid #0f766e; border-radius: 8px; cursor: pointer; }
.tutorial-modal button:hover { background: #0f766e; }
.tutorial-modal button:active { transform: scale(0.98); }
.choice.disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }
.tooltip { position: fixed; z-index: 25000; background: rgba(0,0,0,0.95); color: #fff; padding: 1rem; border-radius: 8px; border: 2px solid #fbbf24; max-width: 320px; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
.tooltip.show { opacity: 1; }
.tooltip-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem; color: #fbbf24; }
.tooltip-desc { font-size: 0.9rem; line-height: 1.4; }
</style>
</head>
<body>
<div class="header">
<div>Floor <span id="floor">1</span> | Round <span id="round">1</span></div>
<div id="debugBtn" style="display:none"><button onclick="showDebugMenu()" style="padding:0.25rem 0.5rem;background:#fbbf24;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer">üõ†Ô∏è</button></div>
<div><span id="gold">0</span>G | <span id="xp">0</span>XP</div>
</div>
<div class="game-area" id="gameView"></div>
<script>
// ===== VERSION CHECK =====
const GAME_VERSION = '9.8';
console.log(`%cüê∏ FROGGLE v${GAME_VERSION} LOADED`, 'color: #14b8a6; font-size: 20px; font-weight: bold;');
console.log('%cIf you see a different version in the UI, clear your cache and reload!', 'color: #f59e0b; font-weight: bold;');

// ===== GAME DATA =====
// Hero images (base64 encoded PNG)
const HERO_IMAGES = {
        warrior: 'warrior-pixel.png',
        tank: 'tankpixel.png',
        mage: 'magepixel.png',
        healer: 'healerpixel.png',
        tapo: 'tapopixel.png'
    };

// Hero portrait images for selection screen
const HERO_PORTRAITS = {
        warrior: 'warriorfull.png',
        tank: 'tankfull.png',
        mage: 'magefull.png',
        healer: 'healerfull.png',
        tapo: 'tapofull.png'
    };

// Death's dialogue lines (cycles through without repeating until all used)
const DEATH_QUOTES = [
    "Some days you're the sticky tongue, some days you're the fly.",
    "You must really like pain. Or do you like death? Weirdo.",
    "Next time bring me a smoothie or something",
    "Hey, have you met those ghost boys in the dungeon? I can't get them to make.. you know.. the transition. Help them out, would you?",
    "Death death lemonade, 'round the coroner I parade",
    "Ribbit? Ribbbbbit? Rib bit?",
    "Oh man, a classic green. You just know he's a jumper.",
    "Hello my baby, hello my honey.",
    "If you refuse me, honey you'll lose me",
    "You guys should check out the Discovery Channel to see what normal frogs do",
    "Toadally froggin died, huh?"
];

const H = {
warrior: {n:'Warrior', p:2, h:5, m:5, s:['Attack','D20']},
tank: {n:'Tank', p:1, h:10, m:10, s:['Shield','D20']},
mage: {n:'Mage', p:1, h:5, m:5, s:['Attack','D20','Expand']},
healer: {n:'Healer', p:1, h:5, m:5, s:['Heal','D20','Expand']},
tapo: {n:'Tapo', p:1, h:1, m:1, s:['Attack','Shield','Heal','D20','Expand','Grapple','Ghost','Asterisk','Star','Alpha']}
};

const E = {
goblin: { n:'Goblin', p:1, h:5, m:5, g:1, x:2, pool:['Asterisk','Expand','Shield'], gainRate:3 },
wolf: { n:'Wolf', p:2, h:5, m:5, g:2, x:4, pool:['Asterisk','Expand','Shield','Grapple','Alpha'], gainRate:2 },
orc: { n:'Orc', p:2, h:7, m:7, g:3, x:6, pool:['Asterisk','Expand','Shield','Grapple','Alpha','Heal','Ghost','Attack2','Shield2'], gainRate:2, startSigils:1 },
giant: { n:'Giant', p:3, h:15, m:15, g:6, x:12, pool:'ANY', gainRate:1, startSigils:[{s:'Shield',l:1}] },
dragon: { n:'Dragon', p:10, h:25, m:25, g:10, x:25, pool:'ANY_ADVANCED', gainRate:1, drawsPerTurn:2, permSigils:[{s:'Attack',l:2},{s:'Expand',l:4}], startSigils:2 }
};

// Enemy emoji icons
const ENEMY_EMOJI = {
'Goblin': 'üë∫',
'Wolf': 'üê∫',
'Orc': 'üëπ',
'Giant': 'üóø',
'Dragon': 'üêâ'
};

// Sigil icons (monochrome for CSS color styling)
const SIGIL_ICONS = {
'Attack': '‚öîÔ∏è',     // Crossed swords (emoji made monochrome via CSS)
'Shield': '‚õâ',      // Shield
'Heal': '‚úö',        // Medical cross
'D20': '‚¨°',         // Hexagon (wireframe d20)
'Asterisk': '‚ú±',    // Asterisk burst
'Alpha': 'Œ±',       // Greek alpha
'Expand': '‚äï',      // Crosshair/expand
'Grapple': '‚òõ',     // Pointing hand
'Star': '‚òÖ',        // Solid star
'Ghost': 'üëª'       // Ghost (emoji made monochrome via CSS)
};

// Track which icons need emoji filtering
const EMOJI_ICONS = ['Attack', 'Ghost'];

// Helper function to display sigil with icon
function sigilIcon(name) {
const icon = SIGIL_ICONS[name] || '';
if (EMOJI_ICONS.includes(name)) {
return `<span style="filter: grayscale(1) contrast(999); display: inline-block;">${icon}</span>${name}
}
return `${icon}${name}
}

// Helper function to display just the icon
function sigilIconOnly(name) {
const icon = SIGIL_ICONS[name] || name;
if (EMOJI_ICONS.includes(name)) {
return `<span style="filter: grayscale(1) contrast(999); display: inline-block;">${icon}</span>`;
}
return icon;
}

// Sigil descriptions for tooltips
const SIGIL_DESCRIPTIONS = {
'Attack': 'Deal POW damage to target. L2: Attack twice. L3: Attack 3 times. L4: Attack 4 times. Stacks with Asterisk.',
'Shield': 'Grant target 2√óPOW shield. L2: 4√óPOW. L3: 6√óPOW. L4: 8√óPOW. Shield blocks damage before HP.',
'Heal': 'Restore 2√óPOW HP to target. L2: 4√óPOW. L3: 6√óPOW. L4: 8√óPOW. Cannot exceed max HP.',
'D20': 'Roll 1d20 and choose: Damage enemy (DC varies) or Heal ally (no DC). Higher levels roll more dice, take best result.',
'Expand': 'Your Attack/Shield/Heal target +1 additional target per level. Mage/Healer get +1 Expand level built-in.',
'Grapple': 'Deal POW damage to target AND they deal POW damage back to you. L2+: Stun target for (Level-1) turns.',
'Ghost': 'Cancel the next lethal hit. Each charge prevents one death. Charges shown on card.',
'Asterisk': 'Prime by using last action. Next turn: First action hits ALL enemies in lane. One use per combat.',
'Star': 'Multiply combat XP by (1 + Level√ó0.5). Stacks across heroes. L4 = 3√ó XP!',
'Alpha': 'Grant target hero an extra action this turn. Can target self. Higher levels grant more actions.'
};

// Tooltip system
let tooltipTimeout = null;
let currentTooltip = null;

function showTooltip(sigilName, element) {
// Tooltip display (tutorial explanation happens in Ribbleton combat)

const desc = SIGIL_DESCRIPTIONS[sigilName];
if(!desc) return;

hideTooltip();

const tooltip = document.createElement('div');
tooltip.className = 'tooltip';
tooltip.innerHTML = `
<div class="tooltip-title">${sigilIcon(sigilName)}</div>
<div class="tooltip-desc">${desc}</div>`;

document.body.appendChild(tooltip);
currentTooltip = tooltip;

// Position tooltip near the element
const rect = element.getBoundingClientRect();
const tooltipRect = tooltip.getBoundingClientRect();
let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
let top = rect.top - tooltipRect.height - 10;

// Keep tooltip on screen
if(left < 10) left = 10;
if(left + tooltipRect.width > window.innerWidth - 10) left = window.innerWidth - tooltipRect.width - 10;
if(top < 10) top = rect.bottom + 10;

tooltip.style.left = left + 'px';
tooltip.style.top = top + 'px';

setTimeout(() => tooltip.classList.add('show'), 10);
}

function hideTooltip() {
if(currentTooltip) {
currentTooltip.classList.remove('show');
setTimeout(() => {
if(currentTooltip) {
currentTooltip.remove();
currentTooltip = null;
}
}, 200);
}
if(tooltipTimeout) {
clearTimeout(tooltipTimeout);
tooltipTimeout = null;
}
}

function generateFibonacci(n) {
const fib = [1, 1];
for(let i = 2; i < n; i++) fib.push(fib[i-1] + fib[i-2]);
return fib;
}
const FIB = generateFibonacci(50);

// ===== GAME STATE =====
let S = {
floor: 1,
round: 1,
turn: 'player',
gold: 0,
xp: 0,
levelUpCount: 0,
heroes: [],
enemies: [],
recruits: [], // Recruited enemies fighting for player
sig: {Attack:1, Shield:1, Heal:1, D20:1, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
sigUpgradeCounts: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
goingRate: 1,
startingXP: 0, // Bonus XP at start of each run (from Death Boy 2 sacrifices)
pedestal: [], // Array of {hero:'Warrior', stat:'POW'|'HP', mode:'Standard'|'Effed'}
hasAncientStatuette: false,
gameMode: 'Standard', // 'Standard' or 'Effed'
effedUnlocked: false,
tapoUnlocked: false, // Unlocked after first FU victory
debugMode: false, // Debug mode toggle
// Turn management
activeIdx: -1,
acted: [],
locked: false,
// Action state
pending: null,
targets: [],
currentInstanceTargets: [],
instancesRemaining: 0,
// Asterisk state
asteriskPrimed: false,
asteriskMultiplier: 1,
asteriskUsedThisCombat: false,
lastActions: {},
// Neutral encounter state
neutralDeck: [],
lastNeutral: null,
ambushed: false,
// Persistent neutral state (survives death - saved in savePermanent/loadPermanent)
ancientStatueDeactivated: false,
ghostBoysConverted: false,
// Temporary neutral state (resets on death - NOT saved)
silverKeyHeld: false,
oracleHero: null,
oracleRoll: null,
oracleStat: null,
wizardSigil: null,
princeGender: 'Prince',
treasureSecretCompartment: false,
// Run tracking (permanent)
runNumber: 1,
// Tutorial flags (permanent - shown once ever)
tutorialFlags: {
ribbleton_intro: false,
ribbleton_warrior_attack: false,
ribbleton_targeting: false,
ribbleton_healer_d20: false,
ribbleton_d20_menu: false,
ribbleton_enemy_turn: false,
ribbleton_healer_heal: false,
ribbleton_expand: false,
ribbleton_finish_wolf: false,
enemies_get_sigils: false,
ribbleton_shield_sigil: false,
ribbleton_handoff: false,
ribbleton_tooltip_intro: false,
levelup_intro: false,
levelup_stat_upgrade: false,
levelup_add_active: false,
levelup_upgrade_active: false,
levelup_upgrade_passive: false,
death_intro: false,
death_exit_warning: false,
neutral_intro: false,
neutral_d20_level: false,
last_stand_intro: false,
run2_hero_lock: false,
first_victory_sequence: false,
first_fu_victory: false,
pedestal_first_placement: false,
tapo_victory_message: false
},
tutorialsDisabled: false,
usedDeathQuotes: [] // Track which death quotes have been shown
};

let sel = [];

// ===== RIBBLETON TUTORIAL STATE =====
let tutorialState = null;
// Tutorial state tracks scripted Ribbleton tutorial progress
// {
//   stage: 'warrior_attack' | 'targeting_wolf' | 'healer_d20' | 'd20_menu' | 'enemy_turn_explained' |
//          'healer_heal' | 'expand_targets' | 'finish_wolf' | 'shield_sigil' | 'handoff' | 'free',
//   wolfDamaged: boolean,
//   wolfKilled: boolean,
//   goblinKilled: boolean,
//   round: number
// }

// ===== HELPERS =====
function getFloorBackground(floor) {
// Progressive darkening from floor 1 (light brown) to floor 19 (black)
const colors = [
'#d9cab1', // Floor 1 - light brown (default)
'#cfc0a9', '#c5b6a1', '#bbac99', '#b1a291', '#a79889', // Floors 2-6
'#9d8e81', '#938479', '#897a71', '#7f7069', '#756661', // Floors 7-11
'#6b5c59', '#615251', '#574849', '#4d3e41', '#433439', // Floors 12-16
'#392a31', '#2f2029', '#251621', '#1b0c19' // Floors 17-20
];
return colors[Math.min(floor - 1, colors.length - 1)] || colors[0];
}

function renderHeroCard(hero, idx, onclickHandler, extraInfo = '') {
const hp = hero.ls ? `Last Stand (T${hero.lst+1})` : `${hero.h}/${hero.m}‚ù§`;
const extra = [];
if(hero.sh > 0) extra.push(`${hero.sh}üõ°`);
if(hero.g > 0) extra.push(`${hero.g}${sigilIconOnly('Ghost')}`);
return `<div class="card hero" onclick="${onclickHandler}" style="cursor:pointer;margin-bottom:0.75rem;transition:transform 0.1s,box-shadow 0.1s" onmouseover="this.style.transform='scale(1.02)';this.style.boxShadow='0 4px 12px rgba(0,0,0,0.3)'" onmouseout="this.style.transform='';this.style.boxShadow=''">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${hero.n}</div>
<div style="text-align:center;font-size:0.8rem">${hero.p}‚ö° | ${hp}${extra.length>0?' | '+extra.join(' '):''}${extraInfo}</div>
</div>`;
}

function upd() {
document.getElementById('floor').textContent = S.floor;
document.getElementById('round').textContent = S.round || '-';
document.getElementById('gold').textContent = S.gold;
// Show combat XP during combat, cumulative XP otherwise
if(S.combatXP !== undefined && S.combatXP > 0) {
document.getElementById('xp').textContent = `${S.xp} (+${S.combatXP})`;
} else {
document.getElementById('xp').textContent = S.xp;
}
// Show/hide debug button
const debugBtn = document.getElementById('debugBtn');
if(debugBtn) debugBtn.style.display = S.debugMode ? 'block' : 'none';
// Update background color based on floor
const gameArea = document.getElementById('gameView');
if(gameArea) gameArea.style.background = getFloorBackground(S.floor);
}

function triggerHitAnimation(targetId) {
// Find the card element by searching for the target ID in the card's onclick attribute
const cards = document.querySelectorAll('.card');
cards.forEach(card => {
const onclick = card.getAttribute('onclick');
if(onclick && onclick.includes(targetId)) {
card.classList.add('hit-flash');
setTimeout(() => card.classList.remove('hit-flash'), 300);
}
});
}

function toast(msg, dur=2000) {
const t = document.createElement('div');
t.className = 'toast';
t.textContent = msg;
document.body.appendChild(t);
setTimeout(() => t.classList.add('show'), 10);
setTimeout(() => {
t.classList.remove('show');
setTimeout(() => t.remove(), 300);
}, dur);
}

function showTutorialPop(flagName, message, onDismiss) {
console.log('[TUTORIAL] showTutorialPop called:', flagName, 'Already shown:', S.tutorialFlags[flagName]);
if(S.tutorialsDisabled || S.tutorialFlags[flagName]) {
console.log('[TUTORIAL] Skipping pop (disabled or already shown), calling callback directly');
if(onDismiss) onDismiss();
return;
}
// Create blocking modal
const backdrop = document.createElement('div');
backdrop.className = 'tutorial-modal-backdrop';
backdrop.innerHTML = `
<div class="tutorial-modal">
<h2>Tutorial</h2>
<p>${message}</p>
<button onclick="dismissTutorialPop('${flagName}')">Got it!</button>
</div>`;
document.body.appendChild(backdrop);
console.log('[TUTORIAL] Backdrop created and appended, total backdrops now:', document.querySelectorAll('.tutorial-modal-backdrop').length);
// Store callback for later
window.tutorialCallback = onDismiss;
}

function dismissTutorialPop(flagName) {
console.log('[TUTORIAL] dismissTutorialPop called:', flagName);
console.log('[TUTORIAL] Backdrops BEFORE removal:', document.querySelectorAll('.tutorial-modal-backdrop').length);
S.tutorialFlags[flagName] = true;
savePermanent();

// Remove ALL backdrops aggressively
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Removing', allBackdrops.length, 'backdrops');
allBackdrops.forEach((b, i) => {
console.log('[TUTORIAL] Removing backdrop', i);
b.remove();
});

// Verify it's gone
setTimeout(() => {
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Backdrops remaining after pop dismiss:', remaining.length);
if(remaining.length > 0) {
console.error('[TUTORIAL] ERROR: Backdrops still blocking!', remaining);
remaining.forEach(r => {
console.error('[TUTORIAL] Zombie backdrop:', r);
r.remove();
});
}

console.log('[TUTORIAL] About to call onDismiss callback');
if(window.tutorialCallback) {
console.log('[TUTORIAL] Calling onDismiss callback NOW');
window.tutorialCallback();
window.tutorialCallback = null;
} else {
console.warn('[TUTORIAL] No callback found!');
}
}, 50);
}

function savePermanent() {
localStorage.setItem('froggle8_permanent', JSON.stringify({
gold: S.gold,
goingRate: S.goingRate,
startingXP: S.startingXP,
sig: S.sig,
sigUpgradeCounts: S.sigUpgradeCounts,
ancientStatueDeactivated: S.ancientStatueDeactivated,
ghostBoysConverted: S.ghostBoysConverted,
hasAncientStatuette: S.hasAncientStatuette,
pedestal: S.pedestal,
effedUnlocked: S.effedUnlocked,
tapoUnlocked: S.tapoUnlocked,
runNumber: S.runNumber,
tutorialFlags: S.tutorialFlags,
tutorialsDisabled: S.tutorialsDisabled,
usedDeathQuotes: S.usedDeathQuotes
}));
}

function loadPermanent() {
const d = localStorage.getItem('froggle8_permanent');
if(!d) return;
const j = JSON.parse(d);
S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:1, Shield:1, Heal:1, D20:1, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.hasAncientStatuette = j.hasAncientStatuette || false;
S.pedestal = j.pedestal || [];
S.effedUnlocked = j.effedUnlocked || false;
S.tapoUnlocked = j.tapoUnlocked || false;
S.runNumber = j.runNumber || 1;
S.tutorialsDisabled = j.tutorialsDisabled || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
if(j.tutorialFlags) {
Object.assign(S.tutorialFlags, j.tutorialFlags);
}
}

function saveGame() {
localStorage.setItem('froggle8', JSON.stringify({
f:S.floor, x:S.xp, luc:S.levelUpCount,
h:S.heroes,
neutralDeck:S.neutralDeck, lastNeutral:S.lastNeutral
}));
savePermanent();
}

function loadGame() {
loadPermanent(); // Load persistent data first
const d = localStorage.getItem('froggle8');
if(!d) return;
const j = JSON.parse(d);
S.floor=j.f; S.xp=j.x; S.levelUpCount=j.luc || 0;
S.heroes=j.h;
S.neutralDeck=j.neutralDeck || [];
S.lastNeutral=j.lastNeutral || null;
S.heroes.forEach(h => { if(!h.ts) h.ts = []; });
upd();
startFloor(S.floor);
toast('Loaded!');
}

// ===== NEUTRAL DECK SYSTEM =====
function initNeutralDeck() {
S.neutralDeck = [
'shopkeeper1', 'wishingwell1', 'treasurechest1',
'wizard1', 'oracle1', 'encampment1',
'statue1', 'ghost1', 'prince1'
];
S.lastNeutral = null;
}

function getNeutralEncounter() {
if(S.neutralDeck.length === 0) {
initNeutralDeck();
}

// TUTORIAL: Floor 2 always gets Oracle Stage 1
if(S.floor === 2 && !S.tutorialFlags.neutral_intro) {
return 'oracle1';
}

// Level 18: Prioritize Stage 2s
if(S.floor === 18) {
const stage2s = S.neutralDeck.filter(n => n.includes('2'));
if(stage2s.length > 0) {
const pick = stage2s[Math.floor(Math.random() * stage2s.length)];
return pick;
}
}

// Filter out last neutral for back-to-back prevention
let available = S.neutralDeck;
if(S.lastNeutral) {
const base = S.lastNeutral.replace(/[12]$/, '');
available = available.filter(n => !n.startsWith(base));
}

// Floor 10: NEVER allow Enemy Encampment (Floor 11 is always ambush)
if(S.floor === 10) {
available = available.filter(n => !n.startsWith('encampment'));
}

if(available.length === 0) {
available = S.neutralDeck;
}

const pick = available[Math.floor(Math.random() * available.length)];
S.lastNeutral = pick;
return pick;
}

function removeNeutralFromDeck(base) {
S.neutralDeck = S.neutralDeck.filter(n => !n.startsWith(base));
}

function replaceStage1WithStage2(base) {
S.neutralDeck = S.neutralDeck.filter(n => n !== `${base}1`);
S.neutralDeck.push(`${base}2`);
}

// ===== D20 ROLLS FOR NEUTRALS =====
function rollD20Neutral() {
const d20Level = S.sig.D20 || 1;
const rolls = [];
for(let i = 0; i < d20Level; i++) {
rolls.push(Math.ceil(Math.random() * 20));
}
const best = Math.max(...rolls);
// TUTORIAL: Explain D20 level affects neutral rolls
showTutorialPop('neutral_d20_level', "This D20 roll uses the same Level as your D20 sigil in combat - so you can up your chances of success in neutral rooms by leveling up that Sigil!");
return {rolls, best};
}

function showD20Result(rolls, best) {
return `Rolling ${rolls.length}d20: [${rolls.join('] [')}] ‚Üí Highest: ${best}
}

// ===== MAIN TITLE PAGE =====
function mainTitlePage() {
console.log('[FROGGLE] mainTitlePage START');
const v = document.getElementById('gameView');
console.log('[FROGGLE] gameView element:', v);
const hasSavedGame = localStorage.getItem('froggle8');
console.log('[FROGGLE] hasSavedGame:', hasSavedGame ? 'YES' : 'NO');
v.innerHTML = `
<div style="position:relative;min-height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#1a1a1a;padding:1rem">
<!-- Title image - contained, not stretched -->
<img src="assets/title-screen.png" style="max-width:100%;max-height:60vh;width:auto;height:auto;object-fit:contain;border-radius:8px;border:3px solid #000;margin-bottom:1rem">

<!-- Version label -->
<div style="background:rgba(0,0,0,0.7);padding:0.5rem 1.5rem;border-radius:20px;border:2px solid rgba(255,255,255,0.3);margin-bottom:1.5rem">
<p style="font-size:0.9rem;color:white;font-weight:bold">v9.8 BETA RELEASE</p>
</div>

<!-- Button container -->
<div style="display:flex;flex-direction:column;gap:1rem;width:100%;max-width:350px">
<button class="btn" onclick="newGame()" style="font-size:1.3rem;padding:1.25rem;box-shadow:0 4px 8px rgba(0,0,0,0.3)">New Game</button>
${hasSavedGame ? `<button class="btn" onclick="loadGameFromTitle()" style="font-size:1.3rem;padding:1.25rem;box-shadow:0 4px 8px rgba(0,0,0,0.3)">Load Game</button>` : ''}
<button class="btn" onclick="exitGame()" style="font-size:1.3rem;padding:1.25rem;background:#888;box-shadow:0 4px 8px rgba(0,0,0,0.3)">Exit</button>
</div>

<!-- Debug mode toggle -->
<div style="position:absolute;bottom:10px;left:10px;background:rgba(0,0,0,0.5);padding:0.5rem;border-radius:4px">
<label style="font-size:0.8rem;cursor:pointer;user-select:none;color:white">
<input type="checkbox" ${S.debugMode ? 'checked' : ''} onchange="toggleDebugMode(this.checked)"> Debug Mode
</label>
</div>
</div>`;
}

function newGame() {
console.log('[FROGGLE] newGame called - runNumber:', S.runNumber, 'tutorialsDisabled:', S.tutorialsDisabled);
if(S.runNumber === 1 && !S.tutorialsDisabled) {
console.log('[FROGGLE] Showing tutorial story');
showTutorialStory();
} else {
console.log('[FROGGLE] Skipping tutorial, going to title()');
title();
}
}

function loadGameFromTitle() {
const s = localStorage.getItem('froggle8');
if(s) {
loadGame();
} else {
toast('No saved game found!');
}
}

function exitGame() {
if(confirm('Thanks for playing FROGGLE! Close the window to exit.')) {
window.close();
}
}

// ===== NARRATIVE SLIDE SYSTEM =====
function showNarrativeSlide(slides, currentIndex = 0) {
console.log('[FROGGLE] showNarrativeSlide called - currentIndex:', currentIndex, 'total slides:', slides.length);
if(currentIndex >= slides.length) {
// All slides shown, call completion callback
console.log('[FROGGLE] All slides complete, calling onComplete');
if(slides.onComplete) slides.onComplete();
return;
}

const slide = slides[currentIndex];
console.log('[FROGGLE] Rendering slide', currentIndex);
const v = document.getElementById('gameView');
console.log('[FROGGLE] gameView element:', v);
const skipButton = slides.skippable ? `<button class="btn" onclick="skipTutorialFromSlide()" style="padding:0.75rem 2rem;background:#888;margin-left:1rem">Skip Tutorial</button>` : '';
console.log('[FROGGLE] Setting innerHTML for slide', currentIndex);
v.innerHTML = `
<div style="max-width:600px;margin:2rem auto;padding:1rem">
${slide.html || `<div style="font-size:1.1rem;line-height:1.8;margin-bottom:2rem;text-align:center">${slide.text}</div>`}
<div style="text-align:center">
<button class="btn" onclick="continueNarrative()" style="padding:0.75rem 2rem">${slide.buttonText || 'Continue'}</button>
${skipButton}
</div>
</div>`;

window.currentNarrativeSlides = slides;
window.currentNarrativeIndex = currentIndex;
console.log('[FROGGLE] Slide', currentIndex, 'rendered successfully');
}

function continueNarrative() {
const slides = window.currentNarrativeSlides;
const nextIndex = window.currentNarrativeIndex + 1;
showNarrativeSlide(slides, nextIndex);
}

function skipTutorialFromSlide() {
S.tutorialsDisabled = true;
savePermanent();
toast('Tutorial skipped! Going to hero selection...', 2000);
setTimeout(() => title(), 500);
}

// ===== RIBBLETON TUTORIAL INTRO =====
function showTutorialStory() {
console.log('[FROGGLE] showTutorialStory START');
const slides = [
{
html: `
<div style="text-align:center">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#14b8a6">The Town of Ribbleton</h2>
<div style="margin:1.5rem 0">
<img src="assets/title-screen.png" style="max-width:100%;height:auto;border-radius:12px;border:3px solid #fbbf24;box-shadow:0 8px 16px rgba(0,0,0,0.2)">
</div>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
Today is <strong>Tapo the Tadpole's first birthday!</strong><br>
The whole village gathered to celebrate! üéâ
</p>
</div>
`
},
{
html: `
<div style="text-align:center">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#14b8a6">Ribbleton's Defenders</h2>
<div style="margin:1.5rem 0">
<img src="assets/tapo.png" style="max-width:200px;height:auto;border-radius:12px;border:3px solid #fbbf24;box-shadow:0 8px 16px rgba(0,0,0,0.2);animation:bounce 2s ease-in-out infinite">
</div>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
The whole town gathered around little Tapo as he blew out the candles on his birthday cake.<br>
<strong>Ribbleton's 4 greatest warriors stood guard over the celebrations...</strong>
</p>
<div style="display:flex;justify-content:center;gap:1rem;margin:1.5rem 0;flex-wrap:wrap">
<div style="animation:partyFlip 1s ease-in-out infinite"><img src="warriorfull.png" style="width:120px;height:auto;border-radius:8px;border:2px solid #fbbf24;box-shadow:0 4px 8px rgba(0,0,0,0.2)"></div>
<div style="animation:partyFlip 1.2s ease-in-out infinite"><img src="tankfull.png" style="width:120px;height:auto;border-radius:8px;border:2px solid #fbbf24;box-shadow:0 4px 8px rgba(0,0,0,0.2)"></div>
<div style="animation:partyFlip 0.8s ease-in-out infinite"><img src="magefull.png" style="width:120px;height:auto;border-radius:8px;border:2px solid #fbbf24;box-shadow:0 4px 8px rgba(0,0,0,0.2)"></div>
<div style="animation:partyFlip 1.4s ease-in-out infinite"><img src="healerfull.png" style="width:120px;height:auto;border-radius:8px;border:2px solid #fbbf24;box-shadow:0 4px 8px rgba(0,0,0,0.2)"></div>
</div>
</div>
<style>
@keyframes bounce {
0%, 100% { transform: translateY(0) scale(1); }
50% { transform: translateY(-20px) scale(1.05); }
}
@keyframes partyFlip {
0%, 100% { transform: scaleX(1) rotate(0deg); }
50% { transform: scaleX(-1) rotate(10deg); }
}
</style>
`
},
{
html: `
<div style="text-align:center">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#dc2626;animation:shake 0.5s ease-in-out infinite">DANGER!</h2>
<div style="margin:1.5rem 0;position:relative">
<div style="width:200px;height:200px;margin:0 auto;position:relative;border-radius:50%;background:radial-gradient(circle, #dc2626, #7c2d12);animation:portalPulse 1s ease-in-out infinite;box-shadow:0 0 40px #dc2626"></div>
<div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:4rem;animation:spin 2s linear infinite">üåÄ</div>
</div>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
Suddenly, <strong>a dark portal</strong> tore open in the town square!<br>
Strange, dangerous enemies began to emerge...
</p>
<div style="display:flex;justify-content:center;gap:2rem;margin:1.5rem 0;font-size:3rem">
<div style="animation:enemyAppear 1s ease-out">üë∫</div>
<div style="animation:enemyAppear 1.3s ease-out">üê∫</div>
</div>
</div>
<style>
@keyframes shake {
0%, 100% { transform: translateX(0); }
25% { transform: translateX(-5px); }
75% { transform: translateX(5px); }
}
@keyframes portalPulse {
0%, 100% { transform: scale(1); opacity: 0.8; }
50% { transform: scale(1.1); opacity: 1; }
}
@keyframes spin {
from { transform: translate(-50%, -50%) rotate(0deg); }
to { transform: translate(-50%, -50%) rotate(360deg); }
}
@keyframes enemyAppear {
from { transform: scale(0) rotate(-180deg); opacity: 0; }
to { transform: scale(1) rotate(0deg); opacity: 1; }
}
</style>
`
}
];
slides.skippable = true; // Make tutorial skippable
slides.onComplete = () => {
// Start combat FIRST so enemies are visible
startRibbletonTutorial();

// Then show narrative overlay describing what's happening
setTimeout(() => {
showTutorialStoryOverlay();
}, 100);
};
console.log('[FROGGLE] About to call showNarrativeSlide with', slides.length, 'slides');
showNarrativeSlide(slides, 0);
console.log('[FROGGLE] showNarrativeSlide called');
}

function showTutorialStoryOverlay() {
// Show narrative on TOP of combat screen
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:550px">
<p style="font-size:1.1rem;line-height:1.6;margin-bottom:1.5rem">
A Goblin and a Wolf have appeared from the portal!
</p>
<div style="display:grid;grid-template-columns:1fr auto 1fr;gap:1.5rem;align-items:center;margin:1.5rem 0">
<div style="display:flex;gap:0.5rem;align-items:center;justify-content:center">
<div style="animation:defensiveStance 1.5s ease-in-out infinite">
<img src="tankfull.png" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem">üõ° On Guard!</div>
</div>
<div style="text-align:center">
<img src="assets/tapo.png" style="width:60px;height:auto;border-radius:6px;border:2px solid #000">
<div style="font-size:0.65rem;opacity:0.7;margin-top:0.25rem">Protected!</div>
</div>
<div style="animation:defensiveStance 1.3s ease-in-out infinite">
<img src="magefull.png" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem">üìñ On Guard!</div>
</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.75rem;align-items:center;font-size:2.5rem">
<div style="animation:enemyThreat 1s ease-in-out infinite">üë∫</div>
<div style="animation:enemyThreat 1.2s ease-in-out infinite">üê∫</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.5rem;align-items:center">
<div style="animation:chargeForward 0.8s ease-out infinite alternate">
<img src="warriorfull.png" style="width:80px;height:auto;border-radius:6px;border:2px solid #fbbf24;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem">‚öîÔ∏è Attacking!</div>
</div>
<div style="animation:chargeForward 1s ease-out infinite alternate">
<img src="healerfull.png" style="width:80px;height:auto;border-radius:6px;border:2px solid #fbbf24;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem">‚úö Attacking!</div>
</div>
</div>
</div>
<p style="font-size:1rem;line-height:1.6;text-align:center;font-style:italic;opacity:0.9">
Tank and Mage stand guard around Tapo while Warrior and Healer charge toward the portal!
</p>
<div style="margin-top:1.5rem;display:flex;gap:1rem;justify-content:center;flex-wrap:wrap">
<button onclick="dismissStoryOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#14b8a6;color:#fff;border:2px solid #0f766e;border-radius:8px;cursor:pointer">Let's fight!</button>
<button onclick="skipTutorialFromOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#888;color:#fff;border:2px solid #666;border-radius:8px;cursor:pointer">Skip Tutorial</button>
</div>
</div>
<style>
@keyframes chargeForward {
0% { transform: translateX(0) scale(1); }
100% { transform: translateX(15px) scale(1.05); }
}
@keyframes defensiveStance {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(-5px); }
}
@keyframes enemyThreat {
0%, 100% { transform: scale(1) rotate(0deg); }
50% { transform: scale(1.2) rotate(10deg); }
}
</style>`;
document.body.appendChild(overlay);
}

function dismissStoryOverlay() {
console.log('[TUTORIAL] Dismissing story overlay');
// Remove ALL backdrops before showing the tutorial pop
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Found', allBackdrops.length, 'backdrops to remove');
allBackdrops.forEach((backdrop, idx) => {
console.log('[TUTORIAL] Removing backdrop', idx);
backdrop.remove();
});

// Double-check they're gone
setTimeout(() => {
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Remaining overlays after dismiss:', remaining.length);
if(remaining.length > 0) {
console.error('[TUTORIAL] ERROR: Still have backdrops!', remaining);
remaining.forEach(r => r.remove());
}

// PROMPT 1: Warrior Attack
showTutorialPop('ribbleton_warrior_attack', "Quick! Attack an enemy! Click on Warrior's Attack sigil.", () => {
console.log('[TUTORIAL] Prompt 1 dismissed - transitioning to warrior_attack stage');
tutorialState.stage = 'warrior_attack';
S.activeIdx = 0;
console.log('[TUTORIAL] S.activeIdx is now:', S.activeIdx);
render();
});
}, 50);
}

function skipTutorialFromOverlay() {
const overlay = document.querySelector('.tutorial-modal-backdrop');
if(overlay) overlay.remove();
S.tutorialsDisabled = true;
savePermanent();
toast('Tutorial skipped! Going to hero selection...', 2000);
setTimeout(() => title(), 500);
}

function skipTutorial() {
S.tutorialsDisabled = true;
savePermanent();
toast('Tutorials disabled for all games');
title();
}

// ===== RIBBLETON TUTORIAL =====
function startRibbletonTutorial() {
// Set up tutorial heroes
S.floor = 0; // Special floor 0 for tutorial
// NOTE: Gold persists! Don't reset it here
S.xp = 0;
S.levelUpCount = 0;
S.heroes = [
{id:'h_tutorial_warrior', n:'Warrior', p:2, h:5, m:5, s:['Attack','D20'], sh:0, g:0, ls:false, lst:0, ts:[], st:0},
{id:'h_tutorial_healer', n:'Healer', p:1, h:5, m:5, s:['Heal','D20','Expand'], sh:0, g:0, ls:false, lst:0, ts:[], st:0}
];

// Initialize tutorial state
tutorialState = {
stage: 'waiting_for_start', // Will transition to 'warrior_attack' after overlay dismissal
wolfDamaged: false,
wolfKilled: false,
goblinKilled: false,
round: 1
};

// Start combat using real combat system!
combat(0);
}


function finishRibbletonTutorial() {
// Post-combat narrative
const slides = [
{text: "The few enemies remaining around the village scampered back into the portal from whence they came. Relieved, and sheathing their weapons, the frog heroes assembled to try to pick up the string of their failed party - but Tapo was missing!!"},
{text: "As the village people looked high and low, our heroes realized there was only one possibility - the poor tadpole had squiggled his way through!"},
{text: "Without a thought for their lives, the brave heroes dove into the swirling darkness..."}
];
slides.onComplete = showTitleCard;
showNarrativeSlide(slides, 0);
}

function showTitleCard() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:#000;display:flex;align-items:center;justify-content:center;z-index:30000">
<div style="text-align:center;color:#fff">
<div style="font-size:3rem;font-weight:bold;margin-bottom:1rem">FROGGLE</div>
<div style="font-size:1.5rem;font-style:italic">A Froggy Roguelike</div>
</div>
</div>`;

setTimeout(() => {
tutorialState = null;
title(); // Go to hero select (which will auto-select Warrior + Healer for Run 1)
}, 5500);
}

// ===== TITLE & HERO SELECT =====
let selectedHeroView = null; // Track which hero card is currently displayed

function title() {
console.log('[FROGGLE] title() called - Hero selection screen');
// TUTORIAL: Run 1 selects Warrior + Healer after hero select screen
const isRun1 = S.runNumber === 1;
if(isRun1 && !S.tutorialsDisabled) {
// Auto-select for tutorial but show the screen
console.log('[FROGGLE] Auto-selecting Warrior + Healer for tutorial');
sel = ['warrior', 'healer'];
}

const v = document.getElementById('gameView');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;

// TUTORIAL: Run 2 forces Tank + Mage
const isRun2 = S.runNumber === 2;
if(isRun2) {
showTutorialPop('run2_hero_lock', "Try out the other 2 heroes! Tank starts with extra health, and Mage starts with the ability to hit 2 targets at once!");
}

v.innerHTML = `
<h1 style="text-align:center;margin:2rem 0;font-size:2rem">FROGGLE üê∏</h1>
<p style="text-align:center;margin-bottom:0.5rem;font-size:0.9rem">v9.8 BETA RELEASE</p>
<p style="text-align:center;margin-bottom:1rem;font-size:1.1rem;font-weight:bold">Mode: <span style="color:${S.gameMode === 'Effed' ? '#dc2626' : '#14b8a6'}">${S.gameMode === 'Standard' ? 'Standard' : 'EFFED UP üî•'}</span></p>
${S.effedUnlocked ? `<div style="text-align:center;margin-bottom:1rem">
<button class="btn" onclick="showChampionsMenu()" style="padding:0.75rem 1.5rem;background:linear-gradient(135deg,#fbbf24,#f59e0b);font-weight:bold">
üèÜ Champions of Floor 20 üèÜ
</button></div>` : ''}

<div style="max-width:600px;margin:0 auto">
<h2 style="text-align:center;margin-bottom:1rem;font-size:1.3rem">Choose 2 Heroes</h2>
<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem;opacity:0.7">Tap a hero to select!</p>
<div style="position:relative;max-width:100%;margin:0 auto;min-height:400px">
<img src="assets/hero-select.png" style="width:100%;height:auto;display:block;border-radius:8px;border:3px solid #000">
<!-- Clickable overlay regions for each hero (4 equal sections) -->
<div style="position:absolute;top:0;left:0;width:25%;height:100%;cursor:pointer;${isRun2?'opacity:0.5;cursor:not-allowed;':''}"
onclick="${isRun2?'':'toggleHeroSelection(\'warrior\')'}"
title="Warrior"></div>
<div style="position:absolute;top:0;left:25%;width:25%;height:100%;cursor:pointer;"
onclick="toggleHeroSelection('tank')"
title="Tank"></div>
<div style="position:absolute;top:0;left:50%;width:25%;height:100%;cursor:pointer;"
onclick="toggleHeroSelection('mage')"
title="Mage"></div>
<div style="position:absolute;top:0;left:75%;width:25%;height:100%;cursor:pointer;${isRun2?'opacity:0.5;cursor:not-allowed;':''}"
onclick="${isRun2?'':'toggleHeroSelection(\'healer\')'}"
title="Healer"></div>

<!-- Hero card overlays -->
<div id="warrior-card" style="position:absolute;bottom:10%;left:1%;width:23%;display:none;z-index:10;"></div>
<div id="tank-card" style="position:absolute;bottom:10%;left:26%;width:23%;display:none;z-index:10;"></div>
<div id="mage-card" style="position:absolute;bottom:10%;left:51%;width:23%;display:none;z-index:10;"></div>
<div id="healer-card" style="position:absolute;bottom:10%;left:76%;width:23%;display:none;z-index:10;"></div>
</div>

${S.tapoUnlocked ? `
<div style="margin-top:1rem;text-align:center">
<button class="btn" onclick="toggleHeroSelection('tapo')" style="background:linear-gradient(135deg,#fbbf24 0%,#22c55e 100%);padding:0.75rem 1.5rem;font-size:1rem;font-weight:bold;border:3px solid #000">
üéâ View Tapo (UNLOCKED!) üéâ
</button>
</div>` : ''}

<!-- Selection display -->
<div style="text-align:center;margin:1.5rem 0;padding:1rem;background:rgba(0,0,0,0.05);border-radius:8px">
<strong>Selected Heroes:</strong>
<div id="selection-display" style="margin-top:0.5rem;font-size:1.1rem;color:#2563eb"></div>
</div>

<button class="btn" id="start" onclick="start()" disabled style="opacity:0.4;width:100%;padding:1rem;font-size:1.1rem">Delve into Floor 1</button>
</div>`;

console.log('[FROGGLE] title() innerHTML set successfully');
if(!isRun1 || S.tutorialsDisabled) sel = [];

// Update selection display
updateSelectionDisplay();

// If run 1 with tutorial, enable start button
if(isRun1 && !S.tutorialsDisabled) {
setTimeout(() => {
const b = document.getElementById('start');
if(b) { b.disabled = false; b.style.opacity = '1'; }
updateSelectionDisplay();
}, 0);
}
}

function toggleHeroSelection(heroType) {
const isRun2 = S.runNumber === 2;
const isLocked = isRun2 && (heroType === 'warrior' || heroType === 'healer');
if(isLocked) return;

const heroData = {
warrior: {name: 'Warrior', pow: 2, hp: 5, maxhp: 5, sigils: ['Attack', 'D20'], desc: 'A balanced fighter with strong attacks'},
tank: {name: 'Tank', pow: 1, hp: 10, maxhp: 10, sigils: ['Shield', 'D20'], desc: 'A sturdy defender with high HP'},
mage: {name: 'Mage', pow: 1, hp: 5, maxhp: 5, sigils: ['Attack', 'D20', 'Expand'], desc: 'A versatile caster who can hit multiple targets'},
healer: {name: 'Healer', pow: 1, hp: 5, maxhp: 5, sigils: ['Heal', 'D20', 'Expand'], desc: 'A support hero who can heal multiple allies'},
tapo: {name: 'Tapo', pow: 1, hp: 1, maxhp: 1, sigils: ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha'], desc: 'The ultimate glass cannon - all sigils, minimal health!'}
};

const hero = heroData[heroType];
const portrait = HERO_PORTRAITS[heroType] || '';

// Toggle selection
const isSelected = sel.includes(heroType);
if(isSelected) {
sel = sel.filter(h => h !== heroType);
} else {
if(sel.length < 2) {
sel.push(heroType);
}
}

// Update all card displays
['warrior', 'tank', 'mage', 'healer'].forEach(h => {
const cardEl = document.getElementById(`${h}-card`);
if(!cardEl) return;

if(sel.includes(h)) {
const hData = heroData[h];
const hPixelImage = HERO_IMAGES[h] || '';
const sigilsHTML = hData.sigils.map(s => `<span class="sigil l1" style="font-size:0.5rem;padding:2px 4px;margin:1px;display:inline-block">${sigilIconOnly(s)}</span>`).join('');
cardEl.innerHTML = `
<div onclick="toggleHeroSelection('${h}')" style="cursor:pointer;background:white;border:3px solid #22c55e;border-radius:8px;padding:0.5rem;box-shadow:0 4px 6px rgba(0,0,0,0.3)">
<div style="text-align:center">
<div style="font-size:0.7rem;font-weight:bold;margin-bottom:0.25rem">${hData.name}</div>
${hPixelImage ? `<img src="${hPixelImage}" style="width:100%;height:auto;border-radius:4px;margin-bottom:0.25rem;image-rendering:pixelated">` : ''}
<div style="font-size:0.6rem;opacity:0.8">${hData.pow}‚ö° | ${hData.hp}‚ù§</div>
<div style="font-size:0.6rem;margin-top:0.25rem">${sigilsHTML}</div>
<div style="font-size:0.5rem;opacity:0.7;margin-top:0.25rem">‚úì SELECTED</div>
</div>
</div>`;
cardEl.style.display = 'block';
} else {
cardEl.style.display = 'none';
}
});

// Handle tapo specially if it exists
if(heroType === 'tapo' || sel.includes('tapo')) {
// Tapo button will be updated by title() re-render
}

updateSelectionDisplay();
}


function updateSelectionDisplay() {
const display = document.getElementById('selection-display');
if(!display) return;

if(sel.length === 0) {
display.textContent = 'None';
display.style.color = '#6b7280';
} else {
const heroNames = sel.map(h => H[h].n);
display.textContent = heroNames.join(' + ');
display.style.color = '#2563eb';
}

const btn = document.getElementById('start');
if(btn) {
btn.disabled = sel.length !== 2;
btn.style.opacity = sel.length === 2 ? '1' : '0.4';
}
}

function toggleMode() {
S.gameMode = S.gameMode === 'Standard' ? 'Effed' : 'Standard';
savePermanent();
title();
}

function pick(t) {
const i = sel.indexOf(t);
if(i>=0) {
sel.splice(i,1);
} else if(sel.length<2) {
sel.push(t);
} else {
toast('Maximum 2 heroes!');
return;
}

// Update selection display
updateSelectionDisplay();

// Refresh the hero card to show updated selection state
if(selectedHeroView === t) {
toggleHeroSelection(t);
}
}

function start() {
if(sel.length!==2) return;
S.floor=1; S.xp=0; S.levelUpCount=0;
// NOTE: Gold persists between runs! Only reset on victory or spent at Death Screen
S.heroes = sel.map((t,i) => ({
id:`h${Date.now()}${i}`,
n:H[t].n, p:H[t].p, h:H[t].h, m:H[t].m,
s:[...H[t].s], sh:0, g:0, ls:false, lst:0, ts:[], st:0
}));
// Apply pedestal buffs
S.pedestal.forEach(slot => {
if(slot.mode !== S.gameMode) return; // Only apply buffs for current mode
const hero = S.heroes.find(h => h.n === slot.hero);
if(!hero) return;
if(slot.stat === 'POW') {
hero.p += 1;
} else if(slot.stat === 'HP') {
hero.m += 5;
hero.h += 5;
}
});
initNeutralDeck();
upd();
// Check if player has starting XP from Death Boy sacrifices
if(S.startingXP > 0) {
S.xp = S.startingXP;
showStartingXPScreen();
} else {
startFloor(1);
}
}

// ===== FLOOR MANAGEMENT =====
function startFloor(f) {
S.floor=f;
upd();
// Special: Floor 20 in Effed mode shows Old Tapo encounter
if(f === 20 && S.gameMode === 'Effed') {
showOldTapo();
return;
}
if(f >= 20) { win(); return; }
// Floor 11 is always ambushed (Goblin Army)
if(f === 11) {
S.ambushed = true;
toast('WARNING: Floor 11 - Goblin Army lies in ambush!', 3000);
}
if(f%2===1) combat(f);
else neutral(f);
}

function getEnemyComp(f) {
const heroCount = S.heroes.length;
if(f===0) return ['goblin', 'wolf']; // Tutorial floor
if(f===1) return Array(heroCount).fill('goblin');
if(f===3) return Array(heroCount).fill('wolf');
if(f===5) return Array(heroCount * 2).fill('orc');
if(f===7) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('giant', 'wolf', 'goblin');
return comp;
}
if(f===9) return ['dragon'];
if(f===11) return Array(heroCount * 5).fill('goblin');
if(f===13) return Array(heroCount * 5).fill('wolf');
if(f===15) return ['dragon', 'dragon', 'dragon'];
if(f===17) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('giant', 'giant', 'orc', 'orc', 'wolf', 'goblin');
return comp;
}
if(f===19) return Array(heroCount * 4).fill('dragon');
return ['goblin'];
}

// ===== COMBAT (v7.2 PERFECT COMBAT - UNCHANGED) =====
function combat(f) {
S.round=1; S.turn='player'; S.activeIdx=-1; S.acted=[]; S.locked=false;
S.lastActions={}; S.asteriskUsedThisCombat=false; S.asteriskPrimed=false; S.asteriskMultiplier=1;
S.combatXP=0; S.combatGold=0; // Track combat rewards separately
// Don't clear recruits here - they may have been added before combat (e.g., Encampment straggler)
if(!S.recruits) S.recruits = [];
S.heroes.forEach(h => {
h.sh=0;
h.st=0;
if(!h.ts) h.ts=[];
// If ambushed, stun all heroes turn 1
if(S.ambushed) h.st = 1;
});
let comp = getEnemyComp(f);

S.enemies = comp.map((t,i) => {
const base = E[t];
const effedMultiplier = S.gameMode === 'Effed' ? 5 : 1;
const enemy = {
id:`e${Date.now()}${i}`, n:base.n,
p:base.p * effedMultiplier,
h:base.h * effedMultiplier,
m:base.m * effedMultiplier,
g:base.g, x:base.x, s: [], pool: base.pool,
gainRate: base.gainRate || 3, turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st:0, li: i % S.heroes.length, sh:0, alphaActed: false
};
if(base.permSigils) base.permSigils.forEach(ps => enemy.s.push({sig:ps.s, level:ps.l, perm:true}));
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
// Array format: [{s:'Shield', l:1}]
base.startSigils.forEach(ss => enemy.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
// Numeric format: draw N random sigils
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(enemy, base);
}
}
}
return enemy;
});
if(S.ambushed) {
toast('AMBUSHED! All heroes stunned Turn 1!', 3000);
S.ambushed = false; // Clear flag after use
}
// Check if we need to show Encampment enemy selection
if(S.encampmentEarlyKills && S.encampmentEarlyKills > 0) {
S.selectingEncampmentTargets = true;
S.encampmentSelectedTargets = [];
}
render();
// Tutorial: Explain tooltips on first combat
if(f === 1 && !S.tutorialsDisabled && !S.tutorialFlags.ribbleton_tooltip_intro) {
showTutorialPop('ribbleton_tooltip_intro', "Hover over (or long-press on mobile) any sigil to see what it does! This works on your heroes' sigils and enemies' sigils too.");
}
}

function getLevel(sig, heroIdx) {
const h = S.heroes[heroIdx];
const hasSigil = h.s.includes(sig) || (h.ts && h.ts.includes(sig));
if(!hasSigil) return 0;
let base = S.sig[sig] || 0;
if(sig === 'Expand' && (h.n === 'Mage' || h.n === 'Healer')) return base + 1;
return base;
}

function getTargetsPerInstance(action, heroIdx) {
const expandLevel = getLevel('Expand', heroIdx);
return 1 + expandLevel;
}

function needsEnemyTarget(action) { return ['Attack', 'Grapple'].includes(action); }
function needsHeroTarget(action) { return ['Heal', 'Shield', 'Alpha'].includes(action); }
function isMultiInstance(action) { return ['Attack', 'Shield', 'Heal'].includes(action); }

function getD20DC(baseDC, heroIdx) {
const h = S.heroes[heroIdx];
if(!h.ls) return baseDC;
return baseDC + h.lst;
}

function selectHero(idx) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending) return;
const h = S.heroes[idx];
if(S.acted.includes(idx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
S.activeIdx = idx;
if(h.ls) toast(`${h.n} in Last Stand - D20 only!`);
render();
}

function act(sig, heroIdx) {
// Hide any pending tooltips when action is selected
hideTooltip();

// RIBBLETON TUTORIAL: Check for scripted actions
if(tutorialState && S.floor === 0) {
const h = S.heroes[heroIdx];
// Stage: warrior_attack - Only allow Warrior to use Attack
if(tutorialState.stage === 'warrior_attack') {
if(h.n !== 'Warrior' || sig !== 'Attack') {
toast("Follow the tutorial instructions!");
return;
}
// Allow Attack, will transition in render when targeting
}
// Stage: healer_d20 - Only allow Healer to use D20
else if(tutorialState.stage === 'healer_d20') {
if(h.n !== 'Healer' || sig !== 'D20') {
toast("Follow the tutorial instructions!");
return;
}
// Will show D20 menu, PROMPT 4 will appear there
}
// Stage: healer_heal - Only allow Healer to use Heal
else if(tutorialState.stage === 'healer_heal') {
if(h.n !== 'Healer' || sig !== 'Heal') {
toast("Follow the tutorial instructions!");
return;
}
// Will transition to expand_targets when targeting
}
// Stage: finish_wolf - Only allow Warrior to Attack
else if(tutorialState.stage === 'finish_wolf') {
if(h.n !== 'Warrior' || sig !== 'Attack') {
toast("Follow the tutorial instructions!");
return;
}
// Let them finish the wolf
}
}

if(S.locked) { toast('Wait for enemy turn!'); return; }
// Allow switching actions only if no instances have been completed yet
if(S.pending) {
// Check if any instances have been completed
if(S.instancesRemaining > 0 && S.instancesRemaining < S.totalInstances) {
toast('Must complete remaining instances!');
return;
}
// Allow switching if no instances completed yet
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
}
const h = S.heroes[heroIdx];
if(S.acted.includes(heroIdx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
if(h.ls && sig !== 'D20') { toast('Last Stand - D20 only!'); return; }
S.activeIdx = heroIdx;

if(sig === 'Asterisk') {
const level = getLevel('Asterisk', heroIdx);
if(level === 0) { toast('Asterisk not unlocked!'); return; }
if(S.asteriskUsedThisCombat) { toast('Asterisk already used this combat!'); return; }
S.asteriskPrimed = true;
S.asteriskMultiplier = level + 1;
toast(`Asterisk primed! Next action √ó${S.asteriskMultiplier}`);
render();
return;
}

const repeats = S.asteriskPrimed ? S.asteriskMultiplier : 1;
if(S.asteriskPrimed) {
S.asteriskUsedThisCombat = true;
S.asteriskPrimed = false;
toast(`Asterisk: ${sig} √ó${repeats}!`);
}

if(sig === 'Ghost') {
const level = getLevel('Ghost', heroIdx);
if(level === 0) { toast('Ghost not unlocked!'); return; }
const totalCharges = level * repeats;
h.g = Math.min((h.g || 0) + totalCharges, 9);
toast(`${h.n} gained ${totalCharges} Ghost charge${totalCharges>1?'s':''}!`);
finishAction(heroIdx);
} else if(sig === 'D20') {
S.pending = 'D20';
S.asteriskD20Repeats = repeats;
S.asteriskD20Count = 0;
d20Menu(heroIdx);
} else if(isMultiInstance(sig)) {
const level = getLevel(sig, heroIdx);
if(level === 0) { toast(`${sig} not unlocked!`); return; }
S.pending = sig;
S.instancesRemaining = level * repeats;
S.totalInstances = level * repeats; // Track for color roll-down
S.targets = [];
S.currentInstanceTargets = [];
render();
} else if(sig === 'Grapple') {
const level = getLevel('Grapple', heroIdx);
if(level === 0) { toast('Grapple not unlocked!'); return; }
S.pending = 'Grapple';
S.grappleRepeats = repeats;
S.grappleLevel = level;
S.targets = [];
render();
} else if(sig === 'Alpha') {
const level = getLevel('Alpha', heroIdx);
if(level === 0) { toast('Alpha not unlocked!'); return; }
const expandLevel = getLevel('Expand', heroIdx);
const targetsNeeded = 1 + expandLevel;
S.pending = 'Alpha';
S.alphaLevel = level;
S.alphaTargetsNeeded = targetsNeeded;
S.targets = [];
toast(`Alpha: Grant ${level} action${level>1?'s':''} to ${targetsNeeded} hero${targetsNeeded>1?'es':''}!`);
render();
}
}

function d20Menu(heroIdx) {
if(S.locked) return;

// RIBBLETON TUTORIAL: PROMPT 4 - Explain D20 gambit
if(tutorialState && S.floor === 0 && tutorialState.stage === 'healer_d20') {
tutorialState.stage = 'd20_menu';
showTutorialPop('ribbleton_d20_menu', "All heroes can use their turn to try to turn the tides of battle with a gambit - try to hurt the Wolf with the DC 16 check!", () => {
// After prompt, show the d20 menu
renderD20MenuAfterTutorial(heroIdx);
});
return;
}

renderD20MenuAfterTutorial(heroIdx);
}

function renderD20MenuAfterTutorial(heroIdx) {
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];

// RIBBLETON TUTORIAL: Special D20 menu that doesn't block view
const isTutorial = tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu';

let html = '';
if(isTutorial) {
// Tutorial version: overlay on left side only, keep enemies visible
html = '<div style="position:fixed;top:50%;left:10px;transform:translateY(-50%);z-index:15000;max-width:380px;background:white;border:4px solid #fbbf24;border-radius:12px;padding:1.5rem;box-shadow:0 8px 32px rgba(0,0,0,0.5)">';
html += '<h3 style="margin-bottom:1rem;color:#6b4423">D20: Do Something Crazy</h3>';
html += `<p style="margin-bottom:0.75rem;color:#14b8a6;font-weight:bold;font-size:0.95rem">Healer has Expand L1! D20 actions can target BOTH enemies (Wolf + Goblin)!</p>`;
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, 16, 'CONFUSE')" style="margin-bottom:0.5rem;background:#fbbf24;border:3px solid #f59e0b;font-size:1.1rem;cursor:pointer">
<strong style="font-size:1.2rem">‚úÖ DC 16: CONFUSE</strong><br>
<span style="font-size:0.95rem">Deal damage = enemy POW</span>
</div>`;
// Show other options greyed out
const lockedOptions = [
{dc:17, name:'STARTLE', desc:'Stun for 1 turn'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:19, name:'SCARE', desc:'Remove from battle'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
lockedOptions.forEach(opt => {
html += `<div style="margin-bottom:0.5rem;background:#e0e0e0;border:2px solid #999;border-radius:8px;padding:0.75rem;opacity:0.5;cursor:not-allowed">
<strong style="font-size:0.95rem">üîí DC ${opt.dc}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
html += '</div>';
// Tutorial: Append as overlay, don't replace combat view
render(); // First render combat view
v.insertAdjacentHTML('beforeend', html);
return;
} else {
// Normal D20 menu (centered, blocks view)
html = '<div style="text-align:center;padding:1rem;background:white;border:3px solid #000;border-radius:8px;margin:1rem auto;max-width:400px">';
html += '<h3 style="margin-bottom:1rem">D20: Do Something Crazy</h3>';
const expandLevel = getLevel('Expand', heroIdx);
const maxTargets = 1 + expandLevel;
if(expandLevel > 0) html += `<p style="margin-bottom:0.75rem;color:#14b8a6;font-weight:bold;font-size:1.05rem;background:rgba(20,184,166,0.1);padding:0.5rem;border-radius:6px;border:2px solid #14b8a6">‚ú® Expand L${expandLevel} Active: Target up to ${maxTargets} enemies!</p>`;
if(S.asteriskD20Repeats > 1) {
html += `<p style="margin-bottom:0.5rem;color:#f59e0b">Asterisk Active: Pick ${S.asteriskD20Repeats} actions!</p>`;
html += `<p style="margin-bottom:1rem;font-size:0.85rem">(${S.asteriskD20Count}/${S.asteriskD20Repeats} used)</p>`;
}
if(h.ls && h.lst > 0) html += `<p style="margin-bottom:0.5rem;color:#dc2626;font-weight:bold">Last Stand Turn ${h.lst + 1}: DCs +${h.lst}</p>`;
const options = [
{dc:16, name:'CONFUSE', desc:'Deal damage = enemy POW'},
{dc:17, name:'STARTLE', desc:'Stun for 1 turn'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:19, name:'SCARE', desc:'Remove from battle'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
options.forEach(opt => {
const adjustedDC = getD20DC(opt.dc, heroIdx);
const dcText = adjustedDC > opt.dc ? `DC ${adjustedDC} (${opt.dc}+${adjustedDC - opt.dc})` : `DC ${opt.dc}
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, ${adjustedDC}, '${opt.name}')" style="margin-bottom:0.5rem">
<strong>${dcText}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
if(S.asteriskD20Count > 0) html += `<button class="btn safe" onclick="finishD20Asterisk(${heroIdx})">Finish (${S.asteriskD20Count} used)</button>`;
else html += `<button class="btn secondary" onclick="cancelAction()">Cancel</button>`;
html += '</div>';
v.innerHTML = html;
}
}

function selectD20Action(heroIdx, dc, actionName) {
if(S.locked) return;
S.d20Action = actionName;
S.d20DC = dc;
S.d20HeroIdx = heroIdx;
S.pending = 'D20_TARGET';
S.targets = [];
render();
}

function rollD20() {
if(S.locked) return;
const heroIdx = S.d20HeroIdx;
const h = S.heroes[heroIdx];
const dc = S.d20DC;
const actionName = S.d20Action;
const d20Level = getLevel('D20', heroIdx);
const rolls = [];

// RIBBLETON TUTORIAL: Fudge roll to always succeed (17-18)
if(tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu') {
const fudgedRoll = 17 + Math.floor(Math.random() * 2); // 17 or 18
rolls.push(fudgedRoll);
} else {
for(let i = 0; i < d20Level; i++) rolls.push(Math.ceil(Math.random() * 20));
}

const best = Math.max(...rolls);
const rollText = `Rolling ${d20Level}d20: [${rolls.join('] [')}] ‚Üí Highest: ${best}

if(best >= dc) {
toast(`${rollText} - SUCCESS!`, 3000);
const targetNames = S.targets.map(id => {
const e = S.enemies.find(e => e.id === id);
return e ? e.n : null;
}).filter(n => n);
S.targets.forEach(targetId => executeD20ActionOnTarget(targetId, actionName));
if(targetNames.length > 0) {
const actionDesc = {'CONFUSE': 'confused', 'STARTLE': 'startled and stunned', 'STEAL': 'robbed', 'SCARE': 'scared away', 'RECRUIT': 'recruited'};
if(actionName !== 'STEAL') toast(`${targetNames.join(', ')} ${actionDesc[actionName]}!`, 2500);
}
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), 800);
return;
}
}
finishD20Asterisk(heroIdx);
} else {
toast(`${rollText} - FAILED!`, 3000);
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), 800);
return;
}
}
finishD20Asterisk(heroIdx);
}
}

function executeD20ActionOnTarget(enemyId, action) {
const enemy = S.enemies.find(e => e.id === enemyId);
if(!enemy) return;
if(action === 'CONFUSE') {
const dmg = enemy.p;
dealDamageToEnemy(enemy, dmg);
} else if(action === 'STARTLE') {
enemy.st = 1;
// Check prince quest completion
if(S.princeQuestActive && S.round === 1 && !S.princeQuestCompleted) {
S.princeQuestCompleted = true;
toast('Prince Quest completed! Ring retrieved!', 3000);
}
} else if(action === 'STEAL') {
const gold = enemy.p;
S.gold += gold;
upd();
toast(`Stole ${gold} Gold from ${enemy.n}!`);
} else if(action === 'SCARE') {
if(enemy.n.includes('Dragon')) { toast(`${enemy.n} immune to SCARE!`); return; }
setTimeout(() => {
S.enemies = S.enemies.filter(e => e.id !== enemyId);
render();
checkCombatEnd();
}, 300);
} else if(action === 'RECRUIT') {
const heroIdx = S.d20HeroIdx;
const hero = S.heroes[heroIdx];
// Check if hero already has a recruit
if(!S.recruits) S.recruits = [];
const existingRecruit = S.recruits.find(r => r.recruitedBy === heroIdx);
if(existingRecruit) {
toast(`${hero.n} already has a recruit!`);
return;
}
// Remove enemy from enemies array
S.enemies = S.enemies.filter(e => e.id !== enemyId);
// Add to recruits array
const recruit = {...enemy, recruitedBy: heroIdx, isRecruit: true};
S.recruits.push(recruit);
toast(`${enemy.n} recruited by ${hero.n}!`, 2500);
setTimeout(() => {
render();
checkCombatEnd();
}, 300);
}
}

function finishD20Asterisk(heroIdx) {
S.acted.push(heroIdx);
S.pending = null;
S.targets = [];
S.asteriskD20Repeats = 1;
S.asteriskD20Count = 0;
checkTurnEnd();
render();
}

function cancelAction() {
if(S.locked) return;
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
render();
}

function tgtEnemy(id) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
if(S.targets.includes(id)) { toast('Already targeted!'); return; }
S.targets.push(id);
const slotsFilled = S.targets.length >= maxTargets;
const allEnemiesSelected = S.targets.length >= S.enemies.length;
if(slotsFilled || allEnemiesSelected) {
if(allEnemiesSelected && S.targets.length < maxTargets) {
const wasted = maxTargets - S.targets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
rollD20();
} else render();
return;
}
if(!S.pending || !needsEnemyTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
if(S.pending === 'Attack') {
if(S.currentInstanceTargets.includes(id)) { toast('Already targeted in this instance!'); return; }
S.targets.push(id);
S.currentInstanceTargets.push(id);
const availableEnemies = S.enemies.length;
const slotsFilled = S.currentInstanceTargets.length >= targetsPerInstance;
const allEnemiesSelected = S.currentInstanceTargets.length >= availableEnemies;
if(slotsFilled || allEnemiesSelected) {
if(allEnemiesSelected && S.currentInstanceTargets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.currentInstanceTargets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) finishAction(heroIdx);
else render();
} else render();
} else if(S.pending === 'Grapple') {
if(S.targets.includes(id)) { toast('Already targeted!'); return; }
S.targets.push(id);
const slotsFilled = S.targets.length >= targetsPerInstance;
const allEnemiesSelected = S.targets.length >= S.enemies.length;
if(slotsFilled || allEnemiesSelected) {
if(allEnemiesSelected && S.targets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.targets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
for(let i = 0; i < S.grappleRepeats; i++) executeGrapple(heroIdx, [...S.targets], S.grappleLevel);
finishAction(heroIdx);
} else render();
}
}

function tgtHero(id) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(!S.pending || !needsHeroTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const h = S.heroes[heroIdx];
const target = S.heroes.find(x => x.id === id);
if(!target) return;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
if(S.pending === 'Shield') {
if(S.currentInstanceTargets.includes(id)) { toast('Already targeted in this instance!'); return; }
S.targets.push(id);
S.currentInstanceTargets.push(id);
const slotsFilled = S.currentInstanceTargets.length >= targetsPerInstance;
const allHeroesSelected = S.currentInstanceTargets.length >= S.heroes.length;
if(slotsFilled || allHeroesSelected) {
if(allHeroesSelected && S.currentInstanceTargets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.currentInstanceTargets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) finishAction(heroIdx);
else render();
} else render();
} else if(S.pending === 'Heal') {
if(S.currentInstanceTargets.includes(id)) { toast('Already targeted in this instance!'); return; }
S.targets.push(id);
S.currentInstanceTargets.push(id);
const slotsFilled = S.currentInstanceTargets.length >= targetsPerInstance;
const allHeroesSelected = S.currentInstanceTargets.length >= S.heroes.length;
if(slotsFilled || allHeroesSelected) {
if(allHeroesSelected && S.currentInstanceTargets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.currentInstanceTargets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) finishAction(heroIdx);
else render();
} else render();
} else if(S.pending === 'Alpha') {
// Alpha: can't target self or already-acted heroes
const alphaUser = S.heroes[S.activeIdx];
if(id === alphaUser.id) { toast('Cannot Alpha yourself!'); return; }
const targetIdx = S.heroes.findIndex(x => x.id === id);
if(S.acted.includes(targetIdx)) { toast('That hero already acted!'); return; }
if(S.targets.includes(id)) { toast('Already targeted!'); return; }
S.targets.push(id);
if(S.targets.length >= S.alphaTargetsNeeded) {
executeAlphaAction(S.activeIdx, S.targets);
} else render();
}
}

function executeAlphaAction(alphaUserIdx, targetIds) {
const alphaUser = S.heroes[alphaUserIdx];
const actionsToGrant = S.alphaLevel;
// Mark Alpha user as acted (forfeits ALL actions)
S.acted.push(alphaUserIdx);
S.pending = null;
S.targets = [];
toast(`${alphaUser.n} used Alpha! Granting ${actionsToGrant} action${actionsToGrant>1?'s':''} to ${targetIds.length} hero${targetIds.length>1?'es':''}!`);
// Set up multi-action state for granted heroes
S.alphaGrantedActions = [];
targetIds.forEach(id => {
const targetIdx = S.heroes.findIndex(h => h.id === id);
if(targetIdx >= 0) {
for(let i = 0; i < actionsToGrant; i++) {
S.alphaGrantedActions.push(targetIdx);
}
}
});
S.alphaCurrentAction = 0;
// Start first granted action
if(S.alphaGrantedActions.length > 0) {
const nextHeroIdx = S.alphaGrantedActions[0];
S.activeIdx = nextHeroIdx;
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
}
render();
}

function selectEncampmentTarget(enemyId) {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const currentSelected = S.encampmentSelectedTargets;
// Toggle selection
if(currentSelected.includes(enemyId)) {
S.encampmentSelectedTargets = currentSelected.filter(id => id !== enemyId);
} else {
if(currentSelected.length >= kills) {
toast(`Already selected ${kills} enem${kills>1?'ies':'y'}!`);
return;
}
S.encampmentSelectedTargets.push(enemyId);
}
render();
}

function confirmEncampmentKills() {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets;
if(selected.length !== kills) {
toast(`Select ${kills} enem${kills>1?'ies':'y'} to remove!`);
return;
}
// Remove selected enemies from S.enemies
S.enemies = S.enemies.filter(e => !selected.includes(e.id));
toast(`${kills} enem${kills>1?'ies':'y'} removed!`, 2000);
// Clear flags
S.selectingEncampmentTargets = false;
S.encampmentEarlyKills = 0;
S.encampmentSelectedTargets = [];
// Start combat normally
render();
}

function executeInstance(action, heroIdx, targets) {
const h = S.heroes[heroIdx];
const pow = h.p;
if(action === 'Attack') {
const targetNames = [];
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
targetNames.push(e.n);
dealDamageToEnemy(e, pow);
});
if(targetNames.length > 0) toast(`${h.n} attacked ${targetNames.join(', ')} for ${pow} damage each!`);
} else if(action === 'Shield') {
const targetNames = [];
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
const level = getLevel('Shield', heroIdx);
const shieldAmt = 2 * pow * level;
target.sh += shieldAmt;
if(target.sh > target.m) target.sh = target.m;
targetNames.push(target.n);
});
if(targetNames.length > 0) {
const level = getLevel('Shield', heroIdx);
const shieldAmt = 2 * pow * level;
toast(`${targetNames.join(' and ')} gained ${shieldAmt} shield!`);
}
} else if(action === 'Heal') {
const healed = [];
const revived = [];
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
const level = getLevel('Heal', heroIdx);
const healAmt = 2 * pow * level;
if(target.ls) {
target.ls = false;
target.lst = 0;
target.h = healAmt;
revived.push(target.n);
} else {
target.h += healAmt;
if(target.h > target.m) target.h = target.m;
healed.push(target.n);
}
});
const level = getLevel('Heal', heroIdx);
const healAmt = 2 * pow * level;
if(healed.length > 0) toast(`${healed.join(' and ')} restored ${healAmt} HP!`);
if(revived.length > 0) toast(`${revived.join(' and ')} revived with ${healAmt} HP!`);
}
}

function executeGrapple(heroIdx, targets, stunDuration) {
const h = S.heroes[heroIdx];
let totalDmg = 0;
const targetNames = [];
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
totalDmg += e.p;
e.st += stunDuration;
targetNames.push(e.n);
// Check prince quest completion
if(S.princeQuestActive && S.round === 1 && !S.princeQuestCompleted) {
S.princeQuestCompleted = true;
toast('Prince Quest completed! Ring retrieved!', 3000);
}
});
if(targetNames.length > 0) toast(`${h.n} grappled ${targetNames.join(', ')} - stunned ${stunDuration} turn${stunDuration>1?'s':''}!`);
h.h -= totalDmg;
if(totalDmg > 0) toast(`${h.n} took ${totalDmg} damage from Grapple recoil!`);
if(h.h <= 0 && !h.ls) {
if(h.g > 0) {
h.g--;
h.h += totalDmg;
toast(`${h.n}'s Ghost charge cancelled the lethal hit!`);
} else {
h.h = 0;
h.ls = true;
h.lst = 0;
toast(`${h.n} entered Last Stand!`);
showTutorialPop('last_stand_intro', "Ouch, that stinks. Well, you're not dead yet! While your ally lives, you live - but it looks like your actions are somewhat limited. Be careful though! If you don't get healing soon, you'll slip further and further away...");
}
}
}

function dealDamageToEnemy(enemy, dmg) {
triggerHitAnimation(enemy.id);
if(enemy.sh > 0) {
if(enemy.sh >= dmg) { enemy.sh -= dmg; return; }
else { dmg -= enemy.sh; enemy.sh = 0; }
}
enemy.h -= dmg;

// RIBBLETON TUTORIAL: Track Wolf damage/death
if(tutorialState && S.floor === 0 && enemy.n === 'Wolf') {
console.log('[TUTORIAL] Wolf took damage! HP now:', enemy.h, 'wolfDamaged was:', tutorialState.wolfDamaged);
if(enemy.h > 0 && !tutorialState.wolfDamaged) {
tutorialState.wolfDamaged = true;
console.log('[TUTORIAL] Set wolfDamaged = true');
// Show PROMPT 3 after this action finishes
}
}

if(enemy.h <= 0) {
if(enemy.g > 0) {
enemy.g--;
enemy.h += dmg;
toast(`${enemy.n}'s Ghost charge cancelled the lethal hit!`, 2000);
return;
}
enemy.h = 0;

// RIBBLETON TUTORIAL: Track Wolf/Goblin kills
if(tutorialState && S.floor === 0) {
if(enemy.n === 'Wolf') tutorialState.wolfKilled = true;
if(enemy.n === 'Goblin') tutorialState.goblinKilled = true;
}

S.gold += enemy.g;
S.combatGold += enemy.g;
S.combatXP += enemy.x;
upd();
setTimeout(() => {
S.enemies = S.enemies.filter(e => e.id !== enemy.id);
render();
checkCombatEnd();
}, 300);
}
}

function finishAction(heroIdx) {
// Check if this is an Alpha-granted action
if(S.alphaGrantedActions && S.alphaGrantedActions.length > 0) {
S.alphaCurrentAction++;
if(S.alphaCurrentAction < S.alphaGrantedActions.length) {
// More Alpha-granted actions remain
const nextHeroIdx = S.alphaGrantedActions[S.alphaCurrentAction];
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = nextHeroIdx;
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
render();
return;
} else {
// All Alpha-granted actions complete
S.alphaGrantedActions = [];
S.alphaCurrentAction = 0;
}
}
// Normal action finish
S.acted.push(heroIdx);
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = -1;

// RIBBLETON TUTORIAL: Show prompts after actions
if(tutorialState && S.floor === 0) {
const h = S.heroes[heroIdx];
console.log('[TUTORIAL] finishAction - stage:', tutorialState.stage, 'wolfDamaged:', tutorialState.wolfDamaged, 'hero:', h.n, 'round:', S.round);
// After Warrior attacks Wolf and damages it -> PROMPT 3
if((tutorialState.stage === 'targeting_wolf' || tutorialState.stage === 'warrior_attack') && tutorialState.wolfDamaged && h.n === 'Warrior' && S.round === 1) {
console.log('[TUTORIAL] Triggering PROMPT 3 - Healer D20');
tutorialState.stage = 'healer_d20';
showTutorialPop('ribbleton_healer_d20', "Nice hit! Doesn't look like the Healer has any damage to heal right now, but they can still make a difference! Click the D20!", () => {
S.activeIdx = 1; // Select Healer
render();
});
checkTurnEnd();
return;
}
// After D20 resolves and damages Wolf -> transition to enemy turn explanation
else if(tutorialState.stage === 'd20_menu' && h.n === 'Healer') {
tutorialState.stage = 'enemy_turn_wait';
// PROMPT 5 will appear before enemy turn in checkTurnEnd
}
// After Healer heals -> PROMPT 8
else if(tutorialState.stage === 'expand_targets' && h.n === 'Healer') {
tutorialState.stage = 'finish_wolf';
showTutorialPop('ribbleton_finish_wolf', "Now finish off that Wolf!", () => {
S.activeIdx = 0; // Select Warrior
render();
});
checkTurnEnd();
return;
}
}

checkTurnEnd();
render();
}

function checkTurnEnd() {
const allActedIncludingLS = S.heroes.filter(h => h.st === 0).every((h, i) => {
const actualIdx = S.heroes.findIndex(hero => hero.id === h.id);
return S.acted.includes(actualIdx);
});
if(allActedIncludingLS) {
S.heroes.forEach(h => { if(h.ls) h.lst++; });

// RIBBLETON TUTORIAL: PROMPT 5 - Explain enemy turn before first enemy turn
if(tutorialState && S.floor === 0 && tutorialState.stage === 'enemy_turn_wait') {
console.log('[TUTORIAL] Triggering PROMPT 5 - Enemy Turn');
tutorialState.stage = 'enemy_turn_explained';
showTutorialPop('ribbleton_enemy_turn', "Uh oh! Enemies attack every turn, and they attack straight across from them!", () => {
console.log('[TUTORIAL] PROMPT 5 dismissed, starting enemy turn');
setTimeout(() => { S.locked = true; enemyTurn(); }, 500);
});
} else {
setTimeout(() => { S.locked = true; enemyTurn(); }, 500);
}
}
}

function enemyTurn() {
S.turn = 'enemy';
S.acted = [];
S.activeIdx = -1;
render();
S.enemies.forEach(e => {
if(e.st > 0) e.st--;
e.turnsSinceGain++;
// RIBBLETON TUTORIAL: Enemies don't gain sigils (except Goblin on Round 3)
const isTutorial = tutorialState && S.floor === 0;
const isGoblinRound3 = isTutorial && e.n === 'Goblin' && S.round === 3;
if(e.turnsSinceGain >= e.gainRate && !isTutorial) {
e.turnsSinceGain = 0;
// Draw multiple sigils per turn if specified (Dragons draw 2)
const draws = e.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(e);
}
}
e.alphaActed = false;
});
// Process recruits - stun decrement and sigil drawing
if(S.recruits) {
S.recruits.forEach(r => {
if(r.st > 0) r.st--;
if(!r.turnsSinceGain) r.turnsSinceGain = 0;
r.turnsSinceGain++;
if(r.turnsSinceGain >= r.gainRate) {
r.turnsSinceGain = 0;
const draws = r.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(r);
}
}
});
}
setTimeout(() => executeAlphaPhase(), 800);
}

function drawEnemyStartSigil(enemy, base) {
const pool = base.pool;
if(!pool) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
if(pool === 'ANY') {
const allSigils = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk', 'Expand'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 1 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
} else if(pool === 'ANY_ADVANCED') {
const allSigils = ['Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 2 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
} else if(Array.isArray(pool)) {
const availablePool = pool.filter(sigName => {
if(sigName === 'Attack2') return !heldSigils.includes('Attack');
if(sigName === 'Shield2') return !heldSigils.includes('Shield');
return !heldSigils.includes(sigName);
});
if(availablePool.length === 0) return;
const pick = availablePool[Math.floor(Math.random() * availablePool.length)];
if(pick === 'Attack2') {
enemy.s.push({sig:'Attack', level:2, perm:false});
} else if(pick === 'Shield2') {
enemy.s.push({sig:'Shield', level:2, perm:false});
} else {
enemy.s.push({sig:pick, level:1, perm:false});
}
}
}

function drawEnemySigil(enemy) {
const pool = enemy.pool;
if(!pool || pool.length === 0) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
if(pool === 'ANY') {
const allSigils = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk', 'Expand'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 1 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
toast(`${enemy.n} drew ${sig} L${level}!`);
} else if(pool === 'ANY_ADVANCED') {
const allSigils = ['Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 2 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
toast(`${enemy.n} drew ${sig} L${level}!`);
} else {
const availablePool = pool.filter(sigName => {
if(sigName === 'Attack2') return !heldSigils.includes('Attack');
if(sigName === 'Shield2') return !heldSigils.includes('Shield');
return !heldSigils.includes(sigName);
});
if(availablePool.length === 0) return;
const pick = availablePool[Math.floor(Math.random() * availablePool.length)];
if(pick === 'Attack2') {
enemy.s.push({sig:'Attack', level:2, perm:false});
toast(`${enemy.n} drew Attack L2!`);
} else if(pick === 'Shield2') {
enemy.s.push({sig:'Shield', level:2, perm:false});
toast(`${enemy.n} drew Shield L2!`);
} else {
enemy.s.push({sig:pick, level:1, perm:false});
toast(`${enemy.n} drew ${pick} L1!`);
}
}
}

function executeAlphaPhase() {
const alphaEnemies = S.enemies.filter(e => e.st === 0 && e.s.some(sigil => sigil.sig === 'Alpha' && !sigil.perm));
if(alphaEnemies.length === 0) { setTimeout(executeRecruitPhase, 300); return; }
let delay = 0;
alphaEnemies.forEach(alphaEnemy => {
setTimeout(() => {
const allies = S.enemies.filter(e => e.id !== alphaEnemy.id && e.h > 0 && !e.s.some(s => s.sig === 'Alpha' && !s.perm));
if(allies.length === 0) { toast(`${alphaEnemy.n}'s Alpha has no valid allies!`); alphaEnemy.alphaActed = true; return; }
allies.sort((a, b) => { if(b.p !== a.p) return b.p - a.p; return b.s.length - a.s.length; });
const bestAlly = allies[0];
const alphaSigil = alphaEnemy.s.find(s => s.sig === 'Alpha');
const attacks = alphaSigil.level;
toast(`${alphaEnemy.n} grants ${bestAlly.n} ${attacks} attack${attacks>1?'s':''}!`);
for(let i = 0; i < attacks; i++) executeEnemyBaseAttack(bestAlly);
alphaEnemy.alphaActed = true;
}, delay);
delay += 600;
});
setTimeout(() => executeRecruitPhase(), delay + 300);
}

function executeRecruitPhase() {
if(!S.recruits || S.recruits.length === 0) { setTimeout(executeNormalEnemyPhase, 300); return; }
let delay = 0;
S.recruits.forEach(recruit => {
setTimeout(() => executeRecruitTurn(recruit), delay);
delay += 600;
});
setTimeout(() => executeNormalEnemyPhase(), delay + 300);
}

function executeRecruitTurn(recruit) {
if(recruit.st > 0) { toast(`${recruit.n} (Recruit) is stunned!`); return; }
if(recruit.h <= 0) return; // Dead recruit
// Recruit attacks enemies (not heroes)
executeRecruitBaseAttack(recruit);
const drawnSigils = recruit.s.filter(s => !s.perm && s.sig !== 'Alpha');
drawnSigils.forEach(sigil => executeRecruitSigil(recruit, sigil));
recruit.s = recruit.s.filter(s => s.perm);
render();
}

function executeRecruitBaseAttack(recruit) {
// Target lowest HP enemy
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) attacked ${target.n} for ${recruit.p}!`);
}

function executeRecruitSigil(recruit, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
for(let i = 0; i < level; i++) {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) ${sig} attacked ${target.n} for ${recruit.p}!`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * recruit.p * level;
recruit.sh = (recruit.sh || 0) + shieldAmt;
if(recruit.sh > recruit.m) recruit.sh = recruit.m;
toast(`${recruit.n} (Recruit) gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * recruit.p * level;
// Heal lowest HP hero
const targets = S.heroes.filter(h => h.h > 0 && !h.ls);
if(targets.length > 0) {
targets.sort((a, b) => a.h - b.h);
const healTarget = targets[0];
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${recruit.n} (Recruit) healed ${healTarget.n} for ${healAmt}!`);
}
} else if(sig === 'Grapple') {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
const dmgToRecruit = target.p;
recruit.h -= dmgToRecruit;
toast(`${recruit.n} (Recruit) grappled ${target.n}!`);
if(recruit.h <= 0) {
recruit.h = 0;
toast(`${recruit.n} (Recruit) defeated by grapple recoil!`);
S.recruits = S.recruits.filter(r => r.id !== recruit.id);
} else {
target.st = level;
toast(`${target.n} stunned for ${level} turns!`);
}
} else if(sig === 'Ghost') {
recruit.g = (recruit.g || 0) + level;
if(recruit.g > 9) recruit.g = 9;
toast(`${recruit.n} (Recruit) gained ${level} Ghost charge!`);
}
}

function executeNormalEnemyPhase() {
const lanes = {};
S.enemies.forEach(e => { if(!lanes[e.li]) lanes[e.li] = []; lanes[e.li].push(e); });
let delay = 0;
Object.keys(lanes).forEach(laneIdx => {
lanes[laneIdx].forEach(enemy => {
setTimeout(() => executeEnemyTurn(enemy), delay);
delay += 600;
});
});
setTimeout(() => endEnemyTurn(), delay + 500);
}

function executeEnemyTurn(enemy) {
if(enemy.st > 0) { toast(`${enemy.n} is stunned!`); return; }
if(enemy.alphaActed) {
toast(`${enemy.n} used Alpha (skipping normal turn)`);
enemy.s = enemy.s.filter(s => s.perm);
return;
}
executeEnemyBaseAttack(enemy);
const drawnSigils = enemy.s.filter(s => !s.perm && s.sig !== 'Alpha');
drawnSigils.forEach(sigil => executeEnemySigil(enemy, sigil));
enemy.s = enemy.s.filter(s => s.perm);
render();
}

function executeEnemyBaseAttack(enemy) {
const target = S.heroes[enemy.li];
if(target && target.h > 0) dealDamageToHero(target, enemy.p, `${enemy.n}'s Base Attack`);
}

function executeEnemySigil(enemy, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
for(let i = 0; i < level; i++) {
const target = S.heroes[enemy.li];
if(target && target.h > 0) dealDamageToHero(target, enemy.p, `${enemy.n}'s ${sig}`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * enemy.p * level;
enemy.sh = (enemy.sh || 0) + shieldAmt;
if(enemy.sh > enemy.m) enemy.sh = enemy.m;
toast(`${enemy.n} gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * enemy.p * level;
const allies = S.enemies.filter(e => e.id !== enemy.id && e.h > 0);
if(allies.length > 0) {
allies.sort((a,b) => a.h - b.h);
const healTarget = allies[0];
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${enemy.n} healed ${healTarget.n} for ${healAmt}!`);
}
} else if(sig === 'Grapple') {
const target = S.heroes[enemy.li];
if(target && target.h > 0) {
const dmgToEnemy = target.p;
enemy.h -= dmgToEnemy;
toast(`${enemy.n} grappled ${target.n}!`);
if(enemy.h <= 0) {
enemy.h = 0;
toast(`${enemy.n} defeated by grapple recoil!`);
S.enemies = S.enemies.filter(e => e.id !== enemy.id);
} else {
target.st = level;
toast(`${target.n} stunned for ${level} turns!`);
}
}
} else if(sig === 'Ghost') {
enemy.g = (enemy.g || 0) + level;
if(enemy.g > 9) enemy.g = 9;
toast(`${enemy.n} gained ${level} Ghost charge!`);
} else if(sig === 'Expand') {
toast(`${enemy.n} used Expand (affects their attacks)`);
} else if(sig === 'Asterisk') {
toast(`${enemy.n} used Asterisk (not yet implemented for enemies)`);
}
}

function dealDamageToHero(hero, dmg, source) {
triggerHitAnimation(hero.id);
if(hero.sh > 0) {
if(hero.sh >= dmg) { hero.sh -= dmg; toast(`${hero.n}'s shield absorbed ${dmg} damage!`); return; }
else { dmg -= hero.sh; hero.sh = 0; }
}
hero.h -= dmg;
toast(`${source} dealt ${dmg} damage to ${hero.n}!`);
if(hero.h <= 0) {
if(hero.g > 0) {
hero.g--;
hero.h += dmg;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
hero.h = 0;
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`);
showTutorialPop('last_stand_intro', "Ouch, that stinks. Well, you're not dead yet! While your ally lives, you live - but it looks like your actions are somewhat limited. Be careful though! If you don't get healing soon, you'll slip further and further away...");
}
}
}

function endEnemyTurn() {
S.heroes.forEach(h => {
if(h.st > 0) {
h.st--;
if(h.st === 0) toast(`${h.n} is no longer stunned!`);
}
});
if(checkCombatEnd()) return;
S.round++;

// RIBBLETON TUTORIAL: Handle round transitions
if(tutorialState && S.floor === 0) {
tutorialState.round = S.round;
console.log('[TUTORIAL] Round transition - Round:', S.round, 'Stage:', tutorialState.stage);
// Round 2: PROMPT 6 - Healer heal
if(S.round === 2 && tutorialState.stage === 'enemy_turn_explained') {
console.log('[TUTORIAL] Triggering PROMPT 6 - Healer Heal');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'healer_heal';
upd();
render();
showTutorialPop('ribbleton_healer_heal', "Oh gosh - looks like both of you took some damage. Healer can help with that - click the Heal sigil! You can pick which order your heroes take their actions.", () => {
S.activeIdx = 1; // Select Healer
render();
});
return;
} else if(S.round === 2) {
console.log('[TUTORIAL] Round 2 but stage is:', tutorialState.stage, '(expected: enemy_turn_explained)');
}
// Round 3: Force Goblin to draw Shield, then PROMPT 9 + 10
else if(S.round === 3 && tutorialState.stage === 'finish_wolf') {
// Force Goblin to draw Shield
const goblin = S.enemies.find(e => e.n === 'Goblin');
if(goblin && !goblin.s.some(s => s.sig === 'Shield')) {
goblin.s.push({sig:'Shield', level:1, perm:false});
toast('Goblin drew Shield L1!');
}
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'shield_sigil';
upd();
render();
// First show that enemies can get sigils
showTutorialPop('enemies_get_sigils', "Enemies can draw sigils too! They draw from a pool specific to their type, and gain sigils over time.", () => {
// Then explain this specific sigil
showTutorialPop('ribbleton_shield_sigil', "The Goblin has drawn a Shield sigil! Enemies use their sigils AFTER they attack, then those sigils fall off. Try to finish him before he can Shield up!", () => {
// PROMPT 10: Handoff
showTutorialPop('ribbleton_handoff', "You're on your own now - good luck!", () => {
tutorialState.stage = 'free';
render();
});
});
});
return;
}
}

S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
upd();
render();
}

function checkCombatEnd() {
if(S.enemies.length === 0) {
// Tutorial Floor 0: Special ending (no XP/Gold rewards)
if(S.floor === 0) {
S.combatXP = 0;
S.combatGold = 0;
setTimeout(() => {
toast('Victory!');
setTimeout(finishRibbletonTutorial, 1000);
}, 500);
return true;
}

// Normal combat victory
setTimeout(() => {
const combatXP = S.combatXP || 0;
let starBonus = 0;
S.heroes.forEach(h => {
const starLevel = getLevel('Star', S.heroes.indexOf(h));
starBonus += starLevel * 0.5;
});
const bonusXP = Math.floor(combatXP * (1 + starBonus));
S.xp += bonusXP;
S.combatXP = 0; // Reset combat XP
// Recruits persist until killed - don't clear here
if(starBonus > 0) toast(`Star Bonus! ${combatXP} √ó ${(1 + starBonus).toFixed(1)} = ${bonusXP} XP`, 3000);
upd();
toast('Victory!');
setTimeout(levelUp, 1000);
}, 500);
return true;
}
const allDead = S.heroes.every(h => h.ls);
if(allDead) {
setTimeout(() => {
toast('Defeated!');
setTimeout(() => showDeathScreen(), 1000);
}, 500);
return true;
}
return false;
}

function render() {
const v = document.getElementById('gameView');
let html = '';
// Special state: Encampment enemy selection
if(S.selectingEncampmentTargets) {
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets.length;
html += '<div style="text-align:center;font-weight:bold;padding:0.75rem;background:rgba(0,0,0,0.05);border-radius:6px;margin-bottom:0.75rem">';
html += `<div style="font-size:1.1rem;color:#dc2626">Encampment Early Kill</div>`;
html += `<div style="font-size:0.85rem;margin-top:0.25rem">Click ${kills} enem${kills>1?'ies':'y'} to remove before combat (${selected}/${kills} selected)</div>`;
html += '</div>';
html += '<div class="combat-grid">';
html += '<div class="column heroes">';
html += '<div style="text-align:center;font-weight:bold;padding:0.25rem;background:rgba(0,0,0,0.1);border-radius:6px;margin-bottom:0.5rem;font-size:0.85rem">HEROES</div>';
S.heroes.forEach((h,i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
const heroImage = HERO_IMAGES[h.n.toLowerCase()] || '';
html += `<div class="card hero">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${h.n}</div>
${heroImage ? `<div style="text-align:center;margin-bottom:0.25rem"><img src="${heroImage}" style="width:48px;height:48px;image-rendering:pixelated"></div>` : ''}
<div class="sigil-divider"></div>
<div class="sigil-row">`;
const activeSigils = [...h.s, ...(h.ts || [])];
activeSigils.forEach(s => {
const lvl = getLevel(s, i);
const cl = lvl===0?'l0':lvl===1?'l1':lvl===2?'l2':lvl===3?'l3':'l4';
html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${s}', this)" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${s}', this), 500)" ontouchend="hideTooltip()">${sigilIconOnly(s)}</span>`;
});
html += '</div>';
html += `<div style="text-align:center;font-size:0.8rem;margin-top:0.25rem">${h.p}‚ö° | ${hp}${extra.length>0?' | '+extra.join(' '):''}</div>`;
html += '</div>';
});
html += '</div>';
html += '<div class="column enemies">';
html += '<div style="text-align:center;font-weight:bold;padding:0.25rem;background:rgba(0,0,0,0.1);border-radius:6px;margin-bottom:0.5rem;font-size:0.85rem">ENEMIES</div>';
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });
S.heroes.forEach((hero, laneIdx) => {
const laneEnemies = enemyLanes[laneIdx] || [];
html += '<div class="combat-lane">';
if(laneEnemies.length === 0) {
html += `<div style="text-align:center;font-size:0.75rem;padding:0.5rem;opacity:0.5;font-style:italic;margin-bottom:0.5rem">Empty</div>`;
} else {
laneEnemies.forEach(e => {
const isSelected = S.encampmentSelectedTargets.includes(e.id);
let cardClasses = 'card enemy targetable';
if(isSelected) cardClasses += ' targeted';
const extra = [];
if(e.sh > 0) extra.push(`${e.sh}üõ°`);
// Only show ghost charges if enemy actually has them (not gold drops!)
const encampmentGhostCharges = e.ghostCharges || 0;
if(encampmentGhostCharges > 0) extra.push(`${encampmentGhostCharges}${sigilIconOnly('Ghost')}`);
if(isSelected) extra.push('‚ùå');
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
html += `<div class="${cardClasses}" onclick="selectEncampmentTarget('${e.id}')">
<div style="text-align:center;font-size:2rem;margin-bottom:0.25rem">${enemyEmoji}</div>
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${e.n}</div>
<div style="text-align:center;font-size:0.8rem">${e.p}‚ö° | ${e.h}/${e.m}‚ù§${extra.length>0?' | '+extra.join(' '):''}</div>
<div class="sigil-divider"></div>
<div class="sigil-row">`;
// Show base Attack ONLY if enemy doesn't have Attack in their sigil list
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
if(!hasAttackSigil) {
html += `<span class="sigil engraved">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
const permStyle = sigil.perm ? 'engraved' : cl;
html += `<span class="sigil ${permStyle}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),500)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig)}${sigil.level}</span>`;
});
html += '</div></div>';
});
}
html += '</div>'; // Close combat-lane
});
html += '</div></div>';
if(selected >= kills) {
html += '<button class="btn" style="background:#dc2626;margin-top:1rem" onclick="confirmEncampmentKills()">Confirm Removals</button>';
}
v.innerHTML = html;
return;
}

// RIBBLETON TUTORIAL: Show targeting prompts
if(tutorialState && S.floor === 0 && S.pending) {
// PROMPT 2: Targeting Wolf with Warrior Attack
if(tutorialState.stage === 'warrior_attack' && S.pending === 'Attack' && S.targets.length === 0) {
tutorialState.stage = 'targeting_wolf';
showTutorialPop('ribbleton_targeting', "You can choose which enemy to target. That Wolf looks nasty - you should take it out first!", () => {
render();
});
return;
}
// PROMPT 7: Expand heal targets
else if(tutorialState.stage === 'healer_heal' && S.pending === 'Heal' && S.currentInstanceTargets.length === 0 && S.targets.length === 0) {
tutorialState.stage = 'expand_targets';
showTutorialPop('ribbleton_expand', "Helpful - Healer starts with Expand! That means they can Expand their actions to 1 extra target. Click both heroes to heal off some damage!", () => {
render();
});
return;
}
}

html += '<div style="text-align:center;font-weight:bold;padding:0.75rem;background:rgba(0,0,0,0.05);border-radius:6px;margin-bottom:0.75rem">';
if(S.turn!=='player') {
html += 'Enemy Turn‚Ä¶';
} else if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
const selected = S.targets.length;
html += `<div style="color:#b64141;font-size:1.1rem">${S.d20Action} (DC ${S.d20DC})</div>`;
html += `<div style="font-size:0.85rem;margin-top:0.25rem">Select target enemy (${selected}/${maxTargets})</div>`;
} else if(S.pending) {
const targetsPerInstance = getTargetsPerInstance(S.pending, S.activeIdx);
const targetType = needsEnemyTarget(S.pending) ? 'enemy' : 'hero';
if(isMultiInstance(S.pending)) {
const targetsInInstance = S.currentInstanceTargets.length;
html += `<div style="color:#b64141;font-size:1.1rem">${S.pending}</div>`;
html += `<div style="font-size:0.85rem;margin-top:0.25rem">Select ${targetType} (${targetsInInstance}/${targetsPerInstance})</div>`;
html += `<div style="font-size:0.75rem;opacity:0.8;margin-top:0.25rem">${S.instancesRemaining} instance${S.instancesRemaining>1?'s':''} remaining</div>`;
} else {
const selected = S.targets.length;
const max = targetsPerInstance;
html += `<div style="color:#b64141;font-size:1.1rem">${S.pending}</div>`;
html += `<div style="font-size:0.85rem;margin-top:0.25rem">Select ${targetType} (${selected}/${max})</div>`;
}
} else if(S.activeIdx === -1) {
const remaining = S.heroes.filter((h,i) => !S.acted.includes(i) && h.st === 0).length;
html += `<div style="font-size:1.1rem">Choose Hero to Act</div>`;
html += `<div style="font-size:0.8rem;opacity:0.8;margin-top:0.25rem">${remaining} hero${remaining>1?'es':''} remaining</div>`;
} else {
const h = S.heroes[S.activeIdx];
if(h) {
if(S.asteriskPrimed) html += `${h.n}'s Turn - Asterisk √ó${S.asteriskMultiplier} PRIMED!`;
else if(h.ls) html += `${h.n} Last Stand (Turn ${h.lst + 1}) - D20 only!`;
else html += `${h.n}'s Turn`;
}
}
html += '</div>';
// New layout: Each hero and their enemies in a horizontal lane
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });

S.heroes.forEach((h,i) => {
html += '<div class="combat-lane">';
html += '<div style="display:flex;gap:0.75rem;justify-content:space-between;align-items:flex-start">';

// Hero section (left side of lane)
html += '<div style="flex:0 0 auto">';
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
const isActive = S.activeIdx === i;
const isTargetable = S.pending && needsHeroTarget(S.pending);
const hasActed = S.acted.includes(i);
let cardClasses = 'card hero';
if(isActive) cardClasses += ' active';
if(isTargetable) cardClasses += ' targetable';
if(hasActed) cardClasses += ' acted';
if(h.ls) cardClasses += ' last-stand';
const isTargeted = S.targets.includes(h.id);
if(isTargeted) cardClasses += ' targeted';
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
if(h.st > 0) extra.push(`üòµ${h.st}T`);
if(hasActed) extra.push('‚úì');
let onclick = '';
if(isTargetable) onclick = `onclick="tgtHero('${h.id}')"`;
else if(!hasActed && h.st === 0 && !S.pending) onclick = `onclick="selectHero(${i})"`;
const heroImage = HERO_IMAGES[h.n.toLowerCase()] || '';
html += `<div class="${cardClasses}" ${onclick}>
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${h.n}</div>
${heroImage ? `<div style="text-align:center;margin-bottom:0.25rem"><img src="${heroImage}" style="width:48px;height:48px;image-rendering:pixelated"></div>` : ''}`;
html += '<div class="sigil-divider"></div>';
html += '<div class="sigil-row">';
const activeSigils = [...h.s, ...(h.ts || [])];
activeSigils.forEach(s => {
const lvl = getLevel(s, i);
// Calculate visual level for roll-down effect
let visualLvl = lvl;
if(S.activeIdx === i && S.pending === s && isMultiInstance(s) && S.totalInstances) {
const usedInstances = S.totalInstances - S.instancesRemaining;
visualLvl = Math.max(0, lvl - usedInstances);
}
const cl = visualLvl===0?'l0':visualLvl===1?'l1':visualLvl===2?'l2':visualLvl===3?'l3':visualLvl===4?'l4':'l5';
const canClick = !S.acted.includes(i) && h.st === 0 && !S.pending && ['Attack','Shield','Grapple','Heal','Ghost','D20','Asterisk'].includes(s);
const isPrimed = (s === 'Asterisk' && S.asteriskPrimed && S.activeIdx === i);
const isActiveAction = (S.pending === s && S.activeIdx === i);
html += `<span class="sigil ${cl} ${isPrimed?'asterisk-primed':''} ${isActiveAction?'active-action':''} ${canClick?'clickable':''}" ${canClick?`onclick="act('${s}', ${i})"`:''}
onmouseenter="showTooltip('${s}', this)" onmouseleave="hideTooltip()"
ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${s}', this), 500)" ontouchend="hideTooltip()">${sigilIconOnly(s)}</span>`;
});
html += '</div>';
html += `<div style="text-align:center;font-size:0.8rem;margin-top:0.25rem">${h.p}‚ö° | ${hp}${extra.length>0?' | '+extra.join(' '):''}</div>`;
html += '</div>';
// Show recruit for this hero if exists
if(S.recruits) {
const recruit = S.recruits.find(r => r.recruitedBy === i);
if(recruit) {
const extra = [];
if(recruit.sh > 0) extra.push(`${recruit.sh}üõ°`);
// Only show ghost charges if recruit actually has them (not gold drops!)
const recruitGhostCharges = recruit.ghostCharges || 0;
if(recruitGhostCharges > 0) extra.push(`${recruitGhostCharges}${sigilIconOnly('Ghost')}`);
if(recruit.st > 0) extra.push(`üòµ${recruit.st}T`);
html += `<div class="card hero" style="opacity:0.85;border:2px dashed #22c55e">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${recruit.n} ü§ù</div>
<div style="text-align:center;font-size:0.8rem">${recruit.p}‚ö° | ${recruit.h}/${recruit.m}‚ù§${extra.length>0?' | '+extra.join(' '):''}</div>
<div style="text-align:center;font-size:0.65rem;opacity:0.7;margin-top:0.25rem">Recruited</div>
<div class="sigil-divider"></div>
<div class="sigil-row">
<span class="sigil engraved">${sigilIconOnly('Attack')}</span>`;
recruit.s.forEach(sigil => {
const cl = sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
const permStyle = sigil.perm ? 'engraved' : cl;
html += `<span class="sigil ${permStyle}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sigil.sig}', this), 500)" ontouchend="hideTooltip()">${sigilIconOnly(sigil.sig)}${sigil.level}</span>`;
});
html += '</div></div>';
}
}
html += '</div>'; // Close hero section

// Enemy section (right side of lane)
html += '<div style="flex:1;display:flex;flex-wrap:wrap;gap:0.5rem;justify-content:flex-end;align-items:flex-start">';
const laneEnemies = enemyLanes[i] || [];
if(laneEnemies.length === 0) {
html += `<div style="text-align:center;font-size:0.75rem;padding:0.5rem;opacity:0.5;font-style:italic">Empty</div>`;
} else {
laneEnemies.forEach(e => {
const isTargetable = (S.pending && needsEnemyTarget(S.pending)) || S.pending === 'D20_TARGET';
const selectCount = S.targets.filter(t => t === e.id).length;
let cardClasses = 'card enemy';
if(isTargetable) cardClasses += ' targetable';
if(selectCount > 0) cardClasses += ' targeted';
const extra = [];
if(e.sh > 0) extra.push(`${e.sh}üõ°`);
// Only show ghost charges if enemy actually has them (not gold drops!)
const ghostCharges = e.ghostCharges || 0;
if(ghostCharges > 0) extra.push(`${ghostCharges}${sigilIconOnly('Ghost')}`);
if(e.st > 0) extra.push(`üòµ${e.st}T`);
if(selectCount > 0) extra.push(`√ó${selectCount}`);
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
html += `<div class="${cardClasses}" ${isTargetable?`onclick="tgtEnemy('${e.id}')"`:''}">
<div style="text-align:center;font-size:2rem;margin-bottom:0.25rem">${enemyEmoji}</div>
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${e.n}</div>
<div style="text-align:center;font-size:0.8rem">${e.p}‚ö° | ${e.h}/${e.m}‚ù§${extra.length>0?' | '+extra.join(' '):''}</div>`;
html += '<div class="sigil-divider"></div>';
html += '<div class="sigil-row">';
// Show base Attack ONLY if enemy doesn't have Attack in their sigil list
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
if(!hasAttackSigil) {
html += `<span class="sigil engraved">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
const permStyle = sigil.perm ? 'engraved' : cl;
html += `<span class="sigil ${permStyle}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),500)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig)}${sigil.level}</span>`;
});
html += '</div></div>';
});
}
html += '</div>'; // Close enemy section
html += '</div>'; // Close flex container
html += '</div>'; // Close combat-lane
});
v.innerHTML = html;
}

// ===== LEVEL UP =====
function levelUp() {
const v = document.getElementById('gameView');
const nextCost = FIB[S.levelUpCount] || 999;
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Level Up!</h2>
<p style="text-align:center;margin-bottom:0.5rem">Floor ${S.floor} Complete</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Current XP: ${S.xp} | Next Level: ${nextCost}XP</p>
<div class="choice" onclick="levelUpMenu()">Spend XP</div>
<button class="btn safe" onclick="nextFloor()">Next Floor</button>`;
}

function nextFloor() {
saveGame();
startFloor(S.floor + 1);
}

function showStartingXPScreen() {
const v = document.getElementById('gameView');
const nextCost = FIB[S.levelUpCount] || 999;
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem;color:#a855f7">Starting XP Bonus!</h2>
<p style="text-align:center;margin-bottom:0.5rem;font-size:1.1rem">You start this run with <strong>${S.startingXP} XP</strong> from Death Boy sacrifices!</p>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;opacity:0.8">Spend it now or bank it for later. Remaining XP: <strong>${S.xp}</strong> | Next Level Cost: <strong>${nextCost}XP</strong></p>
<div class="choice" onclick="startingXPMenu()">Spend XP</div>
<button class="btn safe" onclick="startFloor(1)">Start Run (Bank XP)</button>`;
}

function startingXPMenu() {
const v = document.getElementById('gameView');
const cost = FIB[S.levelUpCount] || 999;
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend Starting XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<div class="choice" onclick="upgradeSigil()">Upgrade Sigil Level</div>
<div class="choice" onclick="addSigilToHero()">Add Sigil to Hero</div>
<button class="btn secondary" onclick="showStartingXPScreen()">Back</button>`;
}

function levelUpMenu() {
showTutorialPop('levelup_intro', "Nice! You got enough XP to get your first Level-Up. Your team shares XP. Let's check out your options! Click into each option to learn more about what it does.");
const v = document.getElementById('gameView');
const cost = FIB[S.levelUpCount] || 999;
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<div class="choice" onclick="upgradeSigil()">Upgrade Sigil Level</div>
<div class="choice" onclick="addSigilToHero()">Add Sigil to Hero</div>
<button class="btn secondary" onclick="levelUp()">Back</button>`;
}

function heroStats() {
showTutorialPop('levelup_stat_upgrade', "This one is pretty straightforward - add +1 POW or +5 HP to a hero of your choice.");
const cost = FIB[S.levelUpCount] || 999;
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Hero Stats</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
S.heroes.forEach((h, idx) => {
html += `<div class="choice" onclick="upPow(${idx})"><strong>${h.n} POW</strong> (${h.p} ‚Üí ${h.p+1})</div>`;
html += `<div class="choice" onclick="upHP(${idx})"><strong>${h.n} HP</strong> (${h.m} ‚Üí ${h.m+5})</div>`;
});
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function upPow(idx) {
const cost = FIB[S.levelUpCount] || 999;
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].p++;
toast(`${S.heroes[idx].n} POW +1!`);
upd();
saveGame();
levelUpMenu();
}

function upHP(idx) {
const cost = FIB[S.levelUpCount] || 999;
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].m += 5;
S.heroes[idx].h += 5;
if(S.heroes[idx].ls) {
S.heroes[idx].ls = false;
S.heroes[idx].lst = 0;
S.heroes[idx].h = 5;
toast(`${S.heroes[idx].n} revived with 5 HP!`);
} else toast(`${S.heroes[idx].n} HP +5!`);
upd();
saveGame();
levelUpMenu();
}

function upgradeSigil() {
showTutorialPop('levelup_upgrade_active', "Each active works based on its level. For example, if you upgrade Attack to Level 2, all heroes with Attack get it at Level 2, letting them attack twice with 1 action! Passives (Expand, Ghost, Asterisk, Star) work differently - they apply globally to all heroes and enhance your existing actions!");
const cost = FIB[S.levelUpCount] || 999;
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Sigil</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const available = allSigils.filter(s => (S.sig[s] || 0) < 4);
if(available.length === 0) html += `<p style="text-align:center;margin-bottom:1rem">All sigils maxed!</p>`;
else {
available.forEach(sig => {
const level = S.sig[sig] || 0;
html += `<div class="choice" onclick="upSigil('${sig}')"><strong>${sigilIcon(sig)} L${level} ‚Üí L${level+1}</strong></div>`;
});
}
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function addSigilToHero() {
showTutorialPop('levelup_add_active', "Heroes only get 1 action per turn. Active sigils give you more choices - in addition to Attack/Heal/D20, you can grant a hero a new ability like Shield or Ghost!");
const cost = FIB[S.levelUpCount] || 999;
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to Hero</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a hero:</p><div style="max-width:400px;margin:0 auto">`;
S.heroes.forEach((h, idx) => {
const sigilInfo = `<br><span style="font-size:0.75rem;opacity:0.8">Current: ${h.s.join(', ')}</span>`;
html += renderHeroCard(h, idx, `selectHeroForSigil(${idx})`, sigilInfo);
});
html += '</div>';
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function selectHeroForSigil(heroIdx) {
const cost = FIB[S.levelUpCount] || 999;
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Alpha', 'Asterisk', 'Star'];
const available = allSigils.filter(sig => !h.s.includes(sig) && !(h.ts && h.ts.includes(sig)));
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to ${h.n}</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(available.length === 0) html += `<p style="text-align:center;margin-bottom:1rem">${h.n} already has all sigils!</p>`;
else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a sigil to add:</p>`;
available.forEach(sig => {
const level = S.sig[sig] || 0;
const levelText = level === 0 ? 'L0 (Passive only)' : `L${level}
html += `<div class="choice" onclick="addSigilConfirm(${heroIdx}, '${sig}')">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">(${levelText})</span>
</div>`;
});
}
html += `<button class="btn secondary" onclick="addSigilToHero()">Back</button>`;
v.innerHTML = html;
}

function addSigilConfirm(heroIdx, sig) {
const cost = FIB[S.levelUpCount] || 999;
if(S.xp < cost) return;
const h = S.heroes[heroIdx];
if(h.s.includes(sig) || (h.ts && h.ts.includes(sig))) { toast(`${h.n} already has ${sig}!`); return; }
S.xp -= cost;
S.levelUpCount++;
if(!h.ts) h.ts = [];
h.ts.push(sig);
toast(`${sig} added to ${h.n} at L${S.sig[sig] || 0}!`);
upd();
saveGame();
levelUpMenu();
}

function upSigil(sig) {
const cost = FIB[S.levelUpCount] || 999;
if(S.xp < cost) return;

// Show passive sigil tutorial when upgrading Expand or Asterisk from L0 to L1
const isPassive = ['Expand', 'Asterisk'].includes(sig);
const currentLevel = S.sig[sig] || 0;
if(isPassive && currentLevel === 0) {
showTutorialPop('levelup_upgrade_passive', "Expand and Asterisk start as PASSIVE sigils - they work automatically but can't be used as actions. Upgrade them to L1 to use them actively!");
}

S.xp -= cost;
S.levelUpCount++;
S.sig[sig] = (S.sig[sig] || 0) + 1;
toast(`${sig} upgraded to L${S.sig[sig]}!`);
upd();
saveGame();
levelUpMenu();
}

// ===== NEUTRAL ENCOUNTERS =====
function neutral(f) {
// TUTORIAL: Show neutral intro on Floor 2
if(f === 2) {
showTutorialPop('neutral_intro', "You can usually walk straight through these floors, but most can offer a benefit if you play it right!");
}

const enc = getNeutralEncounter();

if(S.ghostBoysConverted && enc.startsWith('ghost')) {
showEmptyPlayroom();
return;
}

if(enc === 'shopkeeper1') showShopkeeper1();
else if(enc === 'shopkeeper2') showShopkeeper2();
else if(enc === 'wishingwell1') showWishingWell1();
else if(enc === 'wishingwell2') showWishingWell2();
else if(enc === 'treasurechest1') showTreasureChest1();
else if(enc === 'treasurechest2') showTreasureChest2();
else if(enc === 'wizard1') showWizard1();
else if(enc === 'wizard2') showWizard2();
else if(enc === 'oracle1') showOracle1();
else if(enc === 'oracle2') showOracle2();
else if(enc === 'encampment1') showEncampment1();
else if(enc === 'encampment2') showEncampment2();
else if(enc === 'statue1') showStatue1();
else if(enc === 'statue2') showStatue2();
else if(enc === 'ghost1') showGhost1();
else if(enc === 'ghost2') showGhost2();
else if(enc === 'prince1') showPrince1();
else if(enc === 'prince2') showPrince2();
else {
const v = document.getElementById('gameView');
v.innerHTML = `
<h2 style="text-align:center;margin:2rem 0">Floor ${f}</h2>
<p style="text-align:center;margin-bottom:2rem">${enc}</p>
<button class="btn" onclick="nextFloor()">Continue</button>`;
}
}

// ===== 1. SHOPKEEPER =====
function showShopkeeper1() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/shopkeeper1.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Potions for Sale</div>
<div class="neutral-desc">A hooded figure stands behind a small cart laden with vials and bottles. Their voice is raspy and businesslike: "Potions. Gold. Fair prices."</div>
<div class="choice" onclick="buySmallPotion()"><strong>Small Potion (3G)</strong><div style="font-size:0.85rem">Restore 3 HP to one hero</div></div>
<div class="choice" onclick="buyLargePotion()"><strong>Large Potion (5G)</strong><div style="font-size:0.85rem">Restore 8 HP to one hero</div></div>
<button class="btn safe" onclick="declineShopkeeper()">Do Not Engage</button>
</div>`;
}

let shopSmallBought = false;
let shopLargeBought = false;

function buySmallPotion() {
if(S.gold < 3) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let html = '<div class="neutral-container"><div class="neutral-title">Choose Hero</div><div style="max-width:400px;margin:0 auto">';
S.heroes.forEach((h, idx) => {
html += renderHeroCard(h, idx, `applySmallPotion(${idx})`);
});
html += '</div><button class="btn secondary" onclick="showShopkeeper1()">Back</button></div>';
v.innerHTML = html;
}

function applySmallPotion(idx) {
S.gold -= 3;
const h = S.heroes[idx];
h.h = Math.min(h.h + 3, h.m);
upd();
toast(`${h.n} restored 3 HP!`);
shopSmallBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 3000);
}
showShopkeeper1();
}

function buyLargePotion() {
if(S.gold < 5) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let html = '<div class="neutral-container"><div class="neutral-title">Choose Hero</div><div style="max-width:400px;margin:0 auto">';
S.heroes.forEach((h, idx) => {
html += renderHeroCard(h, idx, `applyLargePotion(${idx})`);
});
html += '</div><button class="btn secondary" onclick="showShopkeeper1()">Back</button></div>';
v.innerHTML = html;
}

function applyLargePotion(idx) {
S.gold -= 5;
const h = S.heroes[idx];
h.h = Math.min(h.h + 8, h.m);
upd();
toast(`${h.n} restored 8 HP!`);
shopLargeBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 3000);
}
showShopkeeper1();
}

function declineShopkeeper() {
shopSmallBought = false;
shopLargeBought = false;
nextFloor();
}

function showShopkeeper2() {
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const available = allSigils.filter(s => (S.sig[s] || 0) < 4);
const cost = S.goingRate;
let html = `
<div class="neutral-container">
<img src="assets/neutrals/shopkeeper2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Death's Bargain</div>
<div class="neutral-desc">The shopkeeper pulls back their hood, revealing a skull grinning beneath. "I am Death's... associate. You've impressed me. Choose wisely."</div>
<p style="text-align:center;font-weight:bold;margin:1rem 0">Cost: ${cost} Gold</p>`;
if(available.length === 0) {
html += `<div class="neutral-outcome">All your sigils are already at maximum power. Death nods approvingly and fades away.</div>`;
html += `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else if(S.gold < cost) {
html += `<div class="neutral-outcome" style="color:#dc2626">You don't have enough Gold! Death shakes their head and fades away.</div>`;
html += `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else {
html += `<div style="font-size:0.9rem;margin-bottom:1rem">Choose one sigil to upgrade permanently (costs ${cost}G, Going Rate does NOT increase):</div>`;
available.forEach(sig => {
const level = S.sig[sig] || 0;
html += `<div class="choice" onclick="acceptDeathsBargain('${sig}', ${cost})">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">L${level} ‚Üí L${level+1}</span>
</div>`;
});
html += `<button class="btn risky" onclick="finishDeathsBargain()">Decline</button>`;
}
html += `</div>`;
v.innerHTML = html;
}

function acceptDeathsBargain(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }
S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
// NOTE: Going Rate does NOT increase for Death's Bargain!
upd();
savePermanent();
toast(`${sig} permanently upgraded to L${S.sig[sig]}! (GR unchanged)`, 3000);
removeNeutralFromDeck('shopkeeper');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Good choice. See you soon."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}, 1000);
}

function finishDeathsBargain() {
removeNeutralFromDeck('shopkeeper');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Shame. You don't get a chance like this every day. Oh well, it's your funeral."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 2. WISHING WELL =====
function showWishingWell1() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/wishingwell1.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">The Old Wishing Well</div>
<div class="neutral-desc">An ancient stone well sits in the center of the chamber. You hear the faint sound of trickling water far below. A glint of gold catches your eye at the bottom.</div>
<button class="btn risky" onclick="climbWell()">Climb down and get coins</button>
<button class="btn" onclick="tossWish()">Toss in a coin and make a wish</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
</div>`;
}

function climbWell() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
let goldGain = 0;
let hpLoss = 0;

if(best === 1) {
outcome = 'You slip on the wet stones and plummet! The landing is brutal.';
hpLoss = 3;
goldGain = -5;
} else if(best >= 2 && best <= 10) {
outcome = 'You climb carefully but scrape yourself on the rough stones. You manage to grab a single coin.';
hpLoss = 1;
goldGain = 1;
} else if(best >= 11 && best <= 19) {
outcome = 'Your climbing skills are impressive! You retrieve a small pouch of coins.';
goldGain = 3;
} else if(best === 20) {
outcome = 'Your descent is flawless! At the bottom, you discover a hidden cache of coins AND the well begins to overflow with crystal-clear water!';
goldGain = 2 * S.heroes.length;
replaceStage1WithStage2('wishingwell');
}

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Climbing the Well</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">${outcome}</div>
<button class="btn" onclick="applyWellClimb(${hpLoss}, ${goldGain})">Continue</button>
</div>`;
}

function applyWellClimb(hpLoss, goldGain) {
if(hpLoss > 0) {
const highestHPHero = S.heroes.reduce((max, h) => h.h > max.h ? h : max, S.heroes[0]);
highestHPHero.h -= hpLoss;
if(highestHPHero.h <= 0 && !highestHPHero.ls) {
if(highestHPHero.g > 0) {
highestHPHero.g--;
highestHPHero.h += hpLoss;
toast(`${highestHPHero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
highestHPHero.h = 0;
highestHPHero.ls = true;
highestHPHero.lst = 0;
toast(`${highestHPHero.n} entered Last Stand!`);
}
}
toast(`${highestHPHero.n} took ${hpLoss} damage!`);
}
S.gold += goldGain;
if(S.gold < 0) S.gold = 0;
upd();
if(goldGain > 0) toast(`Gained ${goldGain} Gold!`);
else if(goldGain < 0) toast(`Lost ${Math.abs(goldGain)} Gold!`);
nextFloor();
}

function tossWish() {
const cost = S.heroes.length;
if(S.gold < cost) {
toast(`Need ${cost} Gold to make a wish!`);
return;
}
S.gold -= cost;
upd();
replaceStage1WithStage2('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">A Wish Made</div>
<div class="neutral-outcome">You toss ${cost} gold coin${cost>1?'s':''} into the well and make a silent wish. The water begins to glow softly, then surges upward, overflowing the well's edge!</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

function showWishingWell2() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/wishingwell2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Overflowing Crystal Waters</div>
<div class="neutral-desc">The well now overflows with sparkling, crystal-clear water that pools around its base. The water seems to pulse with restorative energy.</div>
<button class="btn safe" onclick="drinkCrystalWater()">Drink from the well</button>
</div>`;
}

function drinkCrystalWater() {
S.heroes.forEach(h => {
if(h.ls) {
h.ls = false;
h.lst = 0;
h.h = h.m;
toast(`${h.n} revived to full HP!`);
} else {
h.h = h.m;
}
});
toast('All heroes fully healed!', 3000);
removeNeutralFromDeck('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">The water tastes impossibly pure and refreshing. Warmth spreads through your body as all wounds close and exhaustion fades. You feel completely restored.</div>
<div class="neutral-outcome">The well's glow fades as the water recedes to its normal level. Its magic has been spent.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 3. TREASURE CHEST =====
function showTreasureChest1() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/treasurechest1.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">A Mysterious Chest</div>
<div class="neutral-desc">An ornate wooden chest sits against the far wall, its brass fittings gleaming in the torchlight. No lock is visible, but you sense this may not be as simple as it appears.</div>
<button class="btn risky" onclick="openChest()">Open the chest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
</div>`;
}

function openChest() {
const {rolls: trapRolls, best: trapBest} = rollD20Neutral();
const trapText = showD20Result(trapRolls, trapBest);

let trapOutcome = '';
let trapDmg = 0;
let secretFound = false;

if(trapBest === 1) {
trapOutcome = 'A poison dart flies out and strikes you!';
trapDmg = 3;
} else if(trapBest >= 2 && trapBest <= 9) {
trapOutcome = 'A small dart grazes your arm.';
trapDmg = 1;
} else if(trapBest >= 10 && trapBest <= 18) {
trapOutcome = 'You carefully open the chest without triggering any traps.';
} else {
trapOutcome = 'Your keen eyes spot a hidden compartment in the chest\'s lid!';
secretFound = true;
S.treasureSecretCompartment = true;
}

setTimeout(() => {
if(trapDmg > 0) {
const highestHPHero = S.heroes.reduce((max, h) => h.h > max.h ? h : max, S.heroes[0]);
highestHPHero.h -= trapDmg;
if(highestHPHero.h <= 0 && !highestHPHero.ls) {
if(highestHPHero.g > 0) {
highestHPHero.g--;
highestHPHero.h += trapDmg;
toast(`${highestHPHero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
highestHPHero.h = 0;
highestHPHero.ls = true;
highestHPHero.lst = 0;
toast(`${highestHPHero.n} entered Last Stand!`);
}
}
toast(`${highestHPHero.n} took ${trapDmg} damage!`);
}

const {rolls: contentRolls, best: contentBest} = rollD20Neutral();
const contentText = showD20Result(contentRolls, contentBest);

let contentOutcome = '';
let goldGain = 0;

if(contentBest >= 1 && contentBest <= 9) {
contentOutcome = 'The chest is empty. Someone got here first.';
} else if(contentBest >= 10 && contentBest <= 19) {
goldGain = Math.ceil(Math.random() * 10);
contentOutcome = `The chest contains ${goldGain} gold coins!`;
} else {
goldGain = Math.ceil(Math.random() * 10) * S.heroes.length;
contentOutcome = `The chest is filled with ${goldGain} gold coins!`;
}

if(secretFound && contentBest >= 10) {
S.silverKeyHeld = true;
replaceStage1WithStage2('treasurechest');
contentOutcome += ' Inside the secret compartment, you find a small silver key!';
}

S.gold += goldGain;
upd();

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Opening the Chest</div>
<div class="dice-roll">${trapText}</div>
<div class="neutral-outcome">${trapOutcome}</div>
<div class="dice-roll" style="margin-top:1rem">${contentText}</div>
<div class="neutral-outcome">${contentOutcome}</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}, 500);
}

function showTreasureChest2() {
if(!S.silverKeyHeld) {
nextFloor();
return;
}
const goldGain = 10 * S.heroes.length;
S.gold += goldGain;
S.silverKeyHeld = false;
upd();
removeNeutralFromDeck('treasurechest');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/treasurechest2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Small Silver Chest</div>
<div class="neutral-desc">A small silver chest sits on a stone pedestal, perfectly sized for the key you found earlier. You insert the key and it opens with a satisfying click.</div>
<div class="neutral-outcome">Inside you find ${goldGain} gold coins, perfectly arranged!</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 4. MUMBLING WIZARD =====
function showWizard1() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/wizard1.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Hieroglyphs on the Wall</div>
<div class="neutral-desc">An elderly wizard stands with arms outstretched toward a wall covered in glowing hieroglyphs. He mutters continuously: "Do you see it? Do you see it? Look closely..."</div>
<button class="btn risky" onclick="approachWizard()">Approach the wizard</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
</div>`;
}

function approachWizard() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const sigilPool = ['Grapple', 'Heal', 'Ghost', 'Alpha', 'Star', 'Asterisk'];
const randomSigil = sigilPool[Math.floor(Math.random() * sigilPool.length)];
S.wizardSigil = randomSigil;

if(best >= 1 && best <= 10) {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">The Hieroglyphs</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">You stare at the glowing symbols but can't make sense of them. The wizard sighs heavily: "You don't see it. How unfortunate. Please leave."</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
} else {
const heroesWithSigil = [];
S.heroes.forEach((h, idx) => {
if(h.s.includes(randomSigil) || (h.ts && h.ts.includes(randomSigil))) {
heroesWithSigil.push(idx);
}
});

if(heroesWithSigil.length === 0) {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">The Hieroglyphs</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">The hieroglyph reveals itself as the symbol for ${randomSigil}! The wizard beams with pride.</div>
<div class="neutral-outcome">But when he realizes none of you possess this sigil, his face falls: "Useless! All of you, useless! Get out!"</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
} else {
const v = document.getElementById('gameView');
let html = `
<div class="neutral-container">
<div class="neutral-title">The Hieroglyphs</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">The hieroglyph reveals itself as the symbol for ${randomSigil}! The wizard exclaims: "Yes! YES! You see it! One of you has this power already!"</div>
<div style="font-size:0.9rem;margin:1rem 0">Choose which hero receives the upgrade:</div>`;
heroesWithSigil.forEach(idx => {
const h = S.heroes[idx];
const currentLevel = getLevel(randomSigil, idx);
html += `<div class="choice" onclick="upgradeWizardSigil(${idx}, '${randomSigil}')">
<strong>${h.n}</strong> <span style="opacity:0.7">${sigilIcon(randomSigil)} L${currentLevel} ‚Üí L${currentLevel+1}</span>
</div>`;
});
html += `</div>`;
v.innerHTML = html;
}
}
}

function upgradeWizardSigil(heroIdx, sig) {
const h = S.heroes[heroIdx];
if(!h.ts) h.ts = [];
if(!h.ts.includes(sig) && !h.s.includes(sig)) h.ts.push(sig);

const oldLevel = S.sig[sig] || 0;
S.sig[sig] = oldLevel + 1;

toast(`${sig} temporarily upgraded to L${S.sig[sig]} for ${h.n}!`, 3000);
replaceStage1WithStage2('wizard');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">The wizard places his hands on ${h.n}'s head. The hieroglyph glows brighter, and power flows into them!</div>
<div class="neutral-outcome">"Good, good! Now leave me to my studies."</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}, 500);
}

function showWizard2() {
if(!S.wizardSigil) {
nextFloor();
return;
}

const sig = S.wizardSigil;
const heroesWithSigil = [];
S.heroes.forEach((h, idx) => {
if(h.s.includes(sig) || (h.ts && h.ts.includes(sig))) {
heroesWithSigil.push(idx);
}
});

if(heroesWithSigil.length === 0) {
nextFloor();
return;
}

const v = document.getElementById('gameView');
let html = `
<div class="neutral-container">
<img src="assets/neutrals/wizard2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Sacrifice for Power</div>
<div class="neutral-desc">The wizard channels arcane energy, his eyes glowing with power: "I can make this permanent... but all who carry ${sig} must sacrifice their current mastery. Do you accept?"</div>
<div style="font-size:0.85rem;margin-bottom:1rem;color:#b64141">Cost: All heroes lose ${sig} for THIS RUN ONLY<br>Benefit: ${sig} permanently upgraded in Sigilarium</div>
<button class="btn danger" onclick="acceptWizardSacrifice('${sig}')">Accept Sacrifice</button>
<button class="btn" onclick="declineWizardSacrifice()">Decline</button>
</div>`;
v.innerHTML = html;
}

function acceptWizardSacrifice(sig) {
S.heroes.forEach(h => {
if(h.s.includes(sig)) h.s = h.s.filter(s => s !== sig);
if(h.ts && h.ts.includes(sig)) h.ts = h.ts.filter(s => s !== sig);
});

S.sig[sig] = (S.sig[sig] || 0) + 1;
toast(`${sig} PERMANENTLY upgraded to L${S.sig[sig]}!`, 3000);
removeNeutralFromDeck('wizard');

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">The wizard's ritual completes. All knowledge of ${sig} drains from those who held it, but you feel the power crystallize into something greater.</div>
<div class="neutral-outcome">"The sacrifice strengthens the foundation. Now go."</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

function declineWizardSacrifice() {
removeNeutralFromDeck('wizard');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">The wizard's glow fades. He returns to mumbling at the wall, disappointed but unsurprised.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 5. ORACLE =====
function showOracle1() {
const v = document.getElementById('gameView');
let html = `
<div class="neutral-container">
<img src="assets/neutrals/oracle1.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Consult the Oracle</div>
<div class="neutral-desc">A figure shrouded in mist sits cross-legged before a crystal sphere. Their voice echoes: "Step forward. I will read your fortune. Power or Life?"</div>
<div style="font-size:0.9rem;margin-bottom:1rem">Choose a hero and their desired fortune:</div>`;
S.heroes.forEach((h, idx) => {
html += `<div class="choice" onclick="oracleChoose(${idx}, 'POW')"><strong>${h.n}</strong> - Power</div>`;
html += `<div class="choice" onclick="oracleChoose(${idx}, 'HP')"><strong>${h.n}</strong> - Life</div>`;
});
html += `<button class="btn safe" onclick="nextFloor()">Do Not Engage</button></div>`;
v.innerHTML = html;
}

function oracleChoose(heroIdx, stat) {
S.oracleHero = heroIdx;
S.oracleStat = stat;

const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);
S.oracleRoll = best;

const h = S.heroes[heroIdx];
let fortune = '';
let stage2Effect = '';

if(best === 1) {
fortune = '"Terrible misfortune awaits you."';
stage2Effect = 'CURSE';
replaceStage1WithStage2('oracle');
} else if(best >= 2 && best <= 9) {
fortune = '"What you hope for shall not come to pass."';
stage2Effect = 'NO UNLOCK';
} else if(best >= 10 && best <= 15) {
fortune = '"Great things in your future, but not what you want."';
stage2Effect = 'OPPOSITE';
replaceStage1WithStage2('oracle');
} else if(best >= 16 && best <= 19) {
fortune = '"Your desired future shall come to pass."';
stage2Effect = 'DESIRED';
replaceStage1WithStage2('oracle');
} else {
fortune = '"It happens before my eyes!"';
stage2Effect = 'IMMEDIATE DOUBLE';
replaceStage1WithStage2('oracle');
}

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">The Oracle's Fortune</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">${h.n} steps forward seeking ${stat === 'POW' ? 'Power' : 'Life'}.</div>
<div class="neutral-outcome">The Oracle gazes into the crystal sphere, then speaks: ${fortune}</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

function showOracle2() {
if(S.oracleHero === null || S.oracleRoll === null) {
nextFloor();
return;
}

const heroIdx = S.oracleHero;
const stat = S.oracleStat;
const roll = S.oracleRoll;
const h = S.heroes[heroIdx];

let outcome = '';

if(roll === 1) {
// CURSE
if(stat === 'HP') {
h.m = Math.max(1, h.m - 5);
if(h.h > h.m) h.h = h.m;
outcome = `${h.n} feels weaker. Maximum HP reduced by 5!`;
} else {
h.p = Math.max(0, h.p - 1);
outcome = `${h.n} feels their strength fade. POW reduced by 1!`;
}
} else if(roll >= 10 && roll <= 15) {
// OPPOSITE
if(stat === 'HP') {
h.p++;
outcome = `${h.n} gains unexpected Power! POW +1!`;
} else {
h.m += 5;
h.h += 5;
outcome = `${h.n} feels vitality surge! Maximum HP +5!`;
}
} else if(roll >= 16 && roll <= 19) {
// DESIRED
if(stat === 'HP') {
h.m += 5;
h.h += 5;
outcome = `${h.n} feels strengthened! Maximum HP +5!`;
} else {
h.p++;
outcome = `${h.n} feels power awaken! POW +1!`;
}
} else if(roll === 20) {
// IMMEDIATE DOUBLE
if(stat === 'HP') {
h.m += 10;
h.h += 10;
outcome = `${h.n} surges with life force! Maximum HP +10!`;
} else {
h.p += 2;
outcome = `${h.n} blazes with power! POW +2!`;
}
}

removeNeutralFromDeck('oracle');

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/oracle2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Return to the Oracle</div>
<div class="neutral-outcome">${h.n} returns to the Oracle. The crystal sphere flares brightly!</div>
<div class="neutral-outcome">${outcome}</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 6. ENEMY ENCAMPMENT =====
function showEncampment1() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/encampment1.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Enemies Assembling Ahead</div>
<div class="neutral-desc">Through a crack in the wall ahead, you spy the enemies from your next encounter preparing for battle. They haven't noticed you yet.</div>
<button class="btn risky" onclick="chooseEncampmentAction('sneak')">Sneak by?</button>
<button class="btn risky" onclick="chooseEncampmentAction('engage')">Engage early</button>
</div>`;
}

function chooseEncampmentAction(action) {
const v = document.getElementById('gameView');
let html = '<div class="neutral-container">';
html += `<div class="neutral-title">${action === 'sneak' ? 'Choose Scout' : 'Choose Leader'}</div>`;
html += `<div class="neutral-desc">Which hero will ${action === 'sneak' ? 'sneak past the encampment' : 'lead the charge'}?</div>`;
S.heroes.forEach((h, i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
html += `<div class="choice" onclick="${action === 'sneak' ? 'sneakByEncampment' : 'engageEarlyEncampment'}(${i})">
<strong>${h.n}</strong> - ${h.p}‚ö° | ${hp}
</div>`;
});
html += '</div>';
v.innerHTML = html;
}

function sneakByEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
if(best >= 1 && best <= 10) {
outcome = `${hero.n}'s foot catches on loose stone! The enemies hear you and prepare an ambush!`;
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 3000);
} else if(best >= 11 && best <= 19) {
outcome = `${hero.n} slips past quietly. The enemies remain unaware.`;
} else {
// Roll 20 - recruit a straggler
const comp = getEnemyComp(S.floor + 1);
const stragglerType = comp[Math.floor(Math.random() * comp.length)];
const base = E[stragglerType];
const effedMultiplier = S.gameMode === 'Effed' ? 5 : 1;
const straggler = {
id: `recruit${Date.now()}`,
n: base.n,
p: base.p * effedMultiplier,
h: base.h * effedMultiplier,
m: base.m * effedMultiplier,
g: base.g,
x: base.x,
s: [],
pool: base.pool,
gainRate: base.gainRate || 3,
turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st: 0,
li: heroIdx,
sh: 0,
alphaActed: false,
recruitedBy: heroIdx,
isRecruit: true
};
// Add permanent sigils
if(base.permSigils) base.permSigils.forEach(ps => straggler.s.push({sig:ps.s, level:ps.l, perm:true}));
// Add start sigils
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
base.startSigils.forEach(ss => straggler.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(straggler, base);
}
}
}
if(!S.recruits) S.recruits = [];
S.recruits.push(straggler);
outcome = `${hero.n} sneaks past perfectly AND discovers a rejected ${base.n} who joins ${hero.n}'s ranks!`;
toast(`${base.n} recruited! Will fight in ${hero.n}'s lane!`, 3000);
}

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Sneaking Past</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">${outcome}</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

function engageEarlyEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

if(best >= 1 && best <= 15) {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Engaging Early</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">A scout spots ${hero.n} before they can strike! The enemies prepare an ambush!</div>
<button class="btn" onclick="finishEncampmentFail()">Continue</button>
</div>`;
} else {
const kills = best === 20 ? 2 : 1;
S.encampmentEarlyKills = kills;
replaceStage1WithStage2('encampment');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Engaging Early</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">${hero.n} succeeds at picking off ${kills} enem${kills>1?'ies':'y'}! They're scrambling to form ranks - you'll see the battlefield and pick your targets...</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}
}

function finishEncampmentFail() {
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 3000);
nextFloor();
}

function startEncampmentCombat(kills) {
const v = document.getElementById('gameView');
const comp = getEnemyComp(S.floor + 1);

let html = '<div class="neutral-container"><div class="neutral-title">Choose Enemies to Kill</div>';
html += `<div style="font-size:0.9rem;margin-bottom:1rem">Select ${kills} enem${kills>1?'ies':'y'} to remove:</div>`;

const enemyTypes = {};
comp.forEach(type => {
enemyTypes[type] = (enemyTypes[type] || 0) + 1;
});

Object.keys(enemyTypes).forEach(type => {
const count = enemyTypes[type];
html += `<div class="choice" onclick="killEncampmentEnemy('${type}', ${kills})">
<strong>${E[type].n}</strong> <span style="opacity:0.7">(${count} available, ${E[type].g}G + ${E[type].x}XP each)</span>
</div>`;
});

html += '</div>';
v.innerHTML = html;
}

function killEncampmentEnemy(type, target) {
if(!S.encampmentKilledTypes) S.encampmentKilledTypes = [];
if(!S.encampmentKillsRemaining) S.encampmentKillsRemaining = target;

// Track which enemy type was killed
S.encampmentKilledTypes.push(type);

S.gold += E[type].g;
S.xp += E[type].x;
upd();
toast(`Killed ${E[type].n}! +${E[type].g}G +${E[type].x}XP`);

S.encampmentKillsRemaining--;

if(S.encampmentKillsRemaining <= 0) {
// Combat will be reduced on next floor
replaceStage1WithStage2('encampment');
nextFloor();
} else {
startEncampmentCombat(S.encampmentKillsRemaining);
}
}

function showEncampment2() {
const healAmt = Math.floor(S.heroes[0].m * 0.5);
const goldGain = 2 * S.heroes.length;

S.heroes.forEach(h => {
if(!h.ls) {
h.h = Math.min(h.h + healAmt, h.m);
}
});

S.gold += goldGain;
upd();
toast(`All heroes healed ${healAmt} HP!`, 2000);
toast(`Gained ${goldGain} Gold!`, 2000);

removeNeutralFromDeck('encampment');

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/encampment2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Abandoned Encampment</div>
<div class="neutral-desc">The enemy got cocky and left their base undefended. You enter and rest safely.</div>
<div class="neutral-outcome">All heroes restored ${healAmt} HP!</div>
<div class="neutral-outcome">Found ${goldGain} Gold in supplies!</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 7. ANCIENT STATUE =====
function showStatue1() {
const deactivated = S.ancientStatueDeactivated;
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/statue1.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">The Statue</div>
<div class="neutral-desc">A massive stone statue dominates the chamber. As you watch, it seems to ${deactivated ? 'shift smoothly and gently' : 'grow larger, its surface rippling ominously'}.</div>
${deactivated ? '<div class="neutral-outcome" style="color:#22c55e">The statue has been deactivated. It poses no threat.</div>' : ''}
<button class="btn safe" onclick="nextFloor()">Leave now</button>
<button class="btn risky" onclick="showStatue2()">Remain transfixed</button>
</div>`;
}

function showStatue2() {
const deactivated = S.ancientStatueDeactivated;
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/statue1.png" style="max-width:100%;height:auto;max-width:450px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Growing Larger</div>
<div class="neutral-desc">The statue IS getting bigger! The room feels smaller. ${deactivated ? 'It moves smoothly and gently, non-threatening.' : 'Its stone surface creaks as it expands.'}</div>
<button class="btn risky" onclick="statueEscape(2)">Make a break for exit</button>
<button class="btn risky" onclick="showStatue3()">Remain transfixed</button>
</div>`;
}

function showStatue3() {
const deactivated = S.ancientStatueDeactivated;
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/statue1.png" style="max-width:100%;height:auto;max-width:500px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Consuming the Room</div>
<div class="neutral-desc">The statue now fills most of the room! ${deactivated ? 'Despite its size, it moves with graceful precision.' : 'There\'s still a tight squeeze to the exit...'}</div>
<button class="btn risky" onclick="statueEscape(3)">Squeeze out to exit</button>
<button class="btn danger" onclick="showStatue4()">Remain transfixed</button>
</div>`;
}

function showStatue4() {
const deactivated = S.ancientStatueDeactivated;
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/statue1.png" style="max-width:100%;height:auto;max-width:550px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Smooth Metal Pressing - LAST CHANCE</div>
<div class="neutral-desc">${deactivated ? 'The statue\'s polished surface gleams as it gently fills the space.' : 'The statue\'s smooth metal presses against the walls and you! This is your last chance to escape!'}</div>
<button class="btn danger" onclick="statueEscape(4)">ESCAPE NOW</button>
<button class="btn danger" onclick="showStatue5()">Remain transfixed</button>
</div>`;
}

function statueEscape(stage) {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);
const deactivated = S.ancientStatueDeactivated;

let outcome = '';
let damage = 0;

if(stage === 2) {
if(best >= 1 && best <= 5) damage = deactivated ? 0 : 1;
else if(best === 20) outcome = 'You can\'t shake the feeling you missed something...';
} else if(stage === 3) {
if(best >= 1 && best <= 9) damage = deactivated ? 0 : 2;
else if(best >= 10 && best <= 19) outcome = 'You escape safely.';
else outcome = 'As you squeeze out, you notice a small black arch in the statue.';
} else if(stage === 4) {
if(best >= 1 && best <= 15) damage = deactivated ? 0 : 3;
else if(best >= 16 && best <= 19) outcome = 'You notice an archway as you escape!';
else {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">The archway SWALLOWS you! You find yourself inside the statue!</div>
<button class="btn" onclick="showStatue5()">Continue</button>
</div>`;
return;
}
}

if(damage > 0 && !deactivated) {
S.heroes.forEach(h => {
h.h -= damage;
if(h.h < 0) h.h = 0;
if(h.h === 0 && !h.ls && h.g > 0) {
h.g--;
h.h = h.m;
} else if(h.h === 0 && !h.ls) {
h.ls = true;
h.lst = 0;
toast(`${h.n} entered Last Stand!`);
showTutorialPop('last_stand_intro', "Ouch, that stinks. Well, you're not dead yet! While your ally lives, you live - but it looks like your actions are somewhat limited. Be careful though! If you don't get healing soon, you'll slip further and further away...");
}
});
toast(`All heroes took ${damage} damage!`);
}

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Escaping the Statue</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">${outcome || `You escape${damage > 0 ? ' but take ' + damage + ' damage' : ' safely'}!`}</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

function showStatue5() {
const v = document.getElementById('gameView');
let html = `
<div class="neutral-container">
<img src="assets/neutrals/statue2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Statue Unfurls</div>
<div class="neutral-desc">The statue stops growing and unfurls like a smooth metal flower. At its center sits a small replica statuette. The smooth metal walls can be scaled.</div>
<div style="font-size:0.9rem;margin:1rem 0">Choose a hero to scale the statue:</div>
<div style="max-width:400px;margin:0 auto">`;
S.heroes.forEach((h, idx) => {
html += renderHeroCard(h, idx, `scaleStatue(${idx})`);
});
html += `</div></div>`;
v.innerHTML = html;
}

function scaleStatue(heroIdx) {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);
const deactivated = S.ancientStatueDeactivated;

const h = S.heroes[heroIdx];
let outcome = '';
let damage = 0;
let getStatuette = false;

if(best === 1) {
outcome = 'TRAP! You trigger a mechanism and plummet!';
damage = deactivated ? 0 : (h.h - 1);
} else if(best >= 2 && best <= 15) {
damage = deactivated ? 0 : 4;
getStatuette = true;
outcome = `You ${damage > 0 ? 'struggle up, taking ' + damage + ' damage, but ' : ''}reach the statuette!`;
} else if(best >= 16 && best <= 19) {
getStatuette = true;
outcome = 'You scale effortlessly and claim the statuette!';
} else {
getStatuette = true;
outcome = 'You scale perfectly AND find the deactivation switch!';
S.ancientStatueDeactivated = true;
toast('Ancient Statue PERMANENTLY deactivated!', 3000);
}

if(damage > 0) {
h.h -= damage;
if(h.h < 1) h.h = 1;
}

if(getStatuette) {
S.hasAncientStatuette = true;
savePermanent();
toast('Ancient Statuette obtained!', 2000);
}

removeNeutralFromDeck('statue');

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Scaling the Statue</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">${outcome}</div>
${getStatuette ? '<div class="neutral-outcome" style="color:#fbbf24">The Ancient Statuette can be placed on a Pedestal to grant permanent stat upgrades!</div>' : ''}
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 8. GHOST =====
function showGhost1() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/ghost1.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Two Ghostly Boys Want to Play</div>
<div class="neutral-desc">Two translucent boys appear before you, giggling. "Play with us! Play with us!" They reach out with spectral hands.</div>
<button class="btn danger" onclick="playWithGhostBoys()">Play with the ghost boys</button>
<button class="btn risky" onclick="nextFloor()">Avoid?</button>
</div>`;
}

let ghostEscapeDC = 18;
let ghostEscapeAttempts = 0;

function playWithGhostBoys() {
ghostEscapeDC = 18;
ghostEscapeAttempts = 0;
attemptGhostEscape();
}

function attemptGhostEscape() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

if(best >= ghostEscapeDC) {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Escaping the Ghost Boys</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">You break free from their grip! The boys pout but let you go. "Come back and play sometime..."</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
return;
}

// Failed - damage lowest HP hero
const sortedHeroes = [...S.heroes].filter(h => h.h > 0 || !h.ls).sort((a, b) => a.h - b.h);
if(sortedHeroes.length === 0) {
nextFloor();
return;
}

const victim = sortedHeroes[0];
const hadGhostCharge = victim.g > 0;

victim.h -= 1;
if(victim.h <= 0) {
victim.h = 0;
if(victim.g > 0) {
victim.g--;
victim.h = victim.m;
// EASTER EGG: Ghost charge consumed during Ghost encounter triggers conversion
if(hadGhostCharge) {
replaceStage1WithStage2('ghost');
toast(`${victim.n} used Ghost charge! The boys realize the truth!`, 3000);
// Trigger the full Ghost Boys conversion (showGhost2)
showGhost2();
return;
}
} else {
victim.ls = true;
victim.lst = 0;
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Escaping the Ghost Boys</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">${victim.n} took 1 damage and entered Last Stand! The shock breaks the ghost boys' hold!</div>
<div class="neutral-outcome">"Oops!" they say in unison, then fade away giggling.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
return;
}
}

toast(`${victim.n} took 1 damage!`);
ghostEscapeAttempts++;
ghostEscapeDC -= 2;

if(ghostEscapeAttempts >= 9) {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Finally Free</div>
<div class="neutral-outcome">After many attempts, the ghost boys grow bored and fade away.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
return;
}

const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Trapped with the Ghost Boys</div>
<div class="dice-roll">${rollText}</div>
<div class="neutral-outcome">You remain trapped! Time slips away... ${victim.n} took 1 damage!</div>
<div style="font-size:0.9rem;margin:1rem 0">Attempts: ${ghostEscapeAttempts}/9 | Next DC: ${ghostEscapeDC}</div>
<button class="btn danger" onclick="attemptGhostEscape()">Try to Escape (DC ${ghostEscapeDC})</button>
</div>`;
}

function showGhost2() {
S.ghostBoysConverted = true;
toast('Ghost Boys permanently converted to Empty Playroom!', 3000);
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/ghost2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">The Boys Realize the Truth</div>
<div class="neutral-desc">The ghost boys stare at each other, then at their translucent hands. "We're... we're dead. We're ghosts."</div>
<div class="neutral-outcome">Tears form in their spectral eyes. "We want to go home. We want to see Mommy and Daddy."</div>
<div class="neutral-outcome">They hold hands and walk toward a light that appears. "Thank you for showing us." They vanish peacefully.</div>
<div class="neutral-outcome" style="color:#22c55e">This room is now an Empty Playroom - you can pass safely in future runs.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

function showEmptyPlayroom() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Empty Playroom</div>
<div class="neutral-desc">An empty chamber, dust motes drifting in pale light. It might have been a playroom once, but whatever haunted it is long gone. The air feels peaceful.</div>
<div class="neutral-outcome">Nothing stops you here. You pass through quietly.</div>
<button class="btn" onclick="nextFloor()">Continue to Floor ${S.floor + 1}</button>
</div>`;
}

// ===== 9. FLUMMOXED PRINCE(SS) =====
function showPrince1() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/prince1.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">Help Recover the Ring</div>
<div class="neutral-desc">A flummoxed ${S.princeGender} paces anxiously: "Please, you must help! A creature in the next room ate my engagement ring! If you can stun it on the first turn of battle, I can retrieve it!"</div>
<button class="btn" onclick="acceptPrinceQuest()">Accept the quest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
</div>`;
}

function acceptPrinceQuest() {
toast('Stun any enemy Turn 1 of next combat!', 3000);
S.princeQuestActive = true;
S.princeQuestCompleted = false;
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">The ${S.princeGender} looks hopeful: "Thank you! I'll follow you and grab it when you stun the creature!"</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

function showPrince2() {
const v = document.getElementById('gameView');
// Check if quest was completed
if(!S.princeQuestCompleted) {
// Quest failed
S.princeQuestActive = false;
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-title">Quest Failed</div>
<div class="neutral-desc">The ${S.princeGender} returns, dejected: "The creature fled before I could retrieve the ring. I'll have to find another way..."</div>
<div class="neutral-outcome">The ${S.princeGender} departs sadly. No reward.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
return;
}

// Quest succeeded - show wedding
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const eligible = allSigils.filter(s => (S.sig[s] || 0) < 4);

eligible.sort((a, b) => {
const costA = S.sig[a] || 0;
const costB = S.sig[b] || 0;
return costA - costB;
});

const sigil1 = eligible[0] || 'Attack';
const sigil2 = eligible[1] || 'Shield';

removeNeutralFromDeck('prince');
replaceStage1WithStage2('prince');
S.princeQuestActive = false;

v.innerHTML = `
<div class="neutral-container">
<img src="assets/neutrals/prince2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:2px solid #000">
<div class="neutral-title">The Wedding</div>
<div class="neutral-desc">The ${S.princeGender} proposes to their beloved. A beautiful wedding ceremony unfolds before you!</div>
<div class="neutral-outcome">Each wears a garment displaying a sigil of power. As thanks for your help, you may choose one:</div>
<div class="choice" onclick="choosePrinceSigil('${sigil1}')">
<strong>${sigilIcon(sigil1)}</strong> <span style="opacity:0.7">L${S.sig[sigil1] || 0} ‚Üí L${(S.sig[sigil1] || 0) + 1}</span>
</div>
<div class="choice" onclick="choosePrinceSigil('${sigil2}')">
<strong>${sigilIcon(sigil2)}</strong> <span style="opacity:0.7">L${S.sig[sigil2] || 0} ‚Üí L${(S.sig[sigil2] || 0) + 1}</span>
</div>
</div>`;
}

function choosePrinceSigil(sig) {
S.sig[sig] = (S.sig[sig] || 0) + 1;
toast(`${sig} permanently upgraded to L${S.sig[sig]}!`, 3000);
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">The royal couple thanks you profusely. The ${sig} sigil glows and merges with your power!</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== OLD TAPO ENCOUNTER (FLOOR 20) =====
function showOldTapo() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/old-tapo.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #8b5cf6;box-shadow:0 0 20px rgba(139,92,246,0.5)">
<div class="neutral-title" style="color:#8b5cf6;font-size:1.8rem">The Master of Space and Time</div>
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;background:rgba(139,92,246,0.1);border-radius:8px;margin:1rem 0">
"Tapo, you say? Yes‚Ä¶. I was called Tapo once, before I mastered the mysteries of space and time. Save me? Why, I need no saving‚Ä¶ In fact‚Ä¶."
</div>
<button class="btn" onclick="oldTapoTransform()" style="background:linear-gradient(135deg, #8b5cf6, #6366f1);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Continue</button>
</div>`;
}

function oldTapoTransform() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div style="text-align:center;margin:2rem 0">
<div style="font-size:3rem;animation:clap 0.5s ease-in-out 3;margin-bottom:2rem">üëè</div>
<img src="assets/tapo.png" style="max-width:100%;height:auto;max-width:300px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #fbbf24;animation:bounce 1s ease-in-out 3">
<div style="font-size:2.5rem;font-weight:bold;color:#fbbf24;text-shadow:0 0 10px rgba(251,191,36,0.5);margin:2rem 0;animation:glow 1s ease-in-out infinite">
‚ú® Tapo Unlocked! ‚ú®
</div>
<div class="neutral-outcome" style="font-size:1.1rem;margin:1.5rem 0">
Baby Tapo has been added to your hero roster!<br>
<span style="color:#22c55e">Stats: 1 HP / 1 POW</span><br>
<span style="color:#8b5cf6">Starts with ALL active sigils!</span>
</div>
</div>
<button class="btn" onclick="completeTapoUnlock()" style="background:linear-gradient(135deg, #fbbf24, #f59e0b);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Victory!</button>
</div>
<style>
@keyframes clap {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.5); }
}
@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-20px); }
}
@keyframes glow {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}
</style>`;
}

function completeTapoUnlock() {
S.tapoUnlocked = true;
savePermanent();
win();
}

// ===== DEATH SCREEN =====
function showDeathScreen() {
showTutorialPop('death_intro', "First time, huh? Doesn't seem like it's quite your time yet, and I think keeping you alive could be profitable for me. Cash in Gold now for PERMANENT upgrades.");
savePermanent(); // Save gold, goingRate, sig upgrades
// Recruits persist until killed - don't clear here
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];

// Select a random Death quote that hasn't been used yet
let deathQuote = "";
if(S.usedDeathQuotes.length >= DEATH_QUOTES.length) {
// All quotes used - reset the pool
S.usedDeathQuotes = [];
}
const availableQuotes = DEATH_QUOTES.filter((_, idx) => !S.usedDeathQuotes.includes(idx));
if(availableQuotes.length > 0) {
const randomIdx = Math.floor(Math.random() * availableQuotes.length);
deathQuote = availableQuotes[randomIdx];
// Mark this quote as used
const quoteIndex = DEATH_QUOTES.indexOf(deathQuote);
S.usedDeathQuotes.push(quoteIndex);
savePermanent(); // Save the updated usedDeathQuotes
}

let html = `
<div style="background:#2c2416;padding:2rem;border-radius:8px;max-width:800px;margin:0 auto;color:#e8dcc4">
<h1 style="text-align:center;margin-bottom:1rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
${deathQuote ? `<p style="text-align:center;margin-bottom:1rem;font-size:1rem;color:#999;font-style:italic">"${deathQuote}"</p>` : ''}
<p style="text-align:center;margin-bottom:1.5rem;font-size:1.1rem">Gold: <strong>${S.gold}</strong> | Going Rate: <strong>${S.goingRate}G</strong></p>`;

if(S.gold === 0) {
html += `<p style="text-align:center;margin:2rem 0;font-size:1.2rem;color:#dc2626;font-style:italic">"Nothing? Really? Come back when you have something to offer."</p>`;
} else {
html += `<h3 style="margin-bottom:1rem">Upgrade Sigilarium:</h3>`;
html += `<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:0.75rem;margin-bottom:1.5rem">`;

allSigils.forEach(sig => {
const currentLevel = S.sig[sig] || 0;
if(currentLevel >= 4) return; // Max level

const upgradeCount = S.sigUpgradeCounts[sig] || 0;
const baseCost = S.goingRate;
const escalation = upgradeCount > 0 ? (upgradeCount * 50) : 0;
const cost = baseCost + escalation;

const canAfford = S.gold >= cost;
const colorClass = ['#000', '#fff', '#14b8a6', '#a855f7', '#fbbf24'][currentLevel];
const nextColorClass = ['#000', '#fff', '#14b8a6', '#a855f7', '#fbbf24'][currentLevel + 1];

html += `
<div style="background:rgba(255,255,255,0.05);padding:0.75rem;border-radius:6px;border:1px solid rgba(255,255,255,0.1)">
<div style="font-weight:bold;margin-bottom:0.5rem">${sigilIcon(sig)}</div>
<div style="font-size:0.9rem;margin-bottom:0.5rem">
<span style="color:${colorClass}">L${currentLevel}</span> ‚Üí <span style="color:${nextColorClass}">L${currentLevel+1}</span>
</div>
<div style="font-size:0.85rem;margin-bottom:0.5rem;color:#999">Cost: ${cost}G</div>
<button class="btn" ${!canAfford ? 'disabled style="opacity:0.4"' : ''} onclick="purchaseSigilUpgrade('${sig}', ${cost})" style="padding:0.4rem 0.8rem;font-size:0.85rem">
${canAfford ? 'Purchase' : 'Too Expensive'}
</button>
</div>`;
});

html += `</div>`;
}

// Death Boys (only if Ghost Boys converted)
if(S.ghostBoysConverted) {
html += `
<div style="border-top:2px solid rgba(255,255,255,0.2);padding-top:2rem;margin-top:2rem">
<h2 style="text-align:center;margin-bottom:0.5rem;font-size:1.5rem;color:#a855f7">The Death Boys</h2>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;font-style:italic;opacity:0.8">"We work for Death now! He's WAY cooler than being ghosts!"</p>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-bottom:1.5rem">
<!-- Boy 1: Sell Back -->
<div style="background:rgba(34,197,94,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(34,197,94,0.3)">
<h3 style="color:#22c55e;margin-bottom:0.5rem">Death Boy 1: "Sell Back"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Remove one upgrade level from any sigil and get Gold equal to the current Going Rate (no +5G increase)</p>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G</div>`;

// List all sigils that can be sold back
allSigils.forEach(sig => {
const currentLevel = S.sig[sig] || 0;
const baseLevel = ['Attack','Shield','Heal','D20'].includes(sig) ? 1 : 0;
const canSellBack = currentLevel > baseLevel;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIcon(sig)} L${currentLevel}</span>
<button class="btn" ${!canSellBack ? 'disabled style="opacity:0.4"' : ''} onclick="deathBoySellBack('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSellBack ? `Sell for ${S.goingRate}G` : 'Cannot Sell'}
</button>
</div>`;
});

html += `</div>

<!-- Boy 2: Sacrifice for XP -->
<div style="background:rgba(168,85,247,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(168,85,247,0.3)">
<h3 style="color:#a855f7;margin-bottom:0.5rem">Death Boy 2: "Sacrifice"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Sacrifice one upgrade level to gain ${S.goingRate} Starting XP permanently. Going Rate decreases by 5G.</p>
<div style="font-size:0.8rem;margin-bottom:0.5rem;opacity:0.7">Current Starting XP: ${S.startingXP}</div>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G ‚Üí ${Math.max(1, S.goingRate - 5)}G</div>`;

// List all sigils that can be sacrificed
allSigils.forEach(sig => {
const currentLevel = S.sig[sig] || 0;
const baseLevel = ['Attack','Shield','Heal','D20'].includes(sig) ? 1 : 0;
const canSacrifice = currentLevel > baseLevel && S.goingRate > 1;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIcon(sig)} L${currentLevel}</span>
<button class="btn" ${!canSacrifice ? 'disabled style="opacity:0.4"' : ''} onclick="deathBoySacrifice('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSacrifice ? `+${S.goingRate}XP` : 'Cannot'}
</button>
</div>`;
});

html += `</div>
</div>
</div>`;
}

html += `
<div style="text-align:center;margin-top:2rem">
<button class="btn" onclick="restartAfterDeath()" style="background:#dc2626;font-size:1.2rem;padding:1rem 2rem">I AM DONE DYING</button>
</div>
</div>`;

v.innerHTML = html;
}

function purchaseSigilUpgrade(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }
S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
S.sigUpgradeCounts[sig] = (S.sigUpgradeCounts[sig] || 0) + 1;
S.goingRate += 5;
toast(`${sig} upgraded to L${S.sig[sig]}!`, 2000);
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySellBack(sig) {
const currentLevel = S.sig[sig] || 0;
const baseLevel = ['Attack','Shield','Heal','D20'].includes(sig) ? 1 : 0;
if(currentLevel <= baseLevel) {
toast("Whoa, something's weird. I can't do that", 3000);
return;
}
// Sell back: get gold, lower sigil level, no going rate change
S.gold += S.goingRate;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
toast(`Sold ${sig} L${currentLevel}‚ÜíL${S.sig[sig]} for ${S.goingRate}G!`, 3000);
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySacrifice(sig) {
const currentLevel = S.sig[sig] || 0;
const baseLevel = ['Attack','Shield','Heal','D20'].includes(sig) ? 1 : 0;
if(currentLevel <= baseLevel) {
toast("Whoa, something's weird. I can't do that", 3000);
return;
}
if(S.goingRate <= 1) {
toast("Whoa, something's weird. I can't do that", 3000);
return;
}
// Sacrifice: get starting XP, lower sigil level, decrease going rate
const xpGained = S.goingRate;
S.startingXP += xpGained;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
S.goingRate = Math.max(1, S.goingRate - 5);
toast(`Sacrificed ${sig} L${currentLevel}‚ÜíL${S.sig[sig]} for +${xpGained}XP permanently!`, 3000);
savePermanent();
showDeathScreen(); // Refresh
}

function restartAfterDeath() {
// Check if player has unspent gold
if(S.gold >= S.goingRate && !S.tutorialFlags.death_exit_warning) {
showTutorialPop('death_exit_warning', "Are you sure? This is some great value, and you'll end up giving it to me sooner or later...", () => {
// After tutorial, ask for confirmation
if(confirm('Leave Death Screen with unspent gold?')) {
actuallyRestartAfterDeath();
} else {
showDeathScreen();
}
});
return;
}
actuallyRestartAfterDeath();
}

function actuallyRestartAfterDeath() {
// Increment run number
S.runNumber++;
savePermanent();
// Clear run-specific save
localStorage.removeItem('froggle8');
// Reload page to start fresh
location.reload();
}

// ===== CHAMPIONS MENU =====
function showChampionsMenu() {
const v = document.getElementById('gameView');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;

let html = `
<div style="max-width:700px;margin:0 auto;padding:2rem">
<h1 style="text-align:center;margin-bottom:1rem;font-size:2.5rem;background:linear-gradient(135deg,#fbbf24,#f59e0b);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text">
üèÜ Champions of Floor 20 üèÜ
</h1>
<p style="text-align:center;margin-bottom:2rem;font-size:1.1rem;color:#666">You conquered the depths and earned these rewards!</p>

<div style="background:linear-gradient(135deg,rgba(251,191,36,0.1),rgba(245,158,11,0.1));border:3px solid #fbbf24;border-radius:12px;padding:2rem;margin-bottom:1.5rem">
<h2 style="text-align:center;margin-bottom:1rem;font-size:1.5rem">‚ö±Ô∏è Pedestal of Champions</h2>
<p style="text-align:center;margin-bottom:1.5rem;color:#666">Manage your hero figurines (${pedestalCount}/${maxSlots} placed)</p>
<button class="btn" onclick="showPedestal()" style="background:#22c55e;font-size:1.1rem">View Pedestal</button>
</div>

<div style="background:linear-gradient(135deg,rgba(220,38,38,0.1),rgba(127,29,29,0.1));border:3px solid #dc2626;border-radius:12px;padding:2rem;margin-bottom:1.5rem">
<h2 style="text-align:center;margin-bottom:1rem;font-size:1.5rem">üåÄ Portal to Frogged Up Realm</h2>
<p style="text-align:center;margin-bottom:1rem;color:#666">Switch between Standard and Effed Up modes</p>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem">
Current Mode: <strong style="color:${S.gameMode === 'Effed' ? '#dc2626' : '#14b8a6'}">${S.gameMode === 'Standard' ? 'Standard' : 'EFFED UP üî•'}</strong>
</p>
<button class="btn" onclick="toggleModeFromChampions()" style="background:${S.gameMode === 'Effed' ? '#14b8a6' : '#dc2626'};font-size:1.1rem">
Enter ${S.gameMode === 'Standard' ? 'Effed Up Realm üî•' : 'Standard Realm'}
</button>
</div>

<div style="text-align:center;margin-top:2rem">
<button class="btn secondary" onclick="title()">Back to Title</button>
</div>
</div>`;

v.innerHTML = html;
}

function toggleModeFromChampions() {
S.gameMode = S.gameMode === 'Standard' ? 'Effed' : 'Standard';
showChampionsMenu();
}

// ===== PEDESTAL UI =====
function showPedestal() {
const v = document.getElementById('gameView');
const heroes = ['Warrior', 'Tank', 'Mage', 'Healer'];
const heroIcons = {'Warrior': '‚öî', 'Tank': 'üõ°', 'Mage': 'üìñ', 'Healer': '‚úö'};
const stats = ['POW', 'HP'];

// Count available figurines (earned from victories, not yet slotted)
const availableFigurines = {};
heroes.forEach(hero => {
availableFigurines[hero] = {POW: 0, HP: 0};
});

let html = `
<div style="max-width:700px;margin:0 auto">
<h2 style="text-align:center;margin-bottom:0.5rem">Pedestal - ${S.gameMode} Mode</h2>
<p style="text-align:center;margin-bottom:2rem;font-size:0.9rem;color:#666">Place figurines to grant permanent stat buffs</p>

<div style="background:#f5f5f5;padding:1.5rem;border-radius:8px;border:2px solid #000">
<table style="width:100%;border-collapse:separate;border-spacing:8px">
<thead>
<tr>
<th style="width:80px"></th>`;

// Column headers (hero icons) - monochrome and engraved
heroes.forEach(hero => {
html += `<th style="text-align:center;font-size:1.5rem"><span style="filter:grayscale(1) contrast(999);opacity:0.8;display:inline-block">${heroIcons[hero]}</span><div style="font-size:0.75rem;font-weight:normal;margin-top:0.25rem">${hero}</div></th>`;
});

html += `</tr></thead><tbody>`;

// Each row (POW, HP)
stats.forEach(stat => {
html += `<tr><td style="text-align:right;font-weight:bold;padding-right:1rem">${stat}</td>`;

heroes.forEach(hero => {
const slotted = S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
const isSlotted = !!slotted;

html += `<td style="text-align:center">
<div style="width:80px;height:80px;margin:0 auto;background:${isSlotted ? '#fbbf24' : '#fff'};border:2px solid #000;border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative" onclick="${isSlotted ? `removeFigurine('${hero}','${stat}')` : `slotFigurine('${hero}','${stat}')`}">`;

if(isSlotted) {
const displayIcon = slotted.source === 'statuette' ? 'üóø' : heroIcons[hero];
const iconStyle = 'font-size:2rem;' + (slotted.source === 'statuette' ? 'filter:grayscale(1) contrast(1.2);' : 'filter:grayscale(1) contrast(999);');
html += `<div style="${iconStyle}">${displayIcon}</div>
<div style="position:absolute;top:2px;right:4px;font-size:0.7rem;background:#000;color:#fff;padding:2px 4px;border-radius:3px">${stat === 'POW' ? '+1' : '+5'}</div>`;
} else {
html += `<div style="font-size:1.5rem;color:#ccc">+</div>`;
}

html += `</div></td>`;
});

html += `</tr>`;
});

html += `</tbody></table>
</div>

${S.hasAncientStatuette ? `<div style="margin-top:1.5rem;padding:1rem;background:rgba(251,191,36,0.1);border-radius:6px;text-align:center">
<p style="font-weight:bold;margin-bottom:0.5rem">üóø Ancient Statuette Available!</p>
<p style="font-size:0.9rem;color:#666">The Ancient Statuette can be placed in any slot</p>
</div>` : ''}

<div style="text-align:center;margin-top:2rem">
<button class="btn secondary" onclick="showChampionsMenu()">Back to Champions</button>
</div>
</div>`;

v.innerHTML = html;
}

function slotFigurine(hero, stat) {
// Check if slot is available
if(S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode)) {
toast('Slot already filled!');
return;
}

// Check if we have 8 slots filled
const slotsUsed = S.pedestal.filter(p => p.mode === S.gameMode).length;
if(slotsUsed >= 8) {
toast('All 8 slots filled! Remove a figurine first.');
return;
}

// Use Ancient Statuette if available (can go in any slot)
if(S.hasAncientStatuette) {
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'statuette'});
S.hasAncientStatuette = false;
savePermanent();
toast(`Ancient Statuette placed on ${hero} ${stat}!`, 3000);
showPedestal();
return;
}

// Otherwise, check if this hero can have a figurine (max 2 per hero per mode)
const existingCount = S.pedestal.filter(p => p.hero === hero && p.mode === S.gameMode).length;
if(existingCount >= 2) {
toast(`${hero} already has 2 figurines in ${S.gameMode} mode!`, 3000);
return;
}

// Place the hero figurine
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'hero'});
savePermanent();
toast(`${hero} ${stat} figurine placed!`, 3000);
showPedestal();
}

function removeFigurine(hero, stat) {
const idx = S.pedestal.findIndex(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
if(idx >= 0) {
S.pedestal.splice(idx, 1);
savePermanent();
toast(`${hero} ${stat} figurine removed!`);
showPedestal();
}
}

// ===== WIN =====
function win() {
// Gold is lost on victory (reset to 0)
S.gold = 0;
savePermanent();

// Award figurines for heroes who survived (HP > 0, not Last Stand)
const survivedHeroes = S.heroes.filter(h => h.h > 0 && !h.ls);
const earnedFigurines = [];
survivedHeroes.forEach(h => {
// Check if this hero already has 2 figurines for this mode
const existingCount = S.pedestal.filter(slot => slot.hero === h.n && slot.mode === S.gameMode).length;
if(existingCount < 2) {
earnedFigurines.push(h.n);
}
});

// Unlock Effed Up mode if Standard victory
const firstStandardVictory = S.gameMode === 'Standard' && !S.tutorialFlags.first_victory_sequence;
if(S.gameMode === 'Standard') {
S.effedUnlocked = true;
if(firstStandardVictory) {
S.tutorialFlags.first_victory_sequence = true;
}
}

const firstFU = S.gameMode === 'Effed' && !S.tutorialFlags.first_fu_victory;
if(firstFU) {
S.tutorialFlags.first_fu_victory = true;
// Note: Tapo is now unlocked at Floor 20 via Old Tapo encounter
}

savePermanent();

// Store earned figurines for later display
window.earnedFigurines = earnedFigurines;

// FIRST STANDARD VICTORY: Show cutscene
if(firstStandardVictory) {
showFirstVictoryCutscene();
return;
}

// FIRST FU VICTORY: Show credits
if(firstFU) {
showFUVictoryCredits();
return;
}

// TAPO IN PARTY: Show heartfelt thank you (only if Tapo is alive)
const tapoInParty = S.heroes.some(h => h.n === 'Tapo' && h.h > 0 && !h.ls);
if(tapoInParty && !S.tutorialFlags.tapo_victory_message) {
S.tutorialFlags.tapo_victory_message = true;
savePermanent();
showTapoVictoryMessage();
return;
}

// SUBSEQUENT VICTORIES: Go directly to Pedestal if figurines earned
if(earnedFigurines.length > 0 || S.hasAncientStatuette) {
showStatueRoom();
return;
}

// No figurines earned: show simple victory screen
showSimpleVictoryScreen();
}

function showFirstVictoryCutscene() {
const slides = [
{text: "Your heroes emerged from the portal, Tapo cradled safely in the Warrior's arms. The little tadpole squeaked happily as the town of Ribbleton erupted in cheers!"},
{text: "As the celebration wound down, the village elder approached. \"Heroes,\" she croaked solemnly, \"you have earned a great honor.\""},
{text: "She led you to an ancient stone chamber behind the town square. In the center stood a marble pedestal, gleaming in the torchlight."},
{text: "\"This is the Pedestal of Champions,\" the elder explained. \"Place figurines of your heroes upon it, and they will grow stronger with each new journey.\""},
{text: "The elder gestured to the far wall, where eight empty alcoves waited. \"Each victory earns you the right to place a figurine. Choose wisely - POW or HP.\""},
{text: "Then her expression darkened. \"But beware... that portal you dove through? It was no accident. Something sinister stirs beyond...\""},
{text: "As if on cue, the stone wall behind the pedestal EXPLODED in a shower of rubble! A swirling crimson portal materialized, radiating malevolent energy."},
{text: "\"The EFFED UP realm!\" the elder gasped. \"Only the strongest heroes dare enter there. May the ancients protect you...\""}
];

slides.onComplete = () => {
if(window.earnedFigurines && window.earnedFigurines.length > 0) {
showStatueRoom();
} else {
showSimpleVictoryScreen();
}
};

showNarrativeSlide(slides, 0);
}

function showFUVictoryCredits() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="max-width:600px;margin:2rem auto;padding:2rem;background:linear-gradient(135deg,#1e1b4b 0%,#7c2d12 100%);border-radius:12px;border:3px solid #fbbf24;color:#fff">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem">üî• EFFED UP MODE CONQUERED! üî•</h1>

<div style="text-align:center;margin-bottom:2rem;font-size:1.2rem;line-height:1.8">
<p>You defeated the hardest challenge in FROGGLE.</p>
<p>I genuinely did not think anyone would beat this.</p>
<p style="margin-top:2rem;font-style:italic">Thank you for playing.</p>
<p style="font-size:2rem;margin:2rem 0">‚ù§Ô∏è</p>
</div>

<div style="background:rgba(0,0,0,0.3);padding:1.5rem;border-radius:8px;margin:2rem 0">
<h3 style="text-align:center;margin-bottom:1rem;color:#fbbf24">FROGGLE</h3>
<div style="text-align:center;font-size:0.9rem;line-height:2;opacity:0.9">
<p>A game by Preston Wesner</p>
<p>Design, Art, & Code: Preston</p>
<p>Playtesting: [Your Name Here]</p>
<p>Inspiration: Slay the Spire, Balatro, and too much coffee</p>
<p style="margin-top:1.5rem;font-style:italic">Made with love in 2024</p>
</div>
</div>

<div style="background:rgba(251,191,36,0.2);padding:1.5rem;border-radius:8px;margin:2rem 0;border:2px solid #fbbf24">
<h3 style="text-align:center;margin-bottom:1rem">üéâ TAPO UNLOCKED! üéâ</h3>
<img src="assets/tapo.png" style="max-width:200px;height:auto;display:block;margin:1rem auto;border-radius:8px">
<p style="text-align:center;margin-top:1rem">Tapo the Tadpole is now available as a playable hero!</p>
<p style="text-align:center;font-size:0.9rem;opacity:0.8;margin-top:0.5rem">Stats: 1 POW, 1 HP ‚Ä¢ Has access to ALL sigils in the Sigilarium</p>
<p style="text-align:center;font-size:0.85rem;opacity:0.6;margin-top:0.5rem;font-style:italic">(Glass cannon mode activated)</p>
</div>

<div style="text-align:center">
<button class="btn" onclick="showStatueRoom()" style="background:#22c55e;padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem">Place Figurines</button>
<button class="btn" onclick="title()" style="padding:1rem 2rem;font-size:1.1rem">Play Again</button>
</div>
</div>`;
}

function showTapoVictoryMessage() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="max-width:700px;margin:2rem auto;padding:3rem;background:linear-gradient(135deg,#22c55e 0%,#10b981 50%,#059669 100%);border-radius:16px;border:4px solid #fbbf24;color:#fff;box-shadow:0 8px 32px rgba(0,0,0,0.3)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:3rem;text-shadow:2px 2px 4px rgba(0,0,0,0.3)">üèÜ VICTORY! üèÜ</h1>

<div style="text-align:center;margin:2rem 0">
<img src="assets/tapo.png" style="max-width:250px;height:auto;display:block;margin:0 auto 2rem auto;border-radius:12px;border:3px solid #fbbf24;box-shadow:0 4px 16px rgba(0,0,0,0.3);animation:bounce 2s ease-in-out infinite">
</div>

<div style="background:rgba(0,0,0,0.2);padding:2rem;border-radius:12px;margin:2rem 0;border:2px solid rgba(251,191,36,0.5)">
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
Holy frog. I can't believe you put this much time into my silly little game.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
From the bottom of my heart, thank you for playing.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;font-weight:500">
I hope you had fun!
</p>
<p style="text-align:center;font-size:1.1rem;margin-top:2rem;font-style:italic;opacity:0.9">
-Preston
</p>
</div>

<div style="text-align:center;font-size:2.5rem;margin:2rem 0">
‚ù§Ô∏èüê∏‚ù§Ô∏è
</div>

<div style="text-align:center;margin-top:2rem">
${window.earnedFigurines && window.earnedFigurines.length > 0 ?
  '<button class="btn" onclick="showStatueRoom()" style="background:#fbbf24;color:#000;padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem;font-weight:bold">Place Figurines</button><br>' :
  ''}
<button class="btn" onclick="title()" style="background:#fff;color:#22c55e;padding:1rem 2rem;font-size:1.1rem;font-weight:bold">Play Again</button>
</div>
</div>`;
}

function showStatueRoom() {
// This redirects to the existing Pedestal UI
showTutorialPop('pedestal_first_placement', "Welcome to the Pedestal! Place figurines to permanently boost your heroes. Each hero can have 2 figurines (one POW, one HP) per mode.", () => {
showPedestal();
});
}

function showSimpleVictoryScreen() {
const v = document.getElementById('gameView');
let html = `
<h1 style="text-align:center;margin:2rem 0;font-size:2.5rem">üèÜ VICTORY! üèÜ</h1>`;

if(S.gameMode === 'Effed') {
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1.2rem">You conquered the Effed Up realm once again!<br>Impressive.</p>`;
} else {
html += `<img src="assets/tapo.png" style="max-width:100%;height:auto;max-width:400px;margin:1rem auto;display:block;border-radius:8px;border:3px solid #000">`;
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1.2rem;font-weight:bold">You saved Tapo the Tadpole!</p>`;
}

if(window.earnedFigurines && window.earnedFigurines.length > 0) {
html += `<div style="background:rgba(251,191,36,0.1);padding:1rem;border-radius:8px;margin:1rem auto;max-width:500px">
<h3 style="text-align:center;margin-bottom:0.5rem">üèÜ Hero Figurines Earned! üèÜ</h3>
<p style="text-align:center">The following heroes can place figurines:</p>
<ul style="list-style:none;padding:0;text-align:center">`;
window.earnedFigurines.forEach(name => {
html += `<li style="margin:0.5rem 0;font-weight:bold">${name}</li>`;
});
html += `</ul></div>`;
}

html += `<div style="text-align:center;margin-top:2rem">
<button class="btn" onclick="title()" style="padding:1rem 2rem;font-size:1.1rem">Play Again</button>
</div>`;

v.innerHTML = html;
}

// ===== DEBUG MODE =====
function toggleDebugMode(enabled) {
S.debugMode = enabled;
toast(enabled ? 'Debug Mode ON' : 'Debug Mode OFF', 2000);
}

function showDebugMenu() {
const inCombat = S.enemies && S.enemies.length > 0;
const v = document.getElementById('gameView');
let html = `
<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);border:3px solid #fbbf24;border-radius:12px;padding:2rem;z-index:30000;max-width:400px;width:90%">
<h2 style="text-align:center;color:#fbbf24;margin-bottom:1.5rem">üõ†Ô∏è DEBUG MENU üõ†Ô∏è</h2>
<button class="btn" onclick="debugAddGold()" style="margin-bottom:0.5rem;background:#22c55e">+100 Gold</button>
<button class="btn" onclick="debugAddXP()" style="margin-bottom:0.5rem;background:#22c55e">+100 XP</button>
<div style="margin:0.5rem 0">
<label style="color:white;font-size:0.9rem">Jump to Floor:</label>
<input type="number" id="debugFloorInput" min="1" max="19" value="${S.floor}" style="width:60px;padding:0.25rem;margin:0 0.5rem;font-size:1rem">
<button class="btn" onclick="debugJumpFloor()" style="display:inline-block;width:auto;padding:0.5rem 1rem;margin:0;font-size:0.9rem;min-height:auto">Go</button>
</div>
${inCombat ? `<button class="btn" onclick="debugDealDamage()" style="margin-top:0.5rem;background:#dc2626">Deal 50 DMG to Enemy</button>` : ''}
<button class="btn" onclick="closeDebugMenu()" style="margin-top:1rem;background:#888">Close</button>
</div>
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:29999" onclick="closeDebugMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeDebugMenu() {
// Remove debug menu elements
const menus = document.querySelectorAll('[style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

function debugAddGold() {
S.gold += 100;
upd();
toast('Added 100 Gold!', 2000);
closeDebugMenu();
}

function debugAddXP() {
S.xp += 100;
upd();
toast('Added 100 XP!', 2000);
closeDebugMenu();
}

function debugJumpFloor() {
const input = document.getElementById('debugFloorInput');
const targetFloor = parseInt(input.value);
if(targetFloor < 1 || targetFloor > 19 || isNaN(targetFloor)) {
toast('Invalid floor! Must be 1-19', 2000);
return;
}
closeDebugMenu();
S.floor = targetFloor;
upd();
startFloor(targetFloor);
toast(`Jumped to Floor ${targetFloor}!`, 2000);
}

function debugDealDamage() {
if(!S.enemies || S.enemies.length === 0) {
toast('No enemies in combat!', 2000);
return;
}
// Deal 50 damage to first enemy
const enemy = S.enemies[0];
enemy.h -= 50;
if(enemy.h < 0) enemy.h = 0;
upd();
toast(`Dealt 50 damage to ${enemy.n}!`, 2000);
closeDebugMenu();
// Check if combat is over
setTimeout(() => checkCombatOver(), 100);
}

// ===== INIT =====
window.onload = () => {
console.log('[FROGGLE] window.onload fired');
loadPermanent(); // Always load permanent data first
console.log('[FROGGLE] loadPermanent complete, S.runNumber:', S.runNumber, 'S.tutorialsDisabled:', S.tutorialsDisabled);
mainTitlePage();
console.log('[FROGGLE] mainTitlePage called');
};

// Global error handler for image loading failures
window.addEventListener('error', (e) => {
if(e.target && e.target.tagName === 'IMG') {
console.error('[FROGGLE] IMAGE LOAD FAILED:', e.target.src);
console.error('[FROGGLE] Current location:', window.location.href);
console.error('[FROGGLE] Image path:', e.target.getAttribute('src'));
} else if(e.message) {
console.error('[FROGGLE] JAVASCRIPT ERROR:', e.message);
console.error('[FROGGLE] File:', e.filename, 'Line:', e.lineno, 'Col:', e.colno);
console.error('[FROGGLE] Stack:', e.error ? e.error.stack : 'No stack trace');
}
}, true);

// Catch unhandled promise rejections
window.addEventListener('unhandledrejection', (e) => {
console.error('[FROGGLE] UNHANDLED PROMISE REJECTION:', e.reason);
});
</script>
</body>
</html>