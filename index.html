<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="apple-mobile-web-app-title" content="FROGGLE"/>
<meta name="theme-color" content="#22c55e"/>
<link rel="manifest" href="manifest.json"/>
<link rel="apple-touch-icon" href="assets/tapo-icon-180.png"/>
<link rel="icon" type="image/png" href="assets/tapo-icon.png"/>
<title>FROGGLE v9.97</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body { font-family: -apple-system, sans-serif; background: #d9cab1; color: #1c1b19; position: fixed; width: 100%; height: 100%; overflow: hidden; }
.header { padding: 0.5rem; background: linear-gradient(#fff, #f7f1e3); border-bottom: 2px solid #bda; display: flex; justify-content: space-between; font-size: 0.8rem; }
.game-area { height: calc(100vh - 44px); overflow-y: auto; padding: 0.5rem; -webkit-overflow-scrolling: touch; }
.btn { padding: 1rem; border: 3px solid #000; border-radius: 8px; background: #2c63c7; color: white; font-weight: bold; font-size: 1.1rem; min-height: 56px; width: 100%; margin-bottom: 0.75rem; cursor: pointer; }
.btn:active { transform: scale(0.98); opacity: 0.9; }
.btn.safe { background: #22c55e; }
.btn.risky { background: #f59e0b; }
.btn.danger { background: #dc2626; }
.btn.secondary { background: #6b7280; }
.choice { border: 3px solid #000; padding: 1rem; margin-bottom: 0.75rem; border-radius: 8px; background: white; min-height: 60px; }
.choice:active { transform: scale(0.98); background: #f0f0f0; }
.neutral-btn { padding: 0.5rem 0.75rem; margin-bottom: 0.5rem; border: 2px solid #000; border-radius: 6px; background: white; font-weight: bold; cursor: pointer; font-size: 0.9rem; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
.neutral-btn:active { transform: scale(0.98); opacity: 0.9; }
.neutral-btn.safe { background: #22c55e; color: white; }
.neutral-btn.risky { background: #f59e0b; color: white; }
.neutral-btn.danger { background: #dc2626; color: white; }
.neutral-btn.secondary { background: #6b7280; color: white; }
.neutral-container {
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  width: 100%;
  height: 100vh;
  position: relative;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.neutral-header {
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  align-items: flex-start;
  max-width: 450px;
}
.neutral-stats {
  background: rgba(0,0,0,0.75);
  color: white;
  border-radius: 6px;
  padding: 0.4rem 0.75rem;
  font-size: 0.85rem;
  font-weight: bold;
}
.neutral-narrative {
  background: rgba(0,0,0,0.8);
  color: white;
  border-radius: 8px;
  padding: 0.75rem;
}
.neutral-title { font-size: 1.2rem; font-weight: bold; margin-bottom: 0.5rem; color: #fbbf24; }
.neutral-desc { font-size: 0.9rem; line-height: 1.4; margin-bottom: 0.5rem; }
.neutral-outcome { font-size: 0.85rem; padding: 0.5rem; background: rgba(255,255,255,0.15); border-radius: 4px; margin-bottom: 0.5rem; }
.neutral-content {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}
.neutral-footer {
  padding: 1rem;
  max-width: 450px;
}
.dice-roll { font-size: 1.2rem; font-weight: bold; text-align: center; padding: 1rem; background: #2c63c7; color: white; border-radius: 6px; margin: 1rem 0; }
/* Combat layout */
.combat-grid { display: flex; gap: 0.75rem; margin-bottom: 1rem; justify-content: center; }
.column { display: flex; flex-direction: column; gap: 0.5rem; align-items: center; }
.column.heroes { flex: 0 0 auto; }
.column.enemies { flex: 0 0 auto; }
.combat-lane {
  background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
  border: 4px solid #000;
  border-radius: 10px;
  padding: 1rem;
  margin: 0 auto 2rem auto;
  max-width: 800px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255,255,255,0.2);
  position: relative;
}
.combat-lane:not(:last-child)::after {
  content: '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ';
  position: absolute;
  bottom: -2rem;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(0,0,0,0.4);
  font-size: 1.2rem;
  letter-spacing: -2px;
  text-align: center;
  width: 100%;
  text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}
.card { width: auto; max-width: 160px; border: 3px solid #000; border-radius: 8px; padding: 0.5rem; min-height: 70px; font-size: 0.85rem; transition: transform 0.1s ease; }
.card.hero { background: #2c63c7; color: white; width: 160px; }
.card.enemy { background: #b64141; color: white; width: 160px; }
.card.active { box-shadow: 0 0 0 4px gold; animation: pulse-glow 1s infinite; }
.card.selectable { cursor: pointer; box-shadow: 0 0 0 3px #22c55e; }
.card.selectable:active { transform: scale(0.98); }
.card.targetable { cursor: pointer; }
.card.targetable:active { transform: scale(0.98); }
.card.targeted { box-shadow: 0 0 0 4px lime; }
.card.acted { opacity: 0.6; }
.card.last-stand { border-color: #dc2626; box-shadow: 0 0 0 3px #dc2626; }
.card.hero.targetable { box-shadow: 0 0 0 3px #3b82f6; }
.card.enemy.targetable { box-shadow: 0 0 0 3px #dc2626; }
.card.hero.targeted { box-shadow: 0 0 0 4px #60a5fa; }
.card.enemy.targeted { box-shadow: 0 0 0 4px #ef4444; }
.card.hit-flash { animation: damage-stagger 0.4s ease; }
.card.attack-slide { animation: attack-slide 0.5s ease; }
.card.heal-flash { animation: heal-flash 0.5s ease; position: relative; }
.card.shield-flash { animation: shield-flash 0.5s ease; position: relative; }
@keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 0 4px gold; } 50% { box-shadow: 0 0 0 8px gold; } }
@keyframes damage-stagger {
  0% { transform: translateX(0); filter: brightness(1); }
  15% { transform: translateX(-12px); filter: brightness(2) saturate(2); background-color: rgba(220, 38, 38, 0.4); }
  30% { transform: translateX(6px); filter: brightness(1.8) saturate(2); background-color: rgba(220, 38, 38, 0.3); }
  50% { transform: translateX(-6px); filter: brightness(1.5); background-color: rgba(220, 38, 38, 0.2); }
  70% { transform: translateX(3px); filter: brightness(1.2); }
  100% { transform: translateX(0); filter: brightness(1); background-color: transparent; }
}
@keyframes attack-slide {
  0% { transform: translateX(0); }
  30% { transform: translateX(20px); }
  70% { transform: translateX(20px); }
  100% { transform: translateX(0); }
}
@keyframes heal-flash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.8) hue-rotate(90deg); box-shadow: 0 0 20px rgba(34, 197, 94, 0.8); }
}
@keyframes shield-flash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.5) grayscale(0.3); box-shadow: 0 0 20px rgba(156, 163, 175, 0.8); }
}
@keyframes heal-cross-fade {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
  50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
}
.sigil-row { display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; margin-top: 4px; max-width: 100%; }
.sigil-row.compact { gap: 2px; }
.sigil-row.compact .sigil { padding: 2px 5px; font-size: 0.7rem; min-height: 22px; border-width: 2px; }
.sigil-divider { width: 100%; height: 1px; background: rgba(255,255,255,0.3); margin: 4px 0; }
.sigil { border: 3px solid; border-radius: 6px; padding: 4px 8px; font-size: 0.85rem; display: inline-block; margin: 2px; min-height: 28px; font-weight: 900; background: transparent; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
.sigil.clickable { cursor: pointer; }
.sigil.clickable:active { transform: scale(0.95); }
.sigil.active-action { box-shadow: 0 0 12px #fbbf24; animation: pulse-action 0.8s infinite; }
.sigil.l0 { color: #666; border-color: #666; opacity: 0.6; }
.sigil.l1 { color: #1e40af; border-color: #1e40af; }
.sigil.l2 { color: #0d9488; border-color: #0d9488; }
.sigil.l3 { color: #9333ea; border-color: #9333ea; }
.sigil.l4 { color: #d97706; border-color: #d97706; text-shadow: 0 0 8px rgba(217,119,6,0.4); }
.sigil.l5 {
  background: linear-gradient(90deg, #ff0080, #ff8c00, #40e0d0, #ff0080);
  background-size: 300% 100%;
  animation: rainbow-shift 3s linear infinite;
  border: 2px solid;
  border-image: linear-gradient(90deg, #ff0080, #ff8c00, #40e0d0, #ff0080) 1;
  color: white;
  text-shadow: 0 0 12px rgba(255,255,255,0.8), 0 0 24px rgba(255,0,128,0.6);
  font-weight: bold;
}
@keyframes rainbow-shift {
  0% { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}
.sigil.engraved { color: #6b7280; border-color: #9ca3af; font-style: italic; opacity: 0.7; background: rgba(107,114,128,0.1); }
.sigil.asterisk-primed { box-shadow: 0 0 8px #fbbf24; animation: pulse-asterisk 1s infinite; }
@keyframes pulse-asterisk { 0%, 100% { box-shadow: 0 0 8px #fbbf24; } 50% { box-shadow: 0 0 16px #fbbf24; } }
@keyframes pulse-action { 0%, 100% { box-shadow: 0 0 12px #fbbf24; } 50% { box-shadow: 0 0 20px #fbbf24; } }
.toast { position: fixed; bottom: 20px; right: 20px; background: linear-gradient(#fff, #f7f1e3); border: 2px solid #bda; border-radius: 6px; padding: 1rem 1.5rem; font-weight: bold; box-shadow: 0 4px 12px rgba(0,0,0,0.2); opacity: 0; transform: translateY(20px); transition: all 0.3s; z-index: 10000; max-width: 80%; }
.toast.show { opacity: 1; transform: translateY(0); }
.toast-log { position: fixed; top: 10px; right: 60px; background: linear-gradient(#fff, #f7f1e3); border: 2px solid #bda; border-radius: 6px; padding: 0.5rem; max-width: 280px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 9999; transition: all 0.3s; }
.toast-log.minimized { max-height: 40px; overflow: hidden; cursor: pointer; }
.toast-log.minimized:hover { background: linear-gradient(#f7f1e3, #e7e1d3); }
.toast-log-header { font-weight: bold; font-size: 0.85rem; margin-bottom: 0.25rem; padding: 0.25rem 0.5rem; display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
.toast-log-toggle { font-size: 1rem; }
.toast-log-entries { max-height: 200px; overflow-y: auto; font-size: 0.8rem; }
.toast-log-entry { padding: 0.4rem 0.5rem; border-top: 1px solid rgba(0,0,0,0.1); }
.toast-log-entry:first-child { border-top: none; }
.toast-log-entry.recent { font-weight: bold; }
.turn-locked { pointer-events: none; opacity: 0.7; }
.tutorial-modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 20000; display: flex; align-items: center; justify-content: center; }
.tutorial-modal { background: linear-gradient(#fff, #f7f1e3); border: 4px solid #fbbf24; border-radius: 12px; padding: 2rem; max-width: 600px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); text-align: center; }
.tutorial-modal h2 { margin-top: 0; color: #6b4423; }
.tutorial-modal p { margin: 1rem 0; font-size: 1.1rem; line-height: 1.6; }
.tutorial-modal button { margin-top: 1.5rem; padding: 0.75rem 2rem; font-size: 1.1rem; font-weight: bold; background: #22c55e; color: #fff; border: 2px solid #15803d; border-radius: 8px; cursor: pointer; }
.tutorial-modal button:hover { background: #15803d; }
.tutorial-modal button:active { transform: scale(0.98); }
.choice.disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }
.tooltip { position: fixed; z-index: 25000; background: rgba(0,0,0,0.95); color: #fff; padding: 1rem; border-radius: 8px; border: 2px solid #fbbf24; max-width: 320px; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
.tooltip.show { opacity: 1; }
.tooltip-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem; color: #fbbf24; }
.tooltip-desc { font-size: 0.9rem; line-height: 1.4; }
</style>
</head>
<body>
<div class="header" id="gameHeader">
<div>Floor <span id="floor">1</span> | Round <span id="round">1</span></div>
<div style="display:flex;gap:0.25rem">
<button onclick="showSettingsMenu()" style="padding:0.25rem 0.5rem;background:#3b82f6;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer">‚öôÔ∏è</button>
<div id="debugBtn" style="display:none"><button onclick="showDebugMenu()" style="padding:0.25rem 0.5rem;background:#fbbf24;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer">üõ†Ô∏è</button></div>
</div>
<div><span id="gold">0</span>G | <span id="xp">0</span>XP</div>
</div>
<div class="game-area" id="gameView"></div>
<script>
// ===== VERSION CHECK =====
const GAME_VERSION = '9.97';
console.log(`%cüê∏ FROGGLE v${GAME_VERSION} LOADED`, 'color: #22c55e; font-size: 20px; font-weight: bold;');
console.log('%cIf you see a different version in the UI, clear your cache and reload!', 'color: #f59e0b; font-weight: bold;');

// ===== GAME DATA =====
// Hero images
const HERO_IMAGES = {
        warrior: 'warriorfull.png',
        tank: 'tankfull.png',
        mage: 'magefull.png',
        healer: 'healerfull.png',
        tapo: 'tapofull.png'
    };

// Death's dialogue lines (cycles through without repeating until all used)
const DEATH_QUOTES = [
    "Some days you're the sticky tongue, some days you're the fly.",
    "You must really like pain. Or do you like death? Weirdo.",
    "Next time bring me a smoothie or something",
    "Hey, have you met those ghost boys in the dungeon? I can't get them to make.. you know.. the transition. Help them out, would you?",
    "Death death lemonade, 'round the coroner I parade",
    "Ribbit? Ribbbbbit? Rib bit?",
    "Oh man, a classic green. You just know he's a jumper.",
    "Hello my baby, hello my honey.",
    "If you refuse me, honey you'll lose me",
    "You guys should check out the Discovery Channel to see what normal frogs do",
    "Toadally froggin died, huh?"
];

const H = {
warrior: {n:'Warrior', p:2, h:5, m:5, s:['Attack','D20']},
tank: {n:'Tank', p:1, h:10, m:10, s:['Shield','D20']},
mage: {n:'Mage', p:1, h:5, m:5, s:['Attack','D20','Expand']},
healer: {n:'Healer', p:1, h:5, m:5, s:['Heal','D20','Expand']},
tapo: {n:'Tapo', p:1, h:1, m:1, s:['Attack','Shield','Heal','D20','Expand','Grapple','Ghost','Asterisk','Star','Alpha']}
};

const E = {
goblin: { n:'Goblin', p:1, h:5, m:5, g:1, x:2, pool:['Asterisk','Expand','Shield'], gainRate:3 },
wolf: { n:'Wolf', p:2, h:5, m:5, g:2, x:4, pool:['Asterisk','Expand','Shield','Grapple','Alpha'], gainRate:2 },
orc: { n:'Orc', p:2, h:7, m:7, g:3, x:6, pool:['Asterisk','Expand','Shield','Grapple','Alpha','Heal','Ghost','Attack2','Shield2'], gainRate:2, startSigils:1 },
giant: { n:'Giant', p:3, h:15, m:15, g:6, x:12, pool:'ANY', gainRate:1, startSigils:[{s:'Shield',l:1}] },
dragon: { n:'Dragon', p:10, h:25, m:25, g:10, x:25, pool:'ANY_ADVANCED', gainRate:1, drawsPerTurn:2, permSigils:[{s:'Attack',l:2},{s:'Expand',l:5}], startSigils:2 }
};

// Enemy emoji icons
const ENEMY_EMOJI = {
'Goblin': 'üë∫',
'Wolf': 'üê∫',
'Orc': 'üëπ',
'Giant': 'üóø',
'Dragon': 'üêâ'
};

// Sigil icons - now using extracted PNG images with transparent backgrounds
const SIGIL_IMAGES = {
'Attack': 'assets/sigils/attack.png',
'Shield': 'assets/sigils/shield.png',
'Heal': 'assets/sigils/heal.png',
'D20': 'assets/sigils/d20.png',
'Asterisk': 'assets/sigils/asterisk.png',
'Alpha': 'assets/sigils/alpha.png',
'Expand': 'assets/sigils/expand.png',
'Grapple': 'assets/sigils/grapple.png',
'Star': 'assets/sigils/star.png',
'Ghost': 'assets/sigils/ghost.png'
};

// Helper function to display sigil with icon
function sigilIcon(name) {
const imgPath = SIGIL_IMAGES[name];
if (!imgPath) return name;
return `<img src="${imgPath}" style="height:1em;vertical-align:middle;display:inline-block;margin-right:0.25em;filter:brightness(0);" alt="${name}">${name}`;
}

// Helper function to display just the icon
function sigilIconOnly(name) {
const imgPath = SIGIL_IMAGES[name];
if (!imgPath) return name;
return `<img src="${imgPath}" style="height:1.2em;vertical-align:middle;display:inline-block;filter:brightness(0);" alt="${name}">`;
}

// Sigil descriptions for tooltips
const SIGIL_DESCRIPTIONS = {
'Attack': 'Deal POW damage to target. L2: Attack twice. L3: Attack 3 times. L4: Attack 4 times. Stacks with Asterisk.',
'Shield': 'Grant target 2√óPOW shield. L2: 4√óPOW. L3: 6√óPOW. L4: 8√óPOW. Shield blocks damage before HP.',
'Heal': 'Restore 2√óPOW HP to target. L2: 4√óPOW. L3: 6√óPOW. L4: 8√óPOW. Cannot exceed max HP.',
'D20': 'Roll 1d20 and choose: Damage enemy (DC varies) or Heal ally (no DC). Higher levels roll more dice, take best result.',
'Expand': 'Your Attack/Shield/Heal target +1 additional target per level. Mage/Healer get +1 Expand level built-in.',
'Grapple': 'Deal POW damage to target AND they deal POW damage back to you. L2+: Stun target for (Level-1) turns.',
'Ghost': 'Cancel the next lethal hit. Each charge prevents one death. Charges shown on card.',
'Asterisk': 'Prime by using last action. Next turn: First action hits ALL enemies in lane. One use per combat.',
'Star': 'Multiply combat XP by (1 + Level√ó0.5). Stacks across heroes. L4 = 3√ó XP!',
'Alpha': 'Grant target hero an extra action this turn. Can target self. Higher levels grant more actions.'
};

// ===== UTILITY FUNCTIONS =====
// Unified dice rolling utility
function rollDice(count, sides = 20) {
const rolls = [];
for(let i = 0; i < count; i++) {
rolls.push(Math.ceil(Math.random() * sides));
}
const best = Math.max(...rolls);
return {rolls, best};
}

// Helper for enemy attacks - handles targeting, damage, animations, and toast
function executeEnemyAttackOnHeroes(enemy, targetCount, attackName = 'Base Attack') {
const targets = selectEnemyTargets(enemy, targetCount);
if(targets.length === 0) return 0;

const damagedIds = [];
const targetNames = [];
targets.forEach(target => {
if(target.h > 0) {
targetNames.push(target.n);
damagedIds.push(target.id);
// Apply damage silently (we'll show one toast for all targets)
applyDamageToTarget(target, enemy.p, {isHero: true, silent: true});
}
});

// Trigger all animations simultaneously
damagedIds.forEach(id => triggerHitAnimation(id));

if(targetNames.length > 0) {
toast(`${enemy.n}'s ${attackName} hit ${targetNames.join(', ')} for ${enemy.p} damage each!`);
}

return targets.length;
}

// ===== RENDER HELPERS =====
// Render encampment enemy selection screen
function renderEncampmentSelection() {
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets.length;
let html = '<div style="text-align:center;font-weight:bold;padding:0.75rem;background:rgba(0,0,0,0.05);border-radius:6px;margin-bottom:0.75rem">';
html += `<div style="font-size:1.1rem;color:#dc2626">Encampment Early Kill</div>`;
html += `<div style="font-size:0.85rem;margin-top:0.25rem">Click ${kills} enem${kills>1?'ies':'y'} to remove before combat (${selected}/${kills} selected)</div>`;
html += '</div>';
html += '<div class="combat-grid">';
html += '<div class="column heroes">';
html += '<div style="text-align:center;font-weight:bold;padding:0.25rem;background:rgba(0,0,0,0.1);border-radius:6px;margin-bottom:0.5rem;font-size:0.85rem">HEROES</div>';
S.heroes.forEach((h,i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
const heroImage = HERO_IMAGES[h.n.toLowerCase()] || '';
html += `<div class="card hero">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${h.n}</div>
${heroImage ? `<img src="${heroImage}" style="width:48px;height:48px;border-radius:4px">` : ''}
<div class="sigil-divider"></div>
<div class="sigil-row">`;
const activeSigils = [...h.s, ...(h.ts || [])];
activeSigils.forEach(s => {
const lvl = getLevel(s, i);
const cl = lvl===0?'l0':lvl===1?'l1':lvl===2?'l2':lvl===3?'l3':lvl===4?'l4':'l5';
html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${s}', this)" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${s}', this), 500)" ontouchend="hideTooltip()">${sigilIconOnly(s)}</span>`;
});
html += '</div>';
html += `<div style="text-align:center;font-size:0.8rem;margin-top:0.25rem">${h.p}‚ö° | ${hp}${extra.length>0?' | '+extra.join(' '):''}</div>`;
html += '</div>';
});
html += '</div>';
html += '<div class="column enemies">';
html += '<div style="text-align:center;font-weight:bold;padding:0.25rem;background:rgba(0,0,0,0.1);border-radius:6px;margin-bottom:0.5rem;font-size:0.85rem">ENEMIES</div>';
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });
S.heroes.forEach((hero, laneIdx) => {
const laneEnemies = enemyLanes[laneIdx] || [];
html += `<div class="combat-lane" data-lane="${laneIdx+1}">`;
if(laneEnemies.length === 0) {
html += `<div style="text-align:center;font-size:0.75rem;padding:0.5rem;opacity:0.5;font-style:italic;margin-bottom:0.5rem">Empty</div>`;
} else {
laneEnemies.forEach(e => {
const isSelected = S.encampmentSelectedTargets.includes(e.id);
let cardClasses = 'card enemy targetable';
if(isSelected) cardClasses += ' targeted';
const extra = [];
if(e.sh > 0) extra.push(`${e.sh}üõ°`);
const encampmentGhostCharges = e.ghostCharges || 0;
if(encampmentGhostCharges > 0) extra.push(`${encampmentGhostCharges}${sigilIconOnly('Ghost')}`);
if(isSelected) extra.push('‚ùå');
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
html += `<div class="${cardClasses}" onclick="selectEncampmentTarget('${e.id}')">
<div style="text-align:center;font-size:2rem;margin-bottom:0.25rem">${enemyEmoji}</div>
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${e.n}</div>
<div style="text-align:center;font-size:0.8rem">${e.p}‚ö° | ${e.h}/${e.m}‚ù§${extra.length>0?' | '+extra.join(' '):''}</div>
<div class="sigil-divider"></div>
<div class="sigil-row">`;
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
if(!hasAttackSigil) {
html += `<span class="sigil engraved">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
const permStyle = sigil.perm ? 'engraved' : cl;
html += `<span class="sigil ${permStyle}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),500)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig)}${sigil.level}</span>`;
});
html += '</div></div>';
});
}
html += '</div>';
});
html += '</div></div>';
if(selected >= kills) {
html += '<button class="btn" style="background:#dc2626;margin-top:1rem" onclick="confirmEncampmentKills()">Confirm Removals</button>';
}
return html;
}

// Render combat status header
function renderCombatStatusHeader() {
let html = '<div style="text-align:center;font-weight:bold;padding:0.75rem;background:rgba(0,0,0,0.05);border-radius:6px;margin-bottom:0.75rem">';
if(S.turn!=='player') {
html += 'Enemy Turn‚Ä¶';
} else if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
const selected = S.targets.length;
html += `<div style="color:#b64141;font-size:1.1rem">${S.d20Action} (DC ${S.d20DC})</div>`;
html += `<div style="font-size:0.85rem;margin-top:0.25rem">Select target enemy (${selected}/${maxTargets})</div>`;
} else if(S.pending) {
const targetsPerInstance = getTargetsPerInstance(S.pending, S.activeIdx);
const targetType = needsEnemyTarget(S.pending) ? 'enemy' : 'hero';
if(isMultiInstance(S.pending)) {
const targetsInInstance = S.currentInstanceTargets.length;
html += `<div style="color:#b64141;font-size:1.1rem">${S.pending}</div>`;
html += `<div style="font-size:0.85rem;margin-top:0.25rem">Select ${targetType} (${targetsInInstance}/${targetsPerInstance})</div>`;
html += `<div style="font-size:0.75rem;opacity:0.8;margin-top:0.25rem">${S.instancesRemaining} instance${S.instancesRemaining>1?'s':''} remaining</div>`;
} else {
const selected = S.targets.length;
const max = targetsPerInstance;
html += `<div style="color:#b64141;font-size:1.1rem">${S.pending}</div>`;
html += `<div style="font-size:0.85rem;margin-top:0.25rem">Select ${targetType} (${selected}/${max})</div>`;
}
} else if(S.activeIdx === -1) {
const remaining = S.heroes.filter((h,i) => !S.acted.includes(i) && h.st === 0).length;
html += `<div style="font-size:1.1rem">Choose Hero to Act</div>`;
html += `<div style="font-size:0.8rem;opacity:0.8;margin-top:0.25rem">${remaining} hero${remaining>1?'es':''} remaining</div>`;
} else {
const h = S.heroes[S.activeIdx];
if(h) {
if(S.asteriskPrimed) html += `${h.n}'s Turn - Asterisk √ó${S.asteriskMultiplier} PRIMED!`;
else if(h.ls) html += `${h.n} Last Stand (Turn ${h.lst + 1}) - D20 only!`;
else html += `${h.n}'s Turn`;
}
}
html += '</div>';
return html;
}

// Unified damage application with shield/ghost/laststand handling
function applyDamageToTarget(target, rawDamage, options = {}) {
let dmg = rawDamage;

// Handle shield absorption
if(target.sh > 0) {
if(target.sh >= rawDamage) {
target.sh -= rawDamage;
dmg = 0;
} else {
dmg = rawDamage - target.sh;
target.sh = 0;
}
}

// Apply damage to HP
target.h -= dmg;

// Handle lethal damage
if(target.h <= 0) {
if(target.g > 0) {
// Ghost charge cancels death
target.g--;
target.h += dmg;
if(!options.silent) {
toast(`${target.n}'s Ghost charge cancelled the lethal hit!`, 1200);
}
} else {
// Death/Last Stand
target.h = 0;
if(options.isHero) {
// Heroes enter Last Stand
target.ls = true;
target.lst = 0;
if(!options.silent) {
toast(`${target.n} entered Last Stand!`);
showTutorialPop('last_stand_intro', "Ouch, that stinks. Well, you're not dead yet! While your ally lives, you live - but it looks like your actions are somewhat limited. Be careful though! If you don't get healing soon, you'll slip further and further away...");
}
} else {
// Enemies die - award gold/XP and schedule removal
if(!options.skipRewards) {
S.gold += target.g;
S.combatGold += target.g;
S.combatXP += target.x;
upd();
}
}
}
}

return dmg; // Return actual damage dealt to HP (after shield)
}

// ===== TUTORIAL SYSTEM =====
// Centralized Tutorial Manager for Ribbleton combat tutorial
const TutorialManager = {
// Tutorial stage definitions
stages: {
'waiting_for_start': {allowedActions: []},
'warrior_attack': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'targeting_wolf': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'healer_d20': {allowedActions: [{hero: 'Healer', sig: 'D20'}]},
'd20_menu': {allowedActions: [{hero: 'Healer', sig: 'D20'}]},
'enemy_turn_wait': {allowedActions: []},
'enemy_turn_explained': {allowedActions: []},
'healer_heal': {allowedActions: [{hero: 'Healer', sig: 'Heal'}]},
'expand_targets': {allowedActions: [{hero: 'Healer', sig: 'Heal'}]},
'finish_wolf': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'shield_sigil': {allowedActions: []},
'free': {allowedActions: []} // Tutorial complete, allow all actions
},

// Check if an action is allowed in current tutorial stage
canPerformAction(hero, sig) {
if(!tutorialState || S.floor !== 0) return true; // Not in tutorial
const stage = this.stages[tutorialState.stage];
if(!stage) return true; // Unknown stage, allow
if(tutorialState.stage === 'free') return true; // Tutorial complete

const allowed = stage.allowedActions;
if(allowed.length === 0) return false; // No actions allowed in this stage

return allowed.some(a => a.hero === hero.n && a.sig === sig);
},

// Advance to next stage based on action completion
advanceStage(context) {
if(!tutorialState || S.floor !== 0) return;

const {action, hero, round} = context;

// Stage transitions based on completed actions
if(tutorialState.stage === 'warrior_attack' && tutorialState.wolfDamaged && hero === 'Warrior' && round === 1) {
tutorialState.stage = 'healer_d20';
showTutorialPop('ribbleton_healer_d20', "Nice hit! Doesn't look like the Healer has any damage to heal right now, but they can still make a difference! Click the D20!", () => {
S.activeIdx = 1;
render();
});
}
else if(tutorialState.stage === 'd20_menu' && hero === 'Healer') {
tutorialState.stage = 'enemy_turn_wait';
}
else if(tutorialState.stage === 'expand_targets' && hero === 'Healer') {
tutorialState.stage = 'finish_wolf';
showTutorialPop('ribbleton_finish_wolf', "Now finish off that Wolf!", () => {
S.activeIdx = 0;
render();
});
}
},

// Handle round transitions during tutorial
onRoundStart(round) {
if(!tutorialState || S.floor !== 0) return;

console.log('[TUTORIAL] Round transition - Round:', round, 'Stage:', tutorialState.stage);

// Round 2: Healer Heal prompt
if(round === 2 && (tutorialState.stage === 'enemy_turn_explained' || tutorialState.stage === 'finish_wolf') && !S.tutorialFlags.ribbleton_healer_heal) {
console.log('[TUTORIAL] Triggering PROMPT 6 - Healer Heal (stage:', tutorialState.stage, ')');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'healer_heal';
upd();
render();
showTutorialPop('ribbleton_healer_heal', "Oh gosh - looks like both of you took some damage. Healer can help with that - click the Heal sigil! You can pick which order your heroes take their actions.", () => {
S.activeIdx = 1;
render();
});
} else if(round === 2 && !S.tutorialFlags.ribbleton_healer_heal) {
console.log('[TUTORIAL] Round 2 but stage is:', tutorialState.stage, '(expected: enemy_turn_explained or finish_wolf) - forcing healer_heal anyway');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'healer_heal';
upd();
render();
showTutorialPop('ribbleton_healer_heal', "Oh gosh - looks like both of you took some damage. Healer can help with that - click the Heal sigil! You can pick which order your heroes take their actions.", () => {
S.activeIdx = 1;
render();
});
}
// Round 3: Force Goblin to draw Shield, then PROMPT 9 + 10
else if(round === 3 && tutorialState.stage === 'finish_wolf') {
// Force Goblin to draw Shield
const goblin = S.enemies.find(e => e.n === 'Goblin');
if(goblin && !goblin.s.some(s => s.sig === 'Shield')) {
goblin.s.push({sig:'Shield', level:1, perm:false});
toast('Goblin drew Shield L1!');
}
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'shield_sigil';
upd();
render();
// First show that enemies can get sigils
showTutorialPop('enemies_get_sigils', "Enemies can draw sigils too! They draw from a pool specific to their type, and gain sigils over time.", () => {
// Then explain this specific sigil
showTutorialPop('ribbleton_shield_sigil', "The Goblin has drawn a Shield sigil! Enemies use their sigils AFTER they attack, then those sigils fall off. Try to finish him before he can Shield up!", () => {
// PROMPT 10: Handoff
showTutorialPop('ribbleton_handoff', "You're on your own now - good luck!", () => {
tutorialState.stage = 'free';
render();
});
});
});
}
},

// Handle enemy turn during tutorial
onEnemyTurnStart() {
if(!tutorialState || S.floor !== 0) return;
if(tutorialState.stage === 'enemy_turn_wait') {
S.locked = true;
tutorialState.stage = 'enemy_turn_explained';
showTutorialPop('ribbleton_enemy_turn', "Uh oh! Enemies attack every turn, and they attack straight across from them!", () => {
S.locked = false;
});
}
}
};

// Tutorial system
let tooltipTimeout = null;
let currentTooltip = null;

function showTooltip(sigilName, element) {
// Tooltip display (tutorial explanation happens in Ribbleton combat)

const desc = SIGIL_DESCRIPTIONS[sigilName];
if(!desc) return;

hideTooltip();

const tooltip = document.createElement('div');
tooltip.className = 'tooltip';
tooltip.innerHTML = `
<div class="tooltip-title">${sigilIcon(sigilName)}</div>
<div class="tooltip-desc">${desc}</div>`;

document.body.appendChild(tooltip);
currentTooltip = tooltip;

// Position tooltip near the element
const rect = element.getBoundingClientRect();
const tooltipRect = tooltip.getBoundingClientRect();
let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
let top = rect.top - tooltipRect.height - 10;

// Keep tooltip on screen
if(left < 10) left = 10;
if(left + tooltipRect.width > window.innerWidth - 10) left = window.innerWidth - tooltipRect.width - 10;
if(top < 10) top = rect.bottom + 10;

tooltip.style.left = left + 'px';
tooltip.style.top = top + 'px';

setTimeout(() => tooltip.classList.add('show'), 10);
}

function hideTooltip() {
if(currentTooltip) {
currentTooltip.classList.remove('show');
setTimeout(() => {
if(currentTooltip) {
currentTooltip.remove();
currentTooltip = null;
}
}, 200);
}
if(tooltipTimeout) {
clearTimeout(tooltipTimeout);
tooltipTimeout = null;
}
}

function generateFibonacci(n) {
const fib = [1, 1];
for(let i = 2; i < n; i++) fib.push(fib[i-1] + fib[i-2]);
return fib;
}
const FIB = generateFibonacci(50);

// ===== GAME STATE =====
let S = {
floor: 1,
round: 1,
turn: 'player',
gold: 0,
xp: 0,
levelUpCount: 0,
heroes: [],
enemies: [],
recruits: [], // Recruited enemies fighting for player
sig: {Attack:1, Shield:1, Heal:1, D20:1, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
sigUpgradeCounts: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
goingRate: 1,
startingXP: 0, // Bonus XP at start of each run (from Death Boy 2 sacrifices)
pedestal: [], // Array of {hero:'Warrior', stat:'POW'|'HP', mode:'Standard'|'Effed'}
hasAncientStatuette: false,
gameMode: 'Standard', // 'Standard' or 'Effed'
effedUnlocked: false,
tapoUnlocked: false, // Unlocked after first FU victory
debugMode: false, // Debug mode toggle
// Toast log
toastHistory: [], // Recent toast messages
toastLogExpanded: false, // Toast log expanded state
toastLogVisible: false, // Toast log visibility toggle
// Turn management
activeIdx: -1,
acted: [],
locked: false,
// Action state
pending: null,
targets: [],
currentInstanceTargets: [],
instancesRemaining: 0,
// Asterisk state
asteriskPrimed: false,
asteriskMultiplier: 1,
asteriskUsedThisCombat: false,
lastActions: {},
// Neutral encounter state
neutralDeck: [],
lastNeutral: null,
ambushed: false,
// Persistent neutral state (survives death - saved in savePermanent/loadPermanent)
ancientStatueDeactivated: false,
ghostBoysConverted: false,
// Temporary neutral state (resets on death - NOT saved)
silverKeyHeld: false,
oracleHero: null,
oracleRoll: null,
oracleStat: null,
wizardSigil: null,
princeGender: 'Prince',
treasureSecretCompartment: false,
// Run tracking (permanent)
runNumber: 1,
// Tutorial flags (permanent - shown once ever)
tutorialFlags: {
ribbleton_intro: false,
ribbleton_warrior_attack: false,
ribbleton_targeting: false,
ribbleton_healer_d20: false,
ribbleton_d20_menu: false,
ribbleton_enemy_turn: false,
ribbleton_healer_heal: false,
ribbleton_expand: false,
ribbleton_finish_wolf: false,
enemies_get_sigils: false,
ribbleton_shield_sigil: false,
ribbleton_handoff: false,
ribbleton_tooltip_intro: false,
levelup_intro: false,
levelup_stat_upgrade: false,
levelup_add_active: false,
levelup_upgrade_active: false,
levelup_upgrade_passive: false,
death_intro: false,
death_exit_warning: false,
neutral_intro: false,
neutral_d20_level: false,
last_stand_intro: false,
run2_hero_lock: false,
first_victory_sequence: false,
first_fu_victory: false,
pedestal_first_placement: false,
tapo_victory_message: false
},
helpTipsDisabled: false,
usedDeathQuotes: [] // Track which death quotes have been shown
};

let sel = [];

// ===== RIBBLETON TUTORIAL STATE =====
let tutorialState = null;
// Tutorial state tracks scripted Ribbleton tutorial progress
// {
//   stage: 'warrior_attack' | 'targeting_wolf' | 'healer_d20' | 'd20_menu' | 'enemy_turn_explained' |
//          'healer_heal' | 'expand_targets' | 'finish_wolf' | 'shield_sigil' | 'handoff' | 'free',
//   wolfDamaged: boolean,
//   wolfKilled: boolean,
//   goblinKilled: boolean,
//   round: number
// }

// ===== HELPERS =====
function getFloorBackground(floor) {
// Progressive darkening from floor 1 (light brown) to floor 19 (black)
const colors = [
'#d9cab1', // Floor 1 - light brown (default)
'#cfc0a9', '#c5b6a1', '#bbac99', '#b1a291', '#a79889', // Floors 2-6
'#9d8e81', '#938479', '#897a71', '#7f7069', '#756661', // Floors 7-11
'#6b5c59', '#615251', '#574849', '#4d3e41', '#433439', // Floors 12-16
'#392a31', '#2f2029', '#251621', '#1b0c19' // Floors 17-20
];
return colors[Math.min(floor - 1, colors.length - 1)] || colors[0];
}

function renderHeroCard(hero, idx, onclickHandler, extraInfo = '') {
const hp = hero.ls ? `Last Stand (T${hero.lst+1})` : `${hero.h}/${hero.m}‚ù§`;
const extra = [];
if(hero.sh > 0) extra.push(`${hero.sh}üõ°`);
if(hero.g > 0) extra.push(`${hero.g}${sigilIconOnly('Ghost')}`);
return `<div class="card hero" onclick="${onclickHandler}" style="cursor:pointer;margin-bottom:0.75rem;transition:transform 0.1s,box-shadow 0.1s" onmouseover="this.style.transform='scale(1.02)';this.style.boxShadow='0 4px 12px rgba(0,0,0,0.3)'" onmouseout="this.style.transform='';this.style.boxShadow=''">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${hero.n}</div>
<div style="text-align:center;font-size:0.8rem">${hero.p}‚ö° | ${hp}${extra.length>0?' | '+extra.join(' '):''}${extraInfo}</div>
</div>`;
}

function upd() {
document.getElementById('floor').textContent = S.floor;
document.getElementById('round').textContent = S.round || '-';
document.getElementById('gold').textContent = S.gold;
// Show combat XP during combat, cumulative XP otherwise
if(S.combatXP !== undefined && S.combatXP > 0) {
document.getElementById('xp').textContent = `${S.xp} (+${S.combatXP})`;
} else {
document.getElementById('xp').textContent = S.xp;
}
// Show/hide debug button
const debugBtn = document.getElementById('debugBtn');
if(debugBtn) debugBtn.style.display = S.debugMode ? 'block' : 'none';
// Update background color based on floor
const gameArea = document.getElementById('gameView');
if(gameArea) gameArea.style.background = getFloorBackground(S.floor);
}

function triggerHitAnimation(targetId) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('hit-flash');
setTimeout(() => card.classList.remove('hit-flash'), 400);
}
}

function triggerAttackAnimation(attackerId) {
const card = document.getElementById(attackerId);
if(card) {
card.classList.add('attack-slide');
setTimeout(() => card.classList.remove('attack-slide'), 500);
}
}

function triggerHealAnimation(targetId) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('heal-flash');
// Add healing cross overlay
const cross = document.createElement('div');
cross.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:3rem;color:#22c55e;text-shadow:0 0 10px #22c55e;pointer-events:none;z-index:1000;animation:heal-cross-fade 0.5s ease';
cross.textContent = '‚úö';
card.style.position = 'relative';
card.appendChild(cross);
setTimeout(() => {
card.classList.remove('heal-flash');
if(cross.parentNode) cross.remove();
}, 500);
}
}

function triggerShieldAnimation(targetId) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('shield-flash');
setTimeout(() => card.classList.remove('shield-flash'), 500);
}
}

function toast(msg, dur=1200) {
// Add to history
S.toastHistory.unshift(msg);
if(S.toastHistory.length > 20) S.toastHistory = S.toastHistory.slice(0, 20); // Keep last 20
updateToastLog();
// Show toast popup
const t = document.createElement('div');
t.className = 'toast';
t.textContent = msg;
document.body.appendChild(t);
setTimeout(() => t.classList.add('show'), 10);
setTimeout(() => {
t.classList.remove('show');
setTimeout(() => t.remove(), 300);
}, dur);
}

function initToastLog() {
const existing = document.getElementById('toastLog');
if(existing) return;
const log = document.createElement('div');
log.id = 'toastLog';
log.className = 'toast-log minimized';
log.style.display = S.toastLogVisible ? 'block' : 'none';
log.onclick = (e) => {
if(e.target.closest('.toast-log-header')) toggleToastLog();
};
document.body.appendChild(log);
updateToastLog();
}

function toggleToastLog() {
S.toastLogExpanded = !S.toastLogExpanded;
updateToastLog();
}

function toggleToastLogVisibility(visible) {
S.toastLogVisible = visible;
const log = document.getElementById('toastLog');
if(log) {
log.style.display = visible ? 'block' : 'none';
}
}

function updateToastLog() {
const log = document.getElementById('toastLog');
if(!log) return;
const mostRecent = S.toastHistory[0] || 'No messages yet';
log.className = S.toastLogExpanded ? 'toast-log' : 'toast-log minimized';
let html = `<div class="toast-log-header">
<span>üìú Log</span>
<span class="toast-log-toggle">${S.toastLogExpanded ? '‚ñº' : '‚ñ≤'}</span>
</div>`;
if(S.toastLogExpanded) {
html += '<div class="toast-log-entries">';
S.toastHistory.forEach((msg, idx) => {
html += `<div class="toast-log-entry ${idx === 0 ? 'recent' : ''}">${msg}</div>`;
});
if(S.toastHistory.length === 0) {
html += '<div class="toast-log-entry">No messages yet</div>';
}
html += '</div>';
} else {
html += `<div class="toast-log-entry recent">${mostRecent}</div>`;
}
log.innerHTML = html;
}

function showTutorialPop(flagName, message, onDismiss) {
console.log('[TUTORIAL] showTutorialPop called:', flagName, 'Already shown:', S.tutorialFlags[flagName]);
if(S.helpTipsDisabled || S.tutorialFlags[flagName]) {
console.log('[TUTORIAL] Skipping pop (disabled or already shown), calling callback directly');
if(onDismiss) onDismiss();
return;
}
// Create blocking modal
const backdrop = document.createElement('div');
backdrop.className = 'tutorial-modal-backdrop';
backdrop.innerHTML = `
<div class="tutorial-modal">
<h2>Tutorial</h2>
<p>${message}</p>
<button onclick="dismissTutorialPop('${flagName}')">Got it!</button>
</div>`;
document.body.appendChild(backdrop);
console.log('[TUTORIAL] Backdrop created and appended, total backdrops now:', document.querySelectorAll('.tutorial-modal-backdrop').length);
// Store callback for later
window.tutorialCallback = onDismiss;
}

function dismissTutorialPop(flagName) {
console.log('[TUTORIAL] dismissTutorialPop called:', flagName);
console.log('[TUTORIAL] Backdrops BEFORE removal:', document.querySelectorAll('.tutorial-modal-backdrop').length);
S.tutorialFlags[flagName] = true;
savePermanent();

// Remove ALL backdrops aggressively
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Removing', allBackdrops.length, 'backdrops');
allBackdrops.forEach((b, i) => {
console.log('[TUTORIAL] Removing backdrop', i);
b.remove();
});

// Verify it's gone
setTimeout(() => {
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Backdrops remaining after pop dismiss:', remaining.length);
if(remaining.length > 0) {
console.error('[TUTORIAL] ERROR: Backdrops still blocking!', remaining);
remaining.forEach(r => {
console.error('[TUTORIAL] Zombie backdrop:', r);
r.remove();
});
}

console.log('[TUTORIAL] About to call onDismiss callback');
if(window.tutorialCallback) {
console.log('[TUTORIAL] Calling onDismiss callback NOW');
window.tutorialCallback();
window.tutorialCallback = null;
} else {
console.warn('[TUTORIAL] No callback found!');
}
}, 50);
}

function savePermanent() {
localStorage.setItem('froggle8_permanent', JSON.stringify({
gold: S.gold,
goingRate: S.goingRate,
startingXP: S.startingXP,
sig: S.sig,
sigUpgradeCounts: S.sigUpgradeCounts,
ancientStatueDeactivated: S.ancientStatueDeactivated,
ghostBoysConverted: S.ghostBoysConverted,
hasAncientStatuette: S.hasAncientStatuette,
pedestal: S.pedestal,
effedUnlocked: S.effedUnlocked,
tapoUnlocked: S.tapoUnlocked,
runNumber: S.runNumber,
tutorialFlags: S.tutorialFlags,
helpTipsDisabled: S.helpTipsDisabled,
usedDeathQuotes: S.usedDeathQuotes
}));
}

function loadPermanent() {
const d = localStorage.getItem('froggle8_permanent');
if(!d) return;
const j = JSON.parse(d);
S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:1, Shield:1, Heal:1, D20:1, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.hasAncientStatuette = j.hasAncientStatuette || false;
S.pedestal = j.pedestal || [];
S.effedUnlocked = j.effedUnlocked || false;
S.tapoUnlocked = j.tapoUnlocked || false;
S.runNumber = j.runNumber || 1;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
if(j.tutorialFlags) {
Object.assign(S.tutorialFlags, j.tutorialFlags);
}
}

function saveGame() {
localStorage.setItem('froggle8', JSON.stringify({
f:S.floor, x:S.xp, luc:S.levelUpCount,
h:S.heroes,
neutralDeck:S.neutralDeck, lastNeutral:S.lastNeutral
}));
savePermanent();
}

function loadGame() {
loadPermanent(); // Load persistent data first
const d = localStorage.getItem('froggle8');
if(!d) return;
const j = JSON.parse(d);
S.floor=j.f; S.xp=j.x; S.levelUpCount=j.luc || 0;
S.heroes=j.h;
S.neutralDeck=j.neutralDeck || [];
S.lastNeutral=j.lastNeutral || null;
S.heroes.forEach(h => { if(!h.ts) h.ts = []; });
upd();
startFloor(S.floor);
toast('Loaded!');
}

// ===== NEUTRAL DECK SYSTEM =====
function initNeutralDeck() {
S.neutralDeck = [
'shopkeeper1', 'wishingwell1', 'treasurechest1',
'wizard1', 'oracle1', 'encampment1',
'statue1', 'ghost1', 'prince1'
];
S.lastNeutral = null;
}

function getNeutralEncounter() {
if(S.neutralDeck.length === 0) {
initNeutralDeck();
}

// TUTORIAL: Floor 2 always gets Oracle Stage 1
if(S.floor === 2 && !S.tutorialFlags.neutral_intro) {
return 'oracle1';
}

// Level 18: Prioritize Stage 2s
if(S.floor === 18) {
const stage2s = S.neutralDeck.filter(n => n.includes('2'));
if(stage2s.length > 0) {
const pick = stage2s[Math.floor(Math.random() * stage2s.length)];
return pick;
}
}

// Filter out last neutral for back-to-back prevention
let available = S.neutralDeck;
if(S.lastNeutral) {
const base = S.lastNeutral.replace(/[12]$/, '');
available = available.filter(n => !n.startsWith(base));
}

// Floor 10: NEVER allow Enemy Encampment (Floor 11 is always ambush)
if(S.floor === 10) {
available = available.filter(n => !n.startsWith('encampment'));
}

if(available.length === 0) {
available = S.neutralDeck;
}

const pick = available[Math.floor(Math.random() * available.length)];
S.lastNeutral = pick;
return pick;
}

function removeNeutralFromDeck(base) {
S.neutralDeck = S.neutralDeck.filter(n => !n.startsWith(base));
}

function replaceStage1WithStage2(base) {
S.neutralDeck = S.neutralDeck.filter(n => n !== `${base}1`);
S.neutralDeck.push(`${base}2`);
}

// ===== D20 ROLLS FOR NEUTRALS =====
function rollD20Neutral() {
const d20Level = S.sig.D20 || 1;
// TUTORIAL: Explain D20 level affects neutral rolls
showTutorialPop('neutral_d20_level', "This D20 roll uses the same Level as your D20 sigil in combat - so you can up your chances of success in neutral rooms by leveling up that Sigil!");
return rollDice(d20Level, 20);
}

function showD20Result(rolls, best) {
return `Rolling ${rolls.length}d20: [${rolls.join('] [')}] ‚Üí Highest: ${best}`;
}

function buildNeutralHTML(options) {
const {
bgImage,
title,
description,
outcomes = [],
diceRoll = '',
buttons = '',
showStats = true
} = options;

let html = `<div class="neutral-container" style="background-image: url('${bgImage}')">`;

// Header with stats and narrative
html += '<div class="neutral-header">';
if(showStats) {
html += `<div class="neutral-stats">üí∞ ${S.gold}G | üéØ Floor ${S.floor}</div>`;
}
html += '<div class="neutral-narrative">';
if(title) html += `<div class="neutral-title">${title}</div>`;
if(description) html += `<div class="neutral-desc">${description}</div>`;
if(diceRoll) html += `<div class="dice-roll">${diceRoll}</div>`;
outcomes.forEach(outcome => {
if(outcome) html += `<div class="neutral-outcome">${outcome}</div>`;
});
html += '</div></div>'; // close narrative and header

// Spacer for art
html += '<div style="flex:1"></div>';

// Footer with buttons
if(buttons) {
html += `<div class="neutral-footer">${buttons}</div>`;
}

html += '</div>';
return html;
}

// ===== MAIN TITLE PAGE =====
function mainTitlePage() {
console.log('[FROGGLE] mainTitlePage START');
// Hide game header on title screen
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'none';

const v = document.getElementById('gameView');
console.log('[FROGGLE] gameView element:', v);
const hasSavedGame = localStorage.getItem('froggle8');
console.log('[FROGGLE] hasSavedGame:', hasSavedGame ? 'YES' : 'NO');
v.innerHTML = `
<div style="min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#1a1a1a;padding:1rem;overflow-y:auto">
<!-- Green mat container -->
<div style="background:#22c55e;border:4px solid #000;border-radius:12px;padding:1.5rem;max-width:600px;width:90%;box-shadow:0 8px 16px rgba(0,0,0,0.5)">
<!-- Title image with version label -->
<div style="position:relative;margin-bottom:1.5rem">
<img src="assets/title-screen.png" style="width:100%;height:auto;border-radius:8px;border:3px solid #000;display:block;box-shadow:0 4px 8px rgba(0,0,0,0.3)">
<div style="position:absolute;top:0.3rem;right:0.3rem;background:rgba(0,0,0,0.85);padding:0.25rem 0.5rem;border-radius:6px;border:2px solid rgba(251,191,36,0.7)">
<p style="font-size:0.7rem;color:#fbbf24;font-weight:bold;text-align:right;margin:0">v${GAME_VERSION}</p>
</div>
</div>

<!-- Buttons on green mat -->
<div style="display:flex;gap:0.5rem;width:100%">
<!-- New Game: half width -->
<button class="btn" onclick="newGame()" style="flex:1;font-size:1rem;padding:0.75rem;background:#fbbf24;border:3px solid #f59e0b;font-weight:bold">üê∏ New Game üê∏</button>

<!-- Right side: Load button -->
${hasSavedGame ? `<button class="btn" onclick="loadGameFromTitle()" style="flex:1;font-size:0.9rem;padding:0.75rem;background:#2c63c7;border:3px solid #1e40af;font-weight:bold">üíæ Load Game</button>` : ''}
</div>
</div>
</div>`;
}

function newGame() {
// Reset runNumber to 1 for new game (allows tutorial to show)
S.runNumber = 1;
console.log('[FROGGLE] newGame called - runNumber:', S.runNumber, 'helpTipsDisabled:', S.helpTipsDisabled);
if(S.runNumber === 1 && !S.helpTipsDisabled) {
console.log('[FROGGLE] Showing tutorial story');
showTutorialStory();
} else {
console.log('[FROGGLE] Skipping tutorial, going to title()');
title();
}
}

function loadGameFromTitle() {
const s = localStorage.getItem('froggle8');
if(s) {
loadGame();
} else {
toast('No saved game found!');
}
}

function exitGame() {
if(confirm('Thanks for playing FROGGLE! Close the window to exit.')) {
window.close();
}
}

function exportSave() {
const saveData = localStorage.getItem('froggle8');
const permanentData = localStorage.getItem('froggle8_permanent');
if(!saveData && !permanentData) {
toast('No save data to export!');
return;
}
const exportData = {
save: saveData ? JSON.parse(saveData) : null,
permanent: permanentData ? JSON.parse(permanentData) : null,
exportDate: new Date().toISOString(),
version: GAME_VERSION
};
const dataStr = JSON.stringify(exportData, null, 2);
const blob = new Blob([dataStr], {type: 'application/json'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `froggle-save-${new Date().toISOString().split('T')[0]}.json`;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);
toast('Save exported!');
}

function importSave() {
const input = document.createElement('input');
input.type = 'file';
input.accept = '.json';
input.onchange = (e) => {
const file = e.target.files[0];
if(!file) return;
const reader = new FileReader();
reader.onload = (event) => {
try {
const importData = JSON.parse(event.target.result);
if(importData.save) {
localStorage.setItem('froggle8', JSON.stringify(importData.save));
}
if(importData.permanent) {
localStorage.setItem('froggle8_permanent', JSON.stringify(importData.permanent));
}
toast('Save imported successfully!');
setTimeout(() => {
mainTitlePage();
}, 1000);
} catch(err) {
toast('Error: Invalid save file!');
console.error('Import error:', err);
}
};
reader.readAsText(file);
};
input.click();
}

// ===== NARRATIVE SLIDE SYSTEM =====
function showNarrativeSlide(slides, currentIndex = 0) {
console.log('[FROGGLE] showNarrativeSlide called - currentIndex:', currentIndex, 'total slides:', slides.length);
if(currentIndex >= slides.length) {
// All slides shown, call completion callback
console.log('[FROGGLE] All slides complete, calling onComplete');
if(slides.onComplete) slides.onComplete();
return;
}

const slide = slides[currentIndex];
console.log('[FROGGLE] Rendering slide', currentIndex);
const v = document.getElementById('gameView');
console.log('[FROGGLE] gameView element:', v);
const skipButton = slides.skippable ? `<button class="btn" onclick="skipTutorialFromSlide()" style="padding:0.75rem 2rem;background:#888;margin-left:1rem">Skip Tutorial</button>` : '';
console.log('[FROGGLE] Setting innerHTML for slide', currentIndex);
v.innerHTML = `
<div style="max-width:600px;margin:2rem auto;padding:1rem">
${slide.html || `<div style="font-size:1.1rem;line-height:1.8;margin-bottom:2rem;text-align:center">${slide.text}</div>`}
<div style="text-align:center;display:flex;gap:1rem;justify-content:center;flex-wrap:wrap">
<button class="btn" onclick="continueNarrative()" style="padding:0.75rem 2rem">${slide.buttonText || 'Continue'}</button>
${skipButton}
</div>
</div>`;

window.currentNarrativeSlides = slides;
window.currentNarrativeIndex = currentIndex;
console.log('[FROGGLE] Slide', currentIndex, 'rendered successfully');
}

function continueNarrative() {
const slides = window.currentNarrativeSlides;
const nextIndex = window.currentNarrativeIndex + 1;
showNarrativeSlide(slides, nextIndex);
}

function skipTutorialFromSlide() {
// Skip to hero selection (Help/Tips remain ON by default)
toast('Tutorial skipped! Going to hero selection...', 1200);
setTimeout(() => title(), 500);
}

// ===== RIBBLETON TUTORIAL INTRO =====
function showTutorialStory() {
console.log('[FROGGLE] showTutorialStory START');
const slides = [
{
html: `
<div style="text-align:center">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#22c55e">Tapo's First Birthday!</h2>
<div style="margin:1.5rem 0">
<img src="assets/tapo.png" style="max-width:250px;height:auto;border-radius:12px;border:3px solid #fbbf24;box-shadow:0 8px 16px rgba(0,0,0,0.2);animation:tapoBounce 4s ease-in-out infinite">
</div>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
Today is <strong>Tapo the Tadpole's first birthday!</strong> üéâ
</p>
</div>
<style>
@keyframes tapoBounce {
0%, 100% { transform: translateY(0) scaleX(1); }
25% { transform: translateY(-20px) scaleX(1); }
50% { transform: translateY(0) scaleX(-1); }
75% { transform: translateY(-20px) scaleX(-1); }
}
</style>
`
},
{
html: `
<div style="text-align:center">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#22c55e">Ribbleton's Defenders</h2>
<div style="margin:1.5rem 0">
<img src="assets/tapo.png" style="max-width:200px;height:auto;border-radius:12px;border:3px solid #fbbf24;box-shadow:0 8px 16px rgba(0,0,0,0.2);animation:bounce 2s ease-in-out infinite">
</div>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
Ribbletonians gathered around little Tapo as he blew out the candles on his birthday cake.<br>
<strong>Ribbleton's 4 greatest warriors stood guard over the celebrations...</strong>
</p>
<div style="display:flex;justify-content:center;gap:1rem;margin:1.5rem 0;flex-wrap:wrap">
<div style="animation:partyFlip 2.5s ease-in-out infinite"><img src="warriorfull.png" style="width:120px;height:auto;border-radius:8px;border:2px solid #fbbf24;box-shadow:0 4px 8px rgba(0,0,0,0.2)"></div>
<div style="animation:partyFlip 3s ease-in-out infinite"><img src="tankfull.png" style="width:120px;height:auto;border-radius:8px;border:2px solid #fbbf24;box-shadow:0 4px 8px rgba(0,0,0,0.2)"></div>
<div style="animation:partyFlip 2s ease-in-out infinite"><img src="magefull.png" style="width:120px;height:auto;border-radius:8px;border:2px solid #fbbf24;box-shadow:0 4px 8px rgba(0,0,0,0.2)"></div>
<div style="animation:partyFlip 3.5s ease-in-out infinite"><img src="healerfull.png" style="width:120px;height:auto;border-radius:8px;border:2px solid #fbbf24;box-shadow:0 4px 8px rgba(0,0,0,0.2)"></div>
</div>
</div>
<style>
@keyframes bounce {
0%, 100% { transform: translateY(0) scale(1); }
50% { transform: translateY(-20px) scale(1.05); }
}
@keyframes partyFlip {
0%, 100% { transform: scaleX(1) rotate(0deg); }
50% { transform: scaleX(-1) rotate(10deg); }
}
</style>
`
},
{
html: `
<div style="text-align:center">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#dc2626;animation:shake 0.5s ease-in-out infinite">DANGER!</h2>
<div style="margin:1.5rem 0;position:relative">
<div style="width:200px;height:200px;margin:0 auto;position:relative;border-radius:50%;background:radial-gradient(circle, #dc2626, #7c2d12);animation:portalPulse 1s ease-in-out infinite;box-shadow:0 0 40px #dc2626"></div>
<div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:4rem;animation:spin 2s linear infinite">üåÄ</div>
</div>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
Suddenly, <strong>a dark portal</strong> tore open in Ribbleton's square!<br>
Strange, dangerous enemies began to emerge...
</p>
<div style="display:flex;justify-content:center;gap:2rem;margin:1.5rem 0;font-size:3rem">
<div style="animation:enemyAppear 1s ease-out">üë∫</div>
<div style="animation:enemyAppear 1.3s ease-out">üê∫</div>
</div>
</div>
<style>
@keyframes shake {
0%, 100% { transform: translateX(0); }
25% { transform: translateX(-5px); }
75% { transform: translateX(5px); }
}
@keyframes portalPulse {
0%, 100% { transform: scale(1); opacity: 0.8; }
50% { transform: scale(1.1); opacity: 1; }
}
@keyframes spin {
from { transform: translate(-50%, -50%) rotate(0deg); }
to { transform: translate(-50%, -50%) rotate(360deg); }
}
@keyframes enemyAppear {
from { transform: scale(0) rotate(-180deg); opacity: 0; }
to { transform: scale(1) rotate(0deg); opacity: 1; }
}
</style>
`
}
];
slides.skippable = true; // Make tutorial skippable
slides.onComplete = () => {
// Start combat FIRST so enemies are visible
startRibbletonTutorial();

// Then show narrative overlay describing what's happening
setTimeout(() => {
showTutorialStoryOverlay();
}, 100);
};
console.log('[FROGGLE] About to call showNarrativeSlide with', slides.length, 'slides');
showNarrativeSlide(slides, 0);
console.log('[FROGGLE] showNarrativeSlide called');
}

function showTutorialStoryOverlay() {
// Show narrative on TOP of combat screen
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:550px">
<p style="font-size:1.1rem;line-height:1.6;margin-bottom:1.5rem">
A Goblin and a Wolf have appeared from the portal!
</p>
<div style="display:grid;grid-template-columns:1fr auto 1fr;gap:1.5rem;align-items:center;margin:1.5rem 0">
<div style="display:flex;gap:0.5rem;align-items:center;justify-content:center">
<div style="animation:defensiveStance 1.5s ease-in-out infinite">
<img src="tankfull.png" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem">üõ° On Guard!</div>
</div>
<div style="text-align:center">
<img src="assets/tapo.png" style="width:60px;height:auto;border-radius:6px;border:2px solid #000">
<div style="font-size:0.65rem;opacity:0.7;margin-top:0.25rem">Protected!</div>
</div>
<div style="animation:defensiveStance 1.3s ease-in-out infinite">
<img src="magefull.png" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem">üìñ On Guard!</div>
</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.75rem;align-items:center;font-size:2.5rem">
<div style="animation:enemyThreat 1s ease-in-out infinite">üë∫</div>
<div style="animation:enemyThreat 1.2s ease-in-out infinite">üê∫</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.5rem;align-items:center">
<div style="animation:chargeForward 0.8s ease-out infinite alternate">
<img src="warriorfull.png" style="width:80px;height:auto;border-radius:6px;border:2px solid #fbbf24;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem">‚öîÔ∏è Attacking!</div>
</div>
<div style="animation:chargeForward 1s ease-out infinite alternate">
<img src="healerfull.png" style="width:80px;height:auto;border-radius:6px;border:2px solid #fbbf24;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem">‚úö Attacking!</div>
</div>
</div>
</div>
<p style="font-size:1rem;line-height:1.6;text-align:center;font-style:italic;opacity:0.9">
Tank and Mage stand guard around Tapo while Warrior and Healer charge toward the portal!
</p>
<div style="margin-top:1.5rem;display:flex;gap:1rem;justify-content:center;flex-wrap:wrap">
<button onclick="dismissStoryOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer">Let's fight!</button>
<button onclick="skipTutorialFromOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#888;color:#fff;border:2px solid #666;border-radius:8px;cursor:pointer">Skip Tutorial</button>
</div>
</div>
<style>
@keyframes chargeForward {
0% { transform: translateX(0) scale(1); }
100% { transform: translateX(15px) scale(1.05); }
}
@keyframes defensiveStance {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(-5px); }
}
@keyframes enemyThreat {
0%, 100% { transform: scale(1) rotate(0deg); }
50% { transform: scale(1.2) rotate(10deg); }
}
</style>`;
document.body.appendChild(overlay);
}

function dismissStoryOverlay() {
console.log('[TUTORIAL] Dismissing story overlay');
// Remove ALL backdrops before showing the tutorial pop
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Found', allBackdrops.length, 'backdrops to remove');
allBackdrops.forEach((backdrop, idx) => {
console.log('[TUTORIAL] Removing backdrop', idx);
backdrop.remove();
});

// Double-check they're gone
setTimeout(() => {
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Remaining overlays after dismiss:', remaining.length);
if(remaining.length > 0) {
console.error('[TUTORIAL] ERROR: Still have backdrops!', remaining);
remaining.forEach(r => r.remove());
}

// PROMPT 1: Warrior Attack
showTutorialPop('ribbleton_warrior_attack', "Quick! Attack an enemy! Click on Warrior's Attack sigil.", () => {
console.log('[TUTORIAL] Prompt 1 dismissed - transitioning to warrior_attack stage');
tutorialState.stage = 'warrior_attack';
S.activeIdx = 0;
console.log('[TUTORIAL] S.activeIdx is now:', S.activeIdx);
render();
});
}, 50);
}

function skipTutorialFromOverlay() {
const overlay = document.querySelector('.tutorial-modal-backdrop');
if(overlay) overlay.remove();
// Skip to hero selection (Help/Tips remain ON by default)
toast('Tutorial skipped! Going to hero selection...', 1200);
setTimeout(() => title(), 500);
}

function skipTutorial() {
// This function is for legacy "skip tutorial" - just go to title
toast('Going to hero selection...');
title();
}

// ===== RIBBLETON TUTORIAL =====
function startRibbletonTutorial() {
// Set up tutorial heroes
S.floor = 0; // Special floor 0 for tutorial
// NOTE: Gold persists! Don't reset it here
S.xp = 0;
S.levelUpCount = 0;
S.heroes = [
{id:'h_tutorial_warrior', n:'Warrior', p:2, h:5, m:5, s:['Attack','D20'], sh:0, g:0, ls:false, lst:0, ts:[], st:0},
{id:'h_tutorial_healer', n:'Healer', p:1, h:5, m:5, s:['Heal','D20','Expand'], sh:0, g:0, ls:false, lst:0, ts:[], st:0}
];

// Initialize tutorial state
tutorialState = {
stage: 'waiting_for_start', // Will transition to 'warrior_attack' after overlay dismissal
wolfDamaged: false,
wolfKilled: false,
goblinKilled: false,
round: 1
};

// Start combat using real combat system!
combat(0);
}


function finishRibbletonTutorial() {
// Post-combat narrative
const slides = [
{text: "The few enemies remaining around Ribbleton scampered back into the portal from whence they came. Relieved, and sheathing their weapons, the frog heroes assembled to try to pick up the string of their failed party - but Tapo was missing!!"},
{text: "As the Ribbletonians looked high and low, our heroes realized there was only one possibility - the poor tadpole had squiggled his way through!"},
{text: "Without a thought for their lives, the brave heroes dove into the swirling darkness..."}
];
slides.onComplete = showTitleCard;
showNarrativeSlide(slides, 0);
}

function showTitleCard() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:#000;display:flex;align-items:center;justify-content:center;z-index:30000">
<div style="text-align:center;color:#fff">
<div style="font-size:3rem;font-weight:bold;margin-bottom:1rem">FROGGLE</div>
<div style="font-size:1.5rem;font-style:italic">A Froggy Roguelike</div>
</div>
</div>`;

setTimeout(() => {
tutorialState = null;
title(); // Go to hero select (which will auto-select Warrior + Healer for Run 1)
}, 5500);
}

// ===== TITLE & HERO SELECT =====
let selectedHeroView = null; // Track which hero card is currently displayed

function title() {
console.log('[FROGGLE] title() called - Hero selection screen');
// Reset selection first
sel = [];
// TUTORIAL: Run 1 selects Warrior + Healer after hero select screen
const isRun1 = S.runNumber === 1;
if(isRun1 && !S.helpTipsDisabled) {
// Auto-select for tutorial but show the screen
console.log('[FROGGLE] Auto-selecting Warrior + Healer for tutorial');
sel = ['warrior', 'healer'];
}

const v = document.getElementById('gameView');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;

v.innerHTML = `
<h1 style="text-align:center;margin:2rem 0;font-size:2rem">FROGGLE üê∏</h1>
<p style="text-align:center;margin-bottom:0.5rem;font-size:0.9rem">v9.97</p>
<p style="text-align:center;margin-bottom:1rem;font-size:1.1rem;font-weight:bold">Mode: <span style="color:${S.gameMode === 'Effed' ? '#dc2626' : '#22c55e'}">${S.gameMode === 'Standard' ? 'Standard' : 'EFFED UP üî•'}</span></p>
${S.effedUnlocked ? `<div style="text-align:center;margin-bottom:1rem">
<button class="btn" onclick="showChampionsMenu()" style="padding:0.75rem 1.5rem;background:linear-gradient(135deg,#fbbf24,#f59e0b);font-weight:bold">
üèÜ Champions of Floor 20 üèÜ
</button></div>` : ''}

<div style="max-width:600px;margin:0 auto">
<h2 style="text-align:center;margin-bottom:1rem;font-size:1.3rem">Choose 2 Heroes</h2>
<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem;opacity:0.7">Tap a hero to select!</p>
<div style="position:relative;max-width:100%;margin:0 auto">
<img src="assets/hero-select.png" style="width:100%;height:auto;display:block;border-radius:8px;border:3px solid #000">
<!-- Clickable overlay regions for each hero (4 equal sections) -->
<div style="position:absolute;top:0;left:0;width:25%;height:100%;cursor:pointer;z-index:20;"
onclick="toggleHeroSelection('warrior')"
title="Warrior"></div>
<div style="position:absolute;top:0;left:25%;width:25%;height:100%;cursor:pointer;z-index:20;"
onclick="toggleHeroSelection('tank')"
title="Tank"></div>
<div style="position:absolute;top:0;left:50%;width:25%;height:100%;cursor:pointer;z-index:20;"
onclick="toggleHeroSelection('mage')"
title="Mage"></div>
<div style="position:absolute;top:0;left:75%;width:25%;height:100%;cursor:pointer;z-index:20;"
onclick="toggleHeroSelection('healer')"
title="Healer"></div>

<!-- Hero card overlays -->
<div id="warrior-card" style="position:absolute;bottom:10%;left:1%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="tank-card" style="position:absolute;bottom:10%;left:26%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="mage-card" style="position:absolute;bottom:10%;left:51%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="healer-card" style="position:absolute;bottom:10%;left:76%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
</div>

${S.tapoUnlocked ? `
<div style="margin-top:1rem;text-align:center">
<button class="btn" onclick="toggleHeroSelection('tapo')" style="background:linear-gradient(135deg,#fbbf24 0%,#22c55e 100%);padding:0.75rem 1.5rem;font-size:1rem;font-weight:bold;border:3px solid #000">
üéâ View Tapo (UNLOCKED!) üéâ
</button>
</div>` : ''}

<!-- Selection display -->
<div style="text-align:center;margin:1.5rem 0;padding:1rem;background:rgba(0,0,0,0.05);border-radius:8px">
<strong>Selected Heroes:</strong>
<div id="selection-display" style="margin-top:0.5rem;font-size:1.1rem;color:#2563eb"></div>
</div>

<button class="btn" id="start" onclick="start()" disabled style="opacity:0.4;width:100%;padding:1rem;font-size:1.1rem">Delve into Floor 1</button>
</div>`;

console.log('[FROGGLE] title() innerHTML set successfully');

// Update selection display
updateSelectionDisplay();

// If run 1 with tutorial, enable start button
if(isRun1 && !S.helpTipsDisabled) {
setTimeout(() => {
const b = document.getElementById('start');
if(b) { b.disabled = false; b.style.opacity = '1'; }
updateSelectionDisplay();
}, 0);
}
}

function toggleHeroSelection(heroType) {
const heroData = {
warrior: {name: 'Warrior', pow: 2, hp: 5, maxhp: 5, sigils: ['Attack', 'D20'], desc: 'A balanced fighter with strong attacks'},
tank: {name: 'Tank', pow: 1, hp: 10, maxhp: 10, sigils: ['Shield', 'D20'], desc: 'A sturdy defender with high HP'},
mage: {name: 'Mage', pow: 1, hp: 5, maxhp: 5, sigils: ['Attack', 'D20', 'Expand'], desc: 'A versatile caster who can hit multiple targets'},
healer: {name: 'Healer', pow: 1, hp: 5, maxhp: 5, sigils: ['Heal', 'D20', 'Expand'], desc: 'A support hero who can heal multiple allies'},
tapo: {name: 'Tapo', pow: 1, hp: 1, maxhp: 1, sigils: ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha'], desc: 'The ultimate glass cannon - all sigils, minimal health!'}
};

const hero = heroData[heroType];
const portrait = HERO_IMAGES[heroType] || '';

// Toggle selection
const isSelected = sel.includes(heroType);
if(isSelected) {
sel = sel.filter(h => h !== heroType);
} else {
if(sel.length < 2) {
sel.push(heroType);
}
}

// Update all card displays
['warrior', 'tank', 'mage', 'healer'].forEach(h => {
const cardEl = document.getElementById(`${h}-card`);
if(!cardEl) return;

if(sel.includes(h)) {
const hData = heroData[h];
const hPixelImage = HERO_IMAGES[h] || '';
const sigilsHTML = hData.sigils.map(s => `<span class="sigil l1" style="font-size:0.5rem;padding:2px 4px;margin:1px;display:inline-block">${sigilIconOnly(s)}</span>`).join('');
cardEl.innerHTML = `
<div style="background:white;border:3px solid #22c55e;border-radius:8px;padding:0.5rem;box-shadow:0 4px 6px rgba(0,0,0,0.3);pointer-events:auto;cursor:pointer"
onclick="event.stopPropagation();toggleHeroSelection('${h}')"
<div style="text-align:center">
<div style="font-size:0.7rem;font-weight:bold;margin-bottom:0.25rem">${hData.name}</div>
${hPixelImage ? `<img src="${hPixelImage}" style="width:100%;height:auto;border-radius:4px;margin-bottom:0.25rem">` : ''}
<div style="font-size:0.6rem;opacity:0.8">${hData.pow}‚ö° | ${hData.hp}‚ù§</div>
<div style="font-size:0.6rem;margin-top:0.25rem">${sigilsHTML}</div>
<div style="font-size:0.5rem;opacity:0.7;margin-top:0.25rem">‚úì SELECTED</div>
</div>
</div>`;
cardEl.style.display = 'block';
} else {
cardEl.style.display = 'none';
}
});

// Handle tapo specially if it exists
if(heroType === 'tapo' || sel.includes('tapo')) {
// Tapo button will be updated by title() re-render
}

updateSelectionDisplay();
}


function updateSelectionDisplay() {
const display = document.getElementById('selection-display');
if(!display) return;

if(sel.length === 0) {
display.textContent = 'None';
display.style.color = '#6b7280';
} else {
const heroNames = sel.map(h => H[h].n);
display.textContent = heroNames.join(' + ');
display.style.color = '#2563eb';
}

const btn = document.getElementById('start');
if(btn) {
btn.disabled = sel.length !== 2;
btn.style.opacity = sel.length === 2 ? '1' : '0.4';
}
}

function toggleMode() {
S.gameMode = S.gameMode === 'Standard' ? 'Effed' : 'Standard';
savePermanent();
title();
}

function pick(t) {
const i = sel.indexOf(t);
if(i>=0) {
sel.splice(i,1);
} else if(sel.length<2) {
sel.push(t);
} else {
toast('Maximum 2 heroes!');
return;
}

// Update selection display
updateSelectionDisplay();

// Refresh the hero card to show updated selection state
if(selectedHeroView === t) {
toggleHeroSelection(t);
}
}

function start() {
if(sel.length!==2) return;
// Show game header when entering gameplay
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';

S.floor=1; S.xp=0; S.levelUpCount=0;
// NOTE: Gold persists between runs! Only reset on victory or spent at Death Screen
S.heroes = sel.map((t,i) => ({
id:`h${Date.now()}${i}`,
n:H[t].n, p:H[t].p, h:H[t].h, m:H[t].m,
s:[...H[t].s], sh:0, g:0, ls:false, lst:0, ts:[], st:0
}));
// Apply pedestal buffs
S.pedestal.forEach(slot => {
if(slot.mode !== S.gameMode) return; // Only apply buffs for current mode
const hero = S.heroes.find(h => h.n === slot.hero);
if(!hero) return;
if(slot.stat === 'POW') {
hero.p += 1;
} else if(slot.stat === 'HP') {
hero.m += 5;
hero.h += 5;
}
});
initNeutralDeck();
upd();
// Check if player has starting XP from Death Boy sacrifices
if(S.startingXP > 0) {
S.xp = S.startingXP;
showStartingXPScreen();
} else {
startFloor(1);
}
}

// ===== FLOOR MANAGEMENT =====
function startFloor(f) {
S.floor=f;
upd();
// Special: Floor 20 in Effed mode shows Old Tapo encounter
if(f === 20 && S.gameMode === 'Effed') {
showOldTapo();
return;
}
if(f >= 20) { win(); return; }
// Floor 11 is always ambushed (Goblin Army)
if(f === 11) {
S.ambushed = true;
toast('WARNING: Floor 11 - Goblin Army lies in ambush!', 1800);
}
if(f%2===1) combat(f);
else neutral(f);
}

function getEnemyComp(f) {
const heroCount = S.heroes.length;
if(f===0) return ['goblin', 'wolf']; // Tutorial floor
if(f===1) return Array(heroCount).fill('goblin');
if(f===3) return Array(heroCount).fill('wolf');
if(f===5) return Array(heroCount * 2).fill('orc');
if(f===7) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('giant', 'wolf', 'goblin');
return comp;
}
if(f===9) return ['dragon'];
if(f===11) return Array(heroCount * 5).fill('goblin');
if(f===13) return Array(heroCount * 5).fill('wolf');
if(f===15) return ['dragon', 'dragon', 'dragon'];
if(f===17) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('giant', 'giant', 'orc', 'orc', 'wolf', 'goblin');
return comp;
}
if(f===19) return Array(heroCount * 4).fill('dragon');
return ['goblin'];
}

// ===== COMBAT (v7.2 PERFECT COMBAT - UNCHANGED) =====
function combat(f) {
S.round=1; S.turn='player'; S.activeIdx=-1; S.acted=[]; S.locked=false;
S.lastActions={}; S.asteriskUsedThisCombat=false; S.asteriskPrimed=false; S.asteriskMultiplier=1;
S.combatXP=0; S.combatGold=0; // Track combat rewards separately
// Don't clear recruits here - they may have been added before combat (e.g., Encampment straggler)
if(!S.recruits) S.recruits = [];
S.heroes.forEach(h => {
h.sh=0;
h.st=0;
if(!h.ts) h.ts=[];
// If ambushed, stun all heroes turn 1
if(S.ambushed) h.st = 1;
});
let comp = getEnemyComp(f);

S.enemies = comp.map((t,i) => {
const base = E[t];
const effedMultiplier = S.gameMode === 'Effed' ? 5 : 1;
const enemy = {
id:`e${Date.now()}${i}`, n:base.n,
p:base.p * effedMultiplier,
h:base.h * effedMultiplier,
m:base.m * effedMultiplier,
g:base.g, x:base.x, s: [], pool: base.pool,
gainRate: base.gainRate || 3, turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st:0, li: i % S.heroes.length, sh:0, alphaActed: false
};
if(base.permSigils) base.permSigils.forEach(ps => enemy.s.push({sig:ps.s, level:ps.l, perm:true}));
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
// Array format: [{s:'Shield', l:1}]
base.startSigils.forEach(ss => enemy.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
// Numeric format: draw N random sigils
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(enemy, base);
}
}
}
return enemy;
});
if(S.ambushed) {
toast('AMBUSHED! All heroes stunned Turn 1!', 1800);
S.ambushed = false; // Clear flag after use
}
// Check if we need to show Encampment enemy selection
if(S.encampmentEarlyKills && S.encampmentEarlyKills > 0) {
S.selectingEncampmentTargets = true;
S.encampmentSelectedTargets = [];
}
render();
// Tutorial: Explain tooltips on first combat
if(f === 1 && !S.helpTipsDisabled && !S.tutorialFlags.ribbleton_tooltip_intro) {
showTutorialPop('ribbleton_tooltip_intro', "Hover over (or long-press on mobile) any sigil to see what it does! This works on your heroes' sigils and enemies' sigils too.");
}
}

function getLevel(sig, heroIdx) {
const h = S.heroes[heroIdx];
// Star, Asterisk, and Expand are global passives - all heroes get them when upgraded
if(sig === 'Star' || sig === 'Asterisk' || sig === 'Expand') {
let base = S.sig[sig] || 0;
// Special case: Mage and Healer get +1 to Expand
if(sig === 'Expand' && (h.n === 'Mage' || h.n === 'Healer')) return base + 1;
return base;
}
// For other sigils, check if hero has it
const hasSigil = h.s.includes(sig) || (h.ts && h.ts.includes(sig));
if(!hasSigil) return 0;
let base = S.sig[sig] || 0;
// Actives start at level 1 minimum, passives start at 0
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Asterisk', 'Alpha'];
if(actives.includes(sig) && base === 0) base = 1;
return base;
}

function getTargetsPerInstance(action, heroIdx) {
const expandLevel = getLevel('Expand', heroIdx);
return 1 + expandLevel;
}

function needsEnemyTarget(action) { return ['Attack', 'Grapple'].includes(action); }
function needsHeroTarget(action) { return ['Heal', 'Shield', 'Alpha'].includes(action); }
function isMultiInstance(action) { return ['Attack', 'Shield', 'Heal'].includes(action); }

function getD20DC(baseDC, heroIdx) {
const h = S.heroes[heroIdx];
if(!h.ls) return baseDC;
return baseDC + h.lst;
}

function selectHero(idx) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending) return;
const h = S.heroes[idx];
if(S.acted.includes(idx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
S.activeIdx = idx;
if(h.ls) toast(`${h.n} in Last Stand - D20 only!`);
render();
}

function act(sig, heroIdx) {
// Hide any pending tooltips when action is selected
hideTooltip();

// RIBBLETON TUTORIAL: Check for scripted actions using TutorialManager
const h = S.heroes[heroIdx];
if(!TutorialManager.canPerformAction(h, sig)) {
toast("Follow the tutorial instructions!");
return;
}

if(S.locked) { toast('Wait for enemy turn!'); return; }
// Allow switching actions only if no instances have been completed yet
if(S.pending) {
// Check if any instances have been completed
if(S.instancesRemaining > 0 && S.instancesRemaining < S.totalInstances) {
toast('Must complete remaining instances!');
return;
}
// Allow switching if no instances completed yet
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
}
if(S.acted.includes(heroIdx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
if(h.ls && sig !== 'D20') { toast('Last Stand - D20 only!'); return; }
S.activeIdx = heroIdx;

if(sig === 'Asterisk') {
const level = getLevel('Asterisk', heroIdx);
if(level === 0) { toast('Asterisk not unlocked!'); return; }
if(S.asteriskUsedThisCombat) { toast('Asterisk already used this combat!'); return; }
S.asteriskPrimed = true;
S.asteriskMultiplier = level + 1;
toast(`Asterisk primed! Next action √ó${S.asteriskMultiplier}`);
render();
return;
}

const repeats = S.asteriskPrimed ? S.asteriskMultiplier : 1;
if(S.asteriskPrimed) {
S.asteriskUsedThisCombat = true;
S.asteriskPrimed = false;
toast(`Asterisk: ${sig} √ó${repeats}!`);
}

if(sig === 'Ghost') {
const level = getLevel('Ghost', heroIdx);
if(level === 0) { toast('Ghost not unlocked!'); return; }
const totalCharges = level * repeats;
h.g = Math.min((h.g || 0) + totalCharges, 9);
toast(`${h.n} gained ${totalCharges} Ghost charge${totalCharges>1?'s':''}!`);
finishAction(heroIdx);
} else if(sig === 'D20') {
S.pending = 'D20';
S.asteriskD20Repeats = repeats;
S.asteriskD20Count = 0;
d20Menu(heroIdx);
} else if(isMultiInstance(sig)) {
const level = getLevel(sig, heroIdx);
if(level === 0) { toast(`${sig} not unlocked!`); return; }
S.pending = sig;
S.instancesRemaining = level * repeats;
S.totalInstances = level * repeats; // Track for color roll-down
S.targets = [];
S.currentInstanceTargets = [];
render();
} else if(sig === 'Grapple') {
const level = getLevel('Grapple', heroIdx);
if(level === 0) { toast('Grapple not unlocked!'); return; }
S.pending = 'Grapple';
S.grappleRepeats = repeats;
S.grappleLevel = level;
S.targets = [];
render();
} else if(sig === 'Alpha') {
const level = getLevel('Alpha', heroIdx);
if(level === 0) { toast('Alpha not unlocked!'); return; }
const expandLevel = getLevel('Expand', heroIdx);
const targetsNeeded = 1 + expandLevel;
S.pending = 'Alpha';
S.alphaLevel = level;
S.alphaTargetsNeeded = targetsNeeded;
S.targets = [];
toast(`Alpha: Grant ${level} action${level>1?'s':''} to ${targetsNeeded} hero${targetsNeeded>1?'es':''}!`);
render();
}
}

function d20Menu(heroIdx) {
if(S.locked) return;

// RIBBLETON TUTORIAL: PROMPT 4 - Explain D20 gambit
if(tutorialState && S.floor === 0 && tutorialState.stage === 'healer_d20') {
tutorialState.stage = 'd20_menu';
showTutorialPop('ribbleton_d20_menu', "All heroes can use their turn to try to turn the tides of battle with a gambit - try to hurt the Wolf with the DC 16 check!", () => {
// After prompt, show the d20 menu
renderD20MenuAfterTutorial(heroIdx);
});
return;
}

renderD20MenuAfterTutorial(heroIdx);
}

function renderD20MenuAfterTutorial(heroIdx) {
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];

// RIBBLETON TUTORIAL: Special D20 menu that doesn't block view
const isTutorial = tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu';

let html = '';
if(isTutorial) {
// Tutorial version: overlay on left side only, keep enemies visible
html = '<div style="position:fixed;top:50%;left:10px;transform:translateY(-50%);z-index:15000;max-width:380px;background:white;border:4px solid #fbbf24;border-radius:12px;padding:1.5rem;box-shadow:0 8px 32px rgba(0,0,0,0.5)">';
html += '<h3 style="margin-bottom:1rem;color:#6b4423">D20: Do Something Crazy</h3>';
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, 16, 'CONFUSE')" style="margin-bottom:0.5rem;background:#fbbf24;border:3px solid #f59e0b;font-size:1.1rem;cursor:pointer">
<strong style="font-size:1.2rem">‚úÖ DC 16: CONFUSE</strong><br>
<span style="font-size:0.95rem">Deal damage = enemy POW</span>
</div>`;
// Show other options greyed out
const lockedOptions = [
{dc:17, name:'STARTLE', desc:'Stun for 1 turn'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:19, name:'SCARE', desc:'Remove from battle'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
lockedOptions.forEach(opt => {
html += `<div style="margin-bottom:0.5rem;background:#e0e0e0;border:2px solid #999;border-radius:8px;padding:0.75rem;opacity:0.5;cursor:not-allowed">
<strong style="font-size:0.95rem">üîí DC ${opt.dc}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
html += '</div>';
// Tutorial: Append as overlay, don't replace combat view
render(); // First render combat view
v.insertAdjacentHTML('beforeend', html);
return;
} else {
// Normal D20 menu (centered, blocks view)
html = '<div style="text-align:center;padding:1rem;background:white;border:3px solid #000;border-radius:8px;margin:1rem auto;max-width:400px">';
html += '<h3 style="margin-bottom:1rem">D20: Do Something Crazy</h3>';
const expandLevel = getLevel('Expand', heroIdx);
const maxTargets = 1 + expandLevel;
if(expandLevel > 0) html += `<p style="margin-bottom:0.75rem;color:#22c55e;font-weight:bold;font-size:1.05rem;background:rgba(34,197,94,0.1);padding:0.5rem;border-radius:6px;border:2px solid #22c55e">‚ú® Expand L${expandLevel} Active: Target up to ${maxTargets} enemies!</p>`;
if(S.asteriskD20Repeats > 1) {
html += `<p style="margin-bottom:0.5rem;color:#f59e0b">Asterisk Active: Pick ${S.asteriskD20Repeats} actions!</p>`;
html += `<p style="margin-bottom:1rem;font-size:0.85rem">(${S.asteriskD20Count}/${S.asteriskD20Repeats} used)</p>`;
}
if(h.ls && h.lst > 0) html += `<p style="margin-bottom:0.5rem;color:#dc2626;font-weight:bold">Last Stand Turn ${h.lst + 1}: DCs +${h.lst}</p>`;
const options = [
{dc:16, name:'CONFUSE', desc:'Deal damage = enemy POW'},
{dc:17, name:'STARTLE', desc:'Stun for 1 turn'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:19, name:'SCARE', desc:'Remove from battle'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
options.forEach(opt => {
const adjustedDC = getD20DC(opt.dc, heroIdx);
const dcText = adjustedDC > opt.dc ? `DC ${adjustedDC} (${opt.dc}+${adjustedDC - opt.dc})` : `DC ${opt.dc}`;
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, ${adjustedDC}, '${opt.name}')" style="margin-bottom:0.5rem">
<strong>${dcText}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
if(S.asteriskD20Count > 0) html += `<button class="btn safe" onclick="finishD20Asterisk(${heroIdx})">Finish (${S.asteriskD20Count} used)</button>`;
else html += `<button class="btn secondary" onclick="cancelAction()">Cancel</button>`;
html += '</div>';
v.innerHTML = html;
}
}

function selectD20Action(heroIdx, dc, actionName) {
if(S.locked) return;
S.d20Action = actionName;
S.d20DC = dc;
S.d20HeroIdx = heroIdx;

// RIBBLETON TUTORIAL: Show Expand explanation after choosing CONFUSE
if(tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu' && actionName === 'CONFUSE') {
showTutorialPop('healer_expand_explain', "Healer starts with the Expand passive - that means she gets to choose 1 extra target for each action!", () => {
S.pending = 'D20_TARGET';
S.targets = [];
render();
});
return;
}

S.pending = 'D20_TARGET';
S.targets = [];
render();
}

function rollD20() {
if(S.locked) return;
const heroIdx = S.d20HeroIdx;
const h = S.heroes[heroIdx];
const dc = S.d20DC;
const actionName = S.d20Action;
const d20Level = getLevel('D20', heroIdx);
let rolls, best;

// RIBBLETON TUTORIAL: Fudge roll to always succeed (17-18)
if(tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu') {
const fudgedRoll = 17 + Math.floor(Math.random() * 2); // 17 or 18
rolls = [fudgedRoll];
best = fudgedRoll;
} else {
({rolls, best} = rollDice(d20Level, 20));
}
const rollText = `Rolling ${d20Level}d20: [${rolls.join('] [')}] ‚Üí Highest: ${best}`;

if(best >= dc) {
toast(`${rollText} - SUCCESS!`, 1800);
const targetNames = S.targets.map(id => {
const e = S.enemies.find(e => e.id === id);
return e ? e.n : null;
}).filter(n => n);
S.targets.forEach(targetId => executeD20ActionOnTarget(targetId, actionName));
if(targetNames.length > 0) {
const actionDesc = {'CONFUSE': 'confused', 'STARTLE': 'startled and stunned', 'STEAL': 'robbed', 'SCARE': 'scared away', 'RECRUIT': 'recruited'};
if(actionName !== 'STEAL') toast(`${targetNames.join(', ')} ${actionDesc[actionName]}!`, 2500);
}
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), 800);
return;
}
}
finishD20Asterisk(heroIdx);
} else {
toast(`${rollText} - FAILED!`, 1800);
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), 800);
return;
}
}
finishD20Asterisk(heroIdx);
}
}

function executeD20ActionOnTarget(enemyId, action) {
const enemy = S.enemies.find(e => e.id === enemyId);
if(!enemy) return;
if(action === 'CONFUSE') {
const dmg = enemy.p;
dealDamageToEnemy(enemy, dmg);
} else if(action === 'STARTLE') {
enemy.st = 1;
// Check prince quest completion
if(S.princeQuestActive && S.round === 1 && !S.princeQuestCompleted) {
S.princeQuestCompleted = true;
toast('Prince Quest completed! Ring retrieved!', 1800);
}
} else if(action === 'STEAL') {
const gold = enemy.p;
S.gold += gold;
upd();
toast(`Stole ${gold} Gold from ${enemy.n}!`);
} else if(action === 'SCARE') {
if(enemy.n.includes('Dragon')) { toast(`${enemy.n} immune to SCARE!`); return; }
setTimeout(() => {
S.enemies = S.enemies.filter(e => e.id !== enemyId);
render();
checkCombatEnd();
}, 300);
} else if(action === 'RECRUIT') {
const heroIdx = S.d20HeroIdx;
const hero = S.heroes[heroIdx];
// Check if hero already has a recruit
if(!S.recruits) S.recruits = [];
const existingRecruit = S.recruits.find(r => r.recruitedBy === heroIdx);
if(existingRecruit) {
toast(`${hero.n} already has a recruit!`);
return;
}
// Remove enemy from enemies array
S.enemies = S.enemies.filter(e => e.id !== enemyId);
// Add to recruits array
const recruit = {...enemy, recruitedBy: heroIdx, isRecruit: true};
S.recruits.push(recruit);
toast(`${enemy.n} recruited by ${hero.n}!`, 1500);
setTimeout(() => {
render();
checkCombatEnd();
}, 300);
}
}

function finishD20Asterisk(heroIdx) {
S.acted.push(heroIdx);
S.pending = null;
S.targets = [];
S.asteriskD20Repeats = 1;
S.asteriskD20Count = 0;
checkTurnEnd();
render();
}

function cancelAction() {
if(S.locked) return;
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
render();
}

function tgtEnemy(id) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
if(S.targets.includes(id)) { toast('Already targeted!'); return; }
S.targets.push(id);
const slotsFilled = S.targets.length >= maxTargets;
const allEnemiesSelected = S.targets.length >= S.enemies.length;
if(slotsFilled || allEnemiesSelected) {
if(allEnemiesSelected && S.targets.length < maxTargets) {
const wasted = maxTargets - S.targets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
rollD20();
} else render();
return;
}
if(!S.pending || !needsEnemyTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
if(S.pending === 'Attack') {
if(S.currentInstanceTargets.includes(id)) { toast('Already targeted in this instance!'); return; }
S.targets.push(id);
S.currentInstanceTargets.push(id);
const availableEnemies = S.enemies.length;
const slotsFilled = S.currentInstanceTargets.length >= targetsPerInstance;
const allEnemiesSelected = S.currentInstanceTargets.length >= availableEnemies;
if(slotsFilled || allEnemiesSelected) {
if(allEnemiesSelected && S.currentInstanceTargets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.currentInstanceTargets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) finishAction(heroIdx);
else render();
} else render();
} else if(S.pending === 'Grapple') {
if(S.targets.includes(id)) { toast('Already targeted!'); return; }
S.targets.push(id);
const slotsFilled = S.targets.length >= targetsPerInstance;
const allEnemiesSelected = S.targets.length >= S.enemies.length;
if(slotsFilled || allEnemiesSelected) {
if(allEnemiesSelected && S.targets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.targets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
for(let i = 0; i < S.grappleRepeats; i++) executeGrapple(heroIdx, [...S.targets], S.grappleLevel);
finishAction(heroIdx);
} else render();
}
}

function tgtHero(id) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(!S.pending || !needsHeroTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const h = S.heroes[heroIdx];
const target = S.heroes.find(x => x.id === id);
if(!target) return;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
if(S.pending === 'Shield') {
if(S.currentInstanceTargets.includes(id)) { toast('Already targeted in this instance!'); return; }
S.targets.push(id);
S.currentInstanceTargets.push(id);
const slotsFilled = S.currentInstanceTargets.length >= targetsPerInstance;
const allHeroesSelected = S.currentInstanceTargets.length >= S.heroes.length;
if(slotsFilled || allHeroesSelected) {
if(allHeroesSelected && S.currentInstanceTargets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.currentInstanceTargets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) finishAction(heroIdx);
else render();
} else render();
} else if(S.pending === 'Heal') {
if(S.currentInstanceTargets.includes(id)) { toast('Already targeted in this instance!'); return; }
S.targets.push(id);
S.currentInstanceTargets.push(id);
const slotsFilled = S.currentInstanceTargets.length >= targetsPerInstance;
const allHeroesSelected = S.currentInstanceTargets.length >= S.heroes.length;
if(slotsFilled || allHeroesSelected) {
if(allHeroesSelected && S.currentInstanceTargets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.currentInstanceTargets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) finishAction(heroIdx);
else render();
} else render();
} else if(S.pending === 'Alpha') {
// Alpha: can't target self or already-acted heroes
const alphaUser = S.heroes[S.activeIdx];
if(id === alphaUser.id) { toast('Cannot Alpha yourself!'); return; }
const targetIdx = S.heroes.findIndex(x => x.id === id);
if(S.acted.includes(targetIdx)) { toast('That hero already acted!'); return; }
if(S.targets.includes(id)) { toast('Already targeted!'); return; }
S.targets.push(id);
if(S.targets.length >= S.alphaTargetsNeeded) {
executeAlphaAction(S.activeIdx, S.targets);
} else render();
}
}

function executeAlphaAction(alphaUserIdx, targetIds) {
const alphaUser = S.heroes[alphaUserIdx];
const actionsToGrant = S.alphaLevel;
// Mark Alpha user as acted (forfeits ALL actions)
S.acted.push(alphaUserIdx);
S.pending = null;
S.targets = [];
toast(`${alphaUser.n} used Alpha! Granting ${actionsToGrant} action${actionsToGrant>1?'s':''} to ${targetIds.length} hero${targetIds.length>1?'es':''}!`);
// Set up multi-action state for granted heroes
S.alphaGrantedActions = [];
targetIds.forEach(id => {
const targetIdx = S.heroes.findIndex(h => h.id === id);
if(targetIdx >= 0) {
for(let i = 0; i < actionsToGrant; i++) {
S.alphaGrantedActions.push(targetIdx);
}
}
});
S.alphaCurrentAction = 0;
// Start first granted action
if(S.alphaGrantedActions.length > 0) {
const nextHeroIdx = S.alphaGrantedActions[0];
S.activeIdx = nextHeroIdx;
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
}
render();
}

function selectEncampmentTarget(enemyId) {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const currentSelected = S.encampmentSelectedTargets;
// Toggle selection
if(currentSelected.includes(enemyId)) {
S.encampmentSelectedTargets = currentSelected.filter(id => id !== enemyId);
} else {
if(currentSelected.length >= kills) {
toast(`Already selected ${kills} enem${kills>1?'ies':'y'}!`);
return;
}
S.encampmentSelectedTargets.push(enemyId);
}
render();
}

function confirmEncampmentKills() {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets;
if(selected.length !== kills) {
toast(`Select ${kills} enem${kills>1?'ies':'y'} to remove!`);
return;
}
// Remove selected enemies from S.enemies
S.enemies = S.enemies.filter(e => !selected.includes(e.id));
toast(`${kills} enem${kills>1?'ies':'y'} removed!`, 1200);
// Clear flags
S.selectingEncampmentTargets = false;
S.encampmentEarlyKills = 0;
S.encampmentSelectedTargets = [];
// Start combat normally
render();
}

function executeInstance(action, heroIdx, targets) {
const h = S.heroes[heroIdx];
const pow = h.p;
if(action === 'Attack') {
// Trigger attacker animation
triggerAttackAnimation(h.id);
const targetNames = [];
const damagedEnemyIds = [];
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
targetNames.push(e.n);
damagedEnemyIds.push(e.id);
// Apply damage without triggering animation yet
if(e.sh > 0) {
if(e.sh >= pow) { e.sh -= pow; }
else { const dmg = pow - e.sh; e.sh = 0; e.h -= dmg; }
} else {
e.h -= pow;
}
});
// Trigger all damage animations simultaneously
damagedEnemyIds.forEach(id => triggerHitAnimation(id));
if(targetNames.length > 0) toast(`${h.n} attacked ${targetNames.join(', ')} for ${pow} damage each!`);
} else if(action === 'Shield') {
const targetNames = [];
const shieldedIds = [];
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
const level = getLevel('Shield', heroIdx);
const shieldAmt = 2 * pow * level;
target.sh += shieldAmt;
if(target.sh > target.m) target.sh = target.m;
targetNames.push(target.n);
shieldedIds.push(target.id);
});
// Trigger all shield animations simultaneously
shieldedIds.forEach(id => triggerShieldAnimation(id));
if(targetNames.length > 0) {
const level = getLevel('Shield', heroIdx);
const shieldAmt = 2 * pow * level;
toast(`${targetNames.join(' and ')} gained ${shieldAmt} shield!`);
}
} else if(action === 'Heal') {
const healed = [];
const revived = [];
const healedIds = [];
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
const level = getLevel('Heal', heroIdx);
const healAmt = 2 * pow * level;
healedIds.push(target.id);
if(target.ls) {
target.ls = false;
target.lst = 0;
target.h = healAmt;
revived.push(target.n);
} else {
target.h += healAmt;
if(target.h > target.m) target.h = target.m;
healed.push(target.n);
}
});
// Trigger all heal animations simultaneously
healedIds.forEach(id => triggerHealAnimation(id));
const level = getLevel('Heal', heroIdx);
const healAmt = 2 * pow * level;
if(healed.length > 0) toast(`${healed.join(' and ')} restored ${healAmt} HP!`);
if(revived.length > 0) toast(`${revived.join(' and ')} revived with ${healAmt} HP!`);
}
}

function executeGrapple(heroIdx, targets, stunDuration) {
const h = S.heroes[heroIdx];
// Trigger attacker animation (grapple uses same animation as attack)
triggerAttackAnimation(h.id);
let totalDmg = 0;
const targetNames = [];
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
totalDmg += e.p;
e.st += stunDuration;
targetNames.push(e.n);
// Check prince quest completion
if(S.princeQuestActive && S.round === 1 && !S.princeQuestCompleted) {
S.princeQuestCompleted = true;
toast('Prince Quest completed! Ring retrieved!', 1800);
}
});
if(targetNames.length > 0) toast(`${h.n} grappled ${targetNames.join(', ')} - stunned ${stunDuration} turn${stunDuration>1?'s':''}!`);
if(totalDmg > 0) {
// Hero takes recoil damage - trigger hit animation
triggerHitAnimation(h.id);
toast(`${h.n} took ${totalDmg} damage from Grapple recoil!`);
applyDamageToTarget(h, totalDmg, {isHero: true, silent: true});
}
}

function dealDamageToEnemy(enemy, dmg) {
triggerHitAnimation(enemy.id);

// Apply damage using unified function
applyDamageToTarget(enemy, dmg, {isHero: false, skipRewards: false});

// RIBBLETON TUTORIAL: Track Wolf damage/death
if(tutorialState && S.floor === 0 && enemy.n === 'Wolf') {
console.log('[TUTORIAL] Wolf took damage! HP now:', enemy.h, 'wolfDamaged was:', tutorialState.wolfDamaged);
if(enemy.h > 0 && !tutorialState.wolfDamaged) {
tutorialState.wolfDamaged = true;
console.log('[TUTORIAL] Set wolfDamaged = true');
}
}

// Handle enemy death
if(enemy.h <= 0 && enemy.g === 0) {
// RIBBLETON TUTORIAL: Track Wolf/Goblin kills
if(tutorialState && S.floor === 0) {
if(enemy.n === 'Wolf') tutorialState.wolfKilled = true;
if(enemy.n === 'Goblin') tutorialState.goblinKilled = true;
}

// Remove enemy after animation
setTimeout(() => {
S.enemies = S.enemies.filter(e => e.id !== enemy.id);
render();
checkCombatEnd();
}, 300);
}
}

function finishAction(heroIdx) {
// Check if this is an Alpha-granted action
if(S.alphaGrantedActions && S.alphaGrantedActions.length > 0) {
S.alphaCurrentAction++;
if(S.alphaCurrentAction < S.alphaGrantedActions.length) {
// More Alpha-granted actions remain
const nextHeroIdx = S.alphaGrantedActions[S.alphaCurrentAction];
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = nextHeroIdx;
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
render();
return;
} else {
// All Alpha-granted actions complete
S.alphaGrantedActions = [];
S.alphaCurrentAction = 0;
}
}
// Normal action finish
S.acted.push(heroIdx);
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = -1;

// RIBBLETON TUTORIAL: Check advancement after action using TutorialManager
const h = S.heroes[heroIdx];
TutorialManager.advanceStage({action: 'finish', hero: h.n, round: S.round});

checkTurnEnd();
render();
}

function checkTurnEnd() {
const allActedIncludingLS = S.heroes.filter(h => h.st === 0).every((h, i) => {
const actualIdx = S.heroes.findIndex(hero => hero.id === h.id);
return S.acted.includes(actualIdx);
});
if(allActedIncludingLS) {
S.heroes.forEach(h => { if(h.ls) h.lst++; });

// RIBBLETON TUTORIAL: Handle enemy turn start using TutorialManager
TutorialManager.onEnemyTurnStart();
setTimeout(() => { S.locked = true; enemyTurn(); }, 500);
}
}

function enemyTurn() {
S.turn = 'enemy';
S.acted = [];
S.activeIdx = -1;
render();
S.enemies.forEach(e => {
if(e.st > 0) e.st--;
e.turnsSinceGain++;
// RIBBLETON TUTORIAL: Enemies don't gain sigils (except Goblin on Round 3)
const isTutorial = tutorialState && S.floor === 0;
const isGoblinRound3 = isTutorial && e.n === 'Goblin' && S.round === 3;
if(e.turnsSinceGain >= e.gainRate && !isTutorial) {
e.turnsSinceGain = 0;
// Draw multiple sigils per turn if specified (Dragons draw 2)
const draws = e.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(e);
}
}
e.alphaActed = false;
});
// Process recruits - stun decrement and sigil drawing
if(S.recruits) {
S.recruits.forEach(r => {
if(r.st > 0) r.st--;
if(!r.turnsSinceGain) r.turnsSinceGain = 0;
r.turnsSinceGain++;
if(r.turnsSinceGain >= r.gainRate) {
r.turnsSinceGain = 0;
const draws = r.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(r);
}
}
});
}
setTimeout(() => executeAlphaPhase(), 800);
}

function drawEnemyStartSigil(enemy, base) {
const pool = base.pool;
if(!pool) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
if(pool === 'ANY') {
const allSigils = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk', 'Expand'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 1 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
} else if(pool === 'ANY_ADVANCED') {
const allSigils = ['Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 2 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
} else if(Array.isArray(pool)) {
const availablePool = pool.filter(sigName => {
if(sigName === 'Attack2') return !heldSigils.includes('Attack');
if(sigName === 'Shield2') return !heldSigils.includes('Shield');
return !heldSigils.includes(sigName);
});
if(availablePool.length === 0) return;
const pick = availablePool[Math.floor(Math.random() * availablePool.length)];
if(pick === 'Attack2') {
enemy.s.push({sig:'Attack', level:2, perm:false});
} else if(pick === 'Shield2') {
enemy.s.push({sig:'Shield', level:2, perm:false});
} else {
enemy.s.push({sig:pick, level:1, perm:false});
}
}
}

function drawEnemySigil(enemy) {
const pool = enemy.pool;
if(!pool || pool.length === 0) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
if(pool === 'ANY') {
const allSigils = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk', 'Expand'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 1 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
toast(`${enemy.n} drew ${sig} L${level}!`);
} else if(pool === 'ANY_ADVANCED') {
const allSigils = ['Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 2 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
toast(`${enemy.n} drew ${sig} L${level}!`);
} else {
const availablePool = pool.filter(sigName => {
if(sigName === 'Attack2') return !heldSigils.includes('Attack');
if(sigName === 'Shield2') return !heldSigils.includes('Shield');
return !heldSigils.includes(sigName);
});
if(availablePool.length === 0) return;
const pick = availablePool[Math.floor(Math.random() * availablePool.length)];
if(pick === 'Attack2') {
enemy.s.push({sig:'Attack', level:2, perm:false});
toast(`${enemy.n} drew Attack L2!`);
} else if(pick === 'Shield2') {
enemy.s.push({sig:'Shield', level:2, perm:false});
toast(`${enemy.n} drew Shield L2!`);
} else {
enemy.s.push({sig:pick, level:1, perm:false});
toast(`${enemy.n} drew ${pick} L1!`);
}
}
}

function executeAlphaPhase() {
const alphaEnemies = S.enemies.filter(e => e.st === 0 && e.s.some(sigil => sigil.sig === 'Alpha' && !sigil.perm));
if(alphaEnemies.length === 0) { setTimeout(executeRecruitPhase, 300); return; }
let delay = 0;
alphaEnemies.forEach(alphaEnemy => {
setTimeout(() => {
const allies = S.enemies.filter(e => e.id !== alphaEnemy.id && e.h > 0 && !e.s.some(s => s.sig === 'Alpha' && !s.perm));
if(allies.length === 0) { toast(`${alphaEnemy.n}'s Alpha has no valid allies!`); alphaEnemy.alphaActed = true; return; }
allies.sort((a, b) => { if(b.p !== a.p) return b.p - a.p; return b.s.length - a.s.length; });
const bestAlly = allies[0];
const alphaSigil = alphaEnemy.s.find(s => s.sig === 'Alpha');
const attacks = alphaSigil.level;
toast(`${alphaEnemy.n} grants ${bestAlly.n} ${attacks} attack${attacks>1?'s':''}!`);
for(let i = 0; i < attacks; i++) executeEnemyBaseAttack(bestAlly);
alphaEnemy.alphaActed = true;
}, delay);
delay += 600;
});
setTimeout(() => executeRecruitPhase(), delay + 300);
}

function executeRecruitPhase() {
if(!S.recruits || S.recruits.length === 0) { setTimeout(executeNormalEnemyPhase, 300); return; }
let delay = 0;
S.recruits.forEach(recruit => {
setTimeout(() => executeRecruitTurn(recruit), delay);
delay += 600;
});
setTimeout(() => executeNormalEnemyPhase(), delay + 300);
}

function executeRecruitTurn(recruit) {
if(recruit.st > 0) { toast(`${recruit.n} (Recruit) is stunned!`); return; }
if(recruit.h <= 0) return; // Dead recruit
// Recruit attacks enemies (not heroes)
executeRecruitBaseAttack(recruit);
const drawnSigils = recruit.s.filter(s => !s.perm && s.sig !== 'Alpha');
drawnSigils.forEach(sigil => executeRecruitSigil(recruit, sigil));
recruit.s = recruit.s.filter(s => s.perm);
render();
}

function executeRecruitBaseAttack(recruit) {
// Target lowest HP enemy
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) attacked ${target.n} for ${recruit.p}!`);
}

function executeRecruitSigil(recruit, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
for(let i = 0; i < level; i++) {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) ${sig} attacked ${target.n} for ${recruit.p}!`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * recruit.p * level;
recruit.sh = (recruit.sh || 0) + shieldAmt;
if(recruit.sh > recruit.m) recruit.sh = recruit.m;
toast(`${recruit.n} (Recruit) gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * recruit.p * level;
// Heal lowest HP hero
const targets = S.heroes.filter(h => h.h > 0 && !h.ls);
if(targets.length > 0) {
targets.sort((a, b) => a.h - b.h);
const healTarget = targets[0];
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${recruit.n} (Recruit) healed ${healTarget.n} for ${healAmt}!`);
}
} else if(sig === 'Grapple') {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
const dmgToRecruit = target.p;
recruit.h -= dmgToRecruit;
toast(`${recruit.n} (Recruit) grappled ${target.n}!`);
if(recruit.h <= 0) {
recruit.h = 0;
toast(`${recruit.n} (Recruit) defeated by grapple recoil!`);
S.recruits = S.recruits.filter(r => r.id !== recruit.id);
} else {
target.st = level;
toast(`${target.n} stunned for ${level} turns!`);
}
} else if(sig === 'Ghost') {
recruit.g = (recruit.g || 0) + level;
if(recruit.g > 9) recruit.g = 9;
toast(`${recruit.n} (Recruit) gained ${level} Ghost charge!`);
}
}

function executeNormalEnemyPhase() {
const lanes = {};
S.enemies.forEach(e => { if(!lanes[e.li]) lanes[e.li] = []; lanes[e.li].push(e); });
let delay = 0;
Object.keys(lanes).forEach(laneIdx => {
lanes[laneIdx].forEach(enemy => {
setTimeout(() => executeEnemyTurn(enemy), delay);
delay += 600;
});
});
setTimeout(() => endEnemyTurn(), delay + 500);
}

function executeEnemyTurn(enemy) {
if(enemy.st > 0) { toast(`${enemy.n} is stunned!`); return; }
if(enemy.alphaActed) {
toast(`${enemy.n} used Alpha (skipping normal turn)`);
enemy.s = enemy.s.filter(s => s.perm);
return;
}
executeEnemyBaseAttack(enemy);
const drawnSigils = enemy.s.filter(s => !s.perm && s.sig !== 'Alpha');
drawnSigils.forEach(sigil => executeEnemySigil(enemy, sigil));
enemy.s = enemy.s.filter(s => s.perm);
render();
}

function getEnemyExpandLevel(enemy) {
const expandSigil = enemy.s.find(s => s.sig === 'Expand');
return expandSigil ? expandSigil.level : 0;
}

function selectEnemyTargets(enemy, count) {
// Priority:
// 1. Hero directly across (lane index)
// 2. That hero's recruited ally (if present)
// 3. Heroes nearest to that first hero
// 4. Any remaining heroes
// 5. Nearest hero's recruited ally
// 6. Any remaining allies

let targets = [];
const added = new Set();

// 1. Primary target: Hero in enemy's lane
const primaryHero = S.heroes[enemy.li];
if(primaryHero && primaryHero.h > 0) {
targets.push(primaryHero);
added.add(primaryHero.id);
}
if(targets.length >= count) return targets;

// 2. That hero's recruited ally (if present)
if(S.recruits && S.recruits.length > 0) {
const primaryRecruit = S.recruits.find(r => r.li === enemy.li && r.h > 0);
if(primaryRecruit) {
targets.push(primaryRecruit);
added.add(primaryRecruit.id);
}
}
if(targets.length >= count) return targets;

// 3-4. Expand to nearby heroes by distance from primary lane
const aliveHeroes = S.heroes.filter(h => h.h > 0 && !added.has(h.id));
// Sort by distance from enemy lane
aliveHeroes.sort((a, b) => {
const aIdx = S.heroes.indexOf(a);
const bIdx = S.heroes.indexOf(b);
return Math.abs(aIdx - enemy.li) - Math.abs(bIdx - enemy.li);
});

for(const hero of aliveHeroes) {
if(targets.length >= count) break;
targets.push(hero);
added.add(hero.id);
}
if(targets.length >= count) return targets;

// 5-6. Recruited allies of nearby heroes, then any remaining
if(S.recruits && S.recruits.length > 0) {
const aliveRecruits = S.recruits.filter(r => r.h > 0 && !added.has(r.id));
// Sort by lane distance from enemy
aliveRecruits.sort((a, b) => Math.abs(a.li - enemy.li) - Math.abs(b.li - enemy.li));

for(const recruit of aliveRecruits) {
if(targets.length >= count) break;
targets.push(recruit);
added.add(recruit.id);
}
}

return targets;
}

function executeEnemyBaseAttack(enemy) {
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;
executeEnemyAttackOnHeroes(enemy, targetCount, 'Base Attack');
}

function executeEnemySigil(enemy, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;

for(let i = 0; i < level; i++) {
executeEnemyAttackOnHeroes(enemy, targetCount, `Attack ${i+1}/${level}`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * enemy.p * level;
enemy.sh = (enemy.sh || 0) + shieldAmt;
if(enemy.sh > enemy.m) enemy.sh = enemy.m;
toast(`${enemy.n} gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * enemy.p * level;
const allies = S.enemies.filter(e => e.id !== enemy.id && e.h > 0);
if(allies.length > 0) {
allies.sort((a,b) => a.h - b.h);
const healTarget = allies[0];
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${enemy.n} healed ${healTarget.n} for ${healAmt}!`);
}
} else if(sig === 'Grapple') {
const target = S.heroes[enemy.li];
if(target && target.h > 0) {
const dmgToEnemy = target.p;
enemy.h -= dmgToEnemy;
toast(`${enemy.n} grappled ${target.n}!`);
if(enemy.h <= 0) {
enemy.h = 0;
toast(`${enemy.n} defeated by grapple recoil!`);
S.enemies = S.enemies.filter(e => e.id !== enemy.id);
} else {
target.st = level;
toast(`${target.n} stunned for ${level} turns!`);
}
}
} else if(sig === 'Ghost') {
enemy.g = (enemy.g || 0) + level;
if(enemy.g > 9) enemy.g = 9;
toast(`${enemy.n} gained ${level} Ghost charge!`);
} else if(sig === 'Expand') {
toast(`${enemy.n} used Expand (affects their attacks)`);
} else if(sig === 'Asterisk') {
toast(`${enemy.n} used Asterisk (not yet implemented for enemies)`);
}
}

function dealDamageToHero(hero, dmg, source) {
triggerHitAnimation(hero.id);
const actualDamage = applyDamageToTarget(hero, dmg, {isHero: true});
if(actualDamage > 0) {
toast(`${source} dealt ${actualDamage} damage to ${hero.n}!`);
} else {
toast(`${hero.n}'s shield absorbed ${dmg} damage!`);
}
}

function endEnemyTurn() {
S.heroes.forEach(h => {
if(h.st > 0) {
h.st--;
if(h.st === 0) toast(`${h.n} is no longer stunned!`);
}
});
if(checkCombatEnd()) return;
S.round++;

// RIBBLETON TUTORIAL: Handle round transitions using TutorialManager
if(tutorialState && S.floor === 0) {
tutorialState.round = S.round;
TutorialManager.onRoundStart(S.round);
// If onRoundStart handled the transition (showed a popup), return early
if(S.turn === 'player') {
return;
}
}

S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
upd();
render();
}

function checkCombatEnd() {
if(S.enemies.length === 0) {
// Tutorial Floor 0: Special ending (no XP/Gold rewards)
if(S.floor === 0) {
S.combatXP = 0;
S.combatGold = 0;
setTimeout(() => {
toast('Victory!');
setTimeout(finishRibbletonTutorial, 1000);
}, 500);
return true;
}

// Normal combat victory
setTimeout(() => {
const combatXP = S.combatXP || 0;
let starBonus = 0;
S.heroes.forEach(h => {
const starLevel = getLevel('Star', S.heroes.indexOf(h));
starBonus += starLevel * 0.5;
});
const bonusXP = Math.floor(combatXP * (1 + starBonus));
S.xp += bonusXP;
S.combatXP = 0; // Reset combat XP
// Recruits persist until killed - don't clear here
if(starBonus > 0) toast(`Star Bonus! ${combatXP} √ó ${(1 + starBonus).toFixed(1)} = ${bonusXP} XP`, 3000);
upd();
toast('Victory!');
setTimeout(levelUp, 1000);
}, 500);
return true;
}
const allDead = S.heroes.every(h => h.ls);
if(allDead) {
setTimeout(() => {
toast('Defeated!');
setTimeout(() => showDeathScreen(), 1000);
}, 500);
return true;
}
return false;
}

function render() {
const v = document.getElementById('gameView');
// Special state: Encampment enemy selection
if(S.selectingEncampmentTargets) {
v.innerHTML = renderEncampmentSelection();
return;
}

// RIBBLETON TUTORIAL: Show targeting prompts
if(tutorialState && S.floor === 0 && S.pending) {
// PROMPT 2: Targeting Wolf with Warrior Attack
if(tutorialState.stage === 'warrior_attack' && S.pending === 'Attack' && S.targets.length === 0) {
tutorialState.stage = 'targeting_wolf';
showTutorialPop('ribbleton_targeting', "You can choose which enemy to target. That Wolf looks nasty - you should take it out first!", () => {
render();
});
return;
}
// PROMPT 7: Expand heal targets
else if(tutorialState.stage === 'healer_heal' && S.pending === 'Heal' && S.currentInstanceTargets.length === 0 && S.targets.length === 0) {
tutorialState.stage = 'expand_targets';
showTutorialPop('ribbleton_expand', "Helpful - Healer starts with Expand! That means they can Expand their actions to 1 extra target. Click both heroes to heal off some damage!", () => {
render();
});
return;
}
}

let html = renderCombatStatusHeader();
// New layout: Each hero and their enemies in a horizontal lane
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });

S.heroes.forEach((h,i) => {
html += `<div class="combat-lane">`;
html += '<div style="display:flex;gap:2rem;justify-content:center;align-items:stretch">';

// Hero section (left side of lane)
html += '<div style="flex:0 0 auto;display:flex;flex-direction:column;gap:0.3rem">';

// Show recruit BEHIND (before) hero if exists
if(S.recruits) {
const heroRecruits = S.recruits.filter(r => r.recruitedBy === i);
if(heroRecruits.length > 0) {
// Sort by POW descending, then by current HP descending
heroRecruits.sort((a, b) => {
if(b.p !== a.p) return b.p - a.p;
return b.h - a.h;
});
const recruit = heroRecruits[0];
const extra = [];
if(recruit.sh > 0) extra.push(`${recruit.sh}üõ°`);
const recruitGhostCharges = recruit.ghostCharges || 0;
if(recruitGhostCharges > 0) extra.push(`${recruitGhostCharges}${sigilIconOnly('Ghost')}`);
if(recruit.st > 0) extra.push(`üòµ${recruit.st}T`);
html += `<div id="${recruit.id}" class="card hero" style="opacity:0.85;border:2px dashed #22c55e">`;
// Power at top
html += `<div style="text-align:center;font-size:1rem;font-weight:bold;margin-bottom:0.25rem">${recruit.p}</div>`;
// Recruited label with emoji
html += `<div style="text-align:center;font-size:1.5rem;margin-bottom:0.25rem">ü§ù</div>`;
// HP
html += `<div style="text-align:center;font-size:0.85rem;margin-bottom:0.25rem">${recruit.h}/${recruit.m}</div>`;
// Extra info
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils
const recruitTotalSigils = recruit.s.length + 1;
const compactClass = recruitTotalSigils >= 6 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">
<span class="sigil engraved">${sigilIconOnly('Attack')}</span>`;
recruit.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
const permStyle = sigil.perm ? 'engraved' : cl;
html += `<span class="sigil ${permStyle}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sigil.sig}', this), 500)" ontouchend="hideTooltip()">${sigilIconOnly(sigil.sig)}${sigil.level}</span>`;
});
html += '</div></div>';
}
}

const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
const isActive = S.activeIdx === i;
const isTargetable = S.pending && needsHeroTarget(S.pending);
const hasActed = S.acted.includes(i);
let cardClasses = 'card hero';
if(isActive) cardClasses += ' active';
if(isTargetable) cardClasses += ' targetable';
if(hasActed) cardClasses += ' acted';
if(h.ls) cardClasses += ' last-stand';
const isTargeted = S.targets.includes(h.id);
if(isTargeted) cardClasses += ' targeted';
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
if(h.st > 0) extra.push(`üòµ${h.st}T`);
if(hasActed) extra.push('‚úì');
let onclick = '';
if(isTargetable) onclick = `onclick="tgtHero('${h.id}')"`;
else if(!hasActed && h.st === 0 && !S.pending) onclick = `onclick="selectHero(${i})"`;
const heroImage = HERO_IMAGES[h.n.toLowerCase()] || '';
html += `<div id="${h.id}" class="${cardClasses}" ${onclick}>`;
// Name at top
html += `<div style="text-align:center;font-size:0.75rem;font-weight:bold;margin-bottom:0.25rem;opacity:0.8">${h.n}</div>`;
// POW - portrait - HP (horizontal)
html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.25rem;gap:0.25rem">`;
html += `<div style="font-size:1rem;font-weight:bold;min-width:30px;text-align:center">${h.p}</div>`;
if(heroImage) html += `<img src="${heroImage}" style="width:48px;height:48px;border-radius:4px">`;
html += `<div style="font-size:0.85rem;min-width:50px;text-align:center">${hp}</div>`;
html += `</div>`;
// Extra info
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils with smart wrapping
const activeSigils = [...h.s, ...(h.ts || [])];
const sigilCount = activeSigils.length;
const compactClass = sigilCount >= 6 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">`;
activeSigils.forEach(s => {
const lvl = getLevel(s, i);
// Calculate visual level for roll-down effect
let visualLvl = lvl;
if(S.activeIdx === i && S.pending === s && isMultiInstance(s) && S.totalInstances) {
const usedInstances = S.totalInstances - S.instancesRemaining;
visualLvl = Math.max(0, lvl - usedInstances);
}
const cl = visualLvl===0?'l0':visualLvl===1?'l1':visualLvl===2?'l2':visualLvl===3?'l3':visualLvl===4?'l4':'l5';
// Allow clicking sigils if: hero hasn't acted, not stunned, and either (no pending action OR pending but no instances committed yet)
const canSwitchAction = !S.pending || (S.instancesRemaining === S.totalInstances);
const canClick = !S.acted.includes(i) && h.st === 0 && canSwitchAction && ['Attack','Shield','Grapple','Heal','Ghost','D20','Asterisk','Alpha'].includes(s);
const isPrimed = (s === 'Asterisk' && S.asteriskPrimed && S.activeIdx === i);
const isActiveAction = (S.pending === s && S.activeIdx === i);
html += `<span class="sigil ${cl} ${isPrimed?'asterisk-primed':''} ${isActiveAction?'active-action':''} ${canClick?'clickable':''}" ${canClick?`onclick="act('${s}', ${i})"`:''}
onmouseenter="showTooltip('${s}', this)" onmouseleave="hideTooltip()"
ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${s}', this), 500)" ontouchend="hideTooltip()">${sigilIconOnly(s)}</span>`;
});
html += '</div>';
html += '</div>';
html += '</div>'; // Close hero section

// Divider between heroes and enemies
html += '<div style="width:3px;background:linear-gradient(to bottom,transparent,rgba(0,0,0,0.3) 20%,rgba(0,0,0,0.3) 80%,transparent);flex-shrink:0"></div>';

// Enemy section (right side of lane)
html += '<div style="flex:0 0 auto;display:flex;flex-wrap:wrap;gap:0.3rem;justify-content:flex-start;align-items:flex-start;align-content:flex-start;min-height:80px">';
const laneEnemies = enemyLanes[i] || [];
if(laneEnemies.length === 0) {
html += `<div style="flex:1;text-align:center;font-size:1.2rem;padding:1.5rem;background:rgba(0,0,0,0.1);border:3px dashed rgba(0,0,0,0.3);border-radius:8px;color:rgba(0,0,0,0.4);font-style:italic;display:flex;align-items:center;justify-content:center">No Enemies</div>`;
} else {
laneEnemies.forEach(e => {
const isTargetable = (S.pending && needsEnemyTarget(S.pending)) || S.pending === 'D20_TARGET';
const selectCount = S.targets.filter(t => t === e.id).length;
let cardClasses = 'card enemy';
if(isTargetable) cardClasses += ' targetable';
if(selectCount > 0) cardClasses += ' targeted';
const extra = [];
if(e.sh > 0) extra.push(`${e.sh}üõ°`);
// Only show ghost charges if enemy actually has them (not gold drops!)
const ghostCharges = e.ghostCharges || 0;
if(ghostCharges > 0) extra.push(`${ghostCharges}${sigilIconOnly('Ghost')}`);
if(e.st > 0) extra.push(`üòµ${e.st}T`);
if(selectCount > 0) extra.push(`√ó${selectCount}`);
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
html += `<div id="${e.id}" class="${cardClasses}" ${isTargetable?`onclick="tgtEnemy('${e.id}')"`:''}">`;
// Name at top
html += `<div style="text-align:center;font-size:0.75rem;font-weight:bold;margin-bottom:0.25rem;opacity:0.8">${e.n}</div>`;
// POW - emoji - HP row (horizontal)
html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.25rem;gap:0.25rem">`;
html += `<div style="font-size:1rem;font-weight:bold;min-width:30px;text-align:center">${e.p}</div>`;
html += `<div style="font-size:2rem">${enemyEmoji}</div>`;
html += `<div style="font-size:0.85rem;min-width:50px;text-align:center">${e.h}/${e.m}</div>`;
html += `</div>`;
// Extra info
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils with smart wrapping
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
const totalSigils = e.s.length + (hasAttackSigil ? 0 : 1);
const compactClass = totalSigils >= 6 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">`;
if(!hasAttackSigil) {
html += `<span class="sigil engraved">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
const permStyle = sigil.perm ? 'engraved' : cl;
html += `<span class="sigil ${permStyle}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),500)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig)}${sigil.level}</span>`;
});
html += '</div></div>';
});
}
html += '</div>'; // Close enemy section
html += '</div>'; // Close flex container
html += '</div>'; // Close combat-lane
});
v.innerHTML = html;
}

// ===== LEVEL UP =====
function levelUp() {
const v = document.getElementById('gameView');
const nextCost = FIB[S.levelUpCount] || 999;
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Level Up!</h2>
<p style="text-align:center;margin-bottom:0.5rem">Floor ${S.floor} Complete</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Current XP: ${S.xp} | Next Level: ${nextCost}XP</p>
<div class="choice" onclick="levelUpMenu()">Spend XP</div>
<button class="btn safe" onclick="nextFloor()">Next Floor</button>`;
}

function nextFloor() {
saveGame();
startFloor(S.floor + 1);
}

function showStartingXPScreen() {
const v = document.getElementById('gameView');
const nextCost = FIB[S.levelUpCount] || 999;
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem;color:#a855f7">Starting XP Bonus!</h2>
<p style="text-align:center;margin-bottom:0.5rem;font-size:1.1rem">You start this run with <strong>${S.startingXP} XP</strong> from Death Boy sacrifices!</p>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;opacity:0.8">Spend it now or bank it for later. Remaining XP: <strong>${S.xp}</strong> | Next Level Cost: <strong>${nextCost}XP</strong></p>
<div class="choice" onclick="startingXPMenu()">Spend XP</div>
<button class="btn safe" onclick="startFloor(1)">Start Run (Bank XP)</button>`;
}

function startingXPMenu() {
const v = document.getElementById('gameView');
const cost = FIB[S.levelUpCount] || 999;
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend Starting XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<div class="choice" onclick="upgradeSigil()">Upgrade Sigil Level</div>
<div class="choice" onclick="addSigilToHero()">Add Sigil to Hero</div>
<button class="btn secondary" onclick="showStartingXPScreen()">Back</button>`;
}

function levelUpMenu() {
showTutorialPop('levelup_intro', "Nice! You got enough XP to get your first Level-Up. Your team shares XP. Let's check out your options! Click into each option to learn more about what it does.");
const v = document.getElementById('gameView');
const cost = FIB[S.levelUpCount] || 999;
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<div class="choice" onclick="upgradeSigil()">Upgrade Sigil Level</div>
<div class="choice" onclick="addSigilToHero()">Add Sigil to Hero</div>
<button class="btn secondary" onclick="levelUp()">Back</button>`;
}

function heroStats() {
showTutorialPop('levelup_stat_upgrade', "This one is pretty straightforward - add +1 POW or +5 HP to a hero of your choice.");
const cost = FIB[S.levelUpCount] || 999;
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Hero Stats</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
S.heroes.forEach((h, idx) => {
html += `<div class="choice" onclick="upPow(${idx})"><strong>${h.n} POW</strong> (${h.p} ‚Üí ${h.p+1})</div>`;
html += `<div class="choice" onclick="upHP(${idx})"><strong>${h.n} HP</strong> (${h.m} ‚Üí ${h.m+5})</div>`;
});
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function upPow(idx) {
const cost = FIB[S.levelUpCount] || 999;
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].p++;
toast(`${S.heroes[idx].n} POW +1!`);
upd();
saveGame();
levelUpMenu();
}

function upHP(idx) {
const cost = FIB[S.levelUpCount] || 999;
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].m += 5;
S.heroes[idx].h += 5;
if(S.heroes[idx].ls) {
S.heroes[idx].ls = false;
S.heroes[idx].lst = 0;
S.heroes[idx].h = 5;
toast(`${S.heroes[idx].n} revived with 5 HP!`);
} else toast(`${S.heroes[idx].n} HP +5!`);
upd();
saveGame();
levelUpMenu();
}

function upgradeSigil() {
showTutorialPop('levelup_upgrade_active', "Each active works based on its level. For example, if you upgrade Attack to Level 2, all heroes with Attack get it at Level 2, letting them attack twice with 1 action! Passives (Expand, Ghost, Asterisk, Star) work differently - they apply globally to all heroes and enhance your existing actions!");
const cost = FIB[S.levelUpCount] || 999;
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Sigil</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const available = allSigils.filter(s => (S.sig[s] || 0) < 4);
if(available.length === 0) html += `<p style="text-align:center;margin-bottom:1rem">All sigils maxed!</p>`;
else {
available.forEach(sig => {
const level = S.sig[sig] || 0;
html += `<div class="choice" onclick="upSigil('${sig}')"><strong>${sigilIcon(sig)} L${level} ‚Üí L${level+1}</strong></div>`;
});
}
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function addSigilToHero() {
showTutorialPop('levelup_add_active', "Heroes only get 1 action per turn. Active sigils give you more choices - in addition to Attack/Heal/D20, you can grant a hero a new ability like Shield or Ghost!");
const cost = FIB[S.levelUpCount] || 999;
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to Hero</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a hero:</p><div style="max-width:400px;margin:0 auto">`;
S.heroes.forEach((h, idx) => {
const sigilInfo = `<br><span style="font-size:0.75rem;opacity:0.8">Current: ${h.s.join(', ')}</span>`;
html += renderHeroCard(h, idx, `selectHeroForSigil(${idx})`, sigilInfo);
});
html += '</div>';
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function selectHeroForSigil(heroIdx) {
const cost = FIB[S.levelUpCount] || 999;
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Alpha', 'Asterisk', 'Star'];
const available = allSigils.filter(sig => !h.s.includes(sig) && !(h.ts && h.ts.includes(sig)));
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to ${h.n}</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(available.length === 0) html += `<p style="text-align:center;margin-bottom:1rem">${h.n} already has all sigils!</p>`;
else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a sigil to add:</p>`;
available.forEach(sig => {
const level = S.sig[sig] || 0;
const levelText = level === 0 ? 'L0 (Passive only)' : `L${level}`;
html += `<div class="choice" onclick="addSigilConfirm(${heroIdx}, '${sig}')">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">(${levelText})</span>
</div>`;
});
}
html += `<button class="btn secondary" onclick="addSigilToHero()">Back</button>`;
v.innerHTML = html;
}

function addSigilConfirm(heroIdx, sig) {
const cost = FIB[S.levelUpCount] || 999;
if(S.xp < cost) return;
const h = S.heroes[heroIdx];
if(h.s.includes(sig) || (h.ts && h.ts.includes(sig))) { toast(`${h.n} already has ${sig}!`); return; }
S.xp -= cost;
S.levelUpCount++;
if(!h.ts) h.ts = [];
h.ts.push(sig);
// Calculate effective level for display (actives show as level 1 minimum)
const permLevel = S.sig[sig] || 0;
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Asterisk', 'Alpha'];
const displayLevel = (actives.includes(sig) && permLevel === 0) ? 1 : permLevel;
toast(`${sig} added to ${h.n} at L${displayLevel}!`);
upd();
saveGame();
levelUpMenu();
}

function upSigil(sig) {
const cost = FIB[S.levelUpCount] || 999;
if(S.xp < cost) return;

// Show passive sigil tutorial when upgrading Expand or Asterisk from L0 to L1
const isPassive = ['Expand', 'Asterisk'].includes(sig);
const currentLevel = S.sig[sig] || 0;
if(isPassive && currentLevel === 0) {
showTutorialPop('levelup_upgrade_passive', "Expand and Asterisk start as PASSIVE sigils - they work automatically but can't be used as actions. Upgrade them to L1 to use them actively!");
}

S.xp -= cost;
S.levelUpCount++;
S.sig[sig] = (S.sig[sig] || 0) + 1;
toast(`${sig} upgraded to L${S.sig[sig]}!`);
upd();
saveGame();
levelUpMenu();
}

// ===== NEUTRAL ENCOUNTERS =====
function neutral(f) {
// TUTORIAL: Show neutral intro on Floor 2
if(f === 2) {
showTutorialPop('neutral_intro', "You can usually walk straight through these floors, but most can offer a benefit if you play it right!");
}

const enc = getNeutralEncounter();

if(S.ghostBoysConverted && enc.startsWith('ghost')) {
showEmptyPlayroom();
return;
}

if(enc === 'shopkeeper1') showShopkeeper1();
else if(enc === 'shopkeeper2') showShopkeeper2();
else if(enc === 'wishingwell1') showWishingWell1();
else if(enc === 'wishingwell2') showWishingWell2();
else if(enc === 'treasurechest1') showTreasureChest1();
else if(enc === 'treasurechest2') showTreasureChest2();
else if(enc === 'wizard1') showWizard1();
else if(enc === 'wizard2') showWizard2();
else if(enc === 'oracle1') showOracle1();
else if(enc === 'oracle2') showOracle2();
else if(enc === 'encampment1') showEncampment1();
else if(enc === 'encampment2') showEncampment2();
else if(enc === 'statue1') showStatue1();
else if(enc === 'statue2') showStatue2();
else if(enc === 'ghost1') showGhost1();
else if(enc === 'ghost2') showGhost2();
else if(enc === 'prince1') showPrince1();
else if(enc === 'prince2') showPrince2();
else {
const v = document.getElementById('gameView');
v.innerHTML = `
<h2 style="text-align:center;margin:2rem 0">Floor ${f}</h2>
<p style="text-align:center;margin-bottom:2rem">${enc}</p>
<button class="btn" onclick="nextFloor()">Continue</button>`;
}
}

// ===== 1. SHOPKEEPER =====
function showShopkeeper1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Potions for Sale',
description: 'A hooded figure stands behind a small cart laden with vials and bottles. Their voice is raspy and businesslike: "Potions. Gold. Fair prices."',
buttons: `
<button class="neutral-btn safe" onclick="buySmallPotion()">Small Potion (3G) - Restore 3 HP</button>
<button class="neutral-btn safe" onclick="buyLargePotion()">Large Potion (5G) - Restore 8 HP</button>
<button class="neutral-btn secondary" onclick="declineShopkeeper()">Do Not Engage</button>
`
});
}

let shopSmallBought = false;
let shopLargeBought = false;

function buySmallPotion() {
if(S.gold < 3) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn" onclick="applySmallPotion(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Choose Hero',
description: 'Select a hero to restore 3 HP.',
buttons: heroButtons + `<button class="neutral-btn secondary" onclick="showShopkeeper1()">Back</button>`
});
}

function applySmallPotion(idx) {
S.gold -= 3;
const h = S.heroes[idx];
h.h = Math.min(h.h + 3, h.m);
upd();
toast(`${h.n} restored 3 HP!`);
shopSmallBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 1800);
}
showShopkeeper1();
}

function buyLargePotion() {
if(S.gold < 5) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn" onclick="applyLargePotion(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Choose Hero',
description: 'Select a hero to restore 8 HP.',
buttons: heroButtons + `<button class="neutral-btn secondary" onclick="showShopkeeper1()">Back</button>`
});
}

function applyLargePotion(idx) {
S.gold -= 5;
const h = S.heroes[idx];
h.h = Math.min(h.h + 8, h.m);
upd();
toast(`${h.n} restored 8 HP!`);
shopLargeBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 1800);
}
showShopkeeper1();
}

function declineShopkeeper() {
shopSmallBought = false;
shopLargeBought = false;
nextFloor();
}

function showShopkeeper2() {
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const available = allSigils.filter(s => (S.sig[s] || 0) < 4);
const cost = S.goingRate;
let description = `The shopkeeper pulls back their hood, revealing a skull grinning beneath. "I am Death's... associate. You've impressed me. Choose wisely."<br><br><p style="text-align:center;font-weight:bold;margin:1rem 0">Cost: ${cost} Gold</p>`;
let buttons = '';
let outcomes = [];

if(available.length === 0) {
outcomes.push('All your sigils are already at maximum power. Death nods approvingly and fades away.');
buttons = `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else if(S.gold < cost) {
outcomes.push('<span style="color:#dc2626">You don\'t have enough Gold! Death shakes their head and fades away.</span>');
buttons = `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else {
description += `<div style="font-size:0.9rem;margin-bottom:1rem">Choose one sigil to upgrade permanently (costs ${cost}G, Going Rate does NOT increase):</div>`;
available.forEach(sig => {
const level = S.sig[sig] || 0;
buttons += `<div class="choice" onclick="acceptDeathsBargain('${sig}', ${cost})">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">L${level} ‚Üí L${level+1}</span>
</div>`;
});
buttons += `<button class="btn risky" onclick="finishDeathsBargain()">Decline</button>`;
}

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper2.png',
title: 'Death\'s Bargain',
description,
outcomes,
buttons
});
}

function acceptDeathsBargain(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }
S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
// NOTE: Going Rate does NOT increase for Death's Bargain!
upd();
savePermanent();
toast(`${sig} permanently upgraded to L${S.sig[sig]}! (GR unchanged)`, 3000);
removeNeutralFromDeck('shopkeeper');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Good choice. See you soon."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}, 1000);
}

function finishDeathsBargain() {
removeNeutralFromDeck('shopkeeper');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Shame. You don't get a chance like this every day. Oh well, it's your funeral."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 2. WISHING WELL =====
function showWishingWell1() {
const v = document.getElementById('gameView');
const buttons = `
<button class="btn risky" onclick="climbWell()">Climb down and get coins</button>
<button class="btn" onclick="tossWish()">Toss in a coin and make a wish</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'The Old Wishing Well',
description: 'An ancient stone well sits in the center of the chamber. You hear the faint sound of trickling water far below. A glint of gold catches your eye at the bottom.',
buttons
});
}

function climbWell() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
let goldGain = 0;
let hpLoss = 0;

if(best === 1) {
outcome = 'You slip on the wet stones and plummet! The landing is brutal.';
hpLoss = 3;
goldGain = -5;
} else if(best >= 2 && best <= 10) {
outcome = 'You climb carefully but scrape yourself on the rough stones. You manage to grab a single coin.';
hpLoss = 1;
goldGain = 1;
} else if(best >= 11 && best <= 19) {
outcome = 'Your climbing skills are impressive! You retrieve a small pouch of coins.';
goldGain = 3;
} else if(best === 20) {
outcome = 'Your descent is flawless! At the bottom, you discover a hidden cache of coins AND the well begins to overflow with crystal-clear water!';
goldGain = 2 * S.heroes.length;
replaceStage1WithStage2('wishingwell');
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'Climbing the Well',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="applyWellClimb(${hpLoss}, ${goldGain})">Continue</button>`
});
}

function applyWellClimb(hpLoss, goldGain) {
if(hpLoss > 0) {
// Show hero selection screen
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="applyWellDamage(${idx}, ${hpLoss}, ${goldGain})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'Choose Who Takes Damage',
description: `Choose which hero takes ${hpLoss} damage from climbing the well:`,
buttons: heroButtons
});
} else {
// No damage, just apply gold
S.gold += goldGain;
if(S.gold < 0) S.gold = 0;
upd();
if(goldGain > 0) toast(`Gained ${goldGain} Gold!`);
else if(goldGain < 0) toast(`Lost ${Math.abs(goldGain)} Gold!`);
nextFloor();
}
}

function applyWellDamage(heroIdx, hpLoss, goldGain) {
const hero = S.heroes[heroIdx];
hero.h -= hpLoss;
if(hero.h <= 0 && !hero.ls) {
if(hero.g > 0) {
hero.g--;
hero.h += hpLoss;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
hero.h = 0;
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`);
}
}
toast(`${hero.n} took ${hpLoss} damage!`);

S.gold += goldGain;
if(S.gold < 0) S.gold = 0;
upd();
if(goldGain > 0) toast(`Gained ${goldGain} Gold!`);
else if(goldGain < 0) toast(`Lost ${Math.abs(goldGain)} Gold!`);
nextFloor();
}

function tossWish() {
const cost = S.heroes.length;
if(S.gold < cost) {
toast(`Need ${cost} Gold to make a wish!`);
return;
}
S.gold -= cost;
upd();
replaceStage1WithStage2('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell2.png',
title: 'A Wish Made',
outcomes: [`You toss ${cost} gold coin${cost>1?'s':''} into the well and make a silent wish. The water begins to glow softly, then surges upward, overflowing the well's edge!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showWishingWell2() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell2.png',
title: 'Overflowing Crystal Waters',
description: 'The well now overflows with sparkling, crystal-clear water that pools around its base. The water seems to pulse with restorative energy.',
buttons: `<button class="btn safe" onclick="drinkCrystalWater()">Drink from the well</button>`
});
}

function drinkCrystalWater() {
S.heroes.forEach(h => {
if(h.ls) {
h.ls = false;
h.lst = 0;
h.h = h.m;
toast(`${h.n} revived to full HP!`);
} else {
h.h = h.m;
}
});
toast('All heroes fully healed!', 1800);
removeNeutralFromDeck('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell2.png',
title: 'Fully Restored',
outcomes: [
'The water tastes impossibly pure and refreshing. Warmth spreads through your body as all wounds close and exhaustion fades. You feel completely restored.',
'The well\'s glow fades as the water recedes to its normal level. Its magic has been spent.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 3. TREASURE CHEST =====
function showTreasureChest1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'A Mysterious Chest',
description: 'An ornate wooden chest sits against the far wall, its brass fittings gleaming in the torchlight. No lock is visible, but you sense this may not be as simple as it appears.',
buttons: `
<button class="btn risky" onclick="openChest()">Open the chest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`
});
}

function openChest() {
const {rolls: trapRolls, best: trapBest} = rollD20Neutral();
const trapText = showD20Result(trapRolls, trapBest);

let trapOutcome = '';
let trapDmg = 0;
let secretFound = false;

if(trapBest === 1) {
trapOutcome = 'A poison dart flies out and strikes you!';
trapDmg = 3;
} else if(trapBest >= 2 && trapBest <= 9) {
trapOutcome = 'A small dart grazes your arm.';
trapDmg = 1;
} else if(trapBest >= 10 && trapBest <= 18) {
trapOutcome = 'You carefully open the chest without triggering any traps.';
} else {
trapOutcome = 'Your keen eyes spot a hidden compartment in the chest\'s lid!';
secretFound = true;
S.treasureSecretCompartment = true;
}

setTimeout(() => {
const {rolls: contentRolls, best: contentBest} = rollD20Neutral();
const contentText = showD20Result(contentRolls, contentBest);

let contentOutcome = '';
let goldGain = 0;

if(contentBest >= 1 && contentBest <= 9) {
contentOutcome = 'The chest is empty. Someone got here first.';
} else if(contentBest >= 10 && contentBest <= 19) {
goldGain = Math.ceil(Math.random() * 10);
contentOutcome = `The chest contains ${goldGain} gold coins!`;
} else {
goldGain = Math.ceil(Math.random() * 10) * S.heroes.length;
contentOutcome = `The chest is filled with ${goldGain} gold coins!`;
}

if(secretFound && contentBest >= 10) {
S.silverKeyHeld = true;
replaceStage1WithStage2('treasurechest');
contentOutcome += ' Inside the secret compartment, you find a small silver key!';
}

const v = document.getElementById('gameView');
if(trapDmg > 0) {
// Show hero selection for trap damage
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="finishChestOpen(${idx}, ${trapDmg}, ${goldGain})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Opening the Chest',
description: `Choose which hero takes ${trapDmg} damage:`,
outcomes: [trapOutcome, `Dice roll: ${trapText}`, contentOutcome, `Dice roll: ${contentText}`],
buttons: heroButtons
});
} else {
// No trap damage, just show results and continue
S.gold += goldGain;
upd();
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Opening the Chest',
outcomes: [trapOutcome, `Dice roll: ${trapText}`, contentOutcome, `Dice roll: ${contentText}`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}, 500);
}

function finishChestOpen(heroIdx, trapDmg, goldGain) {
const hero = S.heroes[heroIdx];
hero.h -= trapDmg;
if(hero.h <= 0 && !hero.ls) {
if(hero.g > 0) {
hero.g--;
hero.h += trapDmg;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
hero.h = 0;
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`);
}
}
toast(`${hero.n} took ${trapDmg} damage!`);

S.gold += goldGain;
upd();
nextFloor();
}

function showTreasureChest2() {
if(!S.silverKeyHeld) {
nextFloor();
return;
}
const goldGain = 10 * S.heroes.length;
S.gold += goldGain;
S.silverKeyHeld = false;
upd();
removeNeutralFromDeck('treasurechest');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest2.png',
title: 'Small Silver Chest',
description: 'A small silver chest sits on a stone pedestal, perfectly sized for the key you found earlier. You insert the key and it opens with a satisfying click.',
outcomes: [`Inside you find ${goldGain} gold coins, perfectly arranged!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 4. MUMBLING WIZARD =====
function showWizard1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'Hieroglyphs on the Wall',
description: 'An elderly wizard stands with arms outstretched toward a wall covered in glowing hieroglyphs. He mutters continuously: "Do you see it? Do you see it? Look closely..."',
buttons: `
<button class="btn risky" onclick="approachWizard()">Approach the wizard</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`
});
}

function approachWizard() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const sigilPool = ['Grapple', 'Heal', 'Ghost', 'Alpha', 'Star', 'Asterisk'];
const randomSigil = sigilPool[Math.floor(Math.random() * sigilPool.length)];
S.wizardSigil = randomSigil;

const v = document.getElementById('gameView');

if(best >= 1 && best <= 10) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText,
outcomes: ['You stare at the glowing symbols but can\'t make sense of them. The wizard sighs heavily: "You don\'t see it. How unfortunate. Please leave."'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else {
const heroesWithSigil = [];
S.heroes.forEach((h, idx) => {
if(h.s.includes(randomSigil) || (h.ts && h.ts.includes(randomSigil))) {
heroesWithSigil.push(idx);
}
});

if(heroesWithSigil.length === 0) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText,
outcomes: [
`The hieroglyph reveals itself as the symbol for ${randomSigil}! The wizard beams with pride.`,
'But when he realizes none of you possess this sigil, his face falls: "Useless! All of you, useless! Get out!"'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else {
let description = `The hieroglyph reveals itself as the symbol for ${randomSigil}! The wizard exclaims: "Yes! YES! You see it! One of you has this power already!" Choose which hero receives the upgrade:`;
let buttons = '';
heroesWithSigil.forEach(idx => {
const h = S.heroes[idx];
const currentLevel = getLevel(randomSigil, idx);
buttons += `<button class="neutral-btn safe" onclick="upgradeWizardSigil(${idx}, '${randomSigil}')">${h.n} - ${sigilIcon(randomSigil)} L${currentLevel} ‚Üí L${currentLevel+1}</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText,
description,
buttons
});
}
}
}

function upgradeWizardSigil(heroIdx, sig) {
const h = S.heroes[heroIdx];
if(!h.ts) h.ts = [];
if(!h.ts.includes(sig) && !h.s.includes(sig)) h.ts.push(sig);

const oldLevel = S.sig[sig] || 0;
S.sig[sig] = oldLevel + 1;

toast(`${sig} temporarily upgraded to L${S.sig[sig]} for ${h.n}!`, 1800);
replaceStage1WithStage2('wizard');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
outcomes: [
`The wizard places his hands on ${h.n}'s head. The hieroglyph glows brighter, and power flows into them!`,
'"Good, good! Now leave me to my studies."'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}, 500);
}

function showWizard2() {
if(!S.wizardSigil) {
nextFloor();
return;
}

const sig = S.wizardSigil;
const heroesWithSigil = [];
S.heroes.forEach((h, idx) => {
if(h.s.includes(sig) || (h.ts && h.ts.includes(sig))) {
heroesWithSigil.push(idx);
}
});

if(heroesWithSigil.length === 0) {
nextFloor();
return;
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: 'Sacrifice for Power',
description: `The wizard channels arcane energy, his eyes glowing with power: "I can make this permanent... but all who carry ${sig} must sacrifice their current mastery. Do you accept?"<br><br><div style="font-size:0.85rem;margin-bottom:1rem;color:#b64141">Cost: All heroes lose ${sig} for THIS RUN ONLY<br>Benefit: ${sig} permanently upgraded in Sigilarium</div>`,
buttons: `
<button class="btn danger" onclick="acceptWizardSacrifice('${sig}')">Accept Sacrifice</button>
<button class="btn" onclick="declineWizardSacrifice()">Decline</button>
`
});
}

function acceptWizardSacrifice(sig) {
S.heroes.forEach(h => {
if(h.s.includes(sig)) h.s = h.s.filter(s => s !== sig);
if(h.ts && h.ts.includes(sig)) h.ts = h.ts.filter(s => s !== sig);
});

S.sig[sig] = (S.sig[sig] || 0) + 1;
toast(`${sig} PERMANENTLY upgraded to L${S.sig[sig]}!`, 1800);
removeNeutralFromDeck('wizard');

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
outcomes: [
`The wizard's ritual completes. All knowledge of ${sig} drains from those who held it, but you feel the power crystallize into something greater.`,
'"The sacrifice strengthens the foundation. Now go."'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function declineWizardSacrifice() {
removeNeutralFromDeck('wizard');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
outcomes: ['The wizard\'s glow fades. He returns to mumbling at the wall, disappointed but unsurprised.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 5. ORACLE =====
function showOracle1() {
// Mark tutorial as seen so future runs have random neutrals
S.tutorialFlags.neutral_intro = true;
const v = document.getElementById('gameView');
let description = 'A figure shrouded in mist sits cross-legged before a crystal sphere. Their voice echoes: "Step forward. I will read your fortune. Power or Life?" Choose a hero and their desired fortune:';
let buttons = '';
S.heroes.forEach((h, idx) => {
buttons += `<button class="neutral-btn risky" onclick="oracleChoose(${idx}, 'POW')">${h.n} - Power (+1‚ö°)</button>`;
buttons += `<button class="neutral-btn safe" onclick="oracleChoose(${idx}, 'HP')">${h.n} - Life (+2‚ù§ max)</button>`;
});
buttons += `<button class="neutral-btn secondary" onclick="nextFloor()">Do Not Engage</button>`;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle1.png',
title: 'Consult the Oracle',
description,
buttons
});
}

function oracleChoose(heroIdx, stat) {
S.oracleHero = heroIdx;
S.oracleStat = stat;

const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);
S.oracleRoll = best;

const h = S.heroes[heroIdx];
let fortune = '';
let stage2Effect = '';

if(best === 1) {
fortune = '"Terrible misfortune awaits you."';
stage2Effect = 'CURSE';
replaceStage1WithStage2('oracle');
} else if(best >= 2 && best <= 9) {
fortune = '"What you hope for shall not come to pass."';
stage2Effect = 'NO UNLOCK';
} else if(best >= 10 && best <= 15) {
fortune = '"Great things in your future, but not what you want."';
stage2Effect = 'OPPOSITE';
replaceStage1WithStage2('oracle');
} else if(best >= 16 && best <= 19) {
fortune = '"Your desired future shall come to pass."';
stage2Effect = 'DESIRED';
replaceStage1WithStage2('oracle');
} else {
fortune = '"It happens before my eyes!"';
stage2Effect = 'IMMEDIATE DOUBLE';
replaceStage1WithStage2('oracle');
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle1.png',
title: 'The Oracle\'s Fortune',
diceRoll: rollText,
outcomes: [
`${h.n} steps forward seeking ${stat === 'POW' ? 'Power' : 'Life'}.`,
`The Oracle gazes into the crystal sphere, then speaks: ${fortune}`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showOracle2() {
if(S.oracleHero === null || S.oracleRoll === null) {
nextFloor();
return;
}

const heroIdx = S.oracleHero;
const stat = S.oracleStat;
const roll = S.oracleRoll;
const h = S.heroes[heroIdx];

let outcome = '';

if(roll === 1) {
// CURSE
if(stat === 'HP') {
h.m = Math.max(1, h.m - 5);
if(h.h > h.m) h.h = h.m;
outcome = `${h.n} feels weaker. Maximum HP reduced by 5!`;
} else {
h.p = Math.max(0, h.p - 1);
outcome = `${h.n} feels their strength fade. POW reduced by 1!`;
}
} else if(roll >= 10 && roll <= 15) {
// OPPOSITE
if(stat === 'HP') {
h.p++;
outcome = `${h.n} gains unexpected Power! POW +1!`;
} else {
h.m += 5;
h.h += 5;
outcome = `${h.n} feels vitality surge! Maximum HP +5!`;
}
} else if(roll >= 16 && roll <= 19) {
// DESIRED
if(stat === 'HP') {
h.m += 5;
h.h += 5;
outcome = `${h.n} feels strengthened! Maximum HP +5!`;
} else {
h.p++;
outcome = `${h.n} feels power awaken! POW +1!`;
}
} else if(roll === 20) {
// IMMEDIATE DOUBLE
if(stat === 'HP') {
h.m += 10;
h.h += 10;
outcome = `${h.n} surges with life force! Maximum HP +10!`;
} else {
h.p += 2;
outcome = `${h.n} blazes with power! POW +2!`;
}
}

removeNeutralFromDeck('oracle');

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle2.png',
title: 'Return to the Oracle',
outcomes: [
`${h.n} returns to the Oracle. The crystal sphere flares brightly!`,
outcome
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 6. ENEMY ENCAMPMENT =====
function showEncampment1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Enemies Assembling Ahead',
description: 'Through a crack in the wall ahead, you spy the enemies from your next encounter preparing for battle. They haven\'t noticed you yet.',
buttons: `
<button class="btn risky" onclick="chooseEncampmentAction('sneak')">Sneak by?</button>
<button class="btn risky" onclick="chooseEncampmentAction('engage')">Engage early</button>
`
});
}

function chooseEncampmentAction(action) {
const v = document.getElementById('gameView');
let buttons = '';
S.heroes.forEach((h, i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
buttons += `<button class="neutral-btn ${action === 'sneak' ? '' : 'risky'}" onclick="${action === 'sneak' ? 'sneakByEncampment' : 'engageEarlyEncampment'}(${i})">${h.n} - ${h.p}‚ö° | ${hp}</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: action === 'sneak' ? 'Choose Scout' : 'Choose Leader',
description: `Which hero will ${action === 'sneak' ? 'sneak past the encampment' : 'lead the charge'}?`,
buttons
});
}

function sneakByEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
if(best >= 1 && best <= 10) {
outcome = `${hero.n}'s foot catches on loose stone! The enemies hear you and prepare an ambush!`;
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 1800);
} else if(best >= 11 && best <= 19) {
outcome = `${hero.n} slips past quietly. The enemies remain unaware.`;
} else {
// Roll 20 - recruit a straggler
const comp = getEnemyComp(S.floor + 1);
const stragglerType = comp[Math.floor(Math.random() * comp.length)];
const base = E[stragglerType];
const effedMultiplier = S.gameMode === 'Effed' ? 5 : 1;
const straggler = {
id: `recruit${Date.now()}`,
n: base.n,
p: base.p * effedMultiplier,
h: base.h * effedMultiplier,
m: base.m * effedMultiplier,
g: base.g,
x: base.x,
s: [],
pool: base.pool,
gainRate: base.gainRate || 3,
turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st: 0,
li: heroIdx,
sh: 0,
alphaActed: false,
recruitedBy: heroIdx,
isRecruit: true
};
// Add permanent sigils
if(base.permSigils) base.permSigils.forEach(ps => straggler.s.push({sig:ps.s, level:ps.l, perm:true}));
// Add start sigils
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
base.startSigils.forEach(ss => straggler.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(straggler, base);
}
}
}
if(!S.recruits) S.recruits = [];
S.recruits.push(straggler);
outcome = `${hero.n} sneaks past perfectly AND discovers a rejected ${base.n} who joins ${hero.n}'s ranks!`;
toast(`${base.n} recruited! Will fight in ${hero.n}'s lane!`, 1800);
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Sneaking Past',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function engageEarlyEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= 1 && best <= 15) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`A scout spots ${hero.n} before they can strike! The enemies prepare an ambush!`],
buttons: `<button class="btn" onclick="finishEncampmentFail()">Continue</button>`
});
} else {
const kills = best === 20 ? 2 : 1;
S.encampmentEarlyKills = kills;
replaceStage1WithStage2('encampment');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`${hero.n} succeeds at picking off ${kills} enem${kills>1?'ies':'y'}! They're scrambling to form ranks - you'll see the battlefield and pick your targets...`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function finishEncampmentFail() {
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 1800);
nextFloor();
}

function startEncampmentCombat(kills) {
const v = document.getElementById('gameView');
const comp = getEnemyComp(S.floor + 1);

let description = `<div style="font-size:0.9rem;margin-bottom:1rem">Select ${kills} enem${kills>1?'ies':'y'} to remove:</div>`;
let buttons = '';

const enemyTypes = {};
comp.forEach(type => {
enemyTypes[type] = (enemyTypes[type] || 0) + 1;
});

Object.keys(enemyTypes).forEach(type => {
const count = enemyTypes[type];
buttons += `<div class="choice" onclick="killEncampmentEnemy('${type}', ${kills})">
<strong>${E[type].n}</strong> <span style="opacity:0.7">(${count} available, ${E[type].g}G + ${E[type].x}XP each)</span>
</div>`;
});

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Choose Enemies to Kill',
description,
buttons
});
}

function killEncampmentEnemy(type, target) {
if(!S.encampmentKilledTypes) S.encampmentKilledTypes = [];
if(!S.encampmentKillsRemaining) S.encampmentKillsRemaining = target;

// Track which enemy type was killed
S.encampmentKilledTypes.push(type);

S.gold += E[type].g;
S.xp += E[type].x;
upd();
toast(`Killed ${E[type].n}! +${E[type].g}G +${E[type].x}XP`);

S.encampmentKillsRemaining--;

if(S.encampmentKillsRemaining <= 0) {
// Combat will be reduced on next floor
replaceStage1WithStage2('encampment');
nextFloor();
} else {
startEncampmentCombat(S.encampmentKillsRemaining);
}
}

function showEncampment2() {
const healAmt = Math.floor(S.heroes[0].m * 0.5);
const goldGain = 2 * S.heroes.length;

S.heroes.forEach(h => {
if(!h.ls) {
h.h = Math.min(h.h + healAmt, h.m);
}
});

S.gold += goldGain;
upd();
toast(`All heroes healed ${healAmt} HP!`, 1200);
toast(`Gained ${goldGain} Gold!`, 1200);

removeNeutralFromDeck('encampment');

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment2.png',
title: 'Abandoned Encampment',
description: 'The enemy got cocky and left their base undefended. You enter and rest safely.',
outcomes: [
`All heroes restored ${healAmt} HP!`,
`Found ${goldGain} Gold in supplies!`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 7. ANCIENT STATUE =====
function showStatue1() {
const deactivated = S.ancientStatueDeactivated;
const v = document.getElementById('gameView');
const outcomes = deactivated ? ['<span style="color:#22c55e">The statue has been deactivated. It poses no threat.</span>'] : [];
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/statue1.png',
title: 'The Statue',
description: `A massive stone statue dominates the chamber. As you watch, it seems to ${deactivated ? 'shift smoothly and gently' : 'grow larger, its surface rippling ominously'}.`,
outcomes,
buttons: `
<button class="btn safe" onclick="nextFloor()">Leave now</button>
<button class="btn risky" onclick="showStatue2()">Remain transfixed</button>
`
});
}

function showStatue2() {
const deactivated = S.ancientStatueDeactivated;
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/statue1.png',
title: 'Growing Larger',
description: `The statue IS getting bigger! The room feels smaller. ${deactivated ? 'It moves smoothly and gently, non-threatening.' : 'Its stone surface creaks as it expands.'}`,
buttons: `
<button class="btn risky" onclick="statueEscape(2)">Make a break for exit</button>
<button class="btn risky" onclick="showStatue3()">Remain transfixed</button>
`
});
}

function showStatue3() {
const deactivated = S.ancientStatueDeactivated;
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/statue1.png',
title: 'Consuming the Room',
description: `The statue now fills most of the room! ${deactivated ? 'Despite its size, it moves with graceful precision.' : 'There\'s still a tight squeeze to the exit...'}`,
buttons: `
<button class="btn risky" onclick="statueEscape(3)">Squeeze out to exit</button>
<button class="btn danger" onclick="showStatue4()">Remain transfixed</button>
`
});
}

function showStatue4() {
const deactivated = S.ancientStatueDeactivated;
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/statue1.png',
title: 'Smooth Metal Pressing - LAST CHANCE',
description: `${deactivated ? 'The statue\'s polished surface gleams as it gently fills the space.' : 'The statue\'s smooth metal presses against the walls and you! This is your last chance to escape!'}`,
buttons: `
<button class="btn danger" onclick="statueEscape(4)">ESCAPE NOW</button>
<button class="btn danger" onclick="showStatue5()">Remain transfixed</button>
`
});
}

function statueEscape(stage) {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);
const deactivated = S.ancientStatueDeactivated;

let outcome = '';
let damage = 0;

if(stage === 2) {
if(best >= 1 && best <= 5) damage = deactivated ? 0 : 1;
else if(best === 20) outcome = 'You can\'t shake the feeling you missed something...';
} else if(stage === 3) {
if(best >= 1 && best <= 9) damage = deactivated ? 0 : 2;
else if(best >= 10 && best <= 19) outcome = 'You escape safely.';
else outcome = 'As you squeeze out, you notice a small black arch in the statue.';
} else if(stage === 4) {
if(best >= 1 && best <= 15) damage = deactivated ? 0 : 3;
else if(best >= 16 && best <= 19) outcome = 'You notice an archway as you escape!';
else {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/statue1.png',
diceRoll: rollText,
outcomes: ['The archway SWALLOWS you! You find yourself inside the statue!'],
buttons: `<button class="btn" onclick="showStatue5()">Continue</button>`
});
return;
}
}

const v = document.getElementById('gameView');
if(damage > 0 && !deactivated) {
// Show hero selection for damage
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="applyStatueEscapeDamage(${idx}, ${damage})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/statue1.png',
title: 'Escaping the Statue',
diceRoll: rollText,
description: `Choose which hero takes ${damage} damage:`,
outcomes: ['You escape but the statue crushes you on the way out!'],
buttons: heroButtons
});
} else {
// No damage or deactivated - show result and continue
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/statue1.png',
title: 'Escaping the Statue',
diceRoll: rollText,
outcomes: [outcome || 'You escape safely!'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function applyStatueEscapeDamage(heroIdx, damage) {
const hero = S.heroes[heroIdx];
hero.h -= damage;
if(hero.h < 0) hero.h = 0;
if(hero.h === 0 && !hero.ls && hero.g > 0) {
hero.g--;
hero.h = hero.m;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else if(hero.h === 0 && !hero.ls) {
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`);
showTutorialPop('last_stand_intro', "Ouch, that stinks. Well, you're not dead yet! While your ally lives, you live - but it looks like your actions are somewhat limited. Be careful though! If you don't get healing soon, you'll slip further and further away...");
}
toast(`${hero.n} took ${damage} damage!`);
upd();
nextFloor();
}

function showStatue5() {
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn" onclick="scaleStatue(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/statue1.png',
title: 'Statue Unfurls',
description: 'The statue stops growing and unfurls like a smooth metal flower. At its center sits a small replica statuette. The smooth metal walls can be scaled. Choose a hero to scale the statue:',
buttons: heroButtons
});
}

function scaleStatue(heroIdx) {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);
const deactivated = S.ancientStatueDeactivated;

const h = S.heroes[heroIdx];
let outcome = '';
let damage = 0;
let getStatuette = false;

if(best === 1) {
outcome = 'TRAP! You trigger a mechanism and plummet!';
damage = deactivated ? 0 : (h.h - 1);
} else if(best >= 2 && best <= 15) {
damage = deactivated ? 0 : 4;
getStatuette = true;
outcome = `You ${damage > 0 ? 'struggle up, taking ' + damage + ' damage, but ' : ''}reach the statuette!`;
} else if(best >= 16 && best <= 19) {
getStatuette = true;
outcome = 'You scale effortlessly and claim the statuette!';
} else {
getStatuette = true;
outcome = 'You scale perfectly AND find the deactivation switch!';
S.ancientStatueDeactivated = true;
toast('Ancient Statue PERMANENTLY deactivated!', 1800);
}

if(damage > 0) {
h.h -= damage;
if(h.h < 1) h.h = 1;
}

if(getStatuette) {
S.hasAncientStatuette = true;
savePermanent();
toast('Ancient Statuette obtained!', 1200);
}

removeNeutralFromDeck('statue');

const v = document.getElementById('gameView');
const outcomes = [outcome];
if(getStatuette) {
outcomes.push('<span style="color:#fbbf24">The Ancient Statuette can be placed on a Pedestal to grant permanent stat upgrades!</span>');
}
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/statue1.png',
title: 'Scaling the Statue',
diceRoll: rollText,
outcomes,
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 8. GHOST =====
function showGhost1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Two Ghostly Boys Want to Play',
description: 'Two translucent boys appear before you, giggling. "Play with us! Play with us!" They reach out with spectral hands.',
buttons: `
<button class="btn danger" onclick="playWithGhostBoys()">Play with the ghost boys</button>
<button class="btn risky" onclick="nextFloor()">Avoid?</button>
`
});
}

let ghostEscapeDC = 18;
let ghostEscapeAttempts = 0;

function playWithGhostBoys() {
ghostEscapeDC = 18;
ghostEscapeAttempts = 0;
attemptGhostEscape();
}

function attemptGhostEscape() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= ghostEscapeDC) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Escaping the Ghost Boys',
diceRoll: rollText,
outcomes: ['You break free from their grip! The boys pout but let you go. "Come back and play sometime..."'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Failed - show hero selection
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="applyGhostDamage(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Trapped with the Ghost Boys',
diceRoll: rollText,
description: 'Choose which hero takes 1 damage:',
outcomes: ['You remain trapped! Time slips away...'],
buttons: heroButtons
});
}

function applyGhostDamage(heroIdx) {
const hero = S.heroes[heroIdx];
const hadGhostCharge = hero.g > 0;

hero.h -= 1;
if(hero.h <= 0) {
hero.h = 0;
if(hero.g > 0) {
hero.g--;
hero.h = hero.m;
// EASTER EGG: Ghost charge consumed during Ghost encounter triggers conversion
if(hadGhostCharge) {
replaceStage1WithStage2('ghost');
toast(`${hero.n} used Ghost charge! The boys realize the truth!`, 1800);
upd();
// Trigger the full Ghost Boys conversion (showGhost2)
showGhost2();
return;
}
} else {
hero.ls = true;
hero.lst = 0;
upd();
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Escaping the Ghost Boys',
outcomes: [
`${hero.n} took 1 damage and entered Last Stand! The shock breaks the ghost boys' hold!`,
'"Oops!" they say in unison, then fade away giggling.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}
}

toast(`${hero.n} took 1 damage!`);
ghostEscapeAttempts++;
ghostEscapeDC -= 2;
upd();

const v = document.getElementById('gameView');

if(ghostEscapeAttempts >= 9) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Finally Free',
outcomes: ['After many attempts, the ghost boys grow bored and fade away.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Try Again',
description: `<div style="font-size:0.9rem;margin:1rem 0">Attempts: ${ghostEscapeAttempts}/9 | Next DC: ${ghostEscapeDC}</div>`,
outcomes: [`${hero.n} took 1 damage!`],
buttons: `<button class="btn danger" onclick="attemptGhostEscape()">Try to Escape (DC ${ghostEscapeDC})</button>`
});
}

function showGhost2() {
S.ghostBoysConverted = true;
toast('Ghost Boys permanently converted to Empty Playroom!', 1800);
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost2.png',
title: 'The Boys Realize the Truth',
description: 'The ghost boys stare at each other, then at their translucent hands. "We\'re... we\'re dead. We\'re ghosts."',
outcomes: [
'Tears form in their spectral eyes. "We want to go home. We want to see Mommy and Daddy."',
'They hold hands and walk toward a light that appears. "Thank you for showing us." They vanish peacefully.',
'<span style="color:#22c55e">This room is now an Empty Playroom - you can pass safely in future runs.</span>'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showEmptyPlayroom() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost2.png',
title: 'Empty Playroom',
description: 'An empty chamber, dust motes drifting in pale light. It might have been a playroom once, but whatever haunted it is long gone. The air feels peaceful.',
outcomes: ['Nothing stops you here. You pass through quietly.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue to Floor ${S.floor + 1}</button>`
});
}

// ===== 9. FLUMMOXED PRINCE(SS) =====
function showPrince1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/prince1.png',
title: 'Help Recover the Ring',
description: `A flummoxed ${S.princeGender} paces anxiously: "Please, you must help! A creature in the next room ate my engagement ring! If you can stun it on the first turn of battle, I can retrieve it!"`,
buttons: `
<button class="btn" onclick="acceptPrinceQuest()">Accept the quest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`
});
}

function acceptPrinceQuest() {
toast('Stun any enemy Turn 1 of next combat!', 1800);
S.princeQuestActive = true;
S.princeQuestCompleted = false;
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/prince1.png',
outcomes: [`The ${S.princeGender} looks hopeful: "Thank you! I'll follow you and grab it when you stun the creature!"`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showPrince2() {
const v = document.getElementById('gameView');
// Check if quest was completed
if(!S.princeQuestCompleted) {
// Quest failed
S.princeQuestActive = false;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/prince1.png',
title: 'Quest Failed',
description: `The ${S.princeGender} returns, dejected: "The creature fled before I could retrieve the ring. I'll have to find another way..."`,
outcomes: [`The ${S.princeGender} departs sadly. No reward.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Quest succeeded - show wedding
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const eligible = allSigils.filter(s => (S.sig[s] || 0) < 4);

eligible.sort((a, b) => {
const costA = S.sig[a] || 0;
const costB = S.sig[b] || 0;
return costA - costB;
});

const sigil1 = eligible[0] || 'Attack';
const sigil2 = eligible[1] || 'Shield';

removeNeutralFromDeck('prince');
replaceStage1WithStage2('prince');
S.princeQuestActive = false;

let buttons = '';
buttons += `<div class="choice" onclick="choosePrinceSigil('${sigil1}')">
<strong>${sigilIcon(sigil1)}</strong> <span style="opacity:0.7">L${S.sig[sigil1] || 0} ‚Üí L${(S.sig[sigil1] || 0) + 1}</span>
</div>`;
buttons += `<div class="choice" onclick="choosePrinceSigil('${sigil2}')">
<strong>${sigilIcon(sigil2)}</strong> <span style="opacity:0.7">L${S.sig[sigil2] || 0} ‚Üí L${(S.sig[sigil2] || 0) + 1}</span>
</div>`;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/prince2.png',
title: 'The Wedding',
description: `The ${S.princeGender} proposes to their beloved. A beautiful wedding ceremony unfolds before you!`,
outcomes: ['Each wears a garment displaying a sigil of power. As thanks for your help, you may choose one:'],
buttons
});
}

function choosePrinceSigil(sig) {
S.sig[sig] = (S.sig[sig] || 0) + 1;
toast(`${sig} permanently upgraded to L${S.sig[sig]}!`, 1800);
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/prince2.png',
outcomes: [`The royal couple thanks you profusely. The ${sig} sigil glows and merges with your power!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== OLD TAPO ENCOUNTER (FLOOR 20) =====
function showOldTapo() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/old-tapo.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #8b5cf6;box-shadow:0 0 20px rgba(139,92,246,0.5)">
<div class="neutral-title" style="color:#8b5cf6;font-size:1.8rem">The Master of Space and Time</div>
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;background:rgba(139,92,246,0.1);border-radius:8px;margin:1rem 0">
"Tapo, you say? Yes‚Ä¶. I was called Tapo once, before I mastered the mysteries of space and time. Save me? Why, I need no saving‚Ä¶ In fact‚Ä¶."
</div>
<button class="btn" onclick="oldTapoTransform()" style="background:linear-gradient(135deg, #8b5cf6, #6366f1);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Continue</button>
</div>`;
}

function oldTapoTransform() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div style="text-align:center;margin:2rem 0">
<div style="font-size:3rem;animation:clap 0.5s ease-in-out 3;margin-bottom:2rem">üëè</div>
<img src="assets/tapo.png" style="max-width:100%;height:auto;max-width:300px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #fbbf24;animation:bounce 1s ease-in-out 3">
<div style="font-size:2.5rem;font-weight:bold;color:#fbbf24;text-shadow:0 0 10px rgba(251,191,36,0.5);margin:2rem 0;animation:glow 1s ease-in-out infinite">
‚ú® Tapo Unlocked! ‚ú®
</div>
<div class="neutral-outcome" style="font-size:1.1rem;margin:1.5rem 0">
Baby Tapo has been added to your hero roster!<br>
<span style="color:#22c55e">Stats: 1 HP / 1 POW</span><br>
<span style="color:#8b5cf6">Starts with ALL active sigils!</span>
</div>
</div>
<button class="btn" onclick="completeTapoUnlock()" style="background:linear-gradient(135deg, #fbbf24, #f59e0b);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Victory!</button>
</div>
<style>
@keyframes clap {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.5); }
}
@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-20px); }
}
@keyframes glow {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}
</style>`;
}

function completeTapoUnlock() {
S.tapoUnlocked = true;
savePermanent();
win();
}

// ===== DEATH SCREEN =====
function showDeathScreen() {
showTutorialPop('death_intro', "First time, huh? Doesn't seem like it's quite your time yet, and I think keeping you alive could be profitable for me. Cash in Gold now for PERMANENT upgrades.");
savePermanent(); // Save gold, goingRate, sig upgrades
// Recruits persist until killed - don't clear here
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];

// Select a random Death quote that hasn't been used yet
let deathQuote = "";
if(S.usedDeathQuotes.length >= DEATH_QUOTES.length) {
// All quotes used - reset the pool
S.usedDeathQuotes = [];
}
const availableQuotes = DEATH_QUOTES.filter((_, idx) => !S.usedDeathQuotes.includes(idx));
if(availableQuotes.length > 0) {
const randomIdx = Math.floor(Math.random() * availableQuotes.length);
deathQuote = availableQuotes[randomIdx];
// Mark this quote as used
const quoteIndex = DEATH_QUOTES.indexOf(deathQuote);
S.usedDeathQuotes.push(quoteIndex);
savePermanent(); // Save the updated usedDeathQuotes
}

let html = `
<div style="background:#2c2416;padding:2rem;border-radius:8px;max-width:800px;margin:0 auto;color:#e8dcc4">
<h1 style="text-align:center;margin-bottom:1rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
${deathQuote ? `<p style="text-align:center;margin-bottom:1rem;font-size:1rem;color:#999;font-style:italic">"${deathQuote}"</p>` : ''}
<p style="text-align:center;margin-bottom:1.5rem;font-size:1.1rem">Gold: <strong>${S.gold}</strong> | Going Rate: <strong>${S.goingRate}G</strong></p>`;

if(S.gold === 0) {
html += `<p style="text-align:center;margin:2rem 0;font-size:1.2rem;color:#dc2626;font-style:italic">"Nothing? Really? Come back when you have something to offer."</p>`;
} else {
html += `<h3 style="margin-bottom:1rem">Upgrade Sigilarium:</h3>`;
html += `<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:0.75rem;margin-bottom:1.5rem">`;

allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
// Actives show their effective level (perm + 1 for display)
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Asterisk', 'Alpha'];
const isActive = actives.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const nextLevel = currentLevel + 1;
if(currentLevel >= 5) return; // Max level (5 for display)

const upgradeCount = S.sigUpgradeCounts[sig] || 0;
const baseCost = S.goingRate;
const escalation = upgradeCount > 0 ? (upgradeCount * 50) : 0;
const cost = baseCost + escalation;

const canAfford = S.gold >= cost;
const colorClass = ['#666', '#1e40af', '#0d9488', '#9333ea', '#d97706', '#ff00ff'][currentLevel];
const nextColorClass = ['#666', '#1e40af', '#0d9488', '#9333ea', '#d97706', '#ff00ff'][nextLevel];

html += `
<div style="background:rgba(255,255,255,0.05);padding:0.75rem;border-radius:6px;border:1px solid rgba(255,255,255,0.1)">
<div style="font-weight:bold;margin-bottom:0.5rem">${sigilIcon(sig)}</div>
<div style="font-size:0.9rem;margin-bottom:0.5rem">
<span style="color:${colorClass}">L${currentLevel}</span> ‚Üí <span style="color:${nextColorClass}">L${nextLevel}</span>
</div>
<div style="font-size:0.85rem;margin-bottom:0.5rem;color:#999">Cost: ${cost}G</div>
<button class="btn" ${!canAfford ? 'disabled style="opacity:0.4"' : ''} onclick="purchaseSigilUpgrade('${sig}', ${cost})" style="padding:0.4rem 0.8rem;font-size:0.85rem">
${canAfford ? 'Purchase' : 'Too Expensive'}
</button>
</div>`;
});

html += `</div>`;
}

// Death Boys (only if Ghost Boys converted)
if(S.ghostBoysConverted) {
html += `
<div style="border-top:2px solid rgba(255,255,255,0.2);padding-top:2rem;margin-top:2rem">
<h2 style="text-align:center;margin-bottom:0.5rem;font-size:1.5rem;color:#a855f7">The Death Boys</h2>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;font-style:italic;opacity:0.8">"We work for Death now! He's WAY cooler than being ghosts!"</p>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-bottom:1.5rem">
<!-- Boy 1: Sell Back -->
<div style="background:rgba(34,197,94,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(34,197,94,0.3)">
<h3 style="color:#22c55e;margin-bottom:0.5rem">Death Boy 1: "Sell Back"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Remove one upgrade level from any sigil and get Gold equal to the current Going Rate (no +5G increase)</p>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G</div>`;

// List all sigils that can be sold back
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Asterisk', 'Alpha'];
allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const canSellBack = permLevel > 0;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIcon(sig)} L${currentLevel}</span>
<button class="btn" ${!canSellBack ? 'disabled style="opacity:0.4"' : ''} onclick="deathBoySellBack('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSellBack ? `Sell for ${S.goingRate}G` : 'Cannot Sell'}
</button>
</div>`;
});

html += `</div>

<!-- Boy 2: Sacrifice for XP -->
<div style="background:rgba(168,85,247,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(168,85,247,0.3)">
<h3 style="color:#a855f7;margin-bottom:0.5rem">Death Boy 2: "Sacrifice"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Sacrifice one upgrade level to gain ${S.goingRate} Starting XP permanently. Going Rate decreases by 5G.</p>
<div style="font-size:0.8rem;margin-bottom:0.5rem;opacity:0.7">Current Starting XP: ${S.startingXP}</div>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G ‚Üí ${Math.max(1, S.goingRate - 5)}G</div>`;

// List all sigils that can be sacrificed
const actives2 = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Asterisk', 'Alpha'];
allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives2.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const canSacrifice = permLevel > 0 && S.goingRate > 1;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIcon(sig)} L${currentLevel}</span>
<button class="btn" ${!canSacrifice ? 'disabled style="opacity:0.4"' : ''} onclick="deathBoySacrifice('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSacrifice ? `+${S.goingRate}XP` : 'Cannot'}
</button>
</div>`;
});

html += `</div>
</div>
</div>`;
}

html += `
<div style="text-align:center;margin-top:2rem">
<button class="btn" onclick="restartAfterDeath()" style="background:#dc2626;font-size:1.2rem;padding:1rem 2rem">I AM DONE DYING</button>
</div>
</div>`;

v.innerHTML = html;
}

function purchaseSigilUpgrade(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }
S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
S.sigUpgradeCounts[sig] = (S.sigUpgradeCounts[sig] || 0) + 1;
S.goingRate += 5;
toast(`${sig} upgraded to L${S.sig[sig]}!`, 1200);
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySellBack(sig) {
const permLevel = S.sig[sig] || 0;
if(permLevel <= 0) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
// Sell back: get gold, lower sigil level, no going rate change
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Asterisk', 'Alpha'];
const isActive = actives.includes(sig);
const oldLevel = isActive ? permLevel + 1 : permLevel;
S.gold += S.goingRate;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
const newPermLevel = S.sig[sig];
const newLevel = isActive ? newPermLevel + 1 : newPermLevel;
toast(`Sold ${sig} L${oldLevel}‚ÜíL${newLevel} for ${S.goingRate}G!`, 1800);
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySacrifice(sig) {
const permLevel = S.sig[sig] || 0;
if(permLevel <= 0) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
if(S.goingRate <= 1) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
// Sacrifice: get starting XP, lower sigil level, decrease going rate
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Asterisk', 'Alpha'];
const isActive = actives.includes(sig);
const oldLevel = isActive ? permLevel + 1 : permLevel;
const xpGained = S.goingRate;
S.startingXP += xpGained;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
S.goingRate = Math.max(1, S.goingRate - 5);
const newPermLevel = S.sig[sig];
const newLevel = isActive ? newPermLevel + 1 : newPermLevel;
toast(`Sacrificed ${sig} L${oldLevel}‚ÜíL${newLevel} for +${xpGained}XP permanently!`, 1800);
savePermanent();
showDeathScreen(); // Refresh
}

function restartAfterDeath() {
// Check if player has unspent gold
if(S.gold >= S.goingRate && !S.tutorialFlags.death_exit_warning) {
showTutorialPop('death_exit_warning', "Are you sure? This is some great value, and you'll end up giving it to me sooner or later...", () => {
// After tutorial, ask for confirmation
if(confirm('Leave Death Screen with unspent gold?')) {
actuallyRestartAfterDeath();
} else {
showDeathScreen();
}
});
return;
}
actuallyRestartAfterDeath();
}

function actuallyRestartAfterDeath() {
// Increment run number
S.runNumber++;
savePermanent();
// Clear run-specific save
localStorage.removeItem('froggle8');
// Reload page to start fresh
location.reload();
}

// ===== CHAMPIONS MENU =====
function showChampionsMenu() {
const v = document.getElementById('gameView');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;

let html = `
<div style="max-width:700px;margin:0 auto;padding:2rem">
<h1 style="text-align:center;margin-bottom:1rem;font-size:2.5rem;background:linear-gradient(135deg,#fbbf24,#f59e0b);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text">
üèÜ Champions of Floor 20 üèÜ
</h1>
<p style="text-align:center;margin-bottom:2rem;font-size:1.1rem;color:#666">You conquered the depths and earned these rewards!</p>

<div style="background:linear-gradient(135deg,rgba(251,191,36,0.1),rgba(245,158,11,0.1));border:3px solid #fbbf24;border-radius:12px;padding:2rem;margin-bottom:1.5rem">
<h2 style="text-align:center;margin-bottom:1rem;font-size:1.5rem">‚ö±Ô∏è Pedestal of Champions</h2>
<p style="text-align:center;margin-bottom:1.5rem;color:#666">Manage your hero figurines (${pedestalCount}/${maxSlots} placed)</p>
<button class="btn" onclick="showPedestal()" style="background:#22c55e;font-size:1.1rem">View Pedestal</button>
</div>

<div style="background:linear-gradient(135deg,rgba(220,38,38,0.1),rgba(127,29,29,0.1));border:3px solid #dc2626;border-radius:12px;padding:2rem;margin-bottom:1.5rem">
<h2 style="text-align:center;margin-bottom:1rem;font-size:1.5rem">üåÄ Portal to Frogged Up Realm</h2>
<p style="text-align:center;margin-bottom:1rem;color:#666">Switch between Standard and Effed Up modes</p>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem">
Current Mode: <strong style="color:${S.gameMode === 'Effed' ? '#dc2626' : '#22c55e'}">${S.gameMode === 'Standard' ? 'Standard' : 'EFFED UP üî•'}</strong>
</p>
<button class="btn" onclick="toggleModeFromChampions()" style="background:${S.gameMode === 'Effed' ? '#22c55e' : '#dc2626'};font-size:1.1rem">
Enter ${S.gameMode === 'Standard' ? 'Effed Up Realm üî•' : 'Standard Realm'}
</button>
</div>

<div style="text-align:center;margin-top:2rem">
<button class="btn secondary" onclick="title()">Back to Title</button>
</div>
</div>`;

v.innerHTML = html;
}

function toggleModeFromChampions() {
S.gameMode = S.gameMode === 'Standard' ? 'Effed' : 'Standard';
showChampionsMenu();
}

// ===== PEDESTAL UI =====
function showPedestal() {
const v = document.getElementById('gameView');
const heroes = ['Warrior', 'Tank', 'Mage', 'Healer'];
const heroIcons = {'Warrior': '‚öî', 'Tank': 'üõ°', 'Mage': 'üìñ', 'Healer': '‚úö'};
const stats = ['POW', 'HP'];

// Count available figurines (earned from victories, not yet slotted)
const availableFigurines = {};
heroes.forEach(hero => {
availableFigurines[hero] = {POW: 0, HP: 0};
});

let html = `
<div style="max-width:700px;margin:0 auto">
<h2 style="text-align:center;margin-bottom:0.5rem">Pedestal - ${S.gameMode} Mode</h2>
<p style="text-align:center;margin-bottom:2rem;font-size:0.9rem;color:#666">Place figurines to grant permanent stat buffs</p>

<div style="background:#f5f5f5;padding:1.5rem;border-radius:8px;border:2px solid #000">
<table style="width:100%;border-collapse:separate;border-spacing:8px">
<thead>
<tr>
<th style="width:80px"></th>`;

// Column headers (hero icons) - monochrome and engraved
heroes.forEach(hero => {
html += `<th style="text-align:center;font-size:1.5rem"><span style="filter:grayscale(1) contrast(999);opacity:0.8;display:inline-block">${heroIcons[hero]}</span><div style="font-size:0.75rem;font-weight:normal;margin-top:0.25rem">${hero}</div></th>`;
});

html += `</tr></thead><tbody>`;

// Each row (POW, HP)
stats.forEach(stat => {
html += `<tr><td style="text-align:right;font-weight:bold;padding-right:1rem">${stat}</td>`;

heroes.forEach(hero => {
const slotted = S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
const isSlotted = !!slotted;

html += `<td style="text-align:center">
<div style="width:80px;height:80px;margin:0 auto;background:${isSlotted ? '#fbbf24' : '#fff'};border:2px solid #000;border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative" onclick="${isSlotted ? `removeFigurine('${hero}','${stat}')` : `slotFigurine('${hero}','${stat}')`}">`;

if(isSlotted) {
const displayIcon = slotted.source === 'statuette' ? 'üóø' : heroIcons[hero];
const iconStyle = 'font-size:2rem;' + (slotted.source === 'statuette' ? 'filter:grayscale(1) contrast(1.2);' : 'filter:grayscale(1) contrast(999);');
html += `<div style="${iconStyle}">${displayIcon}</div>
<div style="position:absolute;top:2px;right:4px;font-size:0.7rem;background:#000;color:#fff;padding:2px 4px;border-radius:3px">${stat === 'POW' ? '+1' : '+5'}</div>`;
} else {
html += `<div style="font-size:1.5rem;color:#ccc">+</div>`;
}

html += `</div></td>`;
});

html += `</tr>`;
});

html += `</tbody></table>
</div>

${S.hasAncientStatuette ? `<div style="margin-top:1.5rem;padding:1rem;background:rgba(251,191,36,0.1);border-radius:6px;text-align:center">
<p style="font-weight:bold;margin-bottom:0.5rem">üóø Ancient Statuette Available!</p>
<p style="font-size:0.9rem;color:#666">The Ancient Statuette can be placed in any slot</p>
</div>` : ''}

<div style="text-align:center;margin-top:2rem">
<button class="btn secondary" onclick="showChampionsMenu()">Back to Champions</button>
</div>
</div>`;

v.innerHTML = html;
}

function slotFigurine(hero, stat) {
// Check if slot is available
if(S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode)) {
toast('Slot already filled!');
return;
}

// Check if we have 8 slots filled
const slotsUsed = S.pedestal.filter(p => p.mode === S.gameMode).length;
if(slotsUsed >= 8) {
toast('All 8 slots filled! Remove a figurine first.');
return;
}

// Use Ancient Statuette if available (can go in any slot)
if(S.hasAncientStatuette) {
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'statuette'});
S.hasAncientStatuette = false;
savePermanent();
toast(`Ancient Statuette placed on ${hero} ${stat}!`, 1800);
showPedestal();
return;
}

// Otherwise, check if this hero can have a figurine (max 2 per hero per mode)
const existingCount = S.pedestal.filter(p => p.hero === hero && p.mode === S.gameMode).length;
if(existingCount >= 2) {
toast(`${hero} already has 2 figurines in ${S.gameMode} mode!`, 1800);
return;
}

// Place the hero figurine
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'hero'});
savePermanent();
toast(`${hero} ${stat} figurine placed!`, 1800);
showPedestal();
}

function removeFigurine(hero, stat) {
const idx = S.pedestal.findIndex(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
if(idx >= 0) {
S.pedestal.splice(idx, 1);
savePermanent();
toast(`${hero} ${stat} figurine removed!`);
showPedestal();
}
}

// ===== WIN =====
function win() {
// Gold is lost on victory (reset to 0)
S.gold = 0;
savePermanent();

// Award figurines for heroes who survived (HP > 0, not Last Stand)
const survivedHeroes = S.heroes.filter(h => h.h > 0 && !h.ls);
const earnedFigurines = [];
survivedHeroes.forEach(h => {
// Check if this hero already has 2 figurines for this mode
const existingCount = S.pedestal.filter(slot => slot.hero === h.n && slot.mode === S.gameMode).length;
if(existingCount < 2) {
earnedFigurines.push(h.n);
}
});

// Unlock Effed Up mode if Standard victory
const firstStandardVictory = S.gameMode === 'Standard' && !S.tutorialFlags.first_victory_sequence;
if(S.gameMode === 'Standard') {
S.effedUnlocked = true;
if(firstStandardVictory) {
S.tutorialFlags.first_victory_sequence = true;
}
}

const firstFU = S.gameMode === 'Effed' && !S.tutorialFlags.first_fu_victory;
if(firstFU) {
S.tutorialFlags.first_fu_victory = true;
// Note: Tapo is now unlocked at Floor 20 via Old Tapo encounter
}

savePermanent();

// Store earned figurines for later display
window.earnedFigurines = earnedFigurines;

// FIRST STANDARD VICTORY: Show cutscene
if(firstStandardVictory) {
showFirstVictoryCutscene();
return;
}

// FIRST FU VICTORY: Show credits
if(firstFU) {
showFUVictoryCredits();
return;
}

// TAPO IN PARTY: Show heartfelt thank you (only if Tapo is alive)
const tapoInParty = S.heroes.some(h => h.n === 'Tapo' && h.h > 0 && !h.ls);
if(tapoInParty && !S.tutorialFlags.tapo_victory_message) {
S.tutorialFlags.tapo_victory_message = true;
savePermanent();
showTapoVictoryMessage();
return;
}

// SUBSEQUENT VICTORIES: Go directly to Pedestal if figurines earned
if(earnedFigurines.length > 0 || S.hasAncientStatuette) {
showStatueRoom();
return;
}

// No figurines earned: show simple victory screen
showSimpleVictoryScreen();
}

function showFirstVictoryCutscene() {
const slides = [
{text: "After 20 grueling floors, your heroes finally found him - Tapo the Tadpole, happily playing with a collection of strange glowing figurines!"},
{text: "The little tadpole squeaked excitedly as the heroes approached. Around him lay scattered statues - each one depicting a heroic frog warrior."},
{text: "The heroes carefully gathered the mysterious figurines. As they held them, the statues pulsed with magical energy..."},
{text: "They found an ancient pedestal nearby, covered in glowing runes. Instinctively, they placed the figurines upon it - and felt power surge through them!"},
{text: "With Tapo safely in the Warrior's arms and their new treasures secured, the heroes stepped back through the portal..."},
{text: "The portal deposited them back in Ribbleton's square. The townspeople erupted in cheers as the heroes emerged victorious!"},
{text: "Exhausted but triumphant, the heroes decided to rest and celebrate their victory. They set Tapo down for just a moment..."},
{text: "But when they turned around... Tapo was gone! The portal behind them shimmered ominously. That mischievous little tadpole must have hopped back through!"}
];

slides.onComplete = () => {
if(window.earnedFigurines && window.earnedFigurines.length > 0) {
showStatueRoom();
} else {
showSimpleVictoryScreen();
}
};

showNarrativeSlide(slides, 0);
}

function showFUVictoryCredits() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="max-width:600px;margin:2rem auto;padding:2rem;background:linear-gradient(135deg,#1e1b4b 0%,#7c2d12 100%);border-radius:12px;border:3px solid #fbbf24;color:#fff">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem">üî• EFFED UP MODE CONQUERED! üî•</h1>

<div style="text-align:center;margin-bottom:2rem;font-size:1.2rem;line-height:1.8">
<p>You defeated the hardest challenge in FROGGLE.</p>
<p>I genuinely did not think anyone would beat this.</p>
<p style="margin-top:2rem;font-style:italic">Thank you for playing.</p>
<p style="font-size:2rem;margin:2rem 0">‚ù§Ô∏è</p>
</div>

<div style="background:rgba(0,0,0,0.3);padding:1.5rem;border-radius:8px;margin:2rem 0">
<h3 style="text-align:center;margin-bottom:1rem;color:#fbbf24">FROGGLE</h3>
<div style="text-align:center;font-size:0.9rem;line-height:2;opacity:0.9">
<p>A game by Preston Wesner</p>
<p>Design, Art, & Code: Preston</p>
<p>Playtesting: [Your Name Here]</p>
<p>Inspiration: Slay the Spire, Balatro, and too much coffee</p>
<p style="margin-top:1.5rem;font-style:italic">Made with love in 2024</p>
</div>
</div>

<div style="background:rgba(251,191,36,0.2);padding:1.5rem;border-radius:8px;margin:2rem 0;border:2px solid #fbbf24">
<h3 style="text-align:center;margin-bottom:1rem">üéâ TAPO UNLOCKED! üéâ</h3>
<img src="assets/tapo.png" style="max-width:200px;height:auto;display:block;margin:1rem auto;border-radius:8px">
<p style="text-align:center;margin-top:1rem">Tapo the Tadpole is now available as a playable hero!</p>
<p style="text-align:center;font-size:0.9rem;opacity:0.8;margin-top:0.5rem">Stats: 1 POW, 1 HP ‚Ä¢ Has access to ALL sigils in the Sigilarium</p>
<p style="text-align:center;font-size:0.85rem;opacity:0.6;margin-top:0.5rem;font-style:italic">(Glass cannon mode activated)</p>
</div>

<div style="text-align:center">
<button class="btn" onclick="showStatueRoom()" style="background:#22c55e;padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem">Place Figurines</button>
<button class="btn" onclick="title()" style="padding:1rem 2rem;font-size:1.1rem">Play Again</button>
</div>
</div>`;
}

function showTapoVictoryMessage() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="max-width:700px;margin:2rem auto;padding:3rem;background:linear-gradient(135deg,#22c55e 0%,#10b981 50%,#059669 100%);border-radius:16px;border:4px solid #fbbf24;color:#fff;box-shadow:0 8px 32px rgba(0,0,0,0.3)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:3rem;text-shadow:2px 2px 4px rgba(0,0,0,0.3)">üèÜ VICTORY! üèÜ</h1>

<div style="text-align:center;margin:2rem 0">
<img src="assets/tapo.png" style="max-width:250px;height:auto;display:block;margin:0 auto 2rem auto;border-radius:12px;border:3px solid #fbbf24;box-shadow:0 4px 16px rgba(0,0,0,0.3);animation:bounce 2s ease-in-out infinite">
</div>

<div style="background:rgba(0,0,0,0.2);padding:2rem;border-radius:12px;margin:2rem 0;border:2px solid rgba(251,191,36,0.5)">
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
Holy frog. I can't believe you put this much time into my silly little game.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
From the bottom of my heart, thank you for playing.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;font-weight:500">
I hope you had fun!
</p>
<p style="text-align:center;font-size:1.1rem;margin-top:2rem;font-style:italic;opacity:0.9">
-Preston
</p>
</div>

<div style="text-align:center;font-size:2.5rem;margin:2rem 0">
‚ù§Ô∏èüê∏‚ù§Ô∏è
</div>

<div style="text-align:center;margin-top:2rem">
${window.earnedFigurines && window.earnedFigurines.length > 0 ?
  '<button class="btn" onclick="showStatueRoom()" style="background:#fbbf24;color:#000;padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem;font-weight:bold">Place Figurines</button><br>' :
  ''}
<button class="btn" onclick="title()" style="background:#fff;color:#22c55e;padding:1rem 2rem;font-size:1.1rem;font-weight:bold">Play Again</button>
</div>
</div>`;
}

function showStatueRoom() {
// This redirects to the existing Pedestal UI
showTutorialPop('pedestal_first_placement', "Welcome to the Pedestal! Place figurines to permanently boost your heroes. Each hero can have 2 figurines (one POW, one HP) per mode.", () => {
showPedestal();
});
}

function showSimpleVictoryScreen() {
const v = document.getElementById('gameView');
let html = `
<h1 style="text-align:center;margin:2rem 0;font-size:2.5rem">üèÜ VICTORY! üèÜ</h1>`;

if(S.gameMode === 'Effed') {
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1.2rem">You conquered the Effed Up realm once again!<br>Impressive.</p>`;
} else {
html += `<img src="assets/tapo.png" style="max-width:100%;height:auto;max-width:400px;margin:1rem auto;display:block;border-radius:8px;border:3px solid #000">`;
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1.2rem;font-weight:bold">You saved Tapo the Tadpole!</p>`;
}

if(window.earnedFigurines && window.earnedFigurines.length > 0) {
html += `<div style="background:rgba(251,191,36,0.1);padding:1rem;border-radius:8px;margin:1rem auto;max-width:500px">
<h3 style="text-align:center;margin-bottom:0.5rem">üèÜ Hero Figurines Earned! üèÜ</h3>
<p style="text-align:center">The following heroes can place figurines:</p>
<ul style="list-style:none;padding:0;text-align:center">`;
window.earnedFigurines.forEach(name => {
html += `<li style="margin:0.5rem 0;font-weight:bold">${name}</li>`;
});
html += `</ul></div>`;
}

html += `<div style="text-align:center;margin-top:2rem">
<button class="btn" onclick="title()" style="padding:1rem 2rem;font-size:1.1rem">Play Again</button>
</div>`;

v.innerHTML = html;
}

// ===== DEBUG MODE =====
function toggleDebugMode(enabled) {
S.debugMode = enabled;
toast(enabled ? 'Debug Mode ON' : 'Debug Mode OFF', 1200);
// Update debug button visibility in header
const debugBtn = document.getElementById('debugBtn');
if(debugBtn) debugBtn.style.display = enabled ? 'block' : 'none';
// Refresh settings menu if open to show/hide debug tools button
const settingsMenu = document.querySelector('[style*="z-index:30000"]');
if(settingsMenu) {
closeSettingsMenu();
showSettingsMenu();
}
}

function showDebugMenu() {
const inCombat = S.enemies && S.enemies.length > 0;
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha'];
const heroNames = S.heroes.map((h, i) => ({name: h.n, idx: i}));

let html = `
<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);border:3px solid #fbbf24;border-radius:12px;padding:2rem;z-index:30000;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
<h2 style="text-align:center;color:#fbbf24;margin-bottom:1.5rem">üõ†Ô∏è DEBUG MENU üõ†Ô∏è</h2>

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Resources</h3>
<button class="btn" onclick="debugAddGold()" style="margin-bottom:0.5rem;background:#22c55e">+100 Gold</button>
<button class="btn" onclick="debugAddXP()" style="margin-bottom:0.5rem;background:#22c55e">+100 XP</button>

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Navigation</h3>
<div style="margin:0.5rem 0">
<label style="color:white;font-size:0.9rem">Jump to Floor:</label>
<input type="number" id="debugFloorInput" min="1" max="19" value="${S.floor}" style="width:60px;padding:0.25rem;margin:0 0.5rem;font-size:1rem">
<button class="btn" onclick="debugJumpFloor()" style="display:inline-block;width:auto;padding:0.5rem 1rem;margin:0;font-size:0.9rem;min-height:auto">Go</button>
</div>

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Sigil Levels</h3>
<div style="margin:0.5rem 0">
<select id="debugSigilSelect" style="padding:0.25rem;margin-right:0.5rem;font-size:0.9rem">
${allSigils.map(sig => `<option value="${sig}">${sig} (L${S.sig[sig] || 0})</option>`).join('')}
</select>
<input type="number" id="debugSigilLevel" min="0" max="5" value="1" style="width:50px;padding:0.25rem;margin:0 0.5rem;font-size:1rem">
<button class="btn" onclick="debugSetSigilLevel()" style="display:inline-block;width:auto;padding:0.5rem 1rem;margin:0;font-size:0.9rem;min-height:auto">Set</button>
</div>

${heroNames.length > 0 ? `
<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Hero Stats</h3>
<div style="margin:0.5rem 0">
<select id="debugHeroSelect" style="padding:0.25rem;margin-bottom:0.5rem;font-size:0.9rem;width:100%">
${heroNames.map(h => `<option value="${h.idx}">${h.name} (POW:${S.heroes[h.idx].p}, HP:${S.heroes[h.idx].h}/${S.heroes[h.idx].m})</option>`).join('')}
</select>
<div style="display:flex;gap:0.5rem;margin-bottom:0.5rem">
<div style="flex:1">
<label style="color:white;font-size:0.85rem;display:block">POW:</label>
<input type="number" id="debugHeroPOW" min="1" max="20" value="1" style="width:100%;padding:0.25rem;font-size:1rem">
</div>
<div style="flex:1">
<label style="color:white;font-size:0.85rem;display:block">Max HP:</label>
<input type="number" id="debugHeroMaxHP" min="1" max="50" value="5" style="width:100%;padding:0.25rem;font-size:1rem">
</div>
</div>
<button class="btn" onclick="debugSetHeroStats()" style="background:#3b82f6;margin-bottom:0.5rem">Update Hero Stats</button>
</div>
` : ''}

${inCombat ? `
<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Combat</h3>
<button class="btn" onclick="debugDealDamage()" style="background:#dc2626">Deal 50 DMG to Enemy</button>
` : ''}

<button class="btn" onclick="closeDebugMenu()" style="margin-top:1rem;background:#888">Close</button>
</div>
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:29999" onclick="closeDebugMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeDebugMenu() {
// Remove debug menu elements
const menus = document.querySelectorAll('[style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

// ===== SETTINGS MENU =====
function showSettingsMenu() {
const v = document.getElementById('gameView');
const inGame = S.heroes && S.heroes.length > 0;

let html = `
<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);border:3px solid #3b82f6;border-radius:12px;padding:2rem;z-index:30000;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
<h2 style="text-align:center;color:#3b82f6;margin-bottom:1.5rem">‚öôÔ∏è SETTINGS ‚öôÔ∏è</h2>

${inGame ? `
<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Game</h3>
<button class="btn" onclick="manualSave()" style="margin-bottom:0.5rem;background:#22c55e">üíæ Save Game</button>
` : ''}

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Display</h3>
<label style="display:flex;align-items:center;cursor:pointer;user-select:none;color:white;background:rgba(255,255,255,0.1);padding:0.75rem;border-radius:6px;margin-bottom:0.5rem">
<input type="checkbox" ${S.toastLogVisible ? 'checked' : ''} onchange="toggleToastLogVisibility(this.checked)" style="margin-right:0.5rem;transform:scale(1.2)">
<span>Show Toast Log</span>
</label>
<label style="display:flex;align-items:center;cursor:pointer;user-select:none;color:white;background:rgba(255,255,255,0.1);padding:0.75rem;border-radius:6px;margin-bottom:0.5rem">
<input type="checkbox" ${!S.helpTipsDisabled ? 'checked' : ''} onchange="toggleHelpTips(this.checked)" style="margin-right:0.5rem;transform:scale(1.2)">
<span>üí° Show Help/Tips</span>
</label>

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Reference</h3>
<button class="btn" onclick="showSigilarium()" style="margin-bottom:0.5rem;background:#9333ea">üìñ View Sigilarium</button>

<h3 style="color:#fbbf24;margin:1rem 0 0.5rem 0">Debug</h3>
<label style="display:flex;align-items:center;cursor:pointer;user-select:none;color:white;background:rgba(255,255,255,0.1);padding:0.75rem;border-radius:6px;margin-bottom:0.5rem">
<input type="checkbox" ${S.debugMode ? 'checked' : ''} onchange="toggleDebugMode(this.checked)" style="margin-right:0.5rem;transform:scale(1.2)">
<span>üõ†Ô∏è Enable Debug Mode</span>
</label>
${S.debugMode ? `<button class="btn" onclick="closeSettingsMenu();showDebugMenu()" style="margin-bottom:0.5rem;background:#fbbf24">üõ†Ô∏è Open Debug Tools</button>` : ''}

<button class="btn" onclick="closeSettingsMenu()" style="margin-top:1rem;background:#888">Close</button>
</div>
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:29999" onclick="closeSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeSettingsMenu() {
const menus = document.querySelectorAll('[style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

function manualSave() {
saveGame();
toast('Game Saved!', 1200);
closeSettingsMenu();
}

function toggleHelpTips(enabled) {
S.helpTipsDisabled = !enabled;
// If turning ON, reset all tutorial flags so they show again
if(enabled) {
S.tutorialFlags = {};
toast('Help/Tips enabled! All tips reset and will show again.', 2000);
} else {
toast('Help/Tips disabled. No more popups!', 1200);
}
savePermanent();
}

function showSigilarium() {
closeSettingsMenu();
const v = document.getElementById('gameView');
const activeSigils = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const passiveSigils = ['Star', 'Expand', 'Asterisk'];

const getLevelColor = (level) => {
if(level === 0) return '#666';
if(level === 1) return '#1e40af';
if(level === 2) return '#0d9488';
if(level === 3) return '#9333ea';
if(level === 4) return '#d97706';
return '#ff0080'; // L5 gradient
};

let html = `
<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(#fff,#f7f1e3);border:3px solid #9333ea;border-radius:12px;padding:2rem;z-index:30000;max-width:600px;width:90%;max-height:80vh;overflow-y:auto">
<h2 style="text-align:center;color:#9333ea;margin-bottom:1rem">üìñ SIGILARIUM üìñ</h2>
<p style="text-align:center;font-size:0.9rem;opacity:0.8;margin-bottom:1.5rem">All Sigils and Their Permanent Upgrade Levels</p>

<!-- Active Sigils -->
<h3 style="color:#2c63c7;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #2c63c7;padding-bottom:0.25rem">‚öîÔ∏è Active Sigils</h3>
<div style="display:grid;gap:0.75rem;margin-bottom:1.5rem">
`;

activeSigils.forEach(sig => {
const level = S.sig[sig] || 0;
const effectiveLevel = level === 0 ? 1 : level;
const cl = effectiveLevel===0?'l0':effectiveLevel===1?'l1':effectiveLevel===2?'l2':effectiveLevel===3?'l3':effectiveLevel===4?'l4':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(effectiveLevel);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl}" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Permanent Level: <span style="color:${levelColor};font-weight:bold">L${level}</span></div>
${level === 0 ? '<div style="font-size:0.75rem;color:#22c55e;font-style:italic">Starts at L1 when equipped</div>' : ''}
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>

<!-- Passive Sigils -->
<h3 style="color:#9333ea;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #9333ea;padding-bottom:0.25rem">‚ú® Passive Sigils</h3>
<div style="display:grid;gap:0.75rem">
`;

passiveSigils.forEach(sig => {
const level = S.sig[sig] || 0;
const cl = level===0?'l0':level===1?'l1':level===2?'l2':level===3?'l3':level===4?'l4':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(level);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl}" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Permanent Level: <span style="color:${levelColor};font-weight:bold">L${level}</span></div>
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>
<button class="btn" onclick="closeSigilarium()" style="margin-top:1.5rem;background:#9333ea;width:100%">Close</button>
</div>
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:29999" onclick="closeSigilarium()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeSigilarium() {
const menus = document.querySelectorAll('[style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

function debugAddGold() {
S.gold += 100;
upd();
toast('Added 100 Gold!', 1200);
closeDebugMenu();
}

function debugAddXP() {
S.xp += 100;
upd();
toast('Added 100 XP!', 1200);
closeDebugMenu();
}

function debugJumpFloor() {
const input = document.getElementById('debugFloorInput');
const targetFloor = parseInt(input.value);
if(targetFloor < 1 || targetFloor > 19 || isNaN(targetFloor)) {
toast('Invalid floor! Must be 1-19', 1200);
return;
}
closeDebugMenu();
S.floor = targetFloor;
upd();
startFloor(targetFloor);
toast(`Jumped to Floor ${targetFloor}!`, 1200);
}

function debugDealDamage() {
if(!S.enemies || S.enemies.length === 0) {
toast('No enemies in combat!', 1200);
return;
}
// Deal 50 damage to first enemy
const enemy = S.enemies[0];
enemy.h -= 50;
if(enemy.h < 0) enemy.h = 0;
upd();
toast(`Dealt 50 damage to ${enemy.n}!`, 1200);
closeDebugMenu();
// Check if combat is over
setTimeout(() => checkCombatOver(), 100);
}

function debugSetSigilLevel() {
const sigilSelect = document.getElementById('debugSigilSelect');
const levelInput = document.getElementById('debugSigilLevel');
const sigil = sigilSelect.value;
const newLevel = parseInt(levelInput.value);

if(isNaN(newLevel) || newLevel < 0 || newLevel > 5) {
toast('Invalid level! Must be 0-5', 1200);
return;
}

S.sig[sigil] = newLevel;
savePermanent();
upd();
toast(`Set ${sigil} to Level ${newLevel}!`, 1200);
closeDebugMenu();
}

function debugSetHeroStats() {
const heroSelect = document.getElementById('debugHeroSelect');
const powInput = document.getElementById('debugHeroPOW');
const maxHPInput = document.getElementById('debugHeroMaxHP');
const heroIdx = parseInt(heroSelect.value);
const newPOW = parseInt(powInput.value);
const newMaxHP = parseInt(maxHPInput.value);

if(isNaN(newPOW) || newPOW < 1 || newPOW > 20) {
toast('Invalid POW! Must be 1-20', 1200);
return;
}
if(isNaN(newMaxHP) || newMaxHP < 1 || newMaxHP > 50) {
toast('Invalid Max HP! Must be 1-50', 1200);
return;
}

const hero = S.heroes[heroIdx];
hero.p = newPOW;
hero.m = newMaxHP;
// Also set current HP to max HP for convenience
hero.h = newMaxHP;
saveGame();
upd();
toast(`Updated ${hero.n}: POW=${newPOW}, HP=${newMaxHP}!`, 1200);
closeDebugMenu();
render();
}

// ===== INIT =====
window.onload = () => {
console.log('[FROGGLE] window.onload fired');
loadPermanent(); // Always load permanent data first
console.log('[FROGGLE] loadPermanent complete, S.runNumber:', S.runNumber, 'S.helpTipsDisabled:', S.helpTipsDisabled);
initToastLog(); // Initialize toast log UI
mainTitlePage();
console.log('[FROGGLE] mainTitlePage called');
};

// Global error handler for image loading failures
window.addEventListener('error', (e) => {
if(e.target && e.target.tagName === 'IMG') {
console.error('[FROGGLE] IMAGE LOAD FAILED:', e.target.src);
console.error('[FROGGLE] Current location:', window.location.href);
console.error('[FROGGLE] Image path:', e.target.getAttribute('src'));
} else if(e.message) {
console.error('[FROGGLE] JAVASCRIPT ERROR:', e.message);
console.error('[FROGGLE] File:', e.filename, 'Line:', e.lineno, 'Col:', e.colno);
console.error('[FROGGLE] Stack:', e.error ? e.error.stack : 'No stack trace');
}
}, true);

// Catch unhandled promise rejections
window.addEventListener('unhandledrejection', (e) => {
console.error('[FROGGLE] UNHANDLED PROMISE REJECTION:', e.reason);
});
</script>
</body>
</html>