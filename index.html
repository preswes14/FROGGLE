<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="apple-mobile-web-app-title" content="FROGGLE"/>
<meta name="theme-color" content="#22c55e"/>
<link rel="manifest" href="manifest.json"/>
<link rel="apple-touch-icon" href="assets/tapo-icon-180.png"/>
<link rel="icon" type="image/png" href="assets/tapo-icon.png"/>
<title>FROGGLE v9.992</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body { font-family: -apple-system, sans-serif; background: #d9cab1; color: #1c1b19; position: fixed; width: 100%; height: 100%; overflow: hidden; }

/* Landscape orientation enforcement for mobile */
@media (max-width: 768px) and (orientation: portrait) {
  #rotatePrompt {
    display: flex !important;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
    z-index: 999999;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    padding: 2rem;
  }
  #gameView {
    display: none !important;
  }
  .header {
    display: none !important;
  }
}

@media (min-width: 769px), (orientation: landscape) {
  #rotatePrompt {
    display: none !important;
  }
}

.rotate-icon {
  font-size: 4rem;
  margin-bottom: 1.5rem;
  animation: rotatePhone 2s ease-in-out infinite;
}

@keyframes rotatePhone {
  0%, 100% { transform: rotate(0deg); }
  25% { transform: rotate(-15deg); }
  75% { transform: rotate(15deg); }
}

@keyframes portalPulse {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 0 20px rgba(220, 38, 38, 0.8);
  }
  50% {
    transform: scale(1.08);
    box-shadow: 0 0 40px rgba(220, 38, 38, 1), 0 0 60px rgba(220, 38, 38, 0.6);
  }
}

@keyframes portalGlow {
  0%, 100% {
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8)) drop-shadow(0 0 15px rgba(220, 38, 38, 0.8));
  }
  50% {
    filter: drop-shadow(0 2px 8px rgba(0,0,0,0.9)) drop-shadow(0 0 30px rgba(220, 38, 38, 1));
  }
}

.rotate-message {
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.rotate-submessage {
  font-size: 1rem;
  opacity: 0.9;
  text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

/* Z-INDEX LAYERING REFERENCE:
 * 999999 - Rotate device prompt
 * 30000 - Settings/Debug menus
 * 29999 - Settings/Debug backdrops
 * 25000 - Tooltips
 * 20000 - Tutorial modal backdrops
 * 20 - Hero selection click regions
 * 10 - Hero selection cards
 * Base (0-1) - Normal game elements
 */
.header { padding: 0.5rem; background: linear-gradient(#fff, #f7f1e3); border-bottom: 2px solid #bda; display: flex; justify-content: space-between; font-size: 0.8rem; }
.game-area { height: calc(100vh - 44px); overflow-y: auto; padding: 0.5rem; -webkit-overflow-scrolling: touch; }
.game-area.fade-out { animation: fadeOut 0.2s ease forwards; }
.game-area.fade-in { animation: fadeIn 0.2s ease forwards; }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
.btn { padding: 1rem; border: 3px solid #000; border-radius: 16px; background: #2c63c7; color: white; font-weight: bold; font-size: 1.1rem; min-height: 56px; width: 100%; margin-bottom: 0.75rem; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 12px rgba(0,0,0,0.15); transition: all 0.15s ease; }
.btn:hover { transform: translateY(-2px); box-shadow: 0 6px 0 rgba(0,0,0,0.3), 0 8px 16px rgba(0,0,0,0.2); }
.btn:focus-visible { outline: 3px solid #3b82f6; outline-offset: 2px; }
.btn:active { transform: translateY(4px) scale(0.98); opacity: 0.9; box-shadow: 0 0 0 rgba(0,0,0,0.3), 0 2px 6px rgba(0,0,0,0.15); }
.btn.primary { background: #2c63c7; } /* Default blue */
.btn.safe { background: #22c55e; }
.btn.risky { background: #f97316; }
.btn.danger { background: #dc2626; }
.btn.secondary { background: #6b7280; }
.btn.disabled {
  opacity: 0.4;
  cursor: not-allowed;
  pointer-events: none;
}

/* Size variants */
.btn.small {
  padding: 0.5rem 0.75rem;
  font-size: 0.9rem;
  min-height: 40px;
}

.btn.large {
  padding: 1.5rem;
  font-size: 1.3rem;
  min-height: 70px;
}
.choice { border: 3px solid #000; padding: 1rem; margin-bottom: 0.75rem; border-radius: 16px; background: white; min-height: 60px; width: 100%; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.2), 0 6px 12px rgba(0,0,0,0.1); transition: all 0.15s ease; }
.choice:hover { transform: translateY(-2px); background: #f9f9f9; box-shadow: 0 6px 0 rgba(0,0,0,0.2), 0 8px 16px rgba(0,0,0,0.15); }
.choice:focus-visible { outline: 3px solid #3b82f6; outline-offset: 2px; }
.choice:active { transform: translateY(4px) scale(0.98); background: #f0f0f0; box-shadow: 0 0 0 rgba(0,0,0,0.2), 0 2px 6px rgba(0,0,0,0.1); }
.neutral-btn { padding: 0.5rem 0.75rem; margin-bottom: 0.5rem; border: 2px solid #000; border-radius: 14px; background: white; font-weight: bold; cursor: pointer; font-size: 0.9rem; box-shadow: 0 3px 0 rgba(0,0,0,0.3), 0 4px 8px rgba(0,0,0,0.15); transition: all 0.15s ease; }
.neutral-btn:hover { transform: translateY(-1px); opacity: 0.95; box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 10px rgba(0,0,0,0.2); }
.neutral-btn:focus-visible { outline: 3px solid #3b82f6; outline-offset: 2px; }
.neutral-btn:active { transform: translateY(3px) scale(0.98); opacity: 0.9; box-shadow: 0 0 0 rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.15); }
.neutral-btn.safe { background: #22c55e; color: white; }
.neutral-btn.risky { background: #f97316; color: white; }
.neutral-btn.danger { background: #dc2626; color: white; }
.neutral-btn.secondary { background: #6b7280; color: white; }
.neutral-container {
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: row;
  background: #1a1a1a;
}
.neutral-left {
  flex: 0 0 50%;
  max-width: 50%;
  display: flex;
  flex-direction: column;
  padding: 1rem;
  overflow-y: auto;
  background: #1a1a1a;
}
.neutral-right {
  flex: 0 0 50%;
  max-width: 50%;
  height: auto;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-color: #2a2a2a;
}
@media (min-width: 768px) {
  .neutral-left {
    padding: 1.5rem;
  }
}
@media (min-width: 1400px) {
  .neutral-left {
    padding: 2rem;
  }
}
.neutral-header {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 1rem;
}
.neutral-stats {
  background: rgba(255,255,255,0.1);
  color: white;
  border-radius: 6px;
  padding: 0.4rem 0.75rem;
  font-size: 0.85rem;
  font-weight: bold;
  width: fit-content;
}
.neutral-narrative {
  background: rgba(255,255,255,0.05);
  color: white;
  border-radius: 8px;
  padding: 0.75rem;
  border: 1px solid rgba(255,255,255,0.1);
}
.neutral-title { font-size: 1.2rem; font-weight: bold; margin-bottom: 0.5rem; color: #60a5fa; }
.neutral-desc { font-size: 0.9rem; line-height: 1.4; margin-bottom: 0.5rem; }
.neutral-outcome { font-size: 0.85rem; padding: 0.5rem; background: rgba(255,255,255,0.15); border-radius: 4px; margin-bottom: 0.5rem; }
.neutral-content {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}
.neutral-footer {
  margin-top: auto;
  padding-top: 1rem;
}
.dice-roll { font-size: 1.2rem; font-weight: bold; text-align: center; padding: 1rem; background: #2c63c7; color: white; border-radius: 6px; margin: 1rem 0; }
/* Combat layout */
.combat-grid { display: flex; gap: 0.75rem; margin-bottom: 1rem; justify-content: center; }
.column { display: flex; flex-direction: column; gap: 0.5rem; align-items: center; }
.column.heroes { flex: 0 0 auto; }
.column.enemies { flex: 0 0 auto; }
.combat-lane {
  background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
  border: 4px solid #000;
  border-radius: 10px;
  padding: 1rem;
  margin: 0 auto 2rem auto;
  max-width: 800px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255,255,255,0.2);
  position: relative;
}
.combat-lane:not(:last-child)::after {
  content: '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ';
  position: absolute;
  bottom: -2rem;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(0,0,0,0.4);
  font-size: 1.2rem;
  letter-spacing: -2px;
  text-align: center;
  width: 100%;
  text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}
.card { width: auto; max-width: 160px; border: 3px solid #000; border-radius: 8px; padding: 0.5rem; min-height: 70px; font-size: 0.85rem; position: relative; }
.card.hero { background: #2c63c7; color: white; width: 160px; border-radius: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
.card.enemy { background: #b64141; color: white; width: 160px; }
.card.active { box-shadow: 0 0 0 4px gold; animation: pulse-glow 1s infinite; }
.card.selectable { cursor: pointer; box-shadow: 0 0 0 3px #22c55e; }
.card.selectable:active { transform: scale(0.98); }
.card.targetable { cursor: pointer; }
.card.targetable:active { transform: scale(0.98); }
.card.targeted { box-shadow: 0 0 0 4px lime; }
.card.acted { opacity: 0.6; }
.card.last-stand {
  border-color: #dc2626;
  box-shadow: 0 0 0 3px #dc2626;
  animation: pulse-last-stand 1.5s ease-in-out infinite;
}
.card.hero.targetable { box-shadow: 0 0 0 3px #3b82f6; }
.card.enemy.targetable { box-shadow: 0 0 0 3px #dc2626; }
.card.hero.targeted { box-shadow: 0 0 0 4px #60a5fa; }
.card.enemy.targeted { box-shadow: 0 0 0 4px #ef4444; }
.card.hero-selectable { transition: transform 0.15s ease, box-shadow 0.15s ease; }
.card.hero-selectable:hover { transform: scale(1.02); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
.card.hit-flash { animation: damage-stagger 0.4s ease !important; }
.card.attack-slide { animation: attack-slide 0.48s ease !important; }
.card.heal-flash { animation: heal-flash 0.48s ease !important; }
.card.shield-flash { animation: shield-flash 0.48s ease !important; }
@keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 0 4px gold; } 50% { box-shadow: 0 0 0 8px gold; } }
@keyframes pulse-last-stand {
  0%, 100% { box-shadow: 0 0 0 3px #dc2626, 0 0 15px rgba(220, 38, 38, 0.6); border-color: #dc2626; }
  50% { box-shadow: 0 0 0 6px #dc2626, 0 0 25px rgba(220, 38, 38, 0.9); border-color: #ef4444; }
}
@keyframes pulse-text {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.85; transform: scale(1.05); }
}
@keyframes damage-stagger {
  0% { transform: translateX(0) scale(1); filter: brightness(1); }
  15% { transform: translateX(-15px) scale(0.95); filter: brightness(2) saturate(2); background-color: rgba(220, 38, 38, 0.5); }
  30% { transform: translateX(8px) scale(0.97); filter: brightness(1.8) saturate(2); background-color: rgba(220, 38, 38, 0.4); }
  50% { transform: translateX(-5px) scale(0.98); filter: brightness(1.5) saturate(1.5); background-color: rgba(220, 38, 38, 0.2); }
  70% { transform: translateX(2px) scale(0.99); filter: brightness(1.2); background-color: rgba(220, 38, 38, 0.1); }
  100% { transform: translateX(0) scale(1); filter: brightness(1); background-color: transparent; }
}
@keyframes attack-slide {
  0% { transform: translateX(0) scale(1); }
  15% { transform: translateX(5px) scale(1.08); }
  40% { transform: translateX(25px) scale(1.1); }
  60% { transform: translateX(25px) scale(1.1); }
  80% { transform: translateX(5px) scale(1.02); }
  100% { transform: translateX(0) scale(1); }
}
@keyframes heal-flash {
  0% { filter: brightness(1); transform: scale(1); }
  15% { filter: brightness(1.5) saturate(1.5); transform: scale(1.03); background-color: rgba(34, 197, 94, 0.3); }
  30% { filter: brightness(2) saturate(2) hue-rotate(20deg); transform: scale(1.05); background-color: rgba(34, 197, 94, 0.4); box-shadow: 0 0 25px rgba(34, 197, 94, 0.9); }
  50% { filter: brightness(1.8) saturate(2) hue-rotate(15deg); transform: scale(1.05); background-color: rgba(34, 197, 94, 0.3); box-shadow: 0 0 20px rgba(34, 197, 94, 0.8); }
  70% { filter: brightness(1.4) saturate(1.3); transform: scale(1.02); background-color: rgba(34, 197, 94, 0.2); }
  100% { filter: brightness(1); transform: scale(1); background-color: transparent; box-shadow: none; }
}
@keyframes shield-flash {
  0% { filter: brightness(1); transform: scale(1); }
  15% { filter: brightness(1.3) grayscale(0.2); transform: scale(1.02); background-color: rgba(156, 163, 175, 0.3); }
  30% { filter: brightness(1.6) grayscale(0.4); transform: scale(1.04); background-color: rgba(156, 163, 175, 0.45); box-shadow: 0 0 25px rgba(156, 163, 175, 0.9); }
  50% { filter: brightness(1.5) grayscale(0.3); transform: scale(1.04); background-color: rgba(156, 163, 175, 0.4); box-shadow: 0 0 20px rgba(156, 163, 175, 0.8); }
  70% { filter: brightness(1.2) grayscale(0.1); transform: scale(1.01); background-color: rgba(156, 163, 175, 0.2); }
  100% { filter: brightness(1); transform: scale(1); background-color: transparent; box-shadow: none; }
}
@keyframes heal-cross-fade {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
  50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
}
/* Bonus turn stack visuals for Asterisk/Alpha */
.bonus-turn-stack {
  position: absolute;
  top: 0;
  right: -5px;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: -1;
}
.bonus-turn-card {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  background: #3b82f6;
  border: 3px solid #f97316;
  border-radius: 8px;
  opacity: 0.7;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.bonus-turn-card.sliding-out {
  animation: stack-slide-out 0.3s ease forwards;
}
@keyframes stack-slide-out {
  0% { transform: translate(0, 0); opacity: 0.7; }
  100% { transform: translate(50px, -20px); opacity: 0; }
}
.sigil-row { display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; margin-top: 4px; max-width: 100%; max-height: 70px; overflow: hidden; }
.sigil-row.compact { gap: 2px; max-height: 60px; }
.sigil-row.compact .sigil { padding: 2px 4px; font-size: 0.65rem; min-height: 20px; border-width: 2px; }
.sigil-divider { width: 100%; height: 1px; background: rgba(255,255,255,0.3); margin: 4px 0; }
.sigil { border: 3px solid; border-radius: 6px; padding: 4px 8px; font-size: 0.85rem; display: inline-block; margin: 2px; min-height: 28px; font-weight: 900; background: transparent; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
.sigil.passive { border: none; opacity: 0.85; }
.sigil.clickable { cursor: pointer; }
.sigil.clickable:active { transform: scale(0.95); }
.sigil.active-action { box-shadow: 0 0 12px #3b82f6; animation: pulse-action 0.8s infinite; }
.sigil.l0 { color: #666; border-color: #666; opacity: 0.6; }
.sigil.l0 img { filter: brightness(0) saturate(100%) opacity(0.4); }
.sigil.l1 { color: #000; border-color: #000; }
.sigil.l1 img { filter: brightness(0) saturate(100%); }
.sigil.l2 { color: #0d9488; border-color: #0d9488; }
.sigil.l2 img { filter: sepia(100%) saturate(300%) hue-rotate(140deg) brightness(0.8); }
.sigil.l3 { color: #9333ea; border-color: #9333ea; }
.sigil.l3 img { filter: sepia(100%) saturate(500%) hue-rotate(260deg) brightness(0.7); }
.sigil.l4 { color: #f97316; border-color: #f97316; text-shadow: 0 0 8px rgba(249,115,22,0.4); }
.sigil.l4 img { filter: sepia(100%) saturate(300%) hue-rotate(10deg) brightness(1.1); }
.sigil.l5 {
  background: linear-gradient(90deg, #ff0080, #ff8c00, #40e0d0, #ff0080);
  background-size: 300% 100%;
  animation: rainbow-shift 3s linear infinite;
  border: 2px solid;
  border-image: linear-gradient(90deg, #ff0080, #ff8c00, #40e0d0, #ff0080) 1;
  color: white;
  text-shadow: 0 0 12px rgba(255,255,255,0.8), 0 0 24px rgba(255,0,128,0.6);
  font-weight: bold;
}
.sigil.l5 img { filter: brightness(0) invert(1) drop-shadow(0 0 4px rgba(255,0,128,0.8)); }
@keyframes rainbow-shift {
  0% { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}
.sigil.engraved { color: #6b7280; border-color: #9ca3af; font-style: italic; opacity: 0.7; background: rgba(107,114,128,0.1); }
.sigil.asterisk-primed { box-shadow: 0 0 8px #a855f7; animation: pulse-asterisk 1s infinite; }
@keyframes pulse-asterisk { 0%, 100% { box-shadow: 0 0 8px #a855f7; } 50% { box-shadow: 0 0 16px #a855f7; } }
@keyframes pulse-action { 0%, 100% { box-shadow: 0 0 12px #3b82f6; } 50% { box-shadow: 0 0 20px #3b82f6; } }
.toast { position: fixed; bottom: 20px; right: 20px; background: linear-gradient(#fff, #f7f1e3); border: 2px solid #bda; border-radius: 6px; padding: 1rem 1.5rem; font-weight: bold; box-shadow: 0 4px 12px rgba(0,0,0,0.2); opacity: 0; transform: translateY(20px); transition: all 0.3s; z-index: 10000; max-width: 80%; }
.toast.show { opacity: 1; transform: translateY(0); }
.toast-log { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: linear-gradient(#fff, #f7f1e3); border: 3px solid #22c55e; border-radius: 8px; padding: 0.75rem; max-width: 400px; width: 90%; box-shadow: 0 8px 24px rgba(0,0,0,0.3); z-index: 9999; display: none; }
.toast-log.show { display: block; }
.toast-log-header { font-weight: bold; font-size: 0.85rem; margin-bottom: 0.25rem; padding: 0.25rem 0.5rem; display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
.toast-log-toggle { font-size: 1rem; }
.toast-log-entries { max-height: 200px; overflow-y: auto; font-size: 0.8rem; }
.toast-log-entry { padding: 0.4rem 0.5rem; border-top: 1px solid rgba(0,0,0,0.1); }
.toast-log-entry:first-child { border-top: none; }
.toast-log-entry.recent { font-weight: bold; }
.turn-locked { pointer-events: none; opacity: 0.7; }
.tutorial-modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 20000; display: flex; align-items: center; justify-content: center; }
.tutorial-modal { background: linear-gradient(#fff, #e8f5e9); border: 4px solid #22c55e; border-radius: 12px; padding: 2rem; max-width: 600px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); text-align: center; }
.tutorial-modal h2 { margin-top: 0; color: #6b4423; }
.tutorial-modal p { margin: 1rem 0; font-size: 1.1rem; line-height: 1.6; }
.tutorial-modal button { margin-top: 1.5rem; padding: 0.75rem 2rem; font-size: 1.1rem; font-weight: bold; background: #22c55e; color: #fff; border: 2px solid #15803d; border-radius: 8px; cursor: pointer; }
.tutorial-modal button:hover { background: #15803d; }
.tutorial-modal button:active { transform: scale(0.98); }
.choice.disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }
.tooltip { position: fixed; z-index: 25000; background: rgba(0,0,0,0.95); color: #fff; padding: 1rem; border-radius: 8px; border: 2px solid #3b82f6; max-width: 320px; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
.tooltip.show { opacity: 1; }
.tooltip-green { background: rgba(34,197,94,0.85) !important; border-color: #22c55e !important; }
.tooltip-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem; color: #60a5fa; }
.tooltip-desc { font-size: 0.9rem; line-height: 1.4; }

/* Tablet improvements (768px-1023px) */
@media (min-width: 768px) {
  /* Base scaling for tablet */
  .header {
    font-size: 0.95rem;
    padding: 0.75rem 1rem;
  }

  .game-area {
    padding: 1rem;
    height: calc(100vh - 52px);
  }

  /* Cards medium scaling */
  .card {
    width: 180px !important;
    max-width: 180px;
    padding: 0.75rem;
    min-height: 85px;
    font-size: 0.95rem;
  }
  .card.hero { width: 180px; }
  .card.enemy { width: 180px; }

  /* Combat grid spacing */
  .combat-grid {
    gap: 1rem;
  }
  .column {
    gap: 0.75rem;
  }

  /* Combat lane */
  .combat-lane {
    padding: 1.25rem;
    max-width: 900px;
  }

  /* Sigils medium */
  .sigil {
    font-size: 0.95rem;
    padding: 5px 10px;
    min-height: 32px;
  }
  .sigil-row {
    gap: 6px;
  }

  /* Buttons */
  .btn {
    font-size: 1.2rem;
    padding: 1.1rem;
    min-height: 60px;
  }

  .choice {
    font-size: 1.1rem;
    padding: 1.1rem;
    min-height: 65px;
  }

  .neutral-btn {
    font-size: 1rem;
    padding: 0.6rem 0.9rem;
  }

  /* Toast notifications */
  .toast {
    font-size: 1rem;
    padding: 1.25rem 1.75rem;
    max-width: 500px;
  }

  .toast-log {
    max-width: 480px;
    font-size: 0.9rem;
  }

  /* Tooltips */
  .tooltip {
    max-width: 380px;
    padding: 1.25rem;
  }
  .tooltip-title {
    font-size: 1.2rem;
  }
  .tooltip-desc {
    font-size: 1rem;
  }
}

/* Desktop improvements (1024px+) - Premium experience */
@media (min-width: 1024px) {
  /* Header scaling */
  .header {
    font-size: 1.1rem;
    padding: 1rem 1.5rem;
    height: 56px;
  }

  .header button {
    font-size: 0.85rem !important;
    padding: 0.4rem 0.75rem !important;
  }

  .game-area {
    padding: 1.5rem;
    height: calc(100vh - 56px);
  }

  /* Hero and Enemy Cards - Much larger on desktop */
  .card {
    width: 220px !important;
    max-width: 220px;
    padding: 1rem;
    min-height: 110px;
    font-size: 1.1rem;
    border-width: 4px;
  }
  .card.hero { width: 220px; }
  .card.enemy { width: 220px; }

  /* Hero/enemy images larger */
  .card img {
    width: 64px !important;
    height: 64px !important;
  }

  /* Card text scaling */
  .card > div {
    font-size: 1rem !important;
  }
  .card > div:first-child {
    font-size: 1.2rem !important;
    margin-bottom: 0.5rem !important;
  }

  /* Combat grid - More spacious */
  .combat-grid {
    gap: 1.5rem;
    padding: 1rem 0;
  }

  .column {
    gap: 1rem;
  }

  /* Combat lane - Use more screen */
  .combat-lane {
    padding: 1.5rem 2rem;
    max-width: 1200px;
    margin-bottom: 3rem;
  }

  .combat-lane:not(:last-child)::after {
    font-size: 1.5rem;
    bottom: -2.5rem;
  }

  /* Sigils - Properly sized for desktop */
  .sigil {
    font-size: 1.1rem;
    padding: 6px 12px;
    min-height: 38px;
    border-width: 3px;
    margin: 3px;
  }

  .sigil img {
    height: 1.4em !important;
  }

  .sigil-row {
    gap: 8px;
    margin-top: 8px;
    max-height: 100px;
  }

  .sigil-row.compact {
    gap: 4px;
    max-height: 90px;
  }
  .sigil-row.compact .sigil {
    font-size: 0.85rem;
    padding: 4px 6px;
    min-height: 28px;
  }

  .sigil-divider {
    margin: 6px 0;
  }

  /* Buttons - Desktop appropriate */
  .btn {
    padding: 1.25rem 2rem;
    font-size: 1.4rem;
    min-height: 70px;
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 1rem;
    display: block;
    border-width: 4px;
  }

  .choice {
    padding: 1.25rem 2rem;
    font-size: 1.3rem;
    min-height: 75px;
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 1rem;
    display: block;
    border-width: 4px;
  }

  .neutral-btn {
    padding: 0.75rem 1.25rem;
    font-size: 1.15rem;
    border-width: 3px;
    margin-bottom: 0.75rem;
  }

  /* Neutral screens - Desktop scaling */
  .neutral-stats {
    font-size: 1.05rem;
    padding: 0.6rem 1rem;
  }

  .neutral-title {
    font-size: 1.5rem;
    margin-bottom: 0.75rem;
  }

  .neutral-desc {
    font-size: 1.1rem;
    line-height: 1.5;
  }

  .neutral-outcome {
    font-size: 1rem;
    padding: 0.75rem;
  }

  /* Dice roll */
  .dice-roll {
    font-size: 1.5rem;
    padding: 1.25rem;
  }

  /* Toast notifications */
  .toast {
    font-size: 1.15rem;
    padding: 1.5rem 2rem;
    max-width: 600px;
    bottom: 40px;
    right: 40px;
    border-width: 3px;
  }

  .toast-log {
    max-width: 600px;
    padding: 1rem;
  }

  .toast-log-header {
    font-size: 1rem;
    padding: 0.4rem 0.75rem;
  }

  .toast-log-toggle {
    font-size: 1.2rem;
  }

  .toast-log-entries {
    font-size: 0.95rem;
    max-height: 320px;
  }

  .toast-log-entry {
    padding: 0.5rem 0.75rem;
  }

  /* Tutorial modal */
  .tutorial-modal {
    padding: 2.5rem;
    max-width: 750px;
    border-width: 5px;
  }

  .tutorial-modal h2 {
    font-size: 1.8rem;
  }

  .tutorial-modal p {
    font-size: 1.25rem;
    line-height: 1.7;
  }

  .tutorial-modal button {
    padding: 1rem 2.5rem;
    font-size: 1.25rem;
    border-width: 3px;
  }

  /* Tooltips */
  .tooltip {
    max-width: 450px;
    padding: 1.5rem;
    border-width: 3px;
  }

  .tooltip-title {
    font-size: 1.3rem;
    margin-bottom: 0.75rem;
  }

  .tooltip-desc {
    font-size: 1.1rem;
    line-height: 1.5;
  }
}

/* Large Desktop improvements (1440px+) - Even more premium */
@media (min-width: 1440px) {
  /* Use even more screen real estate */
  .combat-lane {
    max-width: 1400px;
    padding: 2rem 2.5rem;
  }

  /* Cards can be even larger */
  .card {
    width: 240px !important;
    max-width: 240px;
    padding: 1.25rem;
    min-height: 120px;
    font-size: 1.15rem;
  }
  .card.hero { width: 240px; }
  .card.enemy { width: 240px; }

  /* Images scale up */
  .card img {
    width: 72px !important;
    height: 72px !important;
  }

  /* More generous spacing */
  .combat-grid {
    gap: 2rem;
  }

  .column {
    gap: 1.25rem;
  }

  /* Buttons use more width */
  .btn, .choice {
    max-width: 800px;
  }

  /* Larger game area padding */
  .game-area {
    padding: 2rem;
  }

  /* Neutral encounters - Scale up for large desktop */
  .neutral-stats {
    font-size: 1.2rem;
    padding: 0.75rem 1.25rem;
  }

  .neutral-title {
    font-size: 1.75rem;
    margin-bottom: 1rem;
  }

  .neutral-desc {
    font-size: 1.25rem;
    line-height: 1.6;
  }

  .neutral-outcome {
    font-size: 1.15rem;
    padding: 1rem;
  }

  .neutral-btn {
    padding: 1rem 1.5rem;
    font-size: 1.3rem;
    margin-bottom: 1rem;
  }

  .dice-roll {
    font-size: 1.75rem;
    padding: 1.5rem;
  }
}

/* Ultra-wide Desktop (1920px+) */
@media (min-width: 1920px) {
  .combat-lane {
    max-width: 1600px;
  }

  /* Cards at maximum size */
  .card {
    width: 260px !important;
    max-width: 260px;
  }
  .card.hero { width: 260px; }
  .card.enemy { width: 260px; }

  .btn, .choice {
    max-width: 900px;
  }

  /* Neutral encounters - Maximum scale for ultra-wide */
  .neutral-stats {
    font-size: 1.3rem;
    padding: 0.85rem 1.5rem;
  }

  .neutral-title {
    font-size: 2rem;
    margin-bottom: 1.25rem;
  }

  .neutral-desc {
    font-size: 1.4rem;
    line-height: 1.65;
  }

  .neutral-outcome {
    font-size: 1.25rem;
    padding: 1.25rem;
  }

  .neutral-btn {
    padding: 1.15rem 1.75rem;
    font-size: 1.45rem;
    margin-bottom: 1.25rem;
  }

  .dice-roll {
    font-size: 2rem;
    padding: 1.75rem;
  }
}

/* Dynamic element classes for inline styles */
.card-image {
  width: 48px;
  height: 48px;
  border-radius: 4px;
}

.card-emoji {
  text-align: center;
  font-size: 2rem;
  margin-bottom: 0.25rem;
}

.card-stats {
  text-align: center;
  font-size: 0.8rem;
  margin-top: 0.25rem;
}

.combat-header {
  text-align: center;
  font-weight: bold;
  padding: 0.75rem;
  background: rgba(0,0,0,0.05);
  border-radius: 6px;
  margin-bottom: 0.75rem;
}

.combat-header-title {
  font-size: 1.1rem;
  color: #dc2626;
}

.combat-header-subtitle {
  font-size: 0.85rem;
  margin-top: 0.25rem;
}

.combat-header-info {
  font-size: 0.75rem;
  opacity: 0.8;
  margin-top: 0.25rem;
}

.section-label {
  text-align: center;
  font-weight: bold;
  padding: 0.25rem;
  background: rgba(0,0,0,0.1);
  border-radius: 6px;
  margin-bottom: 0.5rem;
  font-size: 0.85rem;
}

.empty-slot {
  text-align: center;
  font-size: 0.75rem;
  padding: 0.5rem;
  opacity: 0.5;
  font-style: italic;
  margin-bottom: 0.5rem;
}

/* Tablet scaling for dynamic elements */
@media (min-width: 768px) {
  .card-image {
    width: 56px;
    height: 56px;
  }

  .card-emoji {
    font-size: 2.25rem;
  }

  .card-stats {
    font-size: 0.9rem;
  }

  .combat-header {
    padding: 1rem;
  }

  .combat-header-title {
    font-size: 1.25rem;
  }

  .combat-header-subtitle {
    font-size: 0.95rem;
  }

  .combat-header-info {
    font-size: 0.85rem;
  }

  .section-label {
    font-size: 0.95rem;
    padding: 0.35rem;
  }

  .empty-slot {
    font-size: 0.85rem;
  }
}

/* Desktop scaling for dynamic elements */
@media (min-width: 1024px) {
  .card-image {
    width: 64px;
    height: 64px;
  }

  .card-emoji {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
  }

  .card-stats {
    font-size: 1rem;
    margin-top: 0.35rem;
  }

  .combat-header {
    padding: 1.25rem;
  }

  .combat-header-title {
    font-size: 1.4rem;
  }

  .combat-header-subtitle {
    font-size: 1.05rem;
    margin-top: 0.35rem;
  }

  .combat-header-info {
    font-size: 0.95rem;
  }

  .section-label {
    font-size: 1.05rem;
    padding: 0.5rem 0.75rem;
  }

  .empty-slot {
    font-size: 0.95rem;
    padding: 0.75rem;
  }
}

/* Large desktop scaling */
@media (min-width: 1440px) {
  .card-image {
    width: 72px;
    height: 72px;
  }

  .card-emoji {
    font-size: 2.75rem;
  }

  .card-stats {
    font-size: 1.1rem;
  }

  .combat-header-title {
    font-size: 1.5rem;
  }

  .combat-header-subtitle {
    font-size: 1.15rem;
  }
}

/* Ultra-wide desktop */
@media (min-width: 1920px) {
  .card-image {
    width: 80px;
    height: 80px;
  }

  .card-emoji {
    font-size: 3rem;
  }
}
</style>
</head>
<body>
<!-- Rotate device prompt (only shows on mobile in portrait) -->
<div id="rotatePrompt" style="display:none;">
<div class="rotate-icon">üì±‚ÜíüîÑ</div>
<div class="rotate-message">Please Rotate Your Device</div>
<div class="rotate-submessage">FROGGLE plays best in landscape mode</div>
</div>

<div class="header" id="gameHeader">
<div>Floor <span id="floor">1</span> | Round <span id="round">1</span></div>
<div style="display:flex;gap:0.25rem">
<button onclick="showSigilarium()" style="padding:0.25rem 0.5rem;background:#9333ea;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer">üåÄ</button>
<button onclick="toggleToastLog()" style="padding:0.25rem 0.5rem;background:#22c55e;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer">ü™µ</button>
<button onclick="showFAQ()" style="padding:0.25rem 0.5rem;background:#f97316;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer">‚ùì</button>
<button onclick="showSettingsMenu()" style="padding:0.25rem 0.5rem;background:#3b82f6;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer">‚öôÔ∏è</button>
<div id="debugBtn" style="display:none"><button onclick="showDebugMenu()" style="padding:0.25rem 0.5rem;background:#3b82f6;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer">üõ†Ô∏è</button></div>
</div>
<div><span id="gold">0</span>G | <span id="xp">0</span>XP</div>
</div>
<div class="game-area" id="gameView"></div>
<script>
// ===== VERSION CHECK =====
const GAME_VERSION = '9.992';
console.log(`%cüê∏ FROGGLE v${GAME_VERSION} LOADED`, 'color: #22c55e; font-size: 20px; font-weight: bold;');
console.log('%cIf you see a different version in the UI, clear your cache and reload!', 'color: #f97316; font-weight: bold;');

// ===== GAME DATA =====
// Hero images
const HERO_IMAGES = {
        warrior: 'assets/characters/warriorfull.png',
        tank: 'assets/characters/tankfull.png',
        mage: 'assets/characters/magefull.png',
        healer: 'assets/characters/healerfull.png',
        tapo: 'assets/characters/tapofull.png'
    };

// Death's dialogue lines (cycles through without repeating until all used)
const DEATH_QUOTES = [
    "Some days you're the sticky tongue, some days you're the fly.",
    "You must really like pain. Or do you like death? Weirdo.",
    "Next time bring me a smoothie or something",
    "Hey, have you met those ghost boys in the dungeon? I can't get them to make.. you know.. the transition. Help them out, would you?",
    "Death death lemonade, 'round the coroner I parade",
    "Ribbit? Ribbbbbit? Rib bit?",
    "Oh man, a classic green. You just know he's a jumper.",
    "Hello my baby, hello my honey.",
    "If you refuse me, honey you'll lose me",
    "You guys should check out the Discovery Channel to see what normal frogs do",
    "Toadally froggin died, huh?"
];

const H = {
warrior: {n:'Warrior', p:2, h:5, m:5, s:['Attack','D20']},
tank: {n:'Tank', p:1, h:10, m:10, s:['Attack','Shield','D20']},
mage: {n:'Mage', p:1, h:5, m:5, s:['Attack','D20','Expand']},
healer: {n:'Healer', p:1, h:5, m:5, s:['Attack','Heal','D20','Expand']},
tapo: {n:'Tapo', p:1, h:1, m:1, s:['Attack','Shield','Heal','Grapple','D20','Alpha','Ghost','Expand','Star','Asterisk']}
};

const E = {
fly: { n:'Fly', p:1, h:2, m:2, goldDrop:0, x:1, pool:[], gainRate:999 },
goblin: { n:'Goblin', p:1, h:5, m:5, goldDrop:1, x:2, pool:['Asterisk','Expand','Shield'], gainRate:3 },
wolf: { n:'Wolf', p:2, h:5, m:5, goldDrop:2, x:4, pool:['Asterisk','Expand','Shield','Grapple','Alpha'], gainRate:2 },
orc: { n:'Orc', p:3, h:10, m:10, goldDrop:3, x:6, pool:['Asterisk','Expand','Shield','Grapple','Alpha','Heal','Ghost','Attack2','Shield2'], gainRate:2, startSigils:1 },
giant: { n:'Giant', p:4, h:12, m:12, goldDrop:6, x:12, pool:'ANY', gainRate:1, startSigils:[{s:'Shield',l:1}] },
caveTroll: { n:'Cave Troll', p:5, h:15, m:15, goldDrop:5, x:15, pool:'ANY', gainRate:1, startSigils:1 },
dragon: { n:'Dragon', p:5, h:25, m:25, goldDrop:10, x:25, pool:'ANY_ADVANCED', gainRate:1, drawsPerTurn:2, permSigils:[{s:'Attack',l:2},{s:'Expand',l:5}], startSigils:2 }
};

// Enemy emoji icons
const ENEMY_EMOJI = {
'Fly': 'ü™∞',
'Goblin': 'üë∫',
'Wolf': 'üê∫',
'Orc': 'üëπ',
'Giant': 'üóø',
'Cave Troll': 'üëπ',
'Dragon': 'üêâ'
};

// Sigil icons - now using extracted PNG images with transparent backgrounds
const SIGIL_IMAGES = {
'Attack': 'assets/sigils/attack.png',
'Shield': 'assets/sigils/shield.png',
'Heal': 'assets/sigils/heal.png',
'D20': 'assets/sigils/d20.png',
'Asterisk': 'assets/sigils/asterisk.png',
'Alpha': 'assets/sigils/alpha.png',
'Expand': 'assets/sigils/expand.png',
'Grapple': 'assets/sigils/grapple.png',
'Star': 'assets/sigils/star.png',
'Ghost': 'assets/sigils/ghost.png'
};

// Helper function to display sigil with icon
function sigilIcon(name) {
const imgPath = SIGIL_IMAGES[name];
if (!imgPath) return `<span>${name}</span>`;
return `<img src="${imgPath}" style="height:1em;vertical-align:middle;display:inline-block;margin-right:0.25em;filter:brightness(0);" alt="${name}">${name}`;
}

// Helper function to display just the icon
function sigilIconOnly(name, level = null) {
const imgPath = SIGIL_IMAGES[name];
if (!imgPath) return `<span>${name}</span>`;
// CSS handles coloring via .sigil.l0 img, .sigil.l1 img, etc.
const icon = `<img src="${imgPath}" style="height:1.2em;vertical-align:middle;display:inline-block;" alt="${name}">`;
// Add level number for L2+ (superscript style)
if (level !== null && level >= 2) {
return `${icon}<sup style="font-size:0.7em;font-weight:bold;margin-left:2px;">${level}</sup>`;
}
return icon;
}

// Sigil descriptions for tooltips
const SIGIL_DESCRIPTIONS = {
'Attack': 'Deal POW damage to target. L2: Attack twice. L3: Attack 3 times. L4: Attack 4 times. Stacks with Asterisk.',
'Shield': 'Grant target 2√óPOW shield. L2: 4√óPOW. L3: 6√óPOW. L4: 8√óPOW. Shield persists between battles (capped at hero max HP).',
'Heal': 'Restore 2√óPOW HP to target. L2: 4√óPOW. L3: 6√óPOW. L4: 8√óPOW. Cannot exceed max HP.',
'D20': 'Roll 1d20 per level, take highest. Need 10+ to succeed. L1: 55%, L2: 80%, L3: 91%, L4: 96%. Effects: Confuse (deal enemy POW to all), Startle (stun), Mend (heal self), Steal (gold), Recruit (join team).',
'Expand': 'PASSIVE: Permanently add +1 target per level to Attack/Shield/Heal. Works automatically. Mage/Healer get +1 Expand built-in.',
'Grapple': 'Stun target for (Level) turns. You take damage equal to target\'s POW.',
'Ghost': 'Cancel the next lethal hit. Each charge prevents one death. Charges shown on card (max 9 charges). Ghost charges PERSIST between combats.',
'Asterisk': 'PASSIVE: Next action triggers +(Level+1) times! Resets after each battle. Works with any action type.',
'Star': 'PASSIVE: Multiply combat XP by (1 + Level√ó0.5). Works automatically. Stacks across heroes. L4 = 3√ó XP!',
'Alpha': 'Grant target hero an extra action this turn. Higher levels grant more actions.'
};

// ===== SIGIL ORDERING =====
// Define consistent sigil order for hero cards and displays
// Top row (actives): Attack, Shield, Heal, Grapple, D20 (D20 always top right)
// Bottom row: Alpha (bottom left), Ghost, Expand, Star, Asterisk (bottom right, passive)
const SIGIL_ORDER = ['Attack', 'Shield', 'Heal', 'Grapple', 'D20', 'Alpha', 'Ghost', 'Expand', 'Star', 'Asterisk'];

function sortSigils(sigils) {
if (!Array.isArray(sigils)) return sigils;
return [...sigils].sort((a, b) => {
const aName = typeof a === 'string' ? a : a.sig;
const bName = typeof b === 'string' ? b : b.sig;
const aIndex = SIGIL_ORDER.indexOf(aName);
const bIndex = SIGIL_ORDER.indexOf(bName);
// If not in order array, put at end
if (aIndex === -1 && bIndex === -1) return 0;
if (aIndex === -1) return 1;
if (bIndex === -1) return -1;
return aIndex - bIndex;
});
}

// ===== UTILITY FUNCTIONS =====
// Unified dice rolling utility
function rollDice(count, sides = 20) {
// Debug mode: Oops All 20s
if(S.oopsAll20s && sides === 20) {
const rolls = Array(count).fill(20);
return {rolls, best: 20};
}
const rolls = [];
for(let i = 0; i < count; i++) {
rolls.push(Math.ceil(Math.random() * sides));
}
const best = Math.max(...rolls);
return {rolls, best};
}

// Helper for enemy attacks - handles targeting, damage, animations, and toast
function executeEnemyAttackOnHeroes(enemy, targetCount, attackName = 'Base Attack') {
const targets = selectEnemyTargets(enemy, targetCount);
if(targets.length === 0) return 0;

const damagedIds = [];
const targetDetails = [];
targets.forEach(target => {
if(target.h > 0) {
const hpBefore = target.h;
damagedIds.push(target.id);
// Apply damage silently (we'll show one toast for all targets)
applyDamageToTarget(target, enemy.p, {isHero: true, silent: true});
const hpAfter = target.h;
targetDetails.push({name: target.n, before: hpBefore, after: hpAfter});
}
});

// Trigger all animations simultaneously
damagedIds.forEach(id => triggerHitAnimation(id));

if(targetDetails.length > 0) {
const targetStrings = targetDetails.map(t => `${t.name} (‚ù§${t.before}‚Üí‚ù§${t.after})`);
toast(`${enemy.n}'s ${attackName} hit ${targetStrings.join(', ')}!`);
}

return targets.length;
}

// ===== RENDER HELPERS =====
// Render encampment enemy selection screen
function renderEncampmentSelection() {
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets.length;
let html = '<div class="combat-header">';
html += `<div class="combat-header-title">Encampment Early Kill</div>`;
html += `<div class="combat-header-subtitle">Click ${kills} enem${kills>1?'ies':'y'} to remove before combat (${selected}/${kills} selected)</div>`;
html += '</div>';
html += '<div class="combat-grid">';
html += '<div class="column heroes">';
html += '<div class="section-label">HEROES</div>';
S.heroes.forEach((h,i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
const heroImage = HERO_IMAGES[h.n.toLowerCase()] || '';
html += `<div class="card hero">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${h.n}</div>
${heroImage ? `<img src="${heroImage}" class="card-image">` : ''}
<div class="sigil-divider"></div>
<div class="sigil-row">`;
const activeSigils = [...h.s, ...(h.ts || [])];
activeSigils.forEach(s => {
const lvl = getLevel(s, i);
const cl = lvl===0?'l0':lvl===1?'l1':lvl===2?'l2':lvl===3?'l3':lvl===4?'l4':'l5';
html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${s}', this, ${lvl})" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${s}', this, ${lvl}), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly(s, lvl)}</span>`;
});
html += '</div>';
html += `<div class="card-stats">${h.p}‚ö° | ${hp}${extra.length>0?' | '+extra.join(' '):''}</div>`;
html += '</div>';
});
html += '</div>';
html += '<div class="column enemies">';
html += '<div class="section-label">ENEMIES</div>';
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });
S.heroes.forEach((hero, laneIdx) => {
const laneEnemies = enemyLanes[laneIdx] || [];
html += `<div class="combat-lane" data-lane="${laneIdx+1}">`;
if(laneEnemies.length === 0) {
html += `<div class="empty-slot">Empty</div>`;
} else {
laneEnemies.forEach(e => {
const isSelected = S.encampmentSelectedTargets.includes(e.id);
let cardClasses = 'card enemy targetable';
if(isSelected) cardClasses += ' targeted';
const extra = [];
if(e.sh > 0) extra.push(`${e.sh}üõ°`);
if(e.g > 0) extra.push(`${e.g}${sigilIconOnly('Ghost')}`);
if(isSelected) extra.push('‚ùå');
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
html += `<div class="${cardClasses}" onclick="selectEncampmentTarget('${e.id}')">
<div class="card-emoji">${enemyEmoji}</div>
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${e.n}</div>
<div class="card-stats">${e.p}‚ö° | ${e.h}/${e.m}‚ù§${extra.length>0?' | '+extra.join(' '):''}</div>
<div class="sigil-divider"></div>
<div class="sigil-row">`;
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
if(!hasAttackSigil) {
html += `<span class="sigil engraved">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
const permStyle = sigil.perm ? 'engraved' : cl;
html += `<span class="sigil ${permStyle}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig)}${sigil.level}</span>`;
});
html += '</div></div>';
});
}
html += '</div>';
});
html += '</div></div>';
if(selected >= kills) {
html += '<button class="btn danger" style="margin-top:1rem" onclick="confirmEncampmentKills()">Confirm Removals</button>';
}
return html;
}

// Render combat status header
function renderCombatStatusHeader() {
let html = '<div class="combat-header">';
if(S.turn!=='player') {
html += 'Enemy Turn‚Ä¶';
} else if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
const selected = S.targets.length;
html += `<div class="combat-header-title">${S.d20Action} (DC ${S.d20DC})</div>`;
html += `<div class="combat-header-subtitle">Select target enemy (${selected}/${maxTargets})</div>`;
} else if(S.pending) {
const targetsPerInstance = getTargetsPerInstance(S.pending, S.activeIdx);
const targetType = needsEnemyTarget(S.pending) ? 'enemy' : 'hero';
if(isMultiInstance(S.pending)) {
const targetsInInstance = S.currentInstanceTargets.length;
html += `<div class="combat-header-title">${S.pending}</div>`;
html += `<div class="combat-header-subtitle">Select ${targetType} (${targetsInInstance}/${targetsPerInstance})</div>`;
html += `<div class="combat-header-info">${S.instancesRemaining} instance${S.instancesRemaining>1?'s':''} remaining</div>`;
} else {
const selected = S.targets.length;
const max = targetsPerInstance;
html += `<div class="combat-header-title">${S.pending}</div>`;
html += `<div class="combat-header-subtitle">Select ${targetType} (${selected}/${max})</div>`;
}
} else if(S.activeIdx === -1) {
const remaining = S.heroes.filter((h,i) => !S.acted.includes(i) && h.st === 0).length;
html += `<div class="combat-header-title">Choose Hero to Act</div>`;
html += `<div class="combat-header-subtitle" style="opacity:0.8">${remaining} hero${remaining>1?'es':''} remaining</div>`;
} else {
const h = S.heroes[S.activeIdx];
if(h) {
if(h.ls) html += `${h.n} Last Stand (Turn ${h.lst + 1}) - D20 only!`;
else html += `${h.n}'s Turn`;
}
}
html += '</div>';
return html;
}

// Unified damage application with shield/ghost/laststand handling
function applyDamageToTarget(target, rawDamage, options = {}) {
let dmg = rawDamage;
let shieldLost = 0;
let hpLost = 0;

// Handle shield absorption
if(target.sh > 0) {
if(target.sh >= rawDamage) {
shieldLost = rawDamage;
target.sh -= rawDamage;
dmg = 0;
} else {
shieldLost = target.sh;
dmg = rawDamage - target.sh;
target.sh = 0;
}
}

// Apply damage to HP
hpLost = dmg;
target.h -= dmg;

// LAYER 1: Warning when hero drops below 30% HP (preventive Last Stand warning)
if(options.isHero && !target.ls && target.h > 0 && target.h < target.m * 0.3) {
// Check if this is the first time we're warning about low HP
if(!S.tutorialFlags.last_stand_warning) {
showTutorialPop('last_stand_warning', `${target.n} is in danger! If they reach 0 HP, they'll enter Last Stand mode - they can only use D20 gambits, and each turn makes survival harder. Use Ghost charges or heal up to avoid it!`);
}
}

// Handle lethal damage
if(target.h <= 0) {
if(target.g > 0) {
// Ghost charge cancels death
target.g--;
target.h += dmg;
hpLost = 0; // Ghost prevented the HP loss
if(!options.silent) {
toast(`${target.n}'s Ghost charge cancelled the lethal hit!`, 1200);
}
} else {
// Death/Last Stand
target.h = 0;
if(options.isHero) {
// Heroes enter Last Stand
target.ls = true;
target.lst = 0;
if(!options.silent) {
// LAYER 2: Extended toast duration (3000ms instead of default)
toast(`${target.n} entered Last Stand!`, 3000);
showTutorialPop('last_stand_intro', "When a hero drops to 0 HP, they enter Last Stand! They can only use D20 gambits, and each turn makes success harder. Heal them to bring them back!");
}
} else {
// Enemies die - award gold/XP and schedule removal
// Skip rewards for Floor 0 tutorial
if(!options.skipRewards && S.floor !== 0) {
S.gold += target.goldDrop || 0;
S.combatGold += target.goldDrop || 0;
S.combatXP += target.x;
upd();
}
}
}
}

return {hpLost, shieldLost, totalDamage: rawDamage}; // Return detailed breakdown
}

// ===== TUTORIAL SYSTEM =====
// Centralized Tutorial Manager for Ribbleton combat tutorial
const TutorialManager = {
// Tutorial stage definitions
stages: {
// Phase 1 stages
'waiting_for_start': {allowedActions: []},
'catching_flies': {allowedActions: 'ALL'}, // Phase 1: Free-form fly catching
// Phase 2 stages
'warrior_attack': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'targeting_wolf': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'healer_d20': {allowedActions: [{hero: 'Healer', sig: 'D20'}]},
'd20_menu': {allowedActions: [{hero: 'Healer', sig: 'D20'}]},
'enemy_turn_wait': {allowedActions: []},
'enemy_turn_explained': {allowedActions: []},
'healer_heal': {allowedActions: [{hero: 'Healer', sig: 'Heal'}]},
'expand_targets': {allowedActions: [{hero: 'Healer', sig: 'Heal'}]},
'finish_wolf': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'shield_sigil': {allowedActions: []},
'free': {allowedActions: 'ALL'} // Tutorial complete, allow all actions
},

// Check if an action is allowed in current tutorial stage
canPerformAction(hero, sig) {
if(!tutorialState || S.floor !== 0) return true; // Not in tutorial
const stage = this.stages[tutorialState.stage];
if(!stage) return true; // Unknown stage, allow
if(stage.allowedActions === 'ALL') return true; // Free-form stage

const allowed = stage.allowedActions;
if(allowed.length === 0) return false; // No actions allowed in this stage

return allowed.some(a => a.hero === hero.n && a.sig === sig);
},

// Get descriptive message for current tutorial stage
getInstructionMessage() {
if(!tutorialState || S.floor !== 0) return "Follow the tutorial instructions!";
const stage = tutorialState.stage;

// Stage-specific messages
const messages = {
'waiting_for_start': "Wait for the tutorial to begin!",
'warrior_attack': "Click the Warrior's Attack sigil, then target the Wolf!",
'targeting_wolf': "Click the Wolf to target it with your Attack!",
'healer_d20': "Click the Healer's D20 to see risky gambit actions!",
'd20_menu': "Select a D20 gambit option!",
'enemy_turn_wait': "Wait for the enemy turn to complete!",
'enemy_turn_explained': "Wait for the next round to begin!",
'healer_heal': "Click the Healer's Heal sigil!",
'expand_targets': "Select targets for your Heal with Expand!",
'finish_wolf': "Use your abilities to defeat the remaining enemies!",
'shield_sigil': "Wait and watch what happens!"
};

return messages[stage] || "Follow the tutorial instructions!";
},

// Advance to next stage based on action completion
advanceStage(context) {
if(!tutorialState || S.floor !== 0) return;

const {action, hero, round} = context;

// Stage transitions based on completed actions
if((tutorialState.stage === 'warrior_attack' || tutorialState.stage === 'targeting_wolf') && tutorialState.wolfDamaged && hero === 'Warrior' && round === 1) {
tutorialState.stage = 'healer_d20';
showTutorialPop('ribbleton_healer_d20', "Nice hit! Before we heal, let's learn about gambits - click the Healer's D20 to see risky actions!", () => {
S.activeIdx = 1;
render();
});
}
else if(tutorialState.stage === 'd20_menu' && hero === 'Healer') {
tutorialState.stage = 'enemy_turn_wait';
}
else if(tutorialState.stage === 'expand_targets' && hero === 'Healer') {
tutorialState.stage = 'finish_wolf';
// REMOVED: "Finish Wolf" popup - trust player to continue combat after heal
}
},

// Handle round transitions during tutorial
onRoundStart(round) {
if(!tutorialState || S.floor !== 0) return;

console.log('[TUTORIAL] Round transition - Round:', round, 'Stage:', tutorialState.stage);

// PHASE 1 (Fly Catching): Round 2 - Remind about Expand ability
if(tutorialState.phase === 1 && round === 2 && !S.tutorialFlags.tapo_expand_tutorial) {
console.log('[TUTORIAL] Phase 1 Round 2 - Reminding about Expand');
S.tutorialFlags.tapo_expand_tutorial = true;
showTutorialPop('tapo_expand_tutorial', "Mage has Expand! This passive lets you hit multiple targets with Attack. Try it now - click Attack and select both flies!", () => {
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
upd();
render();
});
return;
}

// PHASE 2 (Ribbleton): Round 2: Healer Heal prompt (NOW BATCHED WITH EXPAND)
if(round === 2 && (tutorialState.stage === 'enemy_turn_explained' || tutorialState.stage === 'finish_wolf') && !S.tutorialFlags.ribbleton_healer_heal) {
console.log('[TUTORIAL] Triggering PROMPT 4 - Healer Heal + Expand (batched) (stage:', tutorialState.stage, ')');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'healer_heal';
upd();
render();
// Popup now appears when Heal is pending (see render() section) - it includes Expand explanation
S.activeIdx = 1;
render();
} else if(round === 2 && !S.tutorialFlags.ribbleton_healer_heal) {
console.log('[TUTORIAL] Round 2 but stage is:', tutorialState.stage, '(expected: enemy_turn_explained or finish_wolf) - forcing healer_heal anyway');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'healer_heal';
upd();
render();
// Popup now appears when Heal is pending (see render() section) - it includes Expand explanation
S.activeIdx = 1;
render();
}
// Round 3: Force Goblin to draw Shield, then PROMPT 5 (Enemy Sigils batched) + PROMPT 6 (Tooltip + Handoff batched)
else if(round === 3 && tutorialState.stage === 'finish_wolf') {
// Force Goblin to draw Shield
const goblin = S.enemies.find(e => e.n === 'Goblin');
if(goblin && !goblin.s.some(s => s.sig === 'Shield')) {
goblin.s.push({sig:'Shield', level:1, perm:false});
toast('Goblin drew Shield L1!');
}
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'shield_sigil';
upd();
render();
// PROMPT 5: Enemy Sigils + Shield (BATCHED)
showTutorialPop('enemies_get_sigils', "Enemies draw sigils too! The Goblin drew Shield - he'll activate it AFTER attacking this turn, then it's gone. Defeat him before he can shield!", () => {
// PROMPT 6: Tooltip + Handoff (BATCHED)
showTutorialPop('ribbleton_handoff', "Hover over (or long-press on mobile) any sigil to see what it does. You're on your own now - good luck!", () => {
tutorialState.stage = 'free';
render();
});
});
}
},

// Handle enemy turn during tutorial
onEnemyTurnStart() {
if(!tutorialState || S.floor !== 0) return;
if(tutorialState.stage === 'enemy_turn_wait') {
S.locked = true;
tutorialState.stage = 'enemy_turn_explained';
showTutorialPop('ribbleton_enemy_turn', "Uh oh! Enemies attack every turn, and they attack straight across from them!", () => {
S.locked = false;
});
}
}
};

// Tutorial system
let tooltipTimeout = null;
let currentTooltip = null;

// Get level-specific description with colored/bolded numbers
function getLevelDescription(sigilName, level) {
const levelColors = {
0: '#666',
1: '#000',
2: '#0d9488',
3: '#9333ea',
4: '#d97706',
5: '#ff0080'
};
const color = levelColors[level] || '#000';
const boldNum = (num) => `<strong style="color:${color}">${num}</strong>`;

// Level-specific descriptions
const descriptions = {
'Attack': level === 0 ? 'Not unlocked' : level === 1 ? 'Deal POW damage to target' : `Attack ${boldNum(level)} times for POW damage each`,
'Shield': level === 0 ? 'Not unlocked' : level === 1 ? 'Grant target 2√óPOW shield (persists between battles, capped at max HP)' : `Shield ${boldNum(level)} times for 2√óPOW each (persists between battles, capped at max HP)`,
'Heal': level === 0 ? 'Not unlocked' : level === 1 ? 'Restore 2√óPOW HP to target (cannot exceed max HP)' : `Heal ${boldNum(level)} times for 2√óPOW each (cannot exceed max HP)`,
'D20': `Roll ${boldNum(level)}d20, use best result. Choose gambit: Confuse (deal enemy POW to all), Startle (stun), Mend (heal self), Steal (gold), Recruit (join team)`,
'Expand': level === 0 ? 'PASSIVE: Add +1 target to Attack/Shield/Heal. Works automatically. Mage/Healer get +1 built-in' : `PASSIVE: Permanently add ${boldNum(level)} extra target${level > 1 ? 's' : ''} to Attack/Shield/Heal. Works automatically. Mage/Healer get +1 built-in`,
'Grapple': level === 0 ? 'Not unlocked' : `Stun target for ${boldNum(level)} turn${level > 1 ? 's' : ''}. You take damage equal to target's POW`,
'Ghost': level === 0 ? 'Not unlocked' : `Gain ${boldNum(level)} charge${level > 1 ? 's' : ''}. Each charge prevents one death this combat (max 9)`,
'Asterisk': level === 0 ? 'Not unlocked' : `PASSIVE: Next action triggers ${boldNum(level + 1)} times! Resets after each battle`,
'Star': level === 0 ? 'PASSIVE: Not unlocked' : `PASSIVE: Gain ${boldNum(level * 0.5)}√ó extra XP per battle (stacks with other heroes)`,
'Alpha': level === 0 ? 'Not unlocked' : `Grant target hero ${boldNum(level)} extra action${level > 1 ? 's' : ''} this turn`
};

return descriptions[sigilName] || 'No description available';
}

function showTooltip(sigilName, element, level = 1) {
// Check if tooltips are disabled
if(S.tooltipsDisabled) return;

// Tooltip display (tutorial explanation happens in Ribbleton combat)

const desc = getLevelDescription(sigilName, level);
if(!desc) return;

hideTooltip();

const tooltip = document.createElement('div');
tooltip.className = 'tooltip tooltip-green';
tooltip.innerHTML = `
<div class="tooltip-title">${sigilIcon(sigilName)}</div>
<div class="tooltip-desc">${desc}</div>`;

document.body.appendChild(tooltip);
currentTooltip = tooltip;

// Position tooltip near the element
const rect = element.getBoundingClientRect();
const tooltipRect = tooltip.getBoundingClientRect();
let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
let top = rect.top - tooltipRect.height - 10;

// Keep tooltip on screen
if(left < 10) left = 10;
if(left + tooltipRect.width > window.innerWidth - 10) left = window.innerWidth - tooltipRect.width - 10;
if(top < 10) top = rect.bottom + 10;

tooltip.style.left = left + 'px';
tooltip.style.top = top + 'px';

setTimeout(() => tooltip.classList.add('show'), 10);
}

function hideTooltip() {
// Clear any pending tooltip timers
if(tooltipTimeout) {
clearTimeout(tooltipTimeout);
tooltipTimeout = null;
}
// Immediately remove current tooltip
if(currentTooltip) {
currentTooltip.remove();
currentTooltip = null;
}
}

// Helper to create sigil with tooltip (for death screen with longer hover time)
function sigilIconWithTooltip(sig, level = 1, hoverDelay = 500) {
return `<span onmouseenter="showTooltip('${sig}', this, ${level})" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sig}', this, ${level}), ${hoverDelay})" ontouchend="hideTooltip()">${sigilIcon(sig)}</span>`;
}

function generateFibonacci(n) {
const fib = [1, 1];
for(let i = 2; i < n; i++) fib.push(fib[i-1] + fib[i-2]);
return fib;
}
const FIB = generateFibonacci(50);

// Get XP cost for level up - Fibonacci up to 89, then 100, 200, 300, etc.
function getXPCost(levelUpCount) {
// Find the index where Fibonacci reaches 89 (FIB[10] = 89)
if (levelUpCount >= 10) {
// After Fibonacci 89, increment by 100 each time
// levelUpCount 10 = 100, levelUpCount 11 = 200, levelUpCount 12 = 300, etc.
return (levelUpCount - 9) * 100;
}
return FIB[levelUpCount] || 100;
}

// ===== ANIMATION TIMING CONSTANTS =====
// Centralized timing values for easy tuning and consistency
const ANIMATION_TIMINGS = {
  // CSS animation durations (must match CSS @keyframes)
  DAMAGE_FLASH: 400,      // .hit-flash animation duration
  ATTACK_SLIDE: 480,      // .attack-slide animation duration
  HEAL_FLASH: 480,        // .heal-flash animation duration
  SHIELD_FLASH: 480,      // .shield-flash animation duration

  // Screen transition timings
  FADE_TRANSITION: 200,   // Screen fade in/out duration
  FLOOR_INTERSTITIAL: 2000, // Floor name display duration

  // Combat turn timings
  TURN_TRANSITION: 250,   // Hero turn ‚Üí Enemy turn delay
  PHASE_TRANSITION: 200,  // Between enemy phases (Alpha/Recruit/Normal)
  ALPHA_PHASE_START: 400, // Enemy turn start ‚Üí Alpha phase
  ENEMY_ACTION_DELAY: 125, // Stagger between enemy actions (reading order)
  ENEMY_TURN_END: 300,    // After last enemy action
  ACTION_COMPLETE: 500,   // After hero action completes

  // Toast message timings
  TOAST_SHORT: 1200,      // Short notification
  TOAST_MEDIUM: 1800,     // Medium notification
  TOAST_LONG: 2000,       // Long notification
  TOAST_FADE: 300,        // Toast fade out duration

  // Tooltip timings
  TOOLTIP_DELAY: 500,     // Long-press delay for mobile tooltips
  TOOLTIP_FADE: 200,      // Tooltip fade in/out

  // Special animations
  BONUS_TURN_STACK: 300,  // Bonus turn card animation
  VICTORY_DELAY: 1000,    // Delay before level up screen
  DEFEAT_DELAY: 1000,     // Delay before death screen
  TUTORIAL_DELAY: 800,    // Tutorial popup delays
};

// ===== GAME STATE =====
let S = {
// ===== HERO STATE =====
heroes: [],
sig: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
tempSigUpgrades: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
sigUpgradeCounts: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},

// ===== GAME PROGRESSION =====
floor: 1,
gameMode: 'Standard', // 'Standard' or 'fu'
runNumber: 1,
currentSlot: null,
gold: 0,
xp: 0,
levelUpCount: 0,
goingRate: 1,
runsAttempted: 0,
startingXP: 0,

// ===== COMBAT STATE (resets each combat) =====
activeIdx: -1,      // Currently acting hero index (-1 = none)
acted: [],          // Array of hero indices that have acted this turn
locked: false,      // UI locked during enemy turn
pending: null,      // Currently selected action (e.g., 'Attack', 'Shield')
targets: [],        // Selected target IDs for action
currentInstanceTargets: [], // Targets for current multi-instance iteration
instancesRemaining: 0,      // How many instances left to target
totalInstances: 0,          // Total instances for this action
lastActions: {},            // Last action taken by each hero (for Asterisk)
enemies: [],        // Current enemy array
recruits: [],       // Recruited enemies (fight for player)
round: 1,           // Current combat round
turn: 'player',     // 'player' or 'enemy'
combatXP: 0,        // XP earned this combat
combatGold: 0,      // Gold earned this combat
selectingEncampmentTargets: false, // Special state for Encampment encounter
encampmentEarlyKills: 0,           // Number of enemies to kill early
d20HeroIdx: -1,     // Hero index for D20 action targeting
grappleRepeats: 0,  // Number of grapple repeats for recoil calculation
grappleLevel: 0,    // Grapple level for recoil calculation

// ===== NEUTRAL ENCOUNTER STATE (resets each encounter) =====
neutralDeck: [],    // Deck of neutral encounter IDs
lastNeutral: null,  // Last neutral encountered (for non-repeat)
ambushed: false,    // Whether current combat is an ambush

// ===== TEMPORARY NEUTRAL STATE (resets on death) =====
silverKeyHeld: false,     // Silver key from Ghost Boys
oracleHero: null,         // Hero chosen at Oracle
oracleRoll: null,         // Roll result at Oracle
oracleStat: null,         // Stat chosen at Oracle
wizardSigil: null,        // Sigil being tested at Wizard

// ===== PERSISTENT STATE (survives death, saved in permanent storage) =====
ancientStatueDeactivated: false, // Ancient Statue one-time choice made
ghostBoysConverted: false,       // Ghost Boys converted (no longer hostile)
princeGender: 'Prince',          // Gender preference for quest line
pedestal: [],                    // Champion hero figurines [{hero, mode, stats}]
hasAncientStatuette: false,
hasReachedFloor20: false,        // Unlocks blue portal in Ribbleton
fuUnlocked: false,
tapoUnlocked: false,             // Unlocked after first FU victory

// ===== UI STATE =====
toastHistory: [],               // Array of recent toast messages
toastLogExpanded: false,        // Whether toast log is expanded
toastLogVisible: true,          // Whether toast log is shown
tooltipsDisabled: false,        // Whether sigil tooltips are disabled
helpTipsDisabled: false,        // Whether tutorial help tips are disabled

// ===== DEBUG STATE =====
debugMode: false,       // Debug mode toggle
oopsAll20s: false,      // Debug cheat: all d20 rolls = 20

// ===== TUTORIAL STATE (permanent flags) =====
tutorialFlags: {
ribbleton_intro: false,
ribbleton_warrior_attack: false,
ribbleton_targeting: false,
ribbleton_healer_d20: false,
ribbleton_d20_menu: false,
healer_expand_explain: false,
ribbleton_enemy_turn: false,
ribbleton_healer_heal: false,
ribbleton_expand: false,
ribbleton_finish_wolf: false,
enemies_get_sigils: false,
ribbleton_shield_sigil: false,
ribbleton_handoff: false,
ribbleton_tooltip_intro: false,
ribbleton_hub_intro: false,
levelup_intro: false,
levelup_stat_upgrade: false,
levelup_add_active: false,
levelup_upgrade_active: false,
levelup_upgrade_passive: false,
death_intro: false,
death_exit_warning: false,
neutral_intro: false,
neutral_d20_level: false,
faq_intro: false,
last_stand_intro: false,
last_stand_warning: false,
shield_persistence: false,
recruit_intro: false,
run2_hero_lock: false,
first_victory_sequence: false,
first_fu_victory: false,
pedestal_first_placement: false,
tapo_victory_message: false
},
usedDeathQuotes: [] // Track which death quotes have been shown
};

let sel = [];

// ===== RIBBLETON TUTORIAL STATE =====
let tutorialState = null;
// Tutorial state tracks scripted Ribbleton tutorial progress
// {
//   stage: 'warrior_attack' | 'targeting_wolf' | 'healer_d20' | 'd20_menu' | 'enemy_turn_explained' |
//          'healer_heal' | 'expand_targets' | 'finish_wolf' | 'shield_sigil' | 'handoff' | 'free',
//   wolfDamaged: boolean,
//   wolfKilled: boolean,
//   goblinKilled: boolean,
//   round: number
// }

// ===== HELPERS =====
function getFloorBackground(floor) {
// Progressive darkening from floor 1 (light brown) to floor 19 (black)
const colors = [
'#d9cab1', // Floor 1 - light brown (default)
'#cfc0a9', '#c5b6a1', '#bbac99', '#b1a291', '#a79889', // Floors 2-6
'#9d8e81', '#938479', '#897a71', '#7f7069', '#756661', // Floors 7-11
'#6b5c59', '#615251', '#574849', '#4d3e41', '#433439', // Floors 12-16
'#392a31', '#2f2029', '#251621', '#1b0c19' // Floors 17-20
];
return colors[Math.min(floor - 1, colors.length - 1)] || colors[0];
}

function renderHeroCard(hero, idx, onclickHandler, extraInfo = '') {
const hp = hero.ls ? `Last Stand (T${hero.lst+1})` : `${hero.h}/${hero.m}‚ù§`;
const extra = [];
if(hero.sh > 0) extra.push(`${hero.sh}üõ°`);
if(hero.g > 0) extra.push(`${hero.g}${sigilIconOnly('Ghost')}`);
return `<div class="card hero hero-selectable" onclick="${onclickHandler}" style="cursor:pointer;margin-bottom:0.75rem">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${hero.n}</div>
<div class="card-stats">${hero.p}‚ö° | ${hp}${extra.length>0?' | '+extra.join(' '):''}${extraInfo}</div>
</div>`;
}

function upd() {
document.getElementById('floor').textContent = S.floor;
document.getElementById('round').textContent = S.round || '-';
document.getElementById('gold').textContent = S.gold;
// Show combat XP during combat, cumulative XP otherwise
if(S.combatXP !== undefined && S.combatXP > 0) {
document.getElementById('xp').textContent = `${S.xp} (+${S.combatXP})`;
} else {
document.getElementById('xp').textContent = S.xp;
}
// Show/hide debug button
const debugBtn = document.getElementById('debugBtn');
if(debugBtn) debugBtn.style.display = S.debugMode ? 'block' : 'none';
// Update background color based on floor
const gameArea = document.getElementById('gameView');
if(gameArea) gameArea.style.background = getFloorBackground(S.floor);
}

function triggerHitAnimation(targetId) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('hit-flash');
setTimeout(() => card.classList.remove('hit-flash'), ANIMATION_TIMINGS.DAMAGE_FLASH);
}
}

function triggerAttackAnimation(attackerId) {
const card = document.getElementById(attackerId);
if(card) {
card.classList.add('attack-slide');
setTimeout(() => card.classList.remove('attack-slide'), ANIMATION_TIMINGS.ATTACK_SLIDE);
}
}

function triggerHealAnimation(targetId) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('heal-flash');
// Add healing cross overlay
const cross = document.createElement('div');
cross.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:3rem;color:#22c55e;text-shadow:0 0 10px #22c55e;pointer-events:none;z-index:1000;animation:heal-cross-fade 0.48s ease';
cross.textContent = '‚úö';
card.appendChild(cross);
setTimeout(() => {
card.classList.remove('heal-flash');
if(cross.parentNode) cross.remove();
}, ANIMATION_TIMINGS.HEAL_FLASH);
}
}

function triggerShieldAnimation(targetId) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('shield-flash');
setTimeout(() => card.classList.remove('shield-flash'), ANIMATION_TIMINGS.SHIELD_FLASH);
}
}

function addBonusTurnStack(cardId, count) {
const card = document.getElementById(cardId);
if(!card || count <= 0) return;
// Remove existing stack if any
removeBonusTurnStack(cardId);
// Create stack container
const stackContainer = document.createElement('div');
stackContainer.className = 'bonus-turn-stack';
stackContainer.id = `stack-${cardId}`;
// Add stacked cards (show just the corners)
for(let i = 0; i < Math.min(count, 5); i++) {
const stackCard = document.createElement('div');
stackCard.className = 'bonus-turn-card';
stackCard.style.transform = `translate(${-3 - i*3}px, ${-3 - i*3}px)`;
stackCard.style.zIndex = -1 - i;
stackContainer.appendChild(stackCard);
}
card.appendChild(stackContainer);
}

function removeBonusTurnStack(cardId, animated = false) {
const stack = document.getElementById(`stack-${cardId}`);
if(!stack) return;
if(animated && stack.children.length > 0) {
// Animate the top card sliding out
const topCard = stack.children[0];
topCard.classList.add('sliding-out');
setTimeout(() => {
topCard.remove();
// If no more cards, remove the whole stack
if(stack.children.length === 0) {
stack.remove();
}
}, 300);
} else {
stack.remove();
}
}

function updateBonusTurnStack(cardId, count) {
if(count <= 0) {
removeBonusTurnStack(cardId, true);
} else {
const stack = document.getElementById(`stack-${cardId}`);
if(!stack) {
addBonusTurnStack(cardId, count);
} else {
// Adjust stack size
const currentCount = stack.children.length;
if(currentCount > count) {
// Remove excess cards with animation
removeBonusTurnStack(cardId, true);
setTimeout(() => addBonusTurnStack(cardId, count), ANIMATION_TIMINGS.BONUS_TURN_STACK);
} else if(currentCount < count) {
// Add more cards
addBonusTurnStack(cardId, count);
}
}
}
}

function toast(msg, dur=1200) {
// Add to history (strip HTML for text log)
const textMsg = msg.replace(/<[^>]*>/g, '');
S.toastHistory.unshift(textMsg);
if(S.toastHistory.length > 20) S.toastHistory = S.toastHistory.slice(0, 20); // Keep last 20
updateToastLog();
// Show toast popup (supports HTML)
const t = document.createElement('div');
t.className = 'toast';
t.innerHTML = msg; // Changed from textContent to innerHTML to support HTML
document.body.appendChild(t);
setTimeout(() => t.classList.add('show'), 10);
setTimeout(() => {
t.classList.remove('show');
setTimeout(() => t.remove(), ANIMATION_TIMINGS.TOAST_FADE);
}, dur);
}

function initToastLog() {
const existing = document.getElementById('toastLog');
if(existing) return;
const log = document.createElement('div');
log.id = 'toastLog';
log.className = 'toast-log';
document.body.appendChild(log);
updateToastLog();
}

function toggleToastLog() {
const log = document.getElementById('toastLog');
if(!log) return;
log.classList.toggle('show');
}

function toggleToastLogVisibility(visible) {
const log = document.getElementById('toastLog');
if(log) {
if(visible) {
log.classList.add('show');
} else {
log.classList.remove('show');
}
}
}

function updateToastLog() {
const log = document.getElementById('toastLog');
if(!log) return;
let html = `<div class="toast-log-header">
<span style="font-size:1rem">ü™µ Combat Log</span>
<button onclick="toggleToastLog()" style="background:#ef4444;border:2px solid #000;border-radius:4px;padding:0.25rem 0.5rem;font-weight:bold;cursor:pointer;font-size:0.8rem">Close</button>
</div>`;
html += '<div class="toast-log-entries">';
S.toastHistory.forEach((msg, idx) => {
html += `<div class="toast-log-entry ${idx === 0 ? 'recent' : ''}">${msg}</div>`;
});
if(S.toastHistory.length === 0) {
html += '<div class="toast-log-entry">No messages yet</div>';
}
html += '</div>';
log.innerHTML = html;
}

function showTutorialPop(flagName, message, onDismiss) {
console.log('[TUTORIAL] showTutorialPop called:', flagName, 'Already shown:', S.tutorialFlags[flagName]);
if(S.helpTipsDisabled || S.tutorialFlags[flagName]) {
console.log('[TUTORIAL] Skipping pop (disabled or already shown), calling callback directly');
if(onDismiss) onDismiss();
return;
}
// Add tutorial message to toast log for reference
S.toastHistory.unshift(`üìñ ${message}`);
if(S.toastHistory.length > 20) S.toastHistory = S.toastHistory.slice(0, 20);
updateToastLog();
// Create blocking modal
const backdrop = document.createElement('div');
backdrop.className = 'tutorial-modal-backdrop';
backdrop.innerHTML = `
<div class="tutorial-modal">
<h2>Tip!</h2>
<p>${message}</p>
<button onclick="dismissTutorialPop('${flagName}')">Got it!</button>
</div>`;
document.body.appendChild(backdrop);
console.log('[TUTORIAL] Backdrop created and appended, total backdrops now:', document.querySelectorAll('.tutorial-modal-backdrop').length);
// Store callback for later
window.tutorialCallback = onDismiss;
}

function dismissTutorialPop(flagName) {
console.log('[TUTORIAL] dismissTutorialPop called:', flagName);
console.log('[TUTORIAL] Backdrops BEFORE removal:', document.querySelectorAll('.tutorial-modal-backdrop').length);
S.tutorialFlags[flagName] = true;
savePermanent();

// Remove ALL backdrops aggressively with error handling
try {
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Removing', allBackdrops.length, 'backdrops');
allBackdrops.forEach((b, i) => {
console.log('[TUTORIAL] Removing backdrop', i);
b.remove();
});
} catch (error) {
console.error('[TUTORIAL] Error removing backdrops:', error);
}

// Verify it's gone
setTimeout(() => {
try {
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Backdrops remaining after pop dismiss:', remaining.length);
if(remaining.length > 0) {
console.error('[TUTORIAL] ERROR: Backdrops still blocking!', remaining);
remaining.forEach(r => {
console.error('[TUTORIAL] Zombie backdrop:', r);
r.remove();
});
}

console.log('[TUTORIAL] About to call onDismiss callback');
if(window.tutorialCallback) {
console.log('[TUTORIAL] Calling onDismiss callback NOW');
window.tutorialCallback();
window.tutorialCallback = null;
} else {
console.warn('[TUTORIAL] No callback found!');
}
} catch (error) {
console.error('[TUTORIAL] Error in callback execution:', error);
// Still try to clear callback even if there's an error
if(window.tutorialCallback) window.tutorialCallback = null;
}
}, 50);
}

function savePermanent() {
try {
localStorage.setItem('froggle8_permanent', JSON.stringify({
gold: S.gold,
goingRate: S.goingRate,
startingXP: S.startingXP,
sig: S.sig,
sigUpgradeCounts: S.sigUpgradeCounts,
ancientStatueDeactivated: S.ancientStatueDeactivated,
ghostBoysConverted: S.ghostBoysConverted,
pedestal: S.pedestal,
hasReachedFloor20: S.hasReachedFloor20,
fuUnlocked: S.fuUnlocked,
tapoUnlocked: S.tapoUnlocked,
runNumber: S.runNumber,
runsAttempted: S.runsAttempted,
tutorialFlags: S.tutorialFlags,
helpTipsDisabled: S.helpTipsDisabled,
tooltipsDisabled: S.tooltipsDisabled,
usedDeathQuotes: S.usedDeathQuotes
}));
} catch(e) {
console.warn('[SAVE] Failed to save permanent data:', e);
toast('Warning: Progress could not be saved', 2000);
}
}

function loadPermanent() {
try {
const d = localStorage.getItem('froggle8_permanent');
if(!d) return;
const j = JSON.parse(d);
S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// One-time fix: Detect and repair old saves with starter actives at L1 (should be L0)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
let needsFix = false;
starterActives.forEach(sig => {
if(S.sig[sig] === 1 && S.sigUpgradeCounts[sig] === 0) {
// Starter active at L1 with no upgrades = old save format, fix it
S.sig[sig] = 0;
needsFix = true;
}
});
if(needsFix) {
console.log('[SAVE] Fixed old save format: starter actives L1‚ÜíL0');
savePermanent(); // Save the fix
}
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.pedestal = j.pedestal || [];
S.hasReachedFloor20 = j.hasReachedFloor20 || false;
S.fuUnlocked = j.fuUnlocked || j.effedUnlocked || false; // Support old save format
S.tapoUnlocked = j.tapoUnlocked || false;
S.runNumber = j.runNumber || 1;
S.runsAttempted = j.runsAttempted || 0;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.tooltipsDisabled = j.tooltipsDisabled || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
if(j.tutorialFlags) {
Object.assign(S.tutorialFlags, j.tutorialFlags);
}
} catch(e) {
console.warn('[SAVE] Failed to load permanent data:', e);
// Continue with defaults if load fails
}
}

function saveGame() {
try {
localStorage.setItem('froggle8', JSON.stringify({
f:S.floor, x:S.xp, luc:S.levelUpCount,
h:S.heroes,
neutralDeck:S.neutralDeck, lastNeutral:S.lastNeutral,
hasAncientStatuette: S.hasAncientStatuette,
tempSigUpgrades: S.tempSigUpgrades
}));
savePermanent();
} catch(e) {
console.warn('[SAVE] Failed to save game:', e);
toast('Warning: Game could not be saved', 2000);
}
}

function loadGame() {
loadPermanent(); // Load persistent data first
try {
const d = localStorage.getItem('froggle8');
if(!d) return;
const j = JSON.parse(d);
S.floor=j.f; S.xp=j.x; S.levelUpCount=j.luc || 0;
S.heroes=j.h;
S.neutralDeck=j.neutralDeck || [];
S.lastNeutral=j.lastNeutral || null;
S.hasAncientStatuette = j.hasAncientStatuette || false;
S.tempSigUpgrades = j.tempSigUpgrades || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.heroes.forEach(h => { if(!h.ts) h.ts = []; });
upd();
startFloor(S.floor);
toast('Loaded!');
} catch(e) {
console.warn('[SAVE] Failed to load game:', e);
toast('Error loading saved game. Starting new game...', ANIMATION_TIMINGS.TOAST_LONG);
setTimeout(() => transitionScreen(title), ANIMATION_TIMINGS.TOAST_LONG);
}
}

// ===== SAVE SLOT SYSTEM =====
// Get metadata for a save slot (without loading it)
function getSlotMetadata(slot) {
try {
// Try new slot system first
let d = localStorage.getItem(`froggle8_permanent_slot${slot}`);
if(d) {
const j = JSON.parse(d);
return {
exists: true,
runsAttempted: j.runsAttempted || j.runNumber || 1,
goingRate: j.goingRate || 1,
hasActiveRun: !!localStorage.getItem(`froggle8_slot${slot}`)
};
}
// Check old system for migration
if(slot === 1) {
d = localStorage.getItem('froggle8_permanent');
if(d) {
const j = JSON.parse(d);
return {
exists: true,
runsAttempted: j.runNumber || 1,
goingRate: j.goingRate || 1,
hasActiveRun: !!localStorage.getItem('froggle8'),
needsMigration: true
};
}
}
return { exists: false };
} catch(e) {
console.warn(`[SAVE] Error reading slot ${slot}:`, e);
return { exists: false };
}
}

// Migrate old save to slot 1
function migrateOldSave() {
try {
const oldPerm = localStorage.getItem('froggle8_permanent');
const oldRun = localStorage.getItem('froggle8');
if(oldPerm) {
// Parse and fix old save data before migrating
const j = JSON.parse(oldPerm);
// Fix starter actives that were incorrectly at L1 (should be L0 for storage)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
if(j.sig) {
starterActives.forEach(sig => {
if(j.sig[sig] === 1) {
j.sig[sig] = 0;
// Also adjust sigUpgradeCounts if it exists
if(j.sigUpgradeCounts && j.sigUpgradeCounts[sig] > 0) {
j.sigUpgradeCounts[sig] = Math.max(0, j.sigUpgradeCounts[sig] - 1);
}
}
});
}
localStorage.setItem('froggle8_permanent_slot1', JSON.stringify(j));
localStorage.removeItem('froggle8_permanent');
console.log('[SAVE] Migrated and fixed old save to slot 1');
}
if(oldRun) {
localStorage.setItem('froggle8_slot1', oldRun);
localStorage.removeItem('froggle8');
}
} catch(e) {
console.warn('[SAVE] Migration failed:', e);
}
}

// Load a specific slot
function loadSlot(slot) {
S.currentSlot = slot;
localStorage.setItem('froggle8_current_slot', slot.toString());
// Load permanent data
try {
const d = localStorage.getItem(`froggle8_permanent_slot${slot}`);
if(d) {
const j = JSON.parse(d);
S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.runsAttempted = j.runsAttempted || j.runNumber || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// One-time fix: Detect and repair old saves with starter actives at L1 (should be L0)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
let needsFix = false;
starterActives.forEach(sig => {
if(S.sig[sig] === 1 && S.sigUpgradeCounts[sig] === 0) {
// Starter active at L1 with no upgrades = old save format, fix it
S.sig[sig] = 0;
needsFix = true;
}
});
if(needsFix) {
console.log('[SAVE] Fixed old save format: starter actives L1‚ÜíL0');
savePermanent(); // Save the fix
}
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.pedestal = j.pedestal || [];
S.hasReachedFloor20 = j.hasReachedFloor20 || false;
S.fuUnlocked = j.fuUnlocked || j.effedUnlocked || false; // Support old save format
S.tapoUnlocked = j.tapoUnlocked || false;
S.runNumber = j.runNumber || 1;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.tooltipsDisabled = j.tooltipsDisabled || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
if(j.tutorialFlags) Object.assign(S.tutorialFlags, j.tutorialFlags);
}
// Try to load active run
const runData = localStorage.getItem(`froggle8_slot${slot}`);
if(runData) {
const r = JSON.parse(runData);
S.floor = r.f;
S.xp = r.x;
S.levelUpCount = r.luc || 0;
S.heroes = r.h;
S.neutralDeck = r.neutralDeck || [];
S.lastNeutral = r.lastNeutral || null;
S.hasAncientStatuette = r.hasAncientStatuette || false;
S.tempSigUpgrades = r.tempSigUpgrades || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.heroes.forEach(h => { if(!h.ts) h.ts = []; });
upd();
startFloor(S.floor);
toast('Slot loaded!');
return true;
}
} catch(e) {
console.warn('[SAVE] Failed to load slot:', e);
}
return false;
}

// Update save functions to use current slot
const originalSavePermanent = savePermanent;
savePermanent = function() {
if(!S.currentSlot) {
console.warn('[SAVE] No currentSlot set, defaulting to slot 1');
S.currentSlot = 1;
localStorage.setItem('froggle8_current_slot', '1');
}
try {
localStorage.setItem(`froggle8_permanent_slot${S.currentSlot}`, JSON.stringify({
gold: S.gold,
goingRate: S.goingRate,
runsAttempted: S.runsAttempted,
startingXP: S.startingXP,
sig: S.sig,
sigUpgradeCounts: S.sigUpgradeCounts,
ancientStatueDeactivated: S.ancientStatueDeactivated,
ghostBoysConverted: S.ghostBoysConverted,
pedestal: S.pedestal,
hasReachedFloor20: S.hasReachedFloor20,
fuUnlocked: S.fuUnlocked,
tapoUnlocked: S.tapoUnlocked,
runNumber: S.runNumber,
tutorialFlags: S.tutorialFlags,
helpTipsDisabled: S.helpTipsDisabled,
tooltipsDisabled: S.tooltipsDisabled,
usedDeathQuotes: S.usedDeathQuotes
}));
} catch(e) {
console.warn('[SAVE] Failed to save permanent data:', e);
toast('Warning: Progress could not be saved', 2000);
}
};

const originalSaveGame = saveGame;
saveGame = function() {
if(!S.currentSlot) {
console.warn('[SAVE] No currentSlot set, defaulting to slot 1');
S.currentSlot = 1;
localStorage.setItem('froggle8_current_slot', '1');
}
try {
localStorage.setItem(`froggle8_slot${S.currentSlot}`, JSON.stringify({
f:S.floor, x:S.xp, luc:S.levelUpCount,
h:S.heroes,
neutralDeck:S.neutralDeck, lastNeutral:S.lastNeutral,
hasAncientStatuette: S.hasAncientStatuette,
tempSigUpgrades: S.tempSigUpgrades
}));
savePermanent();
} catch(e) {
console.warn('[SAVE] Failed to save game:', e);
toast('Warning: Game could not be saved', 2000);
}
};

// ===== NEUTRAL DECK SYSTEM =====
function initNeutralDeck() {
S.neutralDeck = [
'shopkeeper1', 'wishingwell1', 'treasurechest1',
'wizard1', 'oracle1', 'encampment1',
'gambling1', 'ghost1', 'prince1'
];
S.lastNeutral = null;
}

function getNeutralEncounter() {
// TUTORIAL: Floor 2 always gets Oracle Stage 1
if(S.floor === 2 && !S.tutorialFlags.neutral_intro) {
return 'oracle1';
}

// Level 18: Prioritize Stage 2s
if(S.floor === 18) {
const stage2s = S.neutralDeck.filter(n => n.includes('2'));
if(stage2s.length > 0) {
const pick = stage2s[Math.floor(Math.random() * stage2s.length)];
return pick;
}
}

// Filter out last neutral for back-to-back prevention
let available = S.neutralDeck;
if(S.lastNeutral) {
const base = S.lastNeutral.replace(/[12]$/, '');
available = available.filter(n => !n.startsWith(base));
}

// Floor 10: NEVER allow Enemy Encampment (Floor 11 is always ambush)
if(S.floor === 10) {
available = available.filter(n => !n.startsWith('encampment'));
}

if(available.length === 0) {
available = S.neutralDeck;
}

const pick = available[Math.floor(Math.random() * available.length)];
S.lastNeutral = pick;
return pick;
}

function removeNeutralFromDeck(base) {
S.neutralDeck = S.neutralDeck.filter(n => !n.startsWith(base));
}

function replaceStage1WithStage2(base) {
S.neutralDeck = S.neutralDeck.filter(n => n !== `${base}1`);
S.neutralDeck.push(`${base}2`);
}

// ===== D20 ROLLS FOR NEUTRALS =====
function rollD20Neutral() {
const d20Level = S.sig.D20 || 1;
// TUTORIAL: Explain D20 level affects neutral rolls
showTutorialPop('neutral_d20_level', "These D20 checks use the same Level as your D20 sigil from combat - leveling it up improves your odds everywhere!");
return rollDice(d20Level, 20);
}

function showD20Result(rolls, best) {
// Visual dice display with highlighted best roll
const diceHTML = rolls.map(r => {
const isBest = r === best;
return `<span style="display:inline-block;width:2.5rem;height:2.5rem;line-height:2.5rem;text-align:center;background:${isBest ? '#22c55e' : '#1e293b'};border:2px solid ${isBest ? '#16a34a' : '#475569'};border-radius:0.5rem;margin:0.2rem;font-weight:bold;color:#f1f5f9;font-size:1.2rem;${isBest ? 'box-shadow:0 0 12px rgba(34,197,94,0.6);' : ''}">${r}</span>`;
}).join(' ');
return `<div style="margin:0.5rem 0"><div style="font-size:0.9rem;margin-bottom:0.5rem;color:#666">Rolling ${rolls.length}d20:</div>${diceHTML}</div>`;
}

function formatD20Compact(rolls, best) {
// Compact dice display for toasts/combat
const diceHTML = rolls.map(r => {
const isBest = r === best;
return `<span style="display:inline-block;width:1.8rem;height:1.8rem;line-height:1.8rem;text-align:center;background:${isBest ? '#22c55e' : '#1e293b'};border:2px solid ${isBest ? '#16a34a' : '#475569'};border-radius:0.4rem;margin:0 0.15rem;font-weight:bold;color:#f1f5f9;font-size:1rem;vertical-align:middle;${isBest ? 'box-shadow:0 0 8px rgba(34,197,94,0.6);' : ''}">${r}</span>`;
}).join('');
return diceHTML;
}

function buildNeutralHTML(options) {
const {
bgImage,
title,
description,
outcomes = [],
diceRoll = '',
buttons = '',
showStats = true
} = options;

let html = `<div class="neutral-container">`;

// Left side - Content
html += '<div class="neutral-left">';

// Header with stats and narrative
html += '<div class="neutral-header">';
if(showStats) {
html += `<div class="neutral-stats">üí∞ ${S.gold}G | üéØ Floor ${S.floor}</div>`;
}
html += '<div class="neutral-narrative">';
if(title) html += `<div class="neutral-title">${title}</div>`;
if(description) html += `<div class="neutral-desc">${description}</div>`;
if(diceRoll) html += `<div class="dice-roll">${diceRoll}</div>`;
outcomes.forEach(outcome => {
if(outcome) html += `<div class="neutral-outcome">${outcome}</div>`;
});
html += '</div></div>'; // close narrative and header

// Footer with buttons
if(buttons) {
html += `<div class="neutral-footer">${buttons}</div>`;
}

html += '</div>'; // close neutral-left

// Right side - Art
html += `<div class="neutral-right" style="background-image: url('${bgImage}')"></div>`;

html += '</div>'; // close container
return html;
}

// ===== MAIN TITLE PAGE =====
function mainTitlePage() {
console.log('[FROGGLE] mainTitlePage START');
// Hide game header on title screen
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'none';

const v = document.getElementById('gameView');
console.log('[FROGGLE] gameView element:', v);
// Check for old saves and migrate
migrateOldSave();
// If migration created slot 1 but currentSlot not set, set it
if(!S.currentSlot && localStorage.getItem('froggle8_permanent_slot1')) {
S.currentSlot = 1;
localStorage.setItem('froggle8_current_slot', '1');
console.log('[SAVE] Set currentSlot to 1 after migration');
}
v.innerHTML = `
<div style="min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#1a1a1a;padding:1rem;overflow-y:auto">
<!-- Green mat container -->
<div style="background:#22c55e;border:4px solid #000;border-radius:12px;padding:1.5rem;max-width:600px;width:90%;box-shadow:0 8px 16px rgba(0,0,0,0.5)">
<!-- Title image with version label -->
<div style="position:relative;margin-bottom:1.5rem">
<img src="assets/title-screen.png" style="width:100%;height:auto;border-radius:8px;border:3px solid #000;display:block;box-shadow:0 4px 8px rgba(0,0,0,0.3)">
<div style="position:absolute;top:0.3rem;right:0.3rem;background:rgba(0,0,0,0.85);padding:0.25rem 0.5rem;border-radius:6px;border:2px solid rgba(251,191,36,0.7)">
<p style="font-size:0.7rem;color:#3b82f6;font-weight:bold;text-align:right;margin:0">v${GAME_VERSION}</p>
</div>
</div>

<!-- Single Play button -->
<button class="btn" onclick="showSaveSlotSelection()" style="width:100%;font-size:1.2rem;padding:1rem;background:#3b82f6;border:3px solid #f97316;font-weight:bold">üê∏ PLAY üê∏</button>
</div>
</div>`;
}

// Show save slot selection screen
function showSaveSlotSelection() {
const v = document.getElementById('gameView');
const slot1 = getSlotMetadata(1);
const slot2 = getSlotMetadata(2);

v.innerHTML = `
<div style="min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#1a1a1a;padding:1rem;overflow-y:auto">
<div style="background:#22c55e;border:4px solid #000;border-radius:12px;padding:1.5rem;max-width:600px;width:100%;box-shadow:0 8px 16px rgba(0,0,0,0.5)">
<h2 style="text-align:center;margin-bottom:1.5rem;font-size:1.5rem">Select Save Slot</h2>

<!-- Slot 1 -->
<div style="background:white;border:3px solid #000;border-radius:8px;padding:1rem;margin-bottom:1rem">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem">
<h3 style="font-size:1.2rem;margin:0">Slot 1</h3>
</div>
${slot1.exists ? `
<div style="font-size:0.9rem;opacity:0.8;margin-bottom:0.5rem">
<div>üìä Runs Attempted: <strong>${slot1.runsAttempted}</strong></div>
<div>üí∞ Going Rate: <strong>${slot1.goingRate}G</strong></div>
${slot1.hasActiveRun ? '<div style="color:#22c55e;font-weight:bold">üéÆ Active Run In Progress</div>' : ''}
</div>
<div style="display:flex;gap:0.5rem">
<button class="btn" onclick="continueSlot(1)" style="flex:1;background:#22c55e;border:3px solid #16a34a;font-weight:bold">${slot1.hasActiveRun ? '‚ñ∂Ô∏è Continue' : 'üÜï New Run'}</button>
<button class="btn secondary" onclick="confirmDeleteSlot(1)" style="flex:0;padding:0.5rem 0.75rem">üóëÔ∏è</button>
</div>
` : `
<p style="opacity:0.6;margin-bottom:0.5rem">Empty Slot</p>
<button class="btn" onclick="createNewSlot(1)" style="width:100%;background:#3b82f6;border:3px solid #f97316;font-weight:bold">üÜï New Game</button>
`}
</div>

<!-- Slot 2 -->
<div style="background:white;border:3px solid #000;border-radius:8px;padding:1rem;margin-bottom:1rem">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem">
<h3 style="font-size:1.2rem;margin:0">Slot 2</h3>
</div>
${slot2.exists ? `
<div style="font-size:0.9rem;opacity:0.8;margin-bottom:0.5rem">
<div>üìä Runs Attempted: <strong>${slot2.runsAttempted}</strong></div>
<div>üí∞ Going Rate: <strong>${slot2.goingRate}G</strong></div>
${slot2.hasActiveRun ? '<div style="color:#22c55e;font-weight:bold">üéÆ Active Run In Progress</div>' : ''}
</div>
<div style="display:flex;gap:0.5rem">
<button class="btn" onclick="continueSlot(2)" style="flex:1;background:#22c55e;border:3px solid #16a34a;font-weight:bold">${slot2.hasActiveRun ? '‚ñ∂Ô∏è Continue' : 'üÜï New Run'}</button>
<button class="btn secondary" onclick="confirmDeleteSlot(2)" style="flex:0;padding:0.5rem 0.75rem">üóëÔ∏è</button>
</div>
` : `
<p style="opacity:0.6;margin-bottom:0.5rem">Empty Slot</p>
<button class="btn" onclick="createNewSlot(2)" style="width:100%;background:#3b82f6;border:3px solid #f97316;font-weight:bold">üÜï New Game</button>
`}
</div>

<button class="btn secondary" onclick="mainTitlePage()" style="width:100%">‚Üê Back</button>
</div>
</div>`;
}

// Continue/start a slot
function continueSlot(slot) {
const meta = getSlotMetadata(slot);
if(meta.hasActiveRun) {
// Load existing run
if(loadSlot(slot)) {
// Success - game already started
} else {
toast('Failed to load slot');
}
} else {
// Start new run in existing slot
S.runsAttempted = (meta.runsAttempted || 0) + 1;
newGameInSlot(slot);
}
}

// Create new game in empty slot
function createNewSlot(slot) {
S.currentSlot = slot;
localStorage.setItem('froggle8_current_slot', slot.toString());
S.runsAttempted = 1;
S.runNumber = 1;
newGame();
}

// Start new game in existing slot
function newGameInSlot(slot) {
S.currentSlot = slot;
localStorage.setItem('froggle8_current_slot', slot.toString());
S.runNumber = (S.runsAttempted || 1);
if(S.runNumber === 1 && !S.helpTipsDisabled) {
showTutorialStory();
} else {
title();
}
}

// Delete slot with confirmation
function confirmDeleteSlot(slot) {
if(confirm(`Delete Save Slot ${slot}? This cannot be undone!`)) {
try {
localStorage.removeItem(`froggle8_slot${slot}`);
localStorage.removeItem(`froggle8_permanent_slot${slot}`);
toast(`Slot ${slot} deleted`);
showSaveSlotSelection(); // Refresh
} catch(e) {
toast('Failed to delete slot');
}
}
}

function newGame() {
// Reset runNumber to 1 for new game (allows tutorial to show)
S.runNumber = 1;
console.log('[FROGGLE] newGame called - runNumber:', S.runNumber, 'helpTipsDisabled:', S.helpTipsDisabled);
if(S.runNumber === 1 && !S.helpTipsDisabled) {
console.log('[FROGGLE] Showing tutorial story');
showTutorialStory();
} else {
console.log('[FROGGLE] Skipping tutorial, going to title()');
title();
}
}

function loadGameFromTitle() {
const s = localStorage.getItem('froggle8');
if(s) {
loadGame();
} else {
toast('No saved game found!');
}
}

function exitGame() {
if(confirm('Thanks for playing FROGGLE! Close the window to exit.')) {
window.close();
}
}

function exportSave() {
const saveData = localStorage.getItem('froggle8');
const permanentData = localStorage.getItem('froggle8_permanent');
if(!saveData && !permanentData) {
toast('No save data to export!');
return;
}
const exportData = {
save: saveData ? JSON.parse(saveData) : null,
permanent: permanentData ? JSON.parse(permanentData) : null,
exportDate: new Date().toISOString(),
version: GAME_VERSION
};
const dataStr = JSON.stringify(exportData, null, 2);
const blob = new Blob([dataStr], {type: 'application/json'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `froggle-save-${new Date().toISOString().split('T')[0]}.json`;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);
toast('Save exported!');
}

function importSave() {
const input = document.createElement('input');
input.type = 'file';
input.accept = '.json';
input.onchange = (e) => {
const file = e.target.files[0];
if(!file) return;
const reader = new FileReader();
reader.onload = (event) => {
try {
const importData = JSON.parse(event.target.result);
if(importData.save) {
localStorage.setItem('froggle8', JSON.stringify(importData.save));
}
if(importData.permanent) {
localStorage.setItem('froggle8_permanent', JSON.stringify(importData.permanent));
}
toast('Save imported successfully!');
setTimeout(() => {
mainTitlePage();
}, 1000);
} catch(err) {
toast('Error: Invalid save file!');
console.error('Import error:', err);
}
};
reader.readAsText(file);
};
input.click();
}

// ===== NARRATIVE SLIDE SYSTEM =====
function showNarrativeSlide(slides, currentIndex = 0) {
console.log('[FROGGLE] showNarrativeSlide called - currentIndex:', currentIndex, 'total slides:', slides.length);
if(currentIndex >= slides.length) {
// All slides shown, call completion callback
console.log('[FROGGLE] All slides complete, calling onComplete');
if(slides.onComplete) slides.onComplete();
return;
}

const slide = slides[currentIndex];
console.log('[FROGGLE] Rendering slide', currentIndex);
const v = document.getElementById('gameView');
console.log('[FROGGLE] gameView element:', v);
const skipButton = slides.skippable ? `<button class="btn" onclick="skipTutorialFromSlide()" style="padding:0.75rem 2rem;background:#888;margin-left:1rem">Skip Tutorial</button>` : '';
console.log('[FROGGLE] Setting innerHTML for slide', currentIndex);
v.innerHTML = `
<div style="max-width:600px;margin:2rem auto;padding:1rem">
${slide.html || `<div style="font-size:1.1rem;line-height:1.8;margin-bottom:2rem;text-align:center">${slide.text}</div>`}
<div style="text-align:center;display:flex;gap:1rem;justify-content:center;flex-wrap:wrap">
<button class="btn" onclick="continueNarrative()" style="padding:0.75rem 2rem">${slide.buttonText || 'Continue'}</button>
${skipButton}
</div>
</div>`;

window.currentNarrativeSlides = slides;
window.currentNarrativeIndex = currentIndex;
console.log('[FROGGLE] Slide', currentIndex, 'rendered successfully');
}

function continueNarrative() {
const slides = window.currentNarrativeSlides;
const nextIndex = window.currentNarrativeIndex + 1;
showNarrativeSlide(slides, nextIndex);
}

function skipTutorialFromSlide() {
// Skip to title card, then Ribbleton (Help/Tips remain ON by default)
toast('Tutorial skipped!', ANIMATION_TIMINGS.TOAST_SHORT);
setTimeout(() => transitionScreen(showTitleCard), ANIMATION_TIMINGS.ACTION_COMPLETE);
}

// ===== RIBBLETON TUTORIAL INTRO =====
function showTutorialStory() {
console.log('[FROGGLE] showTutorialStory START');
const slides = [
{
html: `
<div style="text-align:center">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#22c55e">Tapo's First Birthday!</h2>
<div style="margin:1.5rem 0">
<img src="assets/tapo-nobg.png" style="max-width:250px;height:auto;animation:tapoBounce 3s ease-in-out infinite">
</div>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
Today is <strong>Tapo the Tadpole's first birthday!</strong> üéâ
</p>
</div>
<style>
@keyframes tapoBounce {
0% { transform: translateY(0) scaleX(1); }
10% { transform: translateY(-20px) scaleX(1); }
15% { transform: translateY(-10px) scaleX(1); }
20% { transform: translateY(-25px) scaleX(1); }
30% { transform: translateY(0) scaleX(1); }
50% { transform: translateY(0) scaleX(-1); }
60% { transform: translateY(-20px) scaleX(-1); }
65% { transform: translateY(-10px) scaleX(-1); }
70% { transform: translateY(-25px) scaleX(-1); }
80% { transform: translateY(0) scaleX(-1); }
100% { transform: translateY(0) scaleX(1); }
}
</style>
`
},
{
html: `
<div style="text-align:center">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#60a5fa">A Special Gift</h2>
<div style="display:flex;justify-content:center;align-items:center;gap:2rem;margin:2rem 0">
<div>
<img src="assets/characters/magefull.png" style="width:150px;height:auto;border-radius:8px;border:2px solid #22c55e;box-shadow:0 4px 8px rgba(0,0,0,0.2)">
<div style="text-align:center;margin-top:0.5rem;font-weight:bold">Mage</div>
</div>
<div style="font-size:3rem">üéÅ</div>
<div style="animation:tapoBounceSmall 2s ease-in-out infinite">
<img src="assets/tapo-nobg.png" style="width:120px;height:auto">
<div style="text-align:center;margin-top:0.5rem;font-weight:bold">Tapo</div>
</div>
</div>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
Mage promised to teach Tapo how to catch flies as a birthday present!<br>
Together they set off to find some flies.
</p>
</div>
<style>
@keyframes tapoBounceSmall {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(-15px); }
}
</style>
`
}
];
slides.skippable = true;
slides.onComplete = () => {
// Start Phase 1: Tapo's Birthday tutorial
startTaposBirthdayTutorial();

setTimeout(() => {
showTaposBirthdayOverlay();
}, 100);
};
console.log('[FROGGLE] About to call showNarrativeSlide with', slides.length, 'slides');
showNarrativeSlide(slides, 0);
console.log('[FROGGLE] showNarrativeSlide called');
}

function showTaposBirthdayOverlay() {
// Show Phase 1 narrative overlay
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:550px">
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:1.5rem;text-align:center">
ü™∞ <strong>Two flies</strong> are buzzing around! ü™∞
</p>
<p style="font-size:1rem;line-height:1.6;text-align:center;margin-bottom:1.5rem">
Help Mage catch them for Tapo's birthday!
</p>
<button onclick="dismissTaposBirthdayOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer;display:block;margin:0 auto">Let's catch flies!</button>
</div>`;
document.body.appendChild(overlay);
}

function dismissTaposBirthdayOverlay() {
try {
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
allBackdrops.forEach(backdrop => backdrop.remove());
} catch (error) {
console.error('[TUTORIAL] Error removing Tapo birthday backdrops:', error);
}
// Show first tutorial popup
showTutorialPop('tapo_first_attack', "Click Mage's Attack sigil to catch a fly!", () => {
tutorialState.stage = 'catching_flies';
render();
});
}

function startTaposBirthdayTutorial() {
// Phase 1: Mage vs 2 Flies - Mage has Expand from the start
S.floor = 0;
S.xp = 0;
S.levelUpCount = 0;
S.heroes = [
{id:'h_tutorial_mage', n:'Mage', p:1, h:5, m:5, s:['Attack','Expand'], sh:0, g:0, ls:false, lst:0, ts:[], st:0}
];

// Add permanent passives (Asterisk, Star)
const passiveSigils = ['Asterisk', 'Star'];
S.heroes.forEach(hero => {
passiveSigils.forEach(passive => {
const permLevel = S.sig[passive] || 0;
if(permLevel > 0 && !hero.s.includes(passive)) {
hero.s.push(passive);
}
});
});

// Initialize Phase 1 tutorial state
tutorialState = {
stage: 'waiting_for_start',
phase: 1, // Track which phase we're in
fliesKilled: 0,
round: 1
};

// Start combat with 3 Flies
combat(0);
}

function finishTaposBirthdayPhase() {
// Phase 1 victory celebration
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="text-align:center;padding:2rem">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#22c55e">Success!</h2>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
Mage and Tapo catch all the flies!<br>
Tapo squeals with delight as they share the tasty treats together. üéâ
</p>
<button onclick="transitionToPortalInvasion()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer;margin-top:1rem">Continue</button>
</div>`;
}

function transitionToPortalInvasion() {
// Show portal opening narrative
const slides = [
{
html: `
<div style="text-align:center">
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#dc2626;animation:shake 0.5s ease-in-out infinite">DANGER!</h2>
<div style="margin:1.5rem 0;position:relative">
<div style="width:200px;height:200px;margin:0 auto;position:relative;border-radius:50%;background:radial-gradient(circle, #dc2626, #7c2d12);animation:narrativePortalPulse 1s ease-in-out infinite;box-shadow:0 0 40px #dc2626"></div>
<div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:4rem;animation:spin 2s linear infinite">üåÄ</div>
</div>
<p style="font-size:1.1rem;line-height:1.8;margin:1rem 0">
Suddenly, <strong>a dark portal</strong> tears open in the square!<br>
Tank, Warrior, and Healer rush to defend Tapo and Mage!
</p>
<div style="display:flex;justify-content:center;gap:2rem;margin:1.5rem 0;font-size:3rem">
<div style="animation:enemyAppear 1s ease-out">üë∫</div>
<div style="animation:enemyAppear 1.3s ease-out">üê∫</div>
</div>
</div>
<style>
@keyframes shake {
0%, 100% { transform: translateX(0); }
25% { transform: translateX(-5px); }
75% { transform: translateX(5px); }
}
@keyframes narrativePortalPulse {
0%, 100% { transform: scale(1); opacity: 0.8; }
50% { transform: scale(1.1); opacity: 1; }
}
@keyframes spin {
from { transform: translate(-50%, -50%) rotate(0deg); }
to { transform: translate(-50%, -50%) rotate(360deg); }
}
@keyframes enemyAppear {
from { transform: scale(0) rotate(-180deg); opacity: 0; }
to { transform: scale(1) rotate(0deg); opacity: 1; }
}
</style>
`
}
];
slides.onComplete = () => {
// Start Phase 2: Portal Invasion
startRibbletonTutorial();

setTimeout(() => {
showTutorialStoryOverlay();
}, 100);
};
showNarrativeSlide(slides, 0);
}

function showTutorialStoryOverlay() {
// Show narrative on TOP of combat screen
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:550px">
<p style="font-size:1.1rem;line-height:1.6;margin-bottom:1.5rem">
A Goblin and a Wolf appear from the portal!
</p>
<div style="display:grid;grid-template-columns:1fr auto 1fr;gap:1.5rem;align-items:center;margin:1.5rem 0">
<div style="display:flex;gap:0.5rem;align-items:center;justify-content:center">
<div style="animation:defensiveStance 1.5s ease-in-out infinite">
<img src="assets/characters/tankfull.png" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem">üõ° On Guard!</div>
</div>
<div style="text-align:center">
<img src="assets/tapo.png" style="width:60px;height:auto;border-radius:6px;border:2px solid #000">
<div style="font-size:0.65rem;opacity:0.7;margin-top:0.25rem">Protected!</div>
</div>
<div style="animation:defensiveStance 1.3s ease-in-out infinite">
<img src="assets/characters/magefull.png" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem">üìñ On Guard!</div>
</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.75rem;align-items:center;font-size:2.5rem">
<div style="animation:enemyThreat 1s ease-in-out infinite">üë∫</div>
<div style="animation:enemyThreat 1.2s ease-in-out infinite">üê∫</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.5rem;align-items:center">
<div style="animation:chargeForward 0.8s ease-out infinite alternate">
<img src="assets/characters/warriorfull.png" style="width:80px;height:auto;border-radius:6px;border:2px solid #3b82f6;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem">‚öîÔ∏è Attacking!</div>
</div>
<div style="animation:chargeForward 1s ease-out infinite alternate">
<img src="assets/characters/healerfull.png" style="width:80px;height:auto;border-radius:6px;border:2px solid #3b82f6;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem">‚úö Attacking!</div>
</div>
</div>
</div>
<p style="font-size:1rem;line-height:1.6;text-align:center;font-style:italic;opacity:0.9">
Tank and Mage stand guard around Tapo while Warrior and Healer charge toward the portal!
</p>
<div style="margin-top:1.5rem;display:flex;gap:1rem;justify-content:center;flex-wrap:wrap">
<button onclick="dismissStoryOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer">Let's fight!</button>
<button onclick="skipTutorialFromOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#888;color:#fff;border:2px solid #666;border-radius:8px;cursor:pointer">Skip Tutorial</button>
</div>
</div>
<style>
@keyframes chargeForward {
0% { transform: translateX(0) scale(1); }
100% { transform: translateX(15px) scale(1.05); }
}
@keyframes defensiveStance {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(-5px); }
}
@keyframes enemyThreat {
0%, 100% { transform: scale(1) rotate(0deg); }
50% { transform: scale(1.2) rotate(10deg); }
}
</style>`;
document.body.appendChild(overlay);
}

function dismissStoryOverlay() {
console.log('[TUTORIAL] Dismissing story overlay');
// Remove ALL backdrops before showing the tutorial pop
try {
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Found', allBackdrops.length, 'backdrops to remove');
allBackdrops.forEach((backdrop, idx) => {
console.log('[TUTORIAL] Removing backdrop', idx);
backdrop.remove();
});
} catch (error) {
console.error('[TUTORIAL] Error removing story overlay backdrops:', error);
}

// Double-check they're gone
setTimeout(() => {
try {
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
console.log('[TUTORIAL] Remaining overlays after dismiss:', remaining.length);
if(remaining.length > 0) {
console.error('[TUTORIAL] ERROR: Still have backdrops!', remaining);
remaining.forEach(r => r.remove());
}

// PROMPT 1: Warrior Attack + Targeting (BATCHED)
showTutorialPop('ribbleton_warrior_attack', "Welcome to combat! Click the Warrior's Attack sigil.", () => {
console.log('[TUTORIAL] Prompt 1 dismissed - transitioning to warrior_attack stage');
tutorialState.stage = 'warrior_attack';
S.activeIdx = 0;
console.log('[TUTORIAL] S.activeIdx is now:', S.activeIdx);
render();
});
} catch (error) {
console.error('[TUTORIAL] Error in story overlay cleanup:', error);
}
}, 50);
}

function skipTutorialFromOverlay() {
const overlay = document.querySelector('.tutorial-modal-backdrop');
if(overlay) overlay.remove();
// Skip to title card, then Ribbleton (Help/Tips remain ON by default)
toast('Tutorial skipped!', ANIMATION_TIMINGS.TOAST_SHORT);
setTimeout(() => transitionScreen(showTitleCard), ANIMATION_TIMINGS.ACTION_COMPLETE);
}

function skipTutorial() {
// This function is for legacy "skip tutorial" - just go to title
toast('Going to hero selection...');
title();
}

// ===== RIBBLETON TUTORIAL (PHASE 2) =====
function startRibbletonTutorial() {
// Phase 2: Portal Invasion - Wolf and Goblin fight with Warrior and Healer
S.floor = 0;
S.xp = 0;
S.levelUpCount = 0;
S.heroes = [
{id:'h_tutorial_warrior', n:'Warrior', p:2, h:5, m:5, s:['Attack','D20'], sh:0, g:0, ls:false, lst:0, ts:[], st:0},
{id:'h_tutorial_healer', n:'Healer', p:1, h:5, m:5, s:['Heal','D20','Expand'], sh:0, g:0, ls:false, lst:0, ts:[], st:0}
];

// Add permanently upgraded passives (Expand, Asterisk, Star) to tutorial heroes
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
S.heroes.forEach(hero => {
passiveSigils.forEach(passive => {
const permLevel = S.sig[passive] || 0;
if(permLevel > 0 && !hero.s.includes(passive)) {
hero.s.push(passive);
}
});
});

// Initialize Phase 2 tutorial state
tutorialState = {
stage: 'waiting_for_start',
phase: 2, // Phase 2: Portal Invasion
wolfDamaged: false,
wolfKilled: false,
goblinKilled: false,
round: 1
};

// Start combat using real combat system!
combat(0);
}


function finishRibbletonTutorial() {
// Post-combat narrative
const slides = [
{text: "The few enemies remaining around Ribbleton scamper back into the portal. Relieved, the frog heroes sheathe their weapons and look for Tapo - but he's missing!!"},
{text: "As the Ribbletonians search high and low, the heroes realize there's only one possibility - the poor tadpole has squiggled his way through the portal!"},
{text: "The townspeople gather around the heroes. \"You must bring him home!\" they plead. The heroes nod solemnly - Ribbleton will be their sanctuary, and they'll return here between each rescue attempt."}
];
slides.onComplete = showTitleCard;
showNarrativeSlide(slides, 0);
}

function showTitleCard() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:#000;display:flex;align-items:center;justify-content:center;z-index:30000">
<div style="text-align:center;color:#fff">
<div style="font-size:3rem;font-weight:bold;margin-bottom:1rem">FROGGLE</div>
<div style="font-size:1.5rem;font-style:italic">A Froggy Roguelike</div>
</div>
</div>`;

setTimeout(() => {
tutorialState = null;
showRibbleton(); // Go to Ribbleton hub
}, 3000); // Reduced from 5500ms to 3000ms for faster flow
}

// ===== TITLE & HERO SELECT =====
let selectedHeroView = null; // Track which hero card is currently displayed

function title() {
console.log('[FROGGLE] title() called - Hero selection screen');
// Reset selection first
sel = [];

const v = document.getElementById('gameView');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;

v.innerHTML = `
<h1 style="text-align:center;margin:2rem 0;font-size:2rem">FROGGLE üê∏</h1>
<p style="text-align:center;margin-bottom:0.5rem;font-size:0.9rem">v9.992</p>
<p style="text-align:center;margin-bottom:1rem;font-size:1.1rem;font-weight:bold">Mode: <span style="color:${S.gameMode === 'fu' ? '#dc2626' : '#22c55e'}">${S.gameMode === 'Standard' ? 'Standard' : 'FROGGED UP üî•'}</span></p>

<div style="text-align:center;margin-bottom:1rem">
<button class="btn secondary" onclick="showFAQ()" style="padding:0.75rem 1.5rem;font-size:1rem;font-weight:bold">
‚ùì Help/FAQ
</button>
</div>

${S.fuUnlocked ? `<div style="text-align:center;margin-bottom:1rem">
<button class="btn" onclick="showChampionsMenu()" style="padding:0.75rem 1.5rem;background:linear-gradient(135deg,#3b82f6,#f97316);font-weight:bold">
üèÜ Champions of Floor 20 üèÜ
</button></div>` : ''}

<div style="max-width:600px;margin:0 auto">
<h2 style="text-align:center;margin-bottom:1rem;font-size:1.3rem">Choose ${requiredHeroes} Heroes</h2>
<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem;opacity:0.7">Tap a hero to select!</p>
<div id="hero-select-container" style="position:relative;max-width:100%;margin:0 auto;cursor:pointer" onclick="handleHeroImageClick(event, this)">
<img src="assets/hero-select.png" style="width:100%;height:auto;display:block;border-radius:8px;border:3px solid #000;pointer-events:none">
<!-- Hero card overlays -->
<div id="warrior-card" style="position:absolute;bottom:10%;left:1%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="tank-card" style="position:absolute;bottom:10%;left:26%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="mage-card" style="position:absolute;bottom:10%;left:51%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="healer-card" style="position:absolute;bottom:10%;left:76%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
</div>

${S.tapoUnlocked ? `
<div style="margin-top:1rem;text-align:center">
<button class="btn" onclick="toggleHeroSelection('tapo')" style="background:linear-gradient(135deg,#3b82f6 0%,#22c55e 100%);padding:0.75rem 1.5rem;font-size:1rem;font-weight:bold;border:3px solid #000">
üéâ View Tapo (UNLOCKED!) üéâ
</button>
</div>` : ''}

<!-- Selection display -->
<div style="text-align:center;margin:1.5rem 0;padding:1rem;background:rgba(0,0,0,0.05);border-radius:8px">
<strong>Selected Heroes:</strong>
<div id="selection-display" style="margin-top:0.5rem;font-size:1.1rem;color:#2563eb"></div>
</div>

<button class="btn" id="start" onclick="start()" style="width:100%;padding:1rem;font-size:1.1rem">Delve into Floor 1</button>
</div>`;

console.log('[FROGGLE] title() innerHTML set successfully');

// Shield persistence tutorial (after first run with shield usage or death)
if(!S.helpTipsDisabled && !S.tutorialFlags.shield_persistence && S.highestFloor >= 1) {
// Check if they used shield or died
const usedShield = S.sig.Shield > 0 || (S.tempSigUpgrades && S.tempSigUpgrades.Shield > 0);
if(usedShield || S.highestFloor > 0) { // highestFloor > 0 means they died at least once
setTimeout(() => {
showTutorialPop('shield_persistence', "Shields persist between battles! They're capped at max HP, so you can shield up before finishing a floor to enter the next floor with protection. Use this to survive tough encounters!");
}, 100);
}
}

// Update selection display
updateSelectionDisplay();
}

function handleHeroImageClick(event, container) {
// Validate inputs
if (!event || !container) {
console.warn('Invalid event or container, ignoring click');
return;
}

// Calculate which hero was clicked based on X position
const rect = container.getBoundingClientRect();
if (!rect) {
console.warn('Could not get container bounds, ignoring click');
return;
}

const x = event.clientX - rect.left;
const percent = (x / rect.width) * 100;

// Validate coordinates - if invalid, ignore the click
if (Number.isNaN(percent) || percent < 0 || percent > 100) {
console.warn('Invalid click coordinates, ignoring');
return;
}

// Determine hero based on position (4 equal 25% sections)
let heroType;
if (percent < 25) heroType = 'warrior';
else if (percent < 50) heroType = 'tank';
else if (percent < 75) heroType = 'mage';
else heroType = 'healer';

toggleHeroSelection(heroType);
}

function updateHeroCards() {
const heroData = {
warrior: {name: 'Warrior', pow: 2, hp: 5, maxhp: 5, sigils: ['Attack', 'D20'], desc: 'A balanced fighter with strong attacks', callouts: ['Starts with 2 POW', 'Starts with Attack and D20']},
tank: {name: 'Tank', pow: 1, hp: 10, maxhp: 10, sigils: ['Shield', 'D20'], desc: 'A sturdy defender with high HP', callouts: ['Starts with 10 HP', 'Starts with Shield and D20']},
mage: {name: 'Mage', pow: 1, hp: 5, maxhp: 5, sigils: ['Attack', 'D20', 'Expand'], desc: 'A versatile caster who can hit multiple targets', callouts: ['Gets +1 Expand innately (+1 target)', 'Starts with Attack, D20, and Expand']},
healer: {name: 'Healer', pow: 1, hp: 5, maxhp: 5, sigils: ['Heal', 'D20', 'Expand'], desc: 'A support hero who can heal multiple allies', callouts: ['Gets +1 Expand innately (+1 target)', 'Starts with Heal, D20, and Expand']},
tapo: {name: 'Tapo', pow: 1, hp: 1, maxhp: 1, sigils: ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha'], desc: 'The ultimate glass cannon - all sigils, minimal health!', callouts: ['Starts with ALL 10 sigils', 'Only 1 HP - high risk, high reward!']}
};

// Update all card displays
['warrior', 'tank', 'mage', 'healer'].forEach(h => {
const cardEl = document.getElementById(`${h}-card`);
if(!cardEl) return;

if(sel.includes(h)) {
const hData = heroData[h];
const hPixelImage = HERO_IMAGES[h] || '';
const sigilsHTML = hData.sigils.map(s => `<span class="sigil l1" style="font-size:0.5rem;padding:2px 4px;margin:1px;display:inline-block">${sigilIconOnly(s)}</span>`).join('');
const calloutsHTML = hData.callouts ? hData.callouts.map(c => `<div style="font-size:0.45rem;text-align:left;opacity:0.9;margin:1px 0">‚Ä¢ ${c}</div>`).join('') : '';
cardEl.innerHTML = `
<div style="background:white;border:3px solid #22c55e;border-radius:8px;padding:0.5rem;box-shadow:0 4px 6px rgba(0,0,0,0.3);pointer-events:auto;cursor:pointer"
onclick="event.stopPropagation();toggleHeroSelection('${h}')">
<div style="text-align:center">
<div style="font-size:0.7rem;font-weight:bold;margin-bottom:0.25rem">${hData.name}</div>
${hPixelImage ? `<img src="${hPixelImage}" style="width:100%;height:auto;border-radius:4px;margin-bottom:0.25rem">` : ''}
<div style="font-size:0.6rem;opacity:0.8">${hData.pow}‚ö° | ${hData.hp}‚ù§</div>
<div style="font-size:0.6rem;margin-top:0.25rem">${sigilsHTML}</div>
${calloutsHTML ? `<div style="margin-top:0.25rem;padding:0.25rem;background:rgba(251,191,36,0.1);border-radius:4px">${calloutsHTML}</div>` : ''}
<div style="font-size:0.5rem;opacity:0.7;margin-top:0.25rem">‚úì SELECTED</div>
</div>
</div>`;
cardEl.style.display = 'block';
} else {
cardEl.style.display = 'none';
}
});
}

function toggleHeroSelection(heroType) {
// Toggle selection
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
const isSelected = sel.includes(heroType);
if(isSelected) {
sel = sel.filter(h => h !== heroType);
} else {
if(sel.length < requiredHeroes) {
sel.push(heroType);
}
}

// Update card displays and selection display
updateHeroCards();
updateSelectionDisplay();
}


function updateSelectionDisplay() {
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
const display = document.getElementById('selection-display');
if(!display) return;

if(sel.length === 0) {
display.textContent = 'None';
display.style.color = '#6b7280';
} else {
const heroNames = sel.map(h => H[h].n);
display.textContent = heroNames.join(' + ');
display.style.color = '#2563eb';
}

const btn = document.getElementById('start');
if(btn) {
const isDisabled = sel.length !== requiredHeroes;
btn.disabled = isDisabled;
if(isDisabled) {
btn.classList.add('disabled');
} else {
btn.classList.remove('disabled');
}
btn.style.opacity = sel.length === requiredHeroes ? '1' : '0.4';
}
}

function toggleMode() {
S.gameMode = S.gameMode === 'Standard' ? 'fu' : 'Standard';
savePermanent();
title();
}

function pick(t) {
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
const i = sel.indexOf(t);
if(i>=0) {
sel.splice(i,1);
} else if(sel.length<requiredHeroes) {
sel.push(t);
} else {
toast(`Maximum ${requiredHeroes} heroes!`);
return;
}

// Update selection display
updateSelectionDisplay();
}

function start() {
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
if(sel.length!==requiredHeroes) return;
// Show game header when entering gameplay
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';

S.floor=1; S.xp=0; S.levelUpCount=0;
// Reset temporary XP sigil upgrades (these don't persist between runs)
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// NOTE: Gold persists between runs! Only reset on victory or spent at Death Screen
S.heroes = sel.map((t,i) => ({
id:`h-${crypto.randomUUID()}`,
n:H[t].n, p:H[t].p, h:H[t].h, m:H[t].m,
s:[...H[t].s], sh:0, g:0, ls:false, lst:0, ts:[], st:0
}));

// Add permanently upgraded passives (Expand, Asterisk, Star) to all heroes
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
S.heroes.forEach(hero => {
passiveSigils.forEach(passive => {
const permLevel = S.sig[passive] || 0;
// If this passive has been upgraded with gold (L1+) and hero doesn't have it, add it
if(permLevel > 0 && !hero.s.includes(passive)) {
hero.s.push(passive);
}
});
});

// Apply pedestal buffs
S.pedestal.forEach(slot => {
if(slot.mode !== S.gameMode) return; // Only apply buffs for current mode
const hero = S.heroes.find(h => h.n === slot.hero);
if(!hero) return;
if(slot.stat === 'POW') {
hero.p += 1;
} else if(slot.stat === 'HP') {
hero.m += 5;
hero.h += 5;
}
});
initNeutralDeck();
upd();
// Check if player has starting XP from Death Boy sacrifices
if(S.startingXP > 0) {
S.xp = S.startingXP;
showStartingXPScreen();
} else {
startFloor(1);
}
}

// ===== FLOOR MANAGEMENT =====
function getFloorName(f) {
const floorNames = {
1: 'Goblin Horde',
3: 'Wolf Pack',
5: 'Orc Wall',
7: 'Giant\'s Descent',
9: 'Troll Lair',
11: 'Goblin Army',
13: 'Wolf Swarm',
15: 'Dragon\'s Nest',
17: 'Chaos Legion',
19: 'Dungeon of the Hydra'
};
return floorNames[f] || null;
}

function showFloorInterstitial(f, callback) {
const floorName = getFloorName(f);
if(!floorName) {
callback();
return;
}
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="position:fixed;top:0;left:0;width:100%;height:100vh;background:#000;display:flex;align-items:center;justify-content:center;z-index:30000">
<div style="text-align:center;color:#fff;animation:fadeIn 0.5s ease">
<div style="font-size:2.5rem;font-weight:bold;margin-bottom:1rem">Floor ${f}</div>
<div style="font-size:1.8rem;font-style:italic">${floorName}</div>
</div>
</div>
<style>
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
</style>`;
setTimeout(callback, ANIMATION_TIMINGS.FLOOR_INTERSTITIAL);
}

function startFloor(f) {
S.floor=f;
upd();
// Special: Floor 20 in Frogged Up mode shows Old Tapo encounter
if(f === 20 && S.gameMode === 'fu') {
showOldTapo();
return;
}
if(f >= 20) { win(); return; }
// Floor 11 is always ambushed (Goblin Army)
if(f === 11) {
S.ambushed = true;
}
// Show interstitial for combat floors
if(f % 2 === 1) {
showFloorInterstitial(f, () => combat(f));
} else {
neutral(f);
}
}

function getEnemyComp(f) {
const heroCount = S.heroes.length;
if(f===0) {
// Tutorial floor - check phase
if(tutorialState && tutorialState.phase === 1) {
return ['fly', 'fly']; // Phase 1: Tapo's Birthday (2 flies)
} else {
return ['goblin', 'wolf']; // Phase 2: Portal Invasion
}
}
if(f===1) return Array(heroCount).fill('goblin');
if(f===3) return Array(heroCount).fill('wolf');
if(f===5) return Array(heroCount * 2).fill('orc');
if(f===7) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('giant', 'wolf', 'goblin');
return comp;
}
if(f===9) return Array(heroCount).fill('caveTroll');
if(f===11) return Array(heroCount * 5).fill('goblin');
if(f===13) return Array(heroCount * 5).fill('wolf');
if(f===15) return Array(heroCount).fill('dragon');
if(f===17) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('caveTroll', 'giant', 'orc', 'wolf', 'goblin');
return comp;
}
if(f===19) return Array(heroCount * 3).fill('dragon');
return ['goblin'];
}

// ===== COMBAT (v7.2 PERFECT COMBAT - UNCHANGED) =====
/**
 * Initializes combat encounter for given floor.
 *
 * Combat Initialization:
 * - Resets turn state (round=1, turn='player', no actions)
 * - Shields persist from previous combat (capped at max HP)
 * - Ghost charges persist between combats
 * - Stun counters reset to 0
 * - Creates enemies based on floor composition
 * - Handles Ribbleton tutorial special cases
 * - Applies Frogged Up mode multipliers (3x stats and rewards)
 *
 * @param {number} f - Floor number (1-19, or 0 for tutorial)
 */
function combat(f) {
S.round=1; S.turn='player'; S.activeIdx=-1; S.acted=[]; S.locked=false;
S.lastActions={};
S.combatXP=0; S.combatGold=0; // Track combat rewards separately
S.pending=null; S.targets=[]; S.currentInstanceTargets=[]; S.instancesRemaining=0; S.totalInstances=0;
// Don't clear recruits here - they may have been added before combat (e.g., Encampment straggler)
if(!S.recruits) S.recruits = [];
S.heroes.forEach(h => {
// Shields now persist between battles, but cap at max HP
if(h.sh > h.m) h.sh = h.m;
h.st=0;
if(!h.ts) h.ts=[];
// Passive Asterisk: Reset first action flag each combat
h.firstActionUsed = false;
// If ambushed, stun all heroes turn 1
if(S.ambushed) h.st = 1;
});
let comp = getEnemyComp(f);

S.enemies = comp.map((t,i) => {
const base = E[t];
const fuMultiplier = S.gameMode === 'fu' ? 3 : 1;
const enemy = {
id:`e-${crypto.randomUUID()}`, n:base.n,
p:base.p * fuMultiplier,
h:base.h * fuMultiplier,
m:base.m * fuMultiplier,
goldDrop:(base.goldDrop || 0) * fuMultiplier, x:(base.x || 0) * fuMultiplier, s: [], pool: base.pool,
gainRate: base.gainRate || 3, turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st:0, li: i % S.heroes.length, sh:0, g:0, alphaActed: false
};
if(base.permSigils) base.permSigils.forEach(ps => enemy.s.push({sig:ps.s, level:ps.l, perm:true}));
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
// Array format: [{s:'Shield', l:1}]
base.startSigils.forEach(ss => enemy.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
// Numeric format: draw N random sigils
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(enemy, base);
}
}
}
return enemy;
});
if(S.ambushed) {
toast('AMBUSHED! All heroes stunned Turn 1!', 1800);
S.ambushed = false; // Clear flag after use
}
// Check if we need to show Encampment enemy selection
if(S.encampmentEarlyKills && S.encampmentEarlyKills > 0) {
S.selectingEncampmentTargets = true;
S.encampmentSelectedTargets = [];
}
render();
// REMOVED: Tooltip tutorial now batched with handoff in Ribbleton (floor 0)
}

function getLevel(sig, heroIdx) {
const h = S.heroes[heroIdx];
// Calculate total level (permanent + temporary XP upgrades)
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
// Star, Asterisk, and Expand are global passives - all heroes get them when upgraded
if(sig === 'Star' || sig === 'Asterisk' || sig === 'Expand') {
// Special case: Mage and Healer get +1 to Expand
if(sig === 'Expand' && (h.n === 'Mage' || h.n === 'Healer')) return totalLevel + 1;
return totalLevel;
}
// For other sigils, check if hero has it
const hasSigil = h.s.includes(sig) || (h.ts && h.ts.includes(sig));
if(!hasSigil) return 0;
// Actives always display +1 higher (perm 0 = L1, perm 1 = L2, etc.)
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
if(actives.includes(sig)) return totalLevel + 1;
return totalLevel;
}

function getTargetsPerInstance(action, heroIdx) {
const expandLevel = getLevel('Expand', heroIdx);
return 1 + expandLevel;
}

function needsEnemyTarget(action) { return ['Attack', 'Grapple'].includes(action); }
function needsHeroTarget(action) { return ['Heal', 'Shield', 'Alpha'].includes(action); }
function isMultiInstance(action) { return ['Attack', 'Shield', 'Heal'].includes(action); }

function getD20DC(baseDC, heroIdx, gambitName) {
const h = S.heroes[heroIdx];
if(!h || !h.ls) return baseDC;
// Last Stand: +2 immediately, then +2 each turn (h.lst counts turns in Last Stand)
const lastStandBonus = (h.lst + 1) * 2;
// Confuse caps at DC 20, all other gambits continue increasing
if(gambitName === 'CONFUSE') {
return Math.min(baseDC + lastStandBonus, 20);
}
return baseDC + lastStandBonus;
}

function selectHero(idx) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending) return;
const h = S.heroes[idx];
if(!h) { console.error('Invalid hero index:', idx); return; }
if(S.acted.includes(idx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
S.activeIdx = idx;
if(h.ls) toast(`${h.n} in Last Stand - D20 only!`);
render();
}

function act(sig, heroIdx) {
// Hide any pending tooltips when action is selected
hideTooltip();

// RIBBLETON TUTORIAL: Check for scripted actions using TutorialManager
const h = S.heroes[heroIdx];
if(!h) { console.error('Invalid hero index in act():', heroIdx); return; }
if(!TutorialManager.canPerformAction(h, sig)) {
toast(TutorialManager.getInstructionMessage());
return;
}

if(S.locked) { toast('Wait for enemy turn!'); return; }
// Allow switching actions only if no instances have been completed yet
if(S.pending) {
// Check if any instances have been completed
if(S.instancesRemaining > 0 && S.totalInstances && S.instancesRemaining < S.totalInstances) {
toast('Must complete remaining instances!');
return;
}
// Allow switching if no instances completed yet
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
}
if(S.acted.includes(heroIdx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
if(h.ls && sig !== 'D20') { toast('Last Stand - D20 only!'); return; }
S.activeIdx = heroIdx;

// PASSIVE ASTERISK: Auto-apply on first action per combat
const asteriskLevel = getLevel('Asterisk', heroIdx);
const hasAsterisk = asteriskLevel > 0;
const firstAction = !h.firstActionUsed;
let repeats = 1;

if(hasAsterisk && firstAction) {
repeats = asteriskLevel + 1;
h.firstActionUsed = true;
toast(`Asterisk activated! ${sig} √ó${repeats}!`, 1500);
}

if(sig === 'Ghost') {
const level = getLevel('Ghost', heroIdx);
if(level === 0) { toast(`${h.n} doesn't have Ghost! Add it in Level-Up menu (costs XP).`); return; }
const totalCharges = level * repeats;
h.g = Math.min((h.g || 0) + totalCharges, 9);
toast(`${h.n} gained ${totalCharges} Ghost charge${totalCharges>1?'s':''}!`);
finishAction(heroIdx);
} else if(sig === 'D20') {
S.pending = 'D20';
S.asteriskD20Repeats = repeats;
S.asteriskD20Count = 0;
d20Menu(heroIdx);
} else if(isMultiInstance(sig)) {
const level = getLevel(sig, heroIdx);
if(level === 0) { toast(`${h.n} doesn't have ${sig}! Add it in Level-Up menu (costs XP).`); return; }
S.pending = sig;
S.instancesRemaining = level * repeats;
S.totalInstances = level * repeats; // Track for color roll-down
S.targets = [];
S.currentInstanceTargets = [];
render();
} else if(sig === 'Grapple') {
const level = getLevel('Grapple', heroIdx);
if(level === 0) { toast(`${h.n} doesn't have Grapple! Add it in Level-Up menu (costs XP).`); return; }
S.pending = 'Grapple';
S.grappleRepeats = repeats;
S.grappleLevel = level;
S.targets = [];
render();
} else if(sig === 'Alpha') {
const level = getLevel('Alpha', heroIdx);
if(level === 0) { toast(`${h.n} doesn't have Alpha! Add it in Level-Up menu (costs XP).`); return; }
const expandLevel = getLevel('Expand', heroIdx);
const targetsNeeded = 1 + expandLevel;
S.pending = 'Alpha';
S.alphaLevel = level;
S.alphaTargetsNeeded = targetsNeeded;
S.targets = [];
toast(`Alpha: Grant ${level} action${level>1?'s':''} to ${targetsNeeded} hero${targetsNeeded>1?'es':''}!`);
render();
}
}

function d20Menu(heroIdx) {
if(S.locked) return;

// RIBBLETON TUTORIAL: PROMPT 2 - Explain D20 gambit
if(tutorialState && S.floor === 0 && tutorialState.stage === 'healer_d20') {
tutorialState.stage = 'd20_menu';
showTutorialPop('ribbleton_d20_menu', "Choose a gambit! Each has a DC (Difficulty Check) - you need to roll that number or higher to succeed. Pick CONFUSE to damage the Wolf!", () => {
// After prompt, show the d20 menu
renderD20MenuAfterTutorial(heroIdx);
});
return;
}

renderD20MenuAfterTutorial(heroIdx);
}

function renderD20MenuAfterTutorial(heroIdx) {
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];

// RIBBLETON TUTORIAL: Special D20 menu that doesn't block view
const isTutorial = tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu';

let html = '';
if(isTutorial) {
// Tutorial version: overlay on left side only, keep enemies visible
html = '<div style="position:fixed;top:50%;left:10px;transform:translateY(-50%);z-index:15000;max-width:380px;background:white;border:4px solid #3b82f6;border-radius:12px;padding:1.5rem;box-shadow:0 8px 32px rgba(0,0,0,0.5)">';
html += '<h3 style="margin-bottom:1rem;color:#6b4423">D20: Do Something Crazy</h3>';
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, 12, 'CONFUSE')" style="margin-bottom:0.5rem;background:#3b82f6;border:3px solid #f97316;font-size:1.1rem;cursor:pointer">
<strong style="font-size:1.2rem">‚úÖ DC 12: CONFUSE</strong><br>
<span style="font-size:0.95rem">Deal this enemy's POW to all enemies</span>
</div>`;
// Show other options greyed out
const lockedOptions = [
{dc:14, name:'STARTLE', desc:'Stun for 1 turn'},
{dc:16, name:'MEND', desc:'Heal self for POW'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
lockedOptions.forEach(opt => {
html += `<div style="margin-bottom:0.5rem;background:#e0e0e0;border:2px solid #999;border-radius:8px;padding:0.75rem;opacity:0.5;cursor:not-allowed">
<strong style="font-size:0.95rem">üîí DC ${opt.dc}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
html += '</div>';
// Tutorial: Append as overlay, don't replace combat view
render(); // First render combat view
v.insertAdjacentHTML('beforeend', html);
return;
} else {
// Normal D20 menu (centered, blocks view)
html = '<div style="text-align:center;padding:1rem;background:white;border:3px solid #000;border-radius:8px;margin:1rem auto;max-width:400px">';
html += '<h3 style="margin-bottom:1rem">D20: Do Something Crazy</h3>';
const expandLevel = getLevel('Expand', heroIdx);
const maxTargets = 1 + expandLevel;
if(expandLevel > 0) html += `<p style="margin-bottom:0.75rem;color:#22c55e;font-weight:bold;font-size:1.05rem;background:rgba(34,197,94,0.1);padding:0.5rem;border-radius:6px;border:2px solid #22c55e">‚ú® Expand L${expandLevel} Active: Target up to ${maxTargets} enemies!</p>`;
if(S.asteriskD20Repeats > 1) {
html += `<p style="margin-bottom:0.5rem;color:#f97316">Asterisk Active: Pick ${S.asteriskD20Repeats} actions!</p>`;
html += `<p style="margin-bottom:1rem;font-size:0.85rem">(${S.asteriskD20Count}/${S.asteriskD20Repeats} used)</p>`;
}
if(h.ls && h.lst >= 0) {
const lsBonus = (h.lst + 1) * 2;
html += `<p style="margin-bottom:0.5rem;color:#dc2626;font-weight:bold">Last Stand Turn ${h.lst + 1}: DCs +${lsBonus}</p>`;
}
const options = [
{dc:12, name:'CONFUSE', desc:'Deal this enemy\'s POW to all enemies'},
{dc:14, name:'STARTLE', desc:'Stun for 1 turn'},
{dc:16, name:'MEND', desc:'Heal self for POW'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
options.forEach(opt => {
const adjustedDC = getD20DC(opt.dc, heroIdx, opt.name);
const dcText = adjustedDC > opt.dc ? `DC ${adjustedDC} (${opt.dc}+${adjustedDC - opt.dc})` : `DC ${opt.dc}`;
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, ${adjustedDC}, '${opt.name}')" style="margin-bottom:0.5rem">
<strong>${dcText}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
if(S.asteriskD20Count > 0) html += `<button class="btn safe" onclick="finishD20Asterisk(${heroIdx})">Finish (${S.asteriskD20Count} used)</button>`;
else html += `<button class="btn secondary" onclick="cancelAction()">Cancel</button>`;
html += '</div>';
v.innerHTML = html;
}
}

function selectD20Action(heroIdx, dc, actionName) {
if(S.locked) return;
S.d20Action = actionName;
S.d20DC = dc;
S.d20HeroIdx = heroIdx;

// RIBBLETON TUTORIAL: Show Expand explanation after choosing CONFUSE
if(tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu' && actionName === 'CONFUSE') {
showTutorialPop('healer_expand_explain', "Healer also has Expand - just like Mage used with Attack! This lets you add a target to your D20 gambit. Try selecting 2 enemies to Confuse!", () => {
S.pending = 'D20_TARGET';
S.targets = [];
render();
});
return;
}

// RECRUIT TUTORIAL: Show explanation when first selecting Recruit
if(actionName === 'RECRUIT') {
showTutorialPop('recruit_intro', "Recruited enemies will stand behind the hero who recruited them and fight alongside you until death! Each hero can have 1 recruit.", () => {
S.pending = 'D20_TARGET';
S.targets = [];
render();
});
return;
}

// MEND is self-targeting, execute immediately
if(actionName === 'MEND') {
const d20Level = getLevel('D20', heroIdx);
const {rolls, best} = rollDice(d20Level, 20);
const rollText = formatD20Compact(rolls, best);
const h = S.heroes[heroIdx];
if(best >= dc) {
const healAmount = h.p;
h.h = Math.min(h.h + healAmount, h.m);
toast(`${rollText} <span style="color:#22c55e;font-weight:bold">SUCCESS!</span> ${h.n} healed for ${healAmount} HP!`, 2000);
} else {
toast(`${rollText} <span style="color:#ef4444;font-weight:bold">FAILED!</span>`, 1800);
}
S.pending = null;
render();
checkTurnEnd();
return;
}

S.pending = 'D20_TARGET';
S.targets = [];
render();
}

function rollD20() {
if(S.locked) return;
const heroIdx = S.d20HeroIdx;
const h = S.heroes[heroIdx];
const dc = S.d20DC;
const actionName = S.d20Action;
const d20Level = getLevel('D20', heroIdx);
let rolls, best;

// RIBBLETON TUTORIAL: Fudge roll to always succeed (17-18)
if(tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu') {
const fudgedRoll = 17 + Math.floor(Math.random() * 2); // 17 or 18
rolls = [fudgedRoll];
best = fudgedRoll;
} else {
({rolls, best} = rollDice(d20Level, 20));
}
const rollText = formatD20Compact(rolls, best);

if(best >= dc) {
toast(`${rollText} <span style="color:#22c55e;font-weight:bold">SUCCESS!</span>`, 1800);
const targetNames = S.targets.map(id => {
const e = S.enemies.find(e => e.id === id);
return e ? e.n : null;
}).filter(n => n);
S.targets.forEach(targetId => executeD20ActionOnTarget(targetId, actionName));
if(targetNames.length > 0) {
const actionDesc = {'CONFUSE': 'confused', 'STARTLE': 'startled and stunned', 'STEAL': 'robbed', 'RECRUIT': 'recruited'};
if(actionName !== 'STEAL') toast(`${targetNames.join(', ')} ${actionDesc[actionName]}!`, 2500);
}
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), ANIMATION_TIMINGS.TUTORIAL_DELAY);
return;
}
}
finishD20Asterisk(heroIdx);
} else {
toast(`${rollText} <span style="color:#ef4444;font-weight:bold">FAILED!</span>`, ANIMATION_TIMINGS.TOAST_MEDIUM);
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), ANIMATION_TIMINGS.TUTORIAL_DELAY);
return;
}
}
finishD20Asterisk(heroIdx);
}
}

function executeD20ActionOnTarget(enemyId, action) {
const enemy = S.enemies.find(e => e.id === enemyId);
if(!enemy) return;
if(action === 'CONFUSE') {
const dmg = enemy.p;
// Deal this enemy's POW to all enemies
S.enemies.forEach(e => {
dealDamageToEnemy(e, dmg);
});
} else if(action === 'STARTLE') {
enemy.st = 1;
// Check prince quest completion
if(S.princeQuestActive && S.round === 1 && !S.princeQuestCompleted) {
S.princeQuestCompleted = true;
toast('Prince Quest completed! Ring retrieved!', 1800);
}
} else if(action === 'STEAL') {
const gold = enemy.p;
S.gold += gold;
upd();
toast(`Stole ${gold} Gold from ${enemy.n}!`);
} else if(action === 'RECRUIT') {
const heroIdx = S.d20HeroIdx;
const hero = S.heroes[heroIdx];
// Check if hero already has a recruit - if so, replace it
if(!S.recruits) S.recruits = [];
const existingRecruitIdx = S.recruits.findIndex(r => r.recruitedBy === heroIdx);
if(existingRecruitIdx >= 0) {
const oldRecruit = S.recruits[existingRecruitIdx];
S.recruits.splice(existingRecruitIdx, 1);
toast(`${enemy.n} replaces ${oldRecruit.n} as ${hero.n}'s recruit!`, 1800);
} else {
toast(`${enemy.n} recruited by ${hero.n}!`, 1500);
}
// Remove enemy from enemies array
S.enemies = S.enemies.filter(e => e.id !== enemyId);
// Add new recruit to recruits array (max 10 recruits for performance)
const MAX_RECRUITS = 10;
if(S.recruits.length < MAX_RECRUITS) {
const recruit = {...enemy, recruitedBy: heroIdx, isRecruit: true};
S.recruits.push(recruit);
} else {
toast(`${enemy.n} recruited but recruits are full! (Max ${MAX_RECRUITS})`, 2000);
}
setTimeout(() => {
render();
checkCombatEnd();
}, 300);
}
}

function finishD20Asterisk(heroIdx) {
S.acted.push(heroIdx);
S.pending = null;
S.targets = [];
S.asteriskD20Repeats = 1;
S.asteriskD20Count = 0;
checkTurnEnd();
render();
}

function cancelAction() {
if(S.locked) return;
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
render();
}

function tgtEnemy(id) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
if(S.targets.includes(id)) { toast('Already targeted!'); return; }
S.targets.push(id);
const slotsFilled = S.targets.length >= maxTargets;
const allEnemiesSelected = S.targets.length >= S.enemies.length;
if(slotsFilled || allEnemiesSelected) {
if(allEnemiesSelected && S.targets.length < maxTargets) {
const wasted = maxTargets - S.targets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
rollD20();
} else render();
return;
}
if(!S.pending || !needsEnemyTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
if(S.pending === 'Attack') {
if(S.currentInstanceTargets.includes(id)) { toast('Already targeted in this instance!'); return; }
S.targets.push(id);
S.currentInstanceTargets.push(id);
const availableEnemies = S.enemies.length;
const slotsFilled = S.currentInstanceTargets.length >= targetsPerInstance;
const allEnemiesSelected = S.currentInstanceTargets.length >= availableEnemies;
if(slotsFilled || allEnemiesSelected) {
if(allEnemiesSelected && S.currentInstanceTargets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.currentInstanceTargets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
// PHASE 1 TUTORIAL: Explain wasted Expand slots
if(tutorialState && tutorialState.phase === 1 && !S.tutorialFlags.tapo_wasted_expand) {
S.tutorialFlags.tapo_wasted_expand = true;
showTutorialPop('tapo_wasted_expand', "One slot wasted - but that's okay! Expand shines when you have multiple targets.", () => {
upd();
render();
});
}
}
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) {
// Delay finishAction to allow attack animation to complete
setTimeout(() => finishAction(heroIdx), ANIMATION_TIMINGS.ACTION_COMPLETE);
} else {
// Delay render to allow attack animation to complete
setTimeout(() => render(), ANIMATION_TIMINGS.ACTION_COMPLETE);
}
} else render();
} else if(S.pending === 'Grapple') {
if(S.targets.includes(id)) { toast('Already targeted!'); return; }
S.targets.push(id);
const slotsFilled = S.targets.length >= targetsPerInstance;
const allEnemiesSelected = S.targets.length >= S.enemies.length;
if(slotsFilled || allEnemiesSelected) {
if(allEnemiesSelected && S.targets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.targets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
// Safety check: prevent suicidal grapple (heroes cannot grapple if it would kill them)
const hero = S.heroes[heroIdx];
const totalRecoil = S.targets.reduce((sum, tgtId) => {
const enemy = S.enemies.find(e => e.id === tgtId);
return sum + (enemy ? enemy.p : 0);
}, 0) * S.grappleRepeats;
const effectiveHP = (hero.h || 0) + (hero.sh || 0);
if(totalRecoil >= effectiveHP && !hero.g && !hero.ls) {
toast('Grapple would kill you! Pick weaker targets.', 2000);
S.targets = [];
render();
return;
}
for(let i = 0; i < S.grappleRepeats; i++) executeGrapple(heroIdx, [...S.targets], S.grappleLevel);
finishAction(heroIdx);
} else render();
}
}

function tgtHero(id) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(!S.pending || !needsHeroTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const h = S.heroes[heroIdx];
const target = S.heroes.find(x => x.id === id);
if(!target) return;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
if(S.pending === 'Shield') {
if(S.currentInstanceTargets.includes(id)) { toast('Already targeted in this instance!'); return; }
S.targets.push(id);
S.currentInstanceTargets.push(id);
const slotsFilled = S.currentInstanceTargets.length >= targetsPerInstance;
const allHeroesSelected = S.currentInstanceTargets.length >= S.heroes.length;
if(slotsFilled || allHeroesSelected) {
if(allHeroesSelected && S.currentInstanceTargets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.currentInstanceTargets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) {
setTimeout(() => finishAction(heroIdx), ANIMATION_TIMINGS.ACTION_COMPLETE);
} else {
setTimeout(() => render(), ANIMATION_TIMINGS.ACTION_COMPLETE);
}
} else render();
} else if(S.pending === 'Heal') {
if(S.currentInstanceTargets.includes(id)) { toast('Already targeted in this instance!'); return; }
S.targets.push(id);
S.currentInstanceTargets.push(id);
const slotsFilled = S.currentInstanceTargets.length >= targetsPerInstance;
const allHeroesSelected = S.currentInstanceTargets.length >= S.heroes.length;
if(slotsFilled || allHeroesSelected) {
if(allHeroesSelected && S.currentInstanceTargets.length < targetsPerInstance) {
const wasted = targetsPerInstance - S.currentInstanceTargets.length;
toast(`${wasted} target slot${wasted>1?'s':''} wasted!`);
}
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) {
setTimeout(() => finishAction(heroIdx), ANIMATION_TIMINGS.ACTION_COMPLETE);
} else {
setTimeout(() => render(), ANIMATION_TIMINGS.ACTION_COMPLETE);
}
} else render();
} else if(S.pending === 'Alpha') {
// Alpha: can't target self or already-acted heroes
const alphaUser = S.heroes[S.activeIdx];
if(id === alphaUser.id) { toast('Cannot Alpha yourself!'); return; }
const targetIdx = S.heroes.findIndex(x => x.id === id);
if(S.acted.includes(targetIdx)) { toast('That hero already acted!'); return; }
if(S.targets.includes(id)) { toast('Already targeted!'); return; }
S.targets.push(id);
if(S.targets.length >= S.alphaTargetsNeeded) {
executeAlphaAction(S.activeIdx, S.targets);
} else render();
}
}

function executeAlphaAction(alphaUserIdx, targetIds) {
const alphaUser = S.heroes[alphaUserIdx];
const actionsToGrant = S.alphaLevel;
// Mark Alpha user as acted (forfeits ALL actions)
S.acted.push(alphaUserIdx);
S.pending = null;
S.targets = [];
toast(`${alphaUser.n} used Alpha! Granting ${actionsToGrant} action${actionsToGrant>1?'s':''} to ${targetIds.length} hero${targetIds.length>1?'es':''}!`);
// Set up multi-action state for granted heroes
S.alphaGrantedActions = [];
targetIds.forEach(id => {
const targetIdx = S.heroes.findIndex(h => h.id === id);
if(targetIdx >= 0) {
for(let i = 0; i < actionsToGrant; i++) {
S.alphaGrantedActions.push(targetIdx);
}
}
});
S.alphaCurrentAction = 0;
// Start first granted action
if(S.alphaGrantedActions.length > 0) {
const nextHeroIdx = S.alphaGrantedActions[0];
S.activeIdx = nextHeroIdx;
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
}
render();
}

function selectEncampmentTarget(enemyId) {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const currentSelected = S.encampmentSelectedTargets;
// Toggle selection
if(currentSelected.includes(enemyId)) {
S.encampmentSelectedTargets = currentSelected.filter(id => id !== enemyId);
} else {
if(currentSelected.length >= kills) {
toast(`Already selected ${kills} enem${kills>1?'ies':'y'}!`);
return;
}
S.encampmentSelectedTargets.push(enemyId);
}
render();
}

function confirmEncampmentKills() {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets;
if(selected.length !== kills) {
toast(`Select ${kills} enem${kills>1?'ies':'y'} to remove!`);
return;
}
// Remove selected enemies from S.enemies
S.enemies = S.enemies.filter(e => !selected.includes(e.id));
toast(`${kills} enem${kills>1?'ies':'y'} removed!`, 1200);
// Clear flags
S.selectingEncampmentTargets = false;
S.encampmentEarlyKills = 0;
S.encampmentSelectedTargets = [];
// Start combat normally
render();
}

function executeInstance(action, heroIdx, targets) {
const h = S.heroes[heroIdx];
const pow = h.p;
if(action === 'Attack') {
// Trigger attacker animation
triggerAttackAnimation(h.id);
const targetDetails = [];
const damagedEnemyIds = [];
// First pass: Apply damage to all targets
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
const hpBefore = e.h;
damagedEnemyIds.push(e.id);
// Apply damage (without animation yet)
applyDamageToTarget(e, pow, {isHero: false, skipRewards: false});
const hpAfter = e.h;
targetDetails.push({name: e.n, before: hpBefore, after: hpAfter});
// RIBBLETON TUTORIAL: Track Wolf damage/death
if(tutorialState && S.floor === 0 && e.n === 'Wolf') {
console.log('[TUTORIAL] Wolf took damage! HP now:', e.h, 'wolfDamaged was:', tutorialState.wolfDamaged);
if(e.h > 0 && !tutorialState.wolfDamaged) {
tutorialState.wolfDamaged = true;
console.log('[TUTORIAL] Set wolfDamaged = true');
}
}
});
// Second pass: Trigger all hit animations simultaneously
damagedEnemyIds.forEach(id => triggerHitAnimation(id));
// Third pass: Handle deaths and cleanup
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
if(e.h <= 0 && e.g === 0) {
// RIBBLETON TUTORIAL: Track Wolf/Goblin kills
if(tutorialState && S.floor === 0) {
if(e.n === 'Wolf') tutorialState.wolfKilled = true;
if(e.n === 'Goblin') tutorialState.goblinKilled = true;
}
// Remove enemy immediately
S.enemies = S.enemies.filter(enemy => enemy.id !== e.id);
}
});
if(targetDetails.length > 0) {
const targetStrings = targetDetails.map(t => `${t.name} (‚ù§${t.before}‚Üí‚ù§${t.after})`);
toast(`${h.n} attacked ${targetStrings.join(', ')}!`);
}
// Check if combat ended
if(S.enemies.length === 0) {
render();
checkCombatEnd();
}
} else if(action === 'Shield') {
const targetNames = [];
const shieldedIds = [];
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
const level = getLevel('Shield', heroIdx);
const shieldAmt = 2 * pow * level;
target.sh += shieldAmt;
if(target.sh > target.m) target.sh = target.m;
targetNames.push(target.n);
shieldedIds.push(target.id);
});
// Trigger all shield animations simultaneously
shieldedIds.forEach(id => triggerShieldAnimation(id));
if(targetNames.length > 0) {
const level = getLevel('Shield', heroIdx);
const shieldAmt = 2 * pow * level;
toast(`${targetNames.join(' and ')} gained ${shieldAmt} shield!`);
}
} else if(action === 'Heal') {
const healed = [];
const revived = [];
const healedIds = [];
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
const level = getLevel('Heal', heroIdx);
const healAmt = 2 * pow * level;
healedIds.push(target.id);
if(target.ls) {
target.ls = false;
target.lst = 0;
target.h = healAmt;
revived.push(target.n);
} else {
target.h += healAmt;
if(target.h > target.m) target.h = target.m;
healed.push(target.n);
}
});
// Trigger all heal animations simultaneously
healedIds.forEach(id => triggerHealAnimation(id));
const level = getLevel('Heal', heroIdx);
const healAmt = 2 * pow * level;
if(healed.length > 0) toast(`${healed.join(' and ')} restored ${healAmt} HP!`);
if(revived.length > 0) toast(`${revived.join(' and ')} revived with ${healAmt} HP!`);
}
}

function executeGrapple(heroIdx, targets, stunDuration) {
const h = S.heroes[heroIdx];
// Trigger attacker animation (grapple uses same animation as attack)
triggerAttackAnimation(h.id);
let totalDmg = 0;
const targetNames = [];
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
totalDmg += e.p;
e.st += stunDuration;
targetNames.push(e.n);
// Check prince quest completion
if(S.princeQuestActive && S.round === 1 && !S.princeQuestCompleted) {
S.princeQuestCompleted = true;
toast('Prince Quest completed! Ring retrieved!', 1800);
}
});
if(targetNames.length > 0) toast(`${h.n} grappled ${targetNames.join(', ')} - stunned ${stunDuration} turn${stunDuration>1?'s':''}!`);
if(totalDmg > 0) {
// Hero takes recoil damage - trigger hit animation
triggerHitAnimation(h.id);
const damage = applyDamageToTarget(h, totalDmg, {isHero: true, silent: true});
let msg = `${h.n} took Grapple recoil:`;
if(damage.shieldLost > 0 && damage.hpLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è -${damage.hpLost}‚ù§Ô∏è`;
} else if(damage.shieldLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è`;
} else if(damage.hpLost > 0) {
msg += ` -${damage.hpLost}‚ù§Ô∏è`;
}
toast(msg);
}
}

function dealDamageToEnemy(enemy, dmg) {
triggerHitAnimation(enemy.id);
const hpBefore = enemy.h;

// Apply damage using unified function
applyDamageToTarget(enemy, dmg, {isHero: false, skipRewards: false});
const hpAfter = enemy.h;

// Show damage toast
toast(`${enemy.n} took ${dmg} damage (‚ù§${hpBefore}‚Üí‚ù§${hpAfter})!`);

// RIBBLETON TUTORIAL: Track Wolf damage/death
if(tutorialState && S.floor === 0 && enemy.n === 'Wolf') {
console.log('[TUTORIAL] Wolf took damage! HP now:', enemy.h, 'wolfDamaged was:', tutorialState.wolfDamaged);
if(enemy.h > 0 && !tutorialState.wolfDamaged) {
tutorialState.wolfDamaged = true;
console.log('[TUTORIAL] Set wolfDamaged = true');
}
}

// Handle enemy death
if(enemy.h <= 0 && enemy.g === 0) {
// RIBBLETON TUTORIAL: Track Wolf/Goblin kills
if(tutorialState && S.floor === 0) {
if(enemy.n === 'Wolf') tutorialState.wolfKilled = true;
if(enemy.n === 'Goblin') tutorialState.goblinKilled = true;
}

// Remove enemy immediately
S.enemies = S.enemies.filter(e => e.id !== enemy.id);
render();
checkCombatEnd();
}
}

function finishAction(heroIdx) {
// Check if this is an Alpha-granted action
if(S.alphaGrantedActions && S.alphaGrantedActions.length > 0) {
S.alphaCurrentAction++;
// Remove one bonus turn stack from the current hero
const currentHero = S.heroes[heroIdx];
if(currentHero) {
removeBonusTurnStack(currentHero.id, true);
}
if(S.alphaCurrentAction < S.alphaGrantedActions.length) {
// More Alpha-granted actions remain
const nextHeroIdx = S.alphaGrantedActions[S.alphaCurrentAction];
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = nextHeroIdx;
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
render();
return;
} else {
// All Alpha-granted actions complete
S.alphaGrantedActions = [];
S.alphaCurrentAction = 0;
}
}
// Normal action finish
S.acted.push(heroIdx);
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = -1;

// RIBBLETON TUTORIAL: Check advancement after action using TutorialManager
const h = S.heroes[heroIdx];
TutorialManager.advanceStage({action: 'finish', hero: h.n, round: S.round});

checkTurnEnd();
render();
}

function checkTurnEnd() {
// Check if all non-stunned heroes have acted (optimized single-pass)
const allActedIncludingLS = S.heroes.every((h, idx) => {
return h.st > 0 || S.acted.includes(idx);
});
if(allActedIncludingLS) {
S.heroes.forEach(h => { if(h.ls) h.lst++; });

// RIBBLETON TUTORIAL: Handle enemy turn start using TutorialManager
TutorialManager.onEnemyTurnStart();
setTimeout(() => { S.locked = true; enemyTurn(); }, ANIMATION_TIMINGS.TURN_TRANSITION);
}
}

function enemyTurn() {
S.turn = 'enemy';
S.acted = [];
S.activeIdx = -1;
render();
S.enemies.forEach(e => {
if(e.st > 0) e.st--;
e.turnsSinceGain++;
e.alphaActed = false;
});
// Process recruits - stun decrement
if(S.recruits) {
S.recruits.forEach(r => {
if(r.st > 0) r.st--;
if(!r.turnsSinceGain) r.turnsSinceGain = 0;
r.turnsSinceGain++;
});
}
setTimeout(() => executeAlphaPhase(), ANIMATION_TIMINGS.ALPHA_PHASE_START);
}

function drawEnemyStartSigil(enemy, base) {
const pool = base.pool;
if(!pool) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
if(pool === 'ANY') {
const allSigils = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk', 'Expand'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = enemy.n === 'Cave Troll' ? 2 : 1 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
} else if(pool === 'ANY_ADVANCED') {
const allSigils = ['Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 2 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
} else if(Array.isArray(pool)) {
const availablePool = pool.filter(sigName => {
if(sigName === 'Attack2') return !heldSigils.includes('Attack');
if(sigName === 'Shield2') return !heldSigils.includes('Shield');
return !heldSigils.includes(sigName);
});
if(availablePool.length === 0) return;
const pick = availablePool[Math.floor(Math.random() * availablePool.length)];
if(pick === 'Attack2') {
enemy.s.push({sig:'Attack', level:2, perm:false});
} else if(pick === 'Shield2') {
enemy.s.push({sig:'Shield', level:2, perm:false});
} else {
enemy.s.push({sig:pick, level:1, perm:false});
}
}
}

function drawEnemySigil(enemy) {
const pool = enemy.pool;
if(!pool || pool.length === 0) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
if(pool === 'ANY') {
const allSigils = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk', 'Expand'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = enemy.n === 'Cave Troll' ? 2 : 1 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
toast(`${enemy.n} drew ${sig} L${level}!`);
} else if(pool === 'ANY_ADVANCED') {
const allSigils = ['Shield', 'Grapple', 'Heal', 'Ghost', 'Alpha', 'Asterisk'];
const availableSigils = allSigils.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
const level = 2 + Math.floor(Math.random() * 3);
enemy.s.push({sig, level, perm:false});
toast(`${enemy.n} drew ${sig} L${level}!`);
} else {
const availablePool = pool.filter(sigName => {
if(sigName === 'Attack2') return !heldSigils.includes('Attack');
if(sigName === 'Shield2') return !heldSigils.includes('Shield');
return !heldSigils.includes(sigName);
});
if(availablePool.length === 0) return;
const pick = availablePool[Math.floor(Math.random() * availablePool.length)];
if(pick === 'Attack2') {
enemy.s.push({sig:'Attack', level:2, perm:false});
toast(`${enemy.n} drew Attack L2!`);
} else if(pick === 'Shield2') {
enemy.s.push({sig:'Shield', level:2, perm:false});
toast(`${enemy.n} drew Shield L2!`);
} else {
enemy.s.push({sig:pick, level:1, perm:false});
toast(`${enemy.n} drew ${pick} L1!`);
}
}
}

/**
 * Executes Alpha phase of enemy turn.
 *
 * Alpha Mechanic:
 * - Enemies with Alpha sigil grant bonus actions to allies
 * - Alpha enemy does NOT act themselves (skips normal turn)
 * - Chooses strongest ally (highest POW, then most sigils)
 * - Grants Level √ó Attack actions to chosen ally
 * - All Alpha actions resolve before Recruit/Normal phases
 *
 * Execution Order:
 * 1. Find all non-stunned enemies with Alpha sigil
 * 2. For each Alpha enemy: Grant attacks to best ally
 * 3. Mark Alpha enemy as "acted" (skips normal phase)
 * 4. Continue to Recruit phase
 */
function executeAlphaPhase() {
const alphaEnemies = S.enemies.filter(e => e.st === 0 && e.s.some(sigil => sigil.sig === 'Alpha' && !sigil.perm));
if(alphaEnemies.length === 0) { setTimeout(executeRecruitPhase, ANIMATION_TIMINGS.PHASE_TRANSITION); return; }
// Execute all Alpha enemies in reading order with minimal stagger
let delay = 0;
alphaEnemies.forEach((alphaEnemy, idx) => {
setTimeout(() => {
const allies = S.enemies.filter(e => e.id !== alphaEnemy.id && e.h > 0 && !e.s.some(s => s.sig === 'Alpha' && !s.perm));
if(allies.length === 0) { toast(`${alphaEnemy.n}'s Alpha has no valid allies!`); alphaEnemy.alphaActed = true; return; }
allies.sort((a, b) => { if(b.p !== a.p) return b.p - a.p; return b.s.length - a.s.length; });
const bestAlly = allies[0];
const alphaSigil = alphaEnemy.s.find(s => s.sig === 'Alpha');
const attacks = alphaSigil.level;
toast(`${alphaEnemy.n} grants ${bestAlly.n} ${attacks} attack${attacks>1?'s':''}!`);
for(let i = 0; i < attacks; i++) executeEnemyBaseAttack(bestAlly);
alphaEnemy.alphaActed = true;
}, delay);
delay += ANIMATION_TIMINGS.ENEMY_ACTION_DELAY; // Minimal stagger (was 600ms)
});
// Wait for longest animation to complete
setTimeout(() => executeRecruitPhase(), delay + 600);
}

function executeRecruitPhase() {
if(!S.recruits || S.recruits.length === 0) { setTimeout(executeNormalEnemyPhase, ANIMATION_TIMINGS.PHASE_TRANSITION); return; }
// Execute all recruits in reading order with minimal stagger
let delay = 0;
S.recruits.forEach((recruit, idx) => {
setTimeout(() => executeRecruitTurn(recruit), delay);
delay += ANIMATION_TIMINGS.ENEMY_ACTION_DELAY; // Minimal stagger (was 600ms)
});
// Wait for longest animation to complete
setTimeout(() => executeNormalEnemyPhase(), delay + 600);
}

function executeRecruitTurn(recruit) {
if(recruit.st > 0) { toast(`${recruit.n} (Recruit) is stunned!`); return; }
if(recruit.h <= 0) return; // Dead recruit
// Recruit attacks enemies (not heroes)
executeRecruitBaseAttack(recruit);
const drawnSigils = recruit.s.filter(s => !s.perm && s.sig !== 'Alpha');
drawnSigils.forEach(sigil => executeRecruitSigil(recruit, sigil));
recruit.s = recruit.s.filter(s => s.perm);
render();
}

function executeRecruitBaseAttack(recruit) {
// Target lowest HP enemy
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) attacked ${target.n} for ${recruit.p}!`);
}

function executeRecruitSigil(recruit, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
for(let i = 0; i < level; i++) {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) ${sig} attacked ${target.n} for ${recruit.p}!`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * recruit.p * level;
recruit.sh = (recruit.sh || 0) + shieldAmt;
if(recruit.sh > recruit.m) recruit.sh = recruit.m;
toast(`${recruit.n} (Recruit) gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * recruit.p * level;
// Heal lowest HP hero
const targets = S.heroes.filter(h => h.h > 0 && !h.ls);
if(targets.length > 0) {
targets.sort((a, b) => a.h - b.h);
const healTarget = targets[0];
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${recruit.n} (Recruit) healed ${healTarget.n} for ${healAmt}!`);
}
} else if(sig === 'Grapple') {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
const dmgToRecruit = target.p;
recruit.h -= dmgToRecruit;
toast(`${recruit.n} (Recruit) grappled ${target.n}!`);
if(recruit.h <= 0) {
recruit.h = 0;
toast(`${recruit.n} (Recruit) defeated by grapple recoil!`);
S.recruits = S.recruits.filter(r => r.id !== recruit.id);
} else {
target.st = level;
toast(`${target.n} stunned for ${level} turns!`);
}
} else if(sig === 'Ghost') {
recruit.g = (recruit.g || 0) + level;
if(recruit.g > 9) recruit.g = 9;
toast(`${recruit.n} (Recruit) gained ${level} Ghost charge!`);
}
}

function executeNormalEnemyPhase() {
// Execute all enemies in reading order (top-down, left-right) with minimal stagger
const allEnemies = [...S.enemies].sort((a, b) => a.li - b.li); // Sort by lane index

let delay = 0;
allEnemies.forEach((enemy, idx) => {
setTimeout(() => executeEnemyTurn(enemy), delay);
delay += ANIMATION_TIMINGS.ENEMY_ACTION_DELAY; // Just enough stagger for visual clarity (was 600ms)
});

// Wait for longest animation to complete (600ms per enemy action + stagger)
setTimeout(() => endEnemyTurn(), delay + 600);
}

function executeEnemyTurn(enemy) {
if(enemy.st > 0) { toast(`${enemy.n} is stunned!`); return; }
if(enemy.alphaActed) {
toast(`${enemy.n} used Alpha (skipping normal turn)`);
enemy.s = enemy.s.filter(s => s.perm);
return;
}
// PHASE 1 TUTORIAL: Flies don't attack (they're just targets for practice)
if(tutorialState && tutorialState.phase === 1 && enemy.n === 'Fly') {
return; // Flies are passive in the birthday fly-catching game
}
executeEnemyBaseAttack(enemy);
const drawnSigils = enemy.s.filter(s => !s.perm && s.sig !== 'Alpha');

// Filter out suicidal grapples - enemies should never kill themselves
const safeSigils = drawnSigils.filter(sigil => {
if(sigil.sig === 'Grapple') {
const target = S.heroes[enemy.li];
if(target && target.h > 0) {
const recoilDamage = target.p;
// Skip grapple if it would kill the enemy
if(enemy.h <= recoilDamage) {
toast(`${enemy.n} considered Grapple but chose to survive instead!`);
return false;
}
}
}
return true;
});

safeSigils.forEach(sigil => executeEnemySigil(enemy, sigil));
enemy.s = enemy.s.filter(s => s.perm);
render();
}

function getEnemyExpandLevel(enemy) {
const expandSigil = enemy.s.find(s => s.sig === 'Expand');
return expandSigil ? expandSigil.level : 0;
}

function selectEnemyTargets(enemy, count) {
// Priority:
// 1. Hero directly across (lane index)
// 2. That hero's recruited ally (if present)
// 3. Heroes nearest to that first hero
// 4. Any remaining heroes
// 5. Nearest hero's recruited ally
// 6. Any remaining allies

let targets = [];
const added = new Set();

// 1. Primary target: Hero in enemy's lane
const primaryHero = S.heroes[enemy.li];
if(primaryHero && primaryHero.h > 0) {
targets.push(primaryHero);
added.add(primaryHero.id);
}
if(targets.length >= count) return targets;

// 2. That hero's recruited ally (if present)
if(S.recruits && S.recruits.length > 0) {
const primaryRecruit = S.recruits.find(r => r.li === enemy.li && r.h > 0);
if(primaryRecruit) {
targets.push(primaryRecruit);
added.add(primaryRecruit.id);
}
}
if(targets.length >= count) return targets;

// 3-4. Expand to nearby heroes by distance from primary lane
const aliveHeroes = S.heroes.filter(h => h.h > 0 && !added.has(h.id));
// Sort by distance from enemy lane
aliveHeroes.sort((a, b) => {
const aIdx = S.heroes.indexOf(a);
const bIdx = S.heroes.indexOf(b);
return Math.abs(aIdx - enemy.li) - Math.abs(bIdx - enemy.li);
});

for(const hero of aliveHeroes) {
if(targets.length >= count) break;
targets.push(hero);
added.add(hero.id);
}
if(targets.length >= count) return targets;

// 5-6. Recruited allies of nearby heroes, then any remaining
if(S.recruits && S.recruits.length > 0) {
const aliveRecruits = S.recruits.filter(r => r.h > 0 && !added.has(r.id));
// Sort by lane distance from enemy
aliveRecruits.sort((a, b) => Math.abs(a.li - enemy.li) - Math.abs(b.li - enemy.li));

for(const recruit of aliveRecruits) {
if(targets.length >= count) break;
targets.push(recruit);
added.add(recruit.id);
}
}

return targets;
}

function executeEnemyBaseAttack(enemy) {
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;
executeEnemyAttackOnHeroes(enemy, targetCount, 'Base Attack');
}

function executeEnemySigil(enemy, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;

for(let i = 0; i < level; i++) {
executeEnemyAttackOnHeroes(enemy, targetCount, `Attack ${i+1}/${level}`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * enemy.p * level;
enemy.sh = (enemy.sh || 0) + shieldAmt;
if(enemy.sh > enemy.m) enemy.sh = enemy.m;
toast(`${enemy.n} gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * enemy.p * level;
const allies = S.enemies.filter(e => e.id !== enemy.id && e.h > 0);
if(allies.length > 0) {
allies.sort((a,b) => a.h - b.h);
const healTarget = allies[0];
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${enemy.n} healed ${healTarget.n} for ${healAmt}!`);
}
} else if(sig === 'Grapple') {
const target = S.heroes[enemy.li];
if(target && target.h > 0) {
const dmgToEnemy = target.p;
enemy.h -= dmgToEnemy;
toast(`${enemy.n} grappled ${target.n}!`);
if(enemy.h <= 0) {
enemy.h = 0;
toast(`${enemy.n} defeated by grapple recoil!`);
S.enemies = S.enemies.filter(e => e.id !== enemy.id);
} else {
target.st = level;
toast(`${target.n} stunned for ${level} turns!`);
}
}
} else if(sig === 'Ghost') {
enemy.g = (enemy.g || 0) + level;
if(enemy.g > 9) enemy.g = 9;
toast(`${enemy.n} gained ${level} Ghost charge!`);
} else if(sig === 'Expand') {
toast(`${enemy.n} used Expand (affects their attacks)`);
} else if(sig === 'Asterisk') {
// Asterisk for enemies: Multiply attacks by (level + 1)
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;
const multiplier = level + 1;
toast(`${enemy.n} used Asterisk: √ó${multiplier} attacks!`);
for(let i = 0; i < multiplier; i++) {
executeEnemyAttackOnHeroes(enemy, targetCount, `Asterisk Attack ${i+1}/${multiplier}`);
}
}
}

function dealDamageToHero(hero, dmg, source) {
triggerHitAnimation(hero.id);
const hpBefore = hero.h;
const damage = applyDamageToTarget(hero, dmg, {isHero: true});
const hpAfter = hero.h;
// Build detailed damage message with HP change
let msg = `${source} hit ${hero.n} (‚ù§${hpBefore}‚Üí‚ù§${hpAfter}):`;
if(damage.shieldLost > 0 && damage.hpLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è -${damage.hpLost}‚ù§Ô∏è`;
} else if(damage.shieldLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è`;
} else if(damage.hpLost > 0) {
msg += ` -${damage.hpLost}‚ù§Ô∏è`;
}
toast(msg);
}

function endEnemyTurn() {
S.heroes.forEach(h => {
if(h.st > 0) {
h.st--;
if(h.st === 0) toast(`${h.n} is no longer stunned!`);
}
});
if(checkCombatEnd()) return;
S.round++;

// Enemies draw sigils at start of player turn (so player can strategize)
S.enemies.forEach(e => {
// RIBBLETON TUTORIAL: Enemies don't gain sigils (except Goblin on Round 3)
const isTutorial = tutorialState && S.floor === 0;
const isGoblinRound3 = isTutorial && e.n === 'Goblin' && S.round === 3;
if(e.turnsSinceGain >= e.gainRate && (!isTutorial || isGoblinRound3)) {
e.turnsSinceGain = 0;
// Draw multiple sigils per turn if specified (Dragons draw 2)
const draws = e.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(e);
}
// Immediately render to show new sigils
render();
}
});
// Process recruit sigil drawing
if(S.recruits) {
S.recruits.forEach(r => {
if(r.turnsSinceGain >= r.gainRate) {
r.turnsSinceGain = 0;
const draws = r.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(r);
}
// Immediately render to show new sigils
render();
}
});
}

// RIBBLETON TUTORIAL: Handle round transitions using TutorialManager
if(tutorialState && S.floor === 0) {
tutorialState.round = S.round;
TutorialManager.onRoundStart(S.round);
// If onRoundStart handled the transition (showed a popup), return early
if(S.turn === 'player') {
return;
}
}

S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
upd();
// Auto-skip stunned heroes
S.heroes.forEach((h, idx) => {
if(h.st > 0 && !S.acted.includes(idx)) {
S.acted.push(idx);
toast(`${h.n} is stunned and skips their turn!`);
}
});
checkTurnEnd();
render();
}

/**
 * Checks for combat victory or defeat conditions.
 *
 * Victory Conditions:
 * - All enemies defeated (S.enemies.length === 0)
 * - Tutorial Floor 0: Special handling with no rewards
 * - Normal combat: Awards XP with Star bonus multipliers
 *
 * Defeat Conditions:
 * - All heroes in Last Stand mode (allDead check)
 * - Clears temporary XP upgrades immediately for clean Death screen
 *
 * @returns {boolean} - True if combat ended (victory or defeat), false if ongoing
 */
function checkCombatEnd() {
if(S.enemies.length === 0) {
// Tutorial Floor 0: Special ending (no XP/Gold rewards)
if(S.floor === 0) {
S.combatXP = 0;
S.combatGold = 0;
setTimeout(() => {
toast('Victory!');
if(tutorialState && tutorialState.phase === 1) {
// Phase 1 complete: Transition to Phase 2
setTimeout(finishTaposBirthdayPhase, ANIMATION_TIMINGS.VICTORY_DELAY);
} else {
// Phase 2 complete: Finish tutorial
setTimeout(finishRibbletonTutorial, ANIMATION_TIMINGS.VICTORY_DELAY);
}
}, 500);
return true;
}

// Normal combat victory
setTimeout(() => {
const combatXP = S.combatXP || 0;
let starBonus = 0;
S.heroes.forEach(h => {
const starLevel = getLevel('Star', S.heroes.indexOf(h));
starBonus += starLevel * 0.5;
});
const bonusXP = Math.floor(combatXP * (1 + starBonus));
S.xp += bonusXP;
S.combatXP = 0; // Reset combat XP
// Recruits persist until killed - don't clear here
if(starBonus > 0) toast(`Star Bonus! ${combatXP} √ó ${(1 + starBonus).toFixed(1)} = ${bonusXP} XP`, 3000);
upd();
toast('Victory!');
setTimeout(levelUp, ANIMATION_TIMINGS.VICTORY_DELAY);
}, 500);
return true;
}
const allDead = S.heroes.every(h => h.ls);
if(allDead) {
// Clear temporary XP upgrades immediately so Death screen shows clean permanent levels
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
setTimeout(() => {
toast('Defeated!');
setTimeout(() => transitionScreen(showDeathScreen), ANIMATION_TIMINGS.DEFEAT_DELAY);
}, ANIMATION_TIMINGS.ACTION_COMPLETE);
return true;
}
return false;
}

/**
 * Smoothly transitions between major game screens with fade effect.
 *
 * Animation Flow:
 * 1. Fade out current screen (200ms)
 * 2. Execute callback to update content
 * 3. Fade in new screen (200ms)
 *
 * Total transition time: 400ms
 *
 * Used for: error‚Üítitle, tutorial skip‚Üítitle, defeat‚Üídeath, etc.
 *
 * @param {Function} callback - Function to call during fade (updates screen content)
 */
function transitionScreen(callback) {
const v = document.getElementById('gameView');
v.classList.add('fade-out');
setTimeout(() => {
v.classList.remove('fade-out');
callback();
v.classList.add('fade-in');
setTimeout(() => v.classList.remove('fade-in'), ANIMATION_TIMINGS.FADE_TRANSITION);
}, ANIMATION_TIMINGS.FADE_TRANSITION);
}

function render() {
const v = document.getElementById('gameView');
// Special state: Encampment enemy selection
if(S.selectingEncampmentTargets) {
v.innerHTML = renderEncampmentSelection();
return;
}

// RIBBLETON TUTORIAL: Show targeting prompts
if(tutorialState && S.floor === 0 && S.pending) {
// REMOVED: Targeting popup is now batched with Attack popup
// Auto-advance stage when Attack is pending
if(tutorialState.stage === 'warrior_attack' && S.pending === 'Attack' && S.targets.length === 0) {
tutorialState.stage = 'targeting_wolf';
// No popup - already explained in popup 1
}
// PROMPT 4: Heal + Expand (BATCHED)
else if(tutorialState.stage === 'healer_heal' && S.pending === 'Heal' && S.currentInstanceTargets.length === 0 && S.targets.length === 0) {
tutorialState.stage = 'expand_targets';
showTutorialPop('ribbleton_expand', "Use Healer's Expand to heal both wounded heroes!", () => {
render();
});
return;
}
}

let html = renderCombatStatusHeader();
// New layout: Each hero and their enemies in a horizontal lane
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });

S.heroes.forEach((h,i) => {
html += `<div class="combat-lane">`;
html += '<div style="display:flex;gap:2rem;justify-content:center;align-items:stretch">';

// Hero section (left side of lane)
html += '<div style="flex:0 0 auto;display:flex;flex-direction:column;gap:0.3rem">';

// Show recruit BEHIND (before) hero if exists
if(S.recruits) {
const heroRecruits = S.recruits.filter(r => r.recruitedBy === i);
if(heroRecruits.length > 0) {
// Sort by POW descending, then by current HP descending
heroRecruits.sort((a, b) => {
if(b.p !== a.p) return b.p - a.p;
return b.h - a.h;
});
const recruit = heroRecruits[0];
const extra = [];
if(recruit.sh > 0) extra.push(`${recruit.sh}üõ°`);
if(recruit.g > 0) extra.push(`${recruit.g}${sigilIconOnly('Ghost')}`);
if(recruit.st > 0) extra.push(`üòµ${recruit.st}T`);
html += `<div id="${recruit.id}" class="card hero" style="opacity:0.85;border:2px dashed #22c55e">`;
// Power at top
html += `<div style="text-align:center;font-size:1rem;font-weight:bold;margin-bottom:0.25rem">${recruit.p}</div>`;
// Recruited label with emoji
html += `<div style="text-align:center;font-size:1.5rem;margin-bottom:0.25rem">ü§ù</div>`;
// HP
html += `<div style="text-align:center;font-size:0.85rem;margin-bottom:0.25rem">${recruit.h}/${recruit.m}</div>`;
// Extra info
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils
const recruitTotalSigils = recruit.s.length + 1;
const compactClass = recruitTotalSigils >= 4 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">
<span class="sigil engraved">${sigilIconOnly('Attack')}</span>`;
recruit.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
const permStyle = sigil.perm ? 'engraved' : cl;
html += `<span class="sigil ${permStyle}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sigil.sig}', this), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly(sigil.sig)}${sigil.level}</span>`;
});
html += '</div></div>';
}
}

const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
const isActive = S.activeIdx === i;
const isTargetable = S.pending && needsHeroTarget(S.pending);
const hasActed = S.acted.includes(i);
let cardClasses = 'card hero';
if(isActive) cardClasses += ' active';
if(isTargetable) cardClasses += ' targetable';
if(hasActed) cardClasses += ' acted';
if(h.ls) cardClasses += ' last-stand';
const isTargeted = S.targets.includes(h.id);
if(isTargeted) cardClasses += ' targeted';
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
if(h.st > 0) extra.push(`üòµ${h.st}T`);
if(hasActed) extra.push('‚úì');
let onclick = '';
if(isTargetable) onclick = `onclick="tgtHero('${h.id}')"`;
else if(!hasActed && h.st === 0 && !S.pending) onclick = `onclick="selectHero(${i})"`;
const heroImage = HERO_IMAGES[h.n.toLowerCase()] || '';
html += `<div id="${h.id}" class="${cardClasses}" ${onclick}>`;
// LAYER 3: Last Stand visual indicator
if(h.ls) {
html += `<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-bottom:0.25rem;background:#dc2626;color:white;padding:0.2rem;border-radius:4px;animation:pulse-text 1s infinite">‚ö†Ô∏è LAST STAND ‚ö†Ô∏è</div>`;
}
// Name at top
html += `<div style="text-align:center;font-size:0.75rem;font-weight:bold;margin-bottom:0.25rem;opacity:0.8">${h.n}</div>`;
// POW - portrait - HP (horizontal)
html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.25rem;gap:0.25rem">`;
html += `<div style="font-size:1rem;font-weight:bold;min-width:30px;text-align:center">${h.p}</div>`;
if(heroImage) html += `<img src="${heroImage}" style="width:48px;height:48px;border-radius:4px">`;
html += `<div style="font-size:0.85rem;min-width:50px;text-align:center">${hp}</div>`;
html += `</div>`;
// Extra info
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils with smart wrapping
const activeSigils = sortSigils([...h.s, ...(h.ts || [])]);
const sigilCount = activeSigils.length;
const compactClass = sigilCount >= 4 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">`;
activeSigils.forEach(s => {
const lvl = getLevel(s, i);
// Calculate visual level for roll-down effect
let visualLvl = lvl;
if(S.activeIdx === i && S.pending === s && isMultiInstance(s) && S.totalInstances) {
const usedInstances = S.totalInstances - S.instancesRemaining;
visualLvl = Math.max(0, lvl - usedInstances);
}
const cl = visualLvl===0?'l0':visualLvl===1?'l1':visualLvl===2?'l2':visualLvl===3?'l3':visualLvl===4?'l4':'l5';
// Allow clicking sigils if: hero hasn't acted, not stunned, and either (no pending action OR pending but no instances committed yet)
const canSwitchAction = !S.pending || (S.instancesRemaining === S.totalInstances);
const canClick = !S.acted.includes(i) && h.st === 0 && canSwitchAction && ['Attack','Shield','Grapple','Heal','Ghost','D20','Alpha'].includes(s);
const isActiveAction = (S.pending === s && S.activeIdx === i);
const isPassive = ['Expand', 'Star', 'Asterisk'].includes(s);
html += `<span class="sigil ${cl} ${isPassive?'passive':''} ${isActiveAction?'active-action':''} ${canClick?'clickable':''}" ${canClick?`onclick="act('${s}', ${i})"`:''}
onmouseenter="showTooltip('${s}', this, ${visualLvl})" onmouseleave="hideTooltip()"
ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${s}', this, ${visualLvl}), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly(s, visualLvl)}</span>`;
});
html += '</div>';
html += '</div>';
html += '</div>'; // Close hero section

// Divider between heroes and enemies
html += '<div style="width:3px;background:linear-gradient(to bottom,transparent,rgba(0,0,0,0.3) 20%,rgba(0,0,0,0.3) 80%,transparent);flex-shrink:0"></div>';

// Enemy section (right side of lane)
html += '<div style="flex:0 0 auto;display:flex;flex-wrap:wrap;gap:0.3rem;justify-content:flex-start;align-items:flex-start;align-content:flex-start;min-height:80px">';
const laneEnemies = enemyLanes[i] || [];
if(laneEnemies.length === 0) {
html += `<div style="flex:1;text-align:center;font-size:1.2rem;padding:1.5rem;background:rgba(0,0,0,0.1);border:3px dashed rgba(0,0,0,0.3);border-radius:8px;color:rgba(0,0,0,0.4);font-style:italic;display:flex;align-items:center;justify-content:center">No Enemies</div>`;
} else {
laneEnemies.forEach(e => {
const isTargetable = (S.pending && needsEnemyTarget(S.pending)) || S.pending === 'D20_TARGET';
const selectCount = S.targets.filter(t => t === e.id).length;
let cardClasses = 'card enemy';
if(isTargetable) cardClasses += ' targetable';
if(selectCount > 0) cardClasses += ' targeted';
const extra = [];
if(e.sh > 0) extra.push(`${e.sh}üõ°`);
// Show ghost charges if enemy has them
if(e.g > 0) extra.push(`${e.g}${sigilIconOnly('Ghost')}`);
if(e.st > 0) extra.push(`üòµ${e.st}T`);
if(selectCount > 0) extra.push(`√ó${selectCount}`);
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
html += `<div id="${e.id}" class="${cardClasses}" ${isTargetable?`onclick="tgtEnemy('${e.id}')"`:''}">`;
// Name at top
html += `<div style="text-align:center;font-size:0.75rem;font-weight:bold;margin-bottom:0.25rem;opacity:0.8">${e.n}</div>`;
// POW - emoji - HP row (horizontal)
html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.25rem;gap:0.25rem">`;
html += `<div style="font-size:1rem;font-weight:bold;min-width:30px;text-align:center">${e.p}</div>`;
html += `<div style="font-size:2rem">${enemyEmoji}</div>`;
html += `<div style="font-size:0.85rem;min-width:50px;text-align:center">${e.h}/${e.m}</div>`;
html += `</div>`;
// Extra info
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils with smart wrapping
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
const totalSigils = e.s.length + (hasAttackSigil ? 0 : 1);
const compactClass = totalSigils >= 4 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">`;
if(!hasAttackSigil) {
html += `<span class="sigil engraved">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
const permStyle = sigil.perm ? 'engraved' : cl;
html += `<span class="sigil ${permStyle}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig)}${sigil.level}</span>`;
});
html += '</div></div>';
});
}
html += '</div>'; // Close enemy section
html += '</div>'; // Close flex container
html += '</div>'; // Close combat-lane
});
v.innerHTML = html;

// Apply bonus turn stacks after DOM is updated
setTimeout(() => {
// Show Alpha-granted action stacks
if(S.alphaGrantedActions && S.alphaGrantedActions.length > 0) {
// Count remaining actions for each hero
const actionCounts = {};
for(let i = S.alphaCurrentAction || 0; i < S.alphaGrantedActions.length; i++) {
const heroIdx = S.alphaGrantedActions[i];
actionCounts[heroIdx] = (actionCounts[heroIdx] || 0) + 1;
}
// Apply stacks to heroes
Object.keys(actionCounts).forEach(heroIdx => {
const hero = S.heroes[heroIdx];
if(hero) {
addBonusTurnStack(hero.id, actionCounts[heroIdx]);
}
});
}
}, 0);
}

// ===== LEVEL UP =====
function levelUp() {
// Unlock blue portal and award statuette after completing Floor 19 (combat before floor 20)
if(S.floor === 19) {
S.hasReachedFloor20 = true;
S.hasAncientStatuette = true;
savePermanent();
toast('üóø Ancient Statuette acquired! The blue portal in Ribbleton has awakened!', 2500);
}

const v = document.getElementById('gameView');
const nextCost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Level Up!</h2>
<p style="text-align:center;margin-bottom:0.5rem">Floor ${S.floor} Complete</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Current XP: ${S.xp} | Next Level: ${nextCost}XP</p>
<div class="choice" onclick="levelUpMenu()">Spend XP</div>
<button class="btn safe" onclick="nextFloor()">Next Floor</button>`;
}

function nextFloor() {
saveGame();
// Show header buttons tutorial after first neutral encounter (Floor 2 complete)
if(S.floor === 2 && !S.tutorialFlags.faq_intro) {
S.tutorialFlags.faq_intro = true;
showTutorialPop('faq_intro', "You're (mostly) on your own from here - good luck! Need help? Check the header buttons at the top:<br><br>üåÄ <strong>Sigilarium</strong> - View all sigils and their effects<br>ü™µ <strong>Log</strong> - See combat message history<br>‚ùì <strong>FAQ</strong> - Frequently asked questions about game mechanics<br>‚öôÔ∏è <strong>Settings</strong> - Adjust game options and preferences", () => {
startFloor(S.floor + 1);
});
return;
}
startFloor(S.floor + 1);
}

function showStartingXPScreen() {
const v = document.getElementById('gameView');
const nextCost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem;color:#a855f7">Starting XP Bonus!</h2>
<p style="text-align:center;margin-bottom:0.5rem;font-size:1.1rem">You start this run with <strong>${S.startingXP} XP</strong> from Death Boy sacrifices!</p>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;opacity:0.8">Spend it now or bank it for later. Remaining XP: <strong>${S.xp}</strong> | Next Level Cost: <strong>${nextCost}XP</strong></p>
<div class="choice" onclick="startingXPMenu()">Spend XP</div>
<button class="btn safe" onclick="startFloor(1)">Start Run (Bank XP)</button>`;
}

function startingXPMenu() {
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend Starting XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<div class="choice" onclick="upgradeSigil()">Upgrade Sigil Level</div>
<div class="choice" onclick="addSigilToHero()">Add Sigil to Hero</div>
<button class="btn secondary" onclick="showStartingXPScreen()">Back</button>`;
}

function levelUpMenu() {
showTutorialPop('levelup_intro', "Nice! You got enough XP for your first Level-Up! Your team shares XP. Let's check out your options - click on each card to learn more about what it does.");
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<div class="choice" onclick="upgradeSigil()">Upgrade Sigil Level</div>
<div class="choice" onclick="addSigilToHero()">Add Sigil to Hero</div>
<button class="btn secondary" onclick="levelUp()">Back</button>`;
}

function heroStats() {
showTutorialPop('levelup_stat_upgrade', "This one is pretty straightforward - add +1 POW or +5 HP to a hero of your choice.");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Hero Stats</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
S.heroes.forEach((h, idx) => {
html += `<div class="choice" onclick="upPow(${idx})"><strong>${h.n} POW</strong> (${h.p} ‚Üí ${h.p+1})</div>`;
html += `<div class="choice" onclick="upHP(${idx})"><strong>${h.n} HP</strong> (${h.m} ‚Üí ${h.m+5})</div>`;
});
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function upPow(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].p++;
toast(`${S.heroes[idx].n} POW +1!`);
upd();
saveGame();
levelUpMenu();
}

function upHP(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].m += 5;
S.heroes[idx].h += 5;
if(S.heroes[idx].ls) {
S.heroes[idx].ls = false;
S.heroes[idx].lst = 0;
S.heroes[idx].h = 5;
toast(`${S.heroes[idx].n} revived with 5 HP!`);
} else toast(`${S.heroes[idx].n} HP +5!`);
upd();
saveGame();
levelUpMenu();
}

function upgradeSigil() {
showTutorialPop('levelup_upgrade_active', "Each active sigil works based on its level. For example, if you upgrade Attack to Level 2, all heroes with Attack can attack twice with 1 action! Passive sigils (Expand, Asterisk, Star) work differently - they apply globally to all heroes and enhance your existing actions automatically!");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Sigil</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const available = allSigils.filter(s => {
const totalLevel = (S.sig[s] || 0) + (S.tempSigUpgrades[s] || 0);
return totalLevel < 4;
});
if(available.length === 0) html += `<p style="text-align:center;margin-bottom:1rem">All sigils maxed!</p>`;
else {
available.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
// Actives display with minimum level of 1 (since they start at L1 when equipped)
const displayLevel = (isActive && level === 0) ? 1 : level;
const nextDisplayLevel = displayLevel + 1;
// Check if any hero has this sigil
const anyHeroHasSigil = S.heroes.some(hero => hero.s.includes(sig) || (hero.ts && hero.ts.includes(sig)));
const newSigilNote = !anyHeroHasSigil ? `<br><span style="color:#dc2626;font-size:0.85rem">*No hero has this yet!</span>` : '';
html += `<div class="choice" onclick="upSigil('${sig}')"><strong>${sigilIcon(sig)} L${displayLevel} ‚Üí L${nextDisplayLevel}</strong>${newSigilNote}</div>`;
});
}
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function addSigilToHero() {
showTutorialPop('levelup_add_active', "Heroes only get 1 action per turn. Learning new active sigils gives you more choices - in addition to Attack/Heal/D20, you can grant a hero a new ability like Shield or Grapple!");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to Hero</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a hero:</p><div style="max-width:400px;margin:0 auto">`;
S.heroes.forEach((h, idx) => {
const sigilInfo = `<br><span style="font-size:0.75rem;opacity:0.8">Current: ${h.s.join(', ')}</span>`;
html += renderHeroCard(h, idx, `selectHeroForSigil(${idx})`, sigilInfo);
});
html += '</div>';
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function selectHeroForSigil(heroIdx) {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Alpha', 'Asterisk', 'Star'];
const available = allSigils.filter(sig => !h.s.includes(sig) && !(h.ts && h.ts.includes(sig)));
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to ${h.n}</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(available.length === 0) html += `<p style="text-align:center;margin-bottom:1rem">${h.n} already has all sigils!</p>`;
else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a sigil to add:</p>`;
available.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
// Actives at L0 show as L1 (minimum level when equipped), passives show as L0
const displayLevel = (isActive && level === 0) ? 1 : level;
const levelText = (level === 0 && !isActive) ? `L${displayLevel} (Passive only)` : `L${displayLevel}`;
// Check if any hero has this sigil
const anyHeroHasSigil = S.heroes.some(hero => hero.s.includes(sig) || (hero.ts && hero.ts.includes(sig)));
const newSigilNote = !anyHeroHasSigil ? `<span style="color:#dc2626;font-size:0.85rem"> *No hero has this yet!</span>` : '';
html += `<div class="choice" onclick="addSigilConfirm(${heroIdx}, '${sig}')">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">(${levelText})</span>${newSigilNote}
</div>`;
});
}
html += `<button class="btn secondary" onclick="addSigilToHero()">Back</button>`;
v.innerHTML = html;
}

function addSigilConfirm(heroIdx, sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
const h = S.heroes[heroIdx];
if(h.s.includes(sig) || (h.ts && h.ts.includes(sig))) { toast(`${h.n} already has ${sig}!`); return; }
S.xp -= cost;
S.levelUpCount++;
if(!h.ts) h.ts = [];
h.ts.push(sig);
// Sort sigils to maintain consistent order
h.ts = sortSigils(h.ts);
// Calculate effective level for display (actives show as level 1 minimum)
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const displayLevel = (actives.includes(sig) && totalLevel === 0) ? 1 : totalLevel;
toast(`${sig} added to ${h.n} at L${displayLevel}!`);
upd();
saveGame();
levelUpMenu();
}

function upSigil(sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;

// Show passive sigil tutorial when upgrading Expand, Asterisk, or Star from L0 to L1
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
const isPassive = passiveSigils.includes(sig);
const currentLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
if(isPassive && currentLevel === 0) {
showTutorialPop('levelup_upgrade_passive', "Expand, Asterisk, and Star are PASSIVE sigils - they're always active and work automatically! No need to click them in battle.");
}

S.xp -= cost;
S.levelUpCount++;
S.tempSigUpgrades[sig] = (S.tempSigUpgrades[sig] || 0) + 1;
const newLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);

// PASSIVE SIGILS: Automatically add to all heroes who don't have it yet
if(isPassive) {
S.heroes.forEach(hero => {
if(!hero.s.includes(sig) && !(hero.ts && hero.ts.includes(sig))) {
if(!hero.ts) hero.ts = [];
hero.ts.push(sig);
hero.ts = sortSigils(hero.ts);
}
});
toast(`${sig} upgraded to L${newLevel}! Added to all heroes!`);
} else {
toast(`${sig} upgraded to L${newLevel}!`);
}

upd();
saveGame();
levelUpMenu();
}

// ===== NEUTRAL ENCOUNTERS =====
function neutral(f) {
// TUTORIAL: Show neutral intro on Floor 2
if(f === 2) {
showTutorialPop('neutral_intro', "Neutral floors offer choices and opportunities! You can walk straight through, or take a risk for potential rewards.");
}

const enc = getNeutralEncounter();

if(S.ghostBoysConverted && enc.startsWith('ghost')) {
showEmptyPlayroom();
return;
}

if(enc === 'shopkeeper1') showShopkeeper1();
else if(enc === 'shopkeeper2') showShopkeeper2();
else if(enc === 'wishingwell1') showWishingWell1();
else if(enc === 'wishingwell2') showWishingWell2();
else if(enc === 'treasurechest1') showTreasureChest1();
else if(enc === 'treasurechest2') showTreasureChest2();
else if(enc === 'wizard1') showWizard1();
else if(enc === 'wizard2') showWizard2();
else if(enc === 'oracle1') showOracle1();
else if(enc === 'oracle2') showOracle2();
else if(enc === 'encampment1') showEncampment1();
else if(enc === 'encampment2') showEncampment2();
else if(enc === 'gambling1') showGambling1();
else if(enc === 'gambling2') showGambling2();
else if(enc === 'ghost1') showGhost1();
else if(enc === 'ghost2') showGhost2();
else if(enc === 'prince1') showPrince1();
else if(enc === 'prince2') showPrince2();
else {
const v = document.getElementById('gameView');
v.innerHTML = `
<h2 style="text-align:center;margin:2rem 0">Floor ${f}</h2>
<p style="text-align:center;margin-bottom:2rem">${enc}</p>
<button class="btn" onclick="nextFloor()">Continue</button>`;
}
}

// ===== 1. SHOPKEEPER =====
function showShopkeeper1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Potions for Sale',
description: 'A hooded figure stands behind a small cart laden with vials and bottles. Their voice is raspy and businesslike: "Potions. Gold. Fair prices."',
buttons: `
<button class="neutral-btn safe" onclick="buySmallPotion()">Small Potion (3G) - Restore 3 HP</button>
<button class="neutral-btn safe" onclick="buyLargePotion()">Large Potion (5G) - Restore 8 HP</button>
<button class="neutral-btn secondary" onclick="declineShopkeeper()">Do Not Engage</button>
`
});
}

let shopSmallBought = false;
let shopLargeBought = false;

function buySmallPotion() {
if(S.gold < 3) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn" onclick="applySmallPotion(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Choose Hero',
description: 'Select a hero to restore 3 HP.',
buttons: heroButtons + `<button class="neutral-btn secondary" onclick="showShopkeeper1()">Back</button>`
});
}

function applySmallPotion(idx) {
S.gold -= 3;
const h = S.heroes[idx];
h.h = Math.min(h.h + 3, h.m);
upd();
toast(`${h.n} restored 3 HP!`);
shopSmallBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 1800);
}
showShopkeeper1();
}

function buyLargePotion() {
if(S.gold < 5) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn" onclick="applyLargePotion(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Choose Hero',
description: 'Select a hero to restore 8 HP.',
buttons: heroButtons + `<button class="neutral-btn secondary" onclick="showShopkeeper1()">Back</button>`
});
}

function applyLargePotion(idx) {
S.gold -= 5;
const h = S.heroes[idx];
h.h = Math.min(h.h + 8, h.m);
upd();
toast(`${h.n} restored 8 HP!`);
shopLargeBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 1800);
}
showShopkeeper1();
}

function declineShopkeeper() {
shopSmallBought = false;
shopLargeBought = false;
nextFloor();
}

function showShopkeeper2() {
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const available = allSigils.filter(s => (S.sig[s] || 0) < 4);
const cost = S.goingRate;
let description = `The shopkeeper pulls back their hood, revealing a skull grinning beneath. "I am Death's... associate. You've impressed me. Choose wisely."<br><br><p style="text-align:center;font-weight:bold;margin:1rem 0">Cost: ${cost} Gold</p>`;
let buttons = '';
let outcomes = [];

if(available.length === 0) {
outcomes.push('All your sigils are already at maximum power. Death nods approvingly and fades away.');
buttons = `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else if(S.gold < cost) {
outcomes.push('<span style="color:#dc2626">You don\'t have enough Gold! Death shakes their head and fades away.</span>');
buttons = `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else {
description += `<div style="font-size:0.9rem;margin-bottom:1rem">Choose one sigil to upgrade permanently (costs ${cost}G, Going Rate does NOT increase):</div>`;
available.forEach(sig => {
const level = S.sig[sig] || 0;
buttons += `<div class="choice" onclick="acceptDeathsBargain('${sig}', ${cost})">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">L${level} ‚Üí L${level+1}</span>
</div>`;
});
buttons += `<button class="btn risky" onclick="finishDeathsBargain()">Decline</button>`;
}

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper2.png',
title: 'Death\'s Bargain',
description,
outcomes,
buttons
});
}

function acceptDeathsBargain(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }
S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
// NOTE: Going Rate does NOT increase for Death's Bargain!
upd();
savePermanent();
toast(`${sig} permanently upgraded to L${S.sig[sig]}! (GR unchanged)`, 3000);
removeNeutralFromDeck('shopkeeper');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Good choice. See you soon."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}, 1000);
}

function finishDeathsBargain() {
removeNeutralFromDeck('shopkeeper');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Shame. You don't get a chance like this every day. Oh well, it's your funeral."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 2. WISHING WELL =====
function showWishingWell1() {
const v = document.getElementById('gameView');
const buttons = `
<button class="btn risky" onclick="climbWell()">Climb down and get coins</button>
<button class="btn" onclick="tossWish()">Toss in a coin and make a wish</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'The Old Wishing Well',
description: 'An ancient stone well sits in the center of the chamber. You hear the faint sound of trickling water far below. A glint of gold catches your eye at the bottom.',
buttons
});
}

function climbWell() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
let goldGain = 0;
let hpLoss = 0;

if(best === 1) {
outcome = 'You slip on the wet stones and plummet! The landing is brutal.';
hpLoss = 3;
goldGain = -5;
} else if(best >= 2 && best <= 10) {
outcome = 'You climb carefully but scrape yourself on the rough stones. You manage to grab a single coin.';
hpLoss = 1;
goldGain = 1;
} else if(best >= 11 && best <= 19) {
outcome = 'Your climbing skills are impressive! You retrieve a small pouch of coins.';
goldGain = 3;
} else if(best === 20) {
outcome = 'Your descent is flawless! At the bottom, you discover a hidden cache of coins AND the well begins to overflow with crystal-clear water!';
goldGain = 2 * S.heroes.length;
replaceStage1WithStage2('wishingwell');
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'Climbing the Well',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="applyWellClimb(${hpLoss}, ${goldGain})">Continue</button>`
});
}

function applyWellClimb(hpLoss, goldGain) {
if(hpLoss > 0) {
// Show hero selection screen
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="applyWellDamage(${idx}, ${hpLoss}, ${goldGain})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'Choose Who Takes Damage',
description: `Choose which hero takes ${hpLoss} damage from climbing the well:`,
buttons: heroButtons
});
} else {
// No damage, just apply gold
S.gold += goldGain;
if(S.gold < 0) S.gold = 0;
upd();
if(goldGain > 0) toast(`Gained ${goldGain} Gold!`);
else if(goldGain < 0) toast(`Lost ${Math.abs(goldGain)} Gold!`);
nextFloor();
}
}

function applyWellDamage(heroIdx, hpLoss, goldGain) {
const hero = S.heroes[heroIdx];
hero.h -= hpLoss;
if(hero.h <= 0 && !hero.ls) {
if(hero.g > 0) {
hero.g--;
hero.h += hpLoss;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
hero.h = 0;
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`, 3000);
}
}
toast(`${hero.n} took ${hpLoss} damage!`);

S.gold += goldGain;
if(S.gold < 0) S.gold = 0;
upd();
if(goldGain > 0) toast(`Gained ${goldGain} Gold!`);
else if(goldGain < 0) toast(`Lost ${Math.abs(goldGain)} Gold!`);
nextFloor();
}

function tossWish() {
const cost = S.heroes.length;
if(S.gold < cost) {
toast(`Need ${cost} Gold to make a wish!`);
return;
}
S.gold -= cost;
upd();
replaceStage1WithStage2('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'A Wish Made',
outcomes: [`You toss ${cost} gold coin${cost>1?'s':''} into the well and make a silent wish. The water begins to glow softly, then surges upward, overflowing the well's edge!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showWishingWell2() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell2.png',
title: 'Overflowing Crystal Waters',
description: 'The well now overflows with sparkling, crystal-clear water that pools around its base. The water seems to pulse with restorative energy.',
buttons: `<button class="btn safe" onclick="drinkCrystalWater()">Drink from the well</button>`
});
}

function drinkCrystalWater() {
S.heroes.forEach(h => {
if(h.ls) {
h.ls = false;
h.lst = 0;
h.h = h.m;
toast(`${h.n} revived to full HP!`);
} else {
h.h = h.m;
}
});
toast('All heroes fully healed!', 1800);
removeNeutralFromDeck('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell2.png',
title: 'Fully Restored',
outcomes: [
'The water tastes impossibly pure and refreshing. Warmth spreads through your body as all wounds close and exhaustion fades. You feel completely restored.',
'The well\'s glow fades as the water recedes to its normal level. Its magic has been spent.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 3. TREASURE CHEST =====
function showTreasureChest1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'A Mysterious Chest',
description: 'An ornate wooden chest sits against the far wall, its brass fittings gleaming in the torchlight. No lock is visible, but you sense this may not be as simple as it appears.',
buttons: `
<button class="btn risky" onclick="openChest()">Open the chest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`
});
}

function openChest() {
const {rolls: trapRolls, best: trapBest} = rollD20Neutral();
const trapText = showD20Result(trapRolls, trapBest);

let trapOutcome = '';
let trapDmg = 0;
let secretFound = false;

if(trapBest === 1) {
trapOutcome = 'A poison dart flies out and strikes you!';
trapDmg = 3;
} else if(trapBest >= 2 && trapBest <= 9) {
trapOutcome = 'A small dart grazes your arm.';
trapDmg = 1;
} else if(trapBest >= 10 && trapBest <= 18) {
trapOutcome = 'You carefully open the chest without triggering any traps.';
} else {
trapOutcome = 'Your keen eyes spot a hidden compartment in the chest\'s lid!';
secretFound = true;
}

// Show trap result with Continue button
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Opening the Chest',
diceRoll: trapText,
outcomes: [trapOutcome],
buttons: `<button class="btn" onclick="openChestPart2(${trapDmg}, ${secretFound})">Continue</button>`
});
}

function openChestPart2(trapDmg, secretFound) {
setTimeout(() => {
const {rolls: contentRolls, best: contentBest} = rollD20Neutral();
const contentText = showD20Result(contentRolls, contentBest);

let contentOutcome = '';
let goldGain = 0;

if(contentBest >= 1 && contentBest <= 9) {
contentOutcome = 'The chest is empty. Someone got here first.';
} else if(contentBest >= 10 && contentBest <= 19) {
goldGain = Math.ceil(Math.random() * 10);
contentOutcome = `The chest contains ${goldGain} gold coins!`;
} else {
goldGain = Math.ceil(Math.random() * 10) * S.heroes.length;
contentOutcome = `The chest is filled with ${goldGain} gold coins!`;
}

if(secretFound && contentBest >= 10) {
S.silverKeyHeld = true;
replaceStage1WithStage2('treasurechest');
contentOutcome += ' Inside the secret compartment, you find a small silver key!';
}

const v = document.getElementById('gameView');
if(trapDmg > 0) {
// Show hero selection for trap damage
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="finishChestOpen(${idx}, ${trapDmg}, ${goldGain})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Chest Contents',
description: `Choose which hero takes ${trapDmg} damage:`,
diceRoll: contentText,
outcomes: [contentOutcome],
buttons: heroButtons
});
} else {
// No trap damage, just show results and continue
S.gold += goldGain;
upd();
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Chest Contents',
diceRoll: contentText,
outcomes: [contentOutcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}, 0);
}

function finishChestOpen(heroIdx, trapDmg, goldGain) {
const hero = S.heroes[heroIdx];
hero.h -= trapDmg;
if(hero.h <= 0 && !hero.ls) {
if(hero.g > 0) {
hero.g--;
hero.h += trapDmg;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
hero.h = 0;
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`, 3000);
}
}
toast(`${hero.n} took ${trapDmg} damage!`);

S.gold += goldGain;
upd();
nextFloor();
}

function showTreasureChest2() {
if(!S.silverKeyHeld) {
nextFloor();
return;
}
const goldGain = 10 * S.heroes.length;
S.gold += goldGain;
S.silverKeyHeld = false;
upd();
removeNeutralFromDeck('treasurechest');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest2.png',
title: 'Small Silver Chest',
description: 'A small silver chest sits on a stone pedestal, perfectly sized for the key you found earlier. You insert the key and it opens with a satisfying click.',
outcomes: [`Inside you find ${goldGain} gold coins, perfectly arranged!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 4. MUMBLING WIZARD =====
function showWizard1() {
const v = document.getElementById('gameView');
let description = 'An elderly wizard stands with arms outstretched toward a wall covered in glowing hieroglyphs. He mutters continuously: "Do you see it? Do you see it? Look closely..."<br><br>Choose which hero will approach the wizard:';
let buttons = '';
S.heroes.forEach((h, idx) => {
buttons += `<button class="neutral-btn safe" onclick="heroApproachesWizard(${idx})">${h.n}</button>`;
});
buttons += `<button class="btn secondary" onclick="nextFloor()">Do Not Engage</button>`;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'Hieroglyphs on the Wall',
description,
buttons
});
}

function heroApproachesWizard(heroIdx) {
const h = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= 1 && best <= 10) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText,
outcomes: [`${h.n} stares at the glowing symbols but can't make sense of them. The wizard sighs heavily: "You don't see it. How unfortunate. Please leave."`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Non-starter sigil pool
const nonStarterPool = ['Alpha', 'Asterisk', 'Star', 'Grapple', 'Ghost'];

// Get sigils hero has from non-starter pool
const heroNonStarters = nonStarterPool.filter(sig => h.s.includes(sig) || (h.ts && h.ts.includes(sig)));

let chosenSigil;
if(heroNonStarters.length > 0) {
// Prioritize passives (Star, Asterisk, Ghost) if hero has any
const heroPassives = heroNonStarters.filter(sig => ['Star', 'Asterisk', 'Ghost'].includes(sig));
if(heroPassives.length > 0) {
// On natural 20, prioritize lower level sigils
if(best === 20) {
heroPassives.sort((a, b) => getLevel(a, heroIdx) - getLevel(b, heroIdx));
chosenSigil = heroPassives[0];
} else {
chosenSigil = heroPassives[Math.floor(Math.random() * heroPassives.length)];
}
} else {
// No passives, pick from actives hero has
if(best === 20) {
heroNonStarters.sort((a, b) => getLevel(a, heroIdx) - getLevel(b, heroIdx));
chosenSigil = heroNonStarters[0];
} else {
chosenSigil = heroNonStarters[Math.floor(Math.random() * heroNonStarters.length)];
}
}
} else {
// Hero has no non-starters, pick random from pool
chosenSigil = nonStarterPool[Math.floor(Math.random() * nonStarterPool.length)];
}

const currentLevel = getLevel(chosenSigil, heroIdx);
const bonusLevels = best === 20 ? 2 : 1;

// Check if hero has the sigil
const heroHasSigil = h.s.includes(chosenSigil) || (h.ts && h.ts.includes(chosenSigil));

if(!heroHasSigil) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText,
outcomes: [
`The hieroglyph reveals itself as the symbol for ${chosenSigil}! The wizard beams with pride.`,
`But ${h.n} doesn't possess this sigil. The wizard's face falls: "You don't have it? Useless! Get out!"`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Hero has it! Grant temp upgrade
if(!h.ts) h.ts = [];
if(!h.ts.includes(chosenSigil)) h.ts.push(chosenSigil);

const oldLevel = S.sig[chosenSigil] || 0;
S.sig[chosenSigil] = oldLevel + bonusLevels;

S.wizardHero = heroIdx;
S.wizardSigil = chosenSigil;

const critText = best === 20 ? ` <span style="color:#3b82f6;font-weight:bold">(CRITICAL!)</span>` : '';
toast(`${chosenSigil} temporarily upgraded to L${S.sig[chosenSigil]} for ${h.n}!`, 1800);

replaceStage1WithStage2('wizard');
setTimeout(() => {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText + critText,
outcomes: [
`The hieroglyph reveals itself as the symbol for ${chosenSigil}! ${h.n} feels power surge through them.`,
`${chosenSigil} temporarily upgraded from L${currentLevel} to L${currentLevel + bonusLevels}!`,
'"Yes! YES! You understand!" The wizard\'s eyes gleam. "But... there is more I can offer you, if you dare..."'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}, 500);
}

function showWizard2() {
if(S.wizardHero === undefined || !S.wizardSigil) {
nextFloor();
return;
}

// Initialize wizard challenge state
if(!S.wizardChallenges) {
S.wizardChallenges = [5, 10, 15, 20];
S.wizardChallengeIndex = 0;
S.wizardUpgradedSigils = [];
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: 'Trials of Power',
description: 'The wizard\'s eyes gleam with arcane power: "You have potential... but can you prove it? I offer you a series of trials. Each success earns you greater strength. But you must attempt them all - there is no turning back!"<br><br><div style="font-size:0.85rem;margin-top:1rem;color:#666">Four trials: DC 5, DC 10, DC 15, DC 20<br>Each success: Choose a sigil to upgrade temporarily<br>On failure: Keep all upgrades earned so far</div>',
buttons: `<button class="btn risky" onclick="startWizardChallenges()">Accept the Trials</button>
<button class="btn secondary" onclick="declineWizardChallenges()">Decline</button>`
});
}

function startWizardChallenges() {
attemptWizardChallenge();
}

function attemptWizardChallenge() {
const heroIdx = S.wizardHero;
const h = S.heroes[heroIdx];
const challengeIndex = S.wizardChallengeIndex;
const dc = S.wizardChallenges[challengeIndex];

const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best < dc) {
// Failed! Keep what you got
const upgradeCount = S.wizardUpgradedSigils.length;
let outcomeText = upgradeCount > 0
? `${h.n} earned ${upgradeCount} temporary upgrade${upgradeCount > 1 ? 's' : ''} before failing!`
: `${h.n} failed the first trial. No upgrades earned.`;

removeNeutralFromDeck('wizard');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: `Trial ${challengeIndex + 1} - DC ${dc}`,
diceRoll: rollText + ` - <span style="color:#dc2626">FAILED</span>`,
outcomes: [
`${h.n} could not meet the challenge!`,
outcomeText,
'"You have reached your limit. Take what you have earned and go."'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Success! Choose a sigil to upgrade
const heroSigils = [...h.s];
if(h.ts) heroSigils.push(...h.ts);
const availableSigils = heroSigils.filter(sig => !S.wizardUpgradedSigils.includes(sig));

if(availableSigils.length === 0) {
// No more sigils to upgrade
removeNeutralFromDeck('wizard');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: `Trial ${challengeIndex + 1} - DC ${dc}`,
diceRoll: rollText + ` - <span style="color:#22c55e">SUCCESS</span>`,
outcomes: [
`${h.n} passed the trial!`,
`But ${h.n} has no more sigils available to upgrade!`,
`Total upgrades earned: ${S.wizardUpgradedSigils.length}`,
'"You have taken all I can offer. Go now."'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Show sigil selection
let description = `${h.n} passed the trial! Choose a sigil to upgrade temporarily (cannot pick the same sigil twice):`;
let buttons = '';
availableSigils.forEach(sig => {
const currentLevel = getLevel(sig, heroIdx);
buttons += `<button class="neutral-btn safe" onclick="selectWizardUpgrade('${sig}')">${sigilIcon(sig)} ${sig} - L${currentLevel} ‚Üí L${currentLevel + 1}</button>`;
});

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: `Trial ${challengeIndex + 1} - DC ${dc}`,
diceRoll: rollText + ` - <span style="color:#22c55e">SUCCESS</span>`,
description,
buttons
});
}

function selectWizardUpgrade(sig) {
const heroIdx = S.wizardHero;
const h = S.heroes[heroIdx];

// Apply temp upgrade
if(!h.ts) h.ts = [];
if(!h.ts.includes(sig)) h.ts.push(sig);

const oldLevel = S.sig[sig] || 0;
S.sig[sig] = oldLevel + 1;

S.wizardUpgradedSigils.push(sig);
toast(`${sig} temporarily upgraded to L${S.sig[sig]} for ${h.n}!`, 1800);

S.wizardChallengeIndex++;

// Check if more challenges remain
if(S.wizardChallengeIndex >= S.wizardChallenges.length) {
// All trials complete!
removeNeutralFromDeck('wizard');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
outcomes: [
`${h.n} has completed all trials!`,
`Total upgrades: ${S.wizardUpgradedSigils.length}`,
'"Impressive! You have proven yourself worthy. Now go forth with your newfound power!"'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}, ANIMATION_TIMINGS.ACTION_COMPLETE);
} else {
// Continue to next challenge
setTimeout(() => attemptWizardChallenge(), ANIMATION_TIMINGS.TUTORIAL_DELAY);
}
}

function declineWizardChallenges() {
removeNeutralFromDeck('wizard');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
outcomes: ['The wizard\'s glow fades. "Coward! You lack the will to seize greatness!" He returns to mumbling at the wall.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 5. ORACLE =====
function showOracle1() {
// Mark tutorial as seen so future runs have random neutrals
S.tutorialFlags.neutral_intro = true;
const v = document.getElementById('gameView');
let description = 'A figure shrouded in mist sits cross-legged before a crystal sphere. Their voice echoes: "Step forward. I will read your fortune. Power or Life?" Choose a hero and their desired fortune:';
let buttons = '';
S.heroes.forEach((h, idx) => {
buttons += `<button class="neutral-btn risky" onclick="oracleChoose(${idx}, 'POW')">${h.n} - Power (+1‚ö°)</button>`;
buttons += `<button class="neutral-btn safe" onclick="oracleChoose(${idx}, 'HP')">${h.n} - Life (+5‚ù§ max)</button>`;
});
buttons += `<button class="neutral-btn secondary" onclick="nextFloor()">Do Not Engage</button>`;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/prince1.png',
title: 'Consult the Oracle',
description,
buttons
});
}

function oracleChoose(heroIdx, stat) {
S.oracleHero = heroIdx;
S.oracleStat = stat;

const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);
S.oracleRoll = best;

const h = S.heroes[heroIdx];
let fortune = '';
let stage2Effect = '';

if(best === 1) {
fortune = '"Terrible misfortune awaits you."';
stage2Effect = 'CURSE';
replaceStage1WithStage2('oracle');
} else if(best >= 2 && best <= 9) {
fortune = '"What you hope for shall not come to pass."';
stage2Effect = 'NO UNLOCK';
} else if(best >= 10 && best <= 15) {
fortune = '"Great things in your future, but not what you want."';
stage2Effect = 'OPPOSITE';
replaceStage1WithStage2('oracle');
} else if(best >= 16 && best <= 19) {
fortune = '"Your desired future shall come to pass."';
stage2Effect = 'DESIRED';
replaceStage1WithStage2('oracle');
} else {
fortune = '"It happens before my eyes!"';
stage2Effect = 'IMMEDIATE DOUBLE';
replaceStage1WithStage2('oracle');
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/prince1.png',
title: 'The Oracle\'s Fortune',
diceRoll: rollText,
outcomes: [
`${h.n} steps forward seeking ${stat === 'POW' ? 'Power' : 'Life'}.`,
`The Oracle gazes into the crystal sphere, then speaks: ${fortune}`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showOracle2() {
if(S.oracleHero === null || S.oracleRoll === null) {
nextFloor();
return;
}

const heroIdx = S.oracleHero;
const stat = S.oracleStat;
const roll = S.oracleRoll;
const h = S.heroes[heroIdx];

let outcome = '';

if(roll === 1) {
// CURSE
if(stat === 'HP') {
h.m = Math.max(1, h.m - 5);
if(h.h > h.m) h.h = h.m;
outcome = `${h.n} feels weaker. Maximum HP reduced by 5!`;
} else {
h.p = Math.max(0, h.p - 1);
outcome = `${h.n} feels their strength fade. POW reduced by 1!`;
}
} else if(roll >= 10 && roll <= 15) {
// OPPOSITE
if(stat === 'HP') {
h.p++;
outcome = `${h.n} gains unexpected Power! POW +1!`;
} else {
h.m += 5;
h.h += 5;
outcome = `${h.n} feels vitality surge! Maximum HP +5!`;
}
} else if(roll >= 16 && roll <= 19) {
// DESIRED
if(stat === 'HP') {
h.m += 5;
h.h += 5;
outcome = `${h.n} feels strengthened! Maximum HP +5!`;
} else {
h.p++;
outcome = `${h.n} feels power awaken! POW +1!`;
}
} else if(roll === 20) {
// IMMEDIATE DOUBLE
if(stat === 'HP') {
h.m += 10;
h.h += 10;
outcome = `${h.n} surges with life force! Maximum HP +10!`;
} else {
h.p += 2;
outcome = `${h.n} blazes with power! POW +2!`;
}
} else {
// Rolls 2-9 shouldn't reach Stage 2, but handle defensively
outcome = 'The Oracle\'s fortune was unclear. The crystal sphere dims.';
}

removeNeutralFromDeck('oracle');

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle2.png',
title: 'Return to the Oracle',
outcomes: [
`${h.n} returns to the Oracle. The crystal sphere flares brightly!`,
outcome
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 6. ENEMY ENCAMPMENT =====
function showEncampment1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Enemies Assembling Ahead',
description: 'Through a crack in the wall ahead, you spy the enemies from your next encounter preparing for battle. They haven\'t noticed you yet.',
buttons: `
<button class="btn risky" onclick="chooseEncampmentAction('sneak')">Sneak by?</button>
<button class="btn risky" onclick="chooseEncampmentAction('engage')">Engage early</button>
`
});
}

function chooseEncampmentAction(action) {
const v = document.getElementById('gameView');
let buttons = '';
S.heroes.forEach((h, i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
buttons += `<button class="neutral-btn ${action === 'sneak' ? '' : 'risky'}" onclick="${action === 'sneak' ? 'sneakByEncampment' : 'engageEarlyEncampment'}(${i})">${h.n} - ${h.p}‚ö° | ${hp}</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: action === 'sneak' ? 'Choose Scout' : 'Choose Leader',
description: `Which hero will ${action === 'sneak' ? 'sneak past the encampment' : 'lead the charge'}?`,
buttons
});
}

function sneakByEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
if(best >= 1 && best <= 10) {
outcome = `${hero.n}'s foot catches on loose stone! The enemies hear you and prepare an ambush!`;
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 1800);
} else if(best >= 11 && best <= 19) {
outcome = `${hero.n} slips past quietly. The enemies remain unaware.`;
} else {
// Roll 20 - recruit a straggler
const comp = getEnemyComp(S.floor + 1);
const stragglerType = comp[Math.floor(Math.random() * comp.length)];
const base = E[stragglerType];
const fuMultiplier = S.gameMode === 'fu' ? 5 : 1;
const straggler = {
id: `recruit-${crypto.randomUUID()}`,
n: base.n,
p: base.p * fuMultiplier,
h: base.h * fuMultiplier,
m: base.m * fuMultiplier,
g: base.g,
x: base.x,
s: [],
pool: base.pool,
gainRate: base.gainRate || 3,
turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st: 0,
li: heroIdx,
sh: 0,
alphaActed: false,
recruitedBy: heroIdx,
isRecruit: true
};
// Add permanent sigils
if(base.permSigils) base.permSigils.forEach(ps => straggler.s.push({sig:ps.s, level:ps.l, perm:true}));
// Add start sigils
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
base.startSigils.forEach(ss => straggler.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(straggler, base);
}
}
}
if(!S.recruits) S.recruits = [];
S.recruits.push(straggler);
outcome = `${hero.n} sneaks past perfectly AND discovers a rejected ${base.n} who joins ${hero.n}'s ranks!`;
toast(`${base.n} recruited! Will fight in ${hero.n}'s lane!`, 1800);
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Sneaking Past',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function engageEarlyEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= 1 && best <= 15) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`A scout spots ${hero.n} before they can strike! The enemies prepare an ambush!`],
buttons: `<button class="btn" onclick="finishEncampmentFail()">Continue</button>`
});
} else {
const kills = best === 20 ? 2 : 1;
S.encampmentEarlyKills = kills;
replaceStage1WithStage2('encampment');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`${hero.n} succeeds at picking off ${kills} enem${kills>1?'ies':'y'}! They're scrambling to form ranks - you'll see the battlefield and pick your targets...`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function finishEncampmentFail() {
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 1800);
nextFloor();
}

// ===== 6b. ENCAMPMENT STAGE 2 =====
function showEncampment2() {
const healAmt = Math.floor(S.heroes[0].m * 0.5);
const goldGain = 2 * S.heroes.length;

S.heroes.forEach(h => {
if(!h.ls) {
h.h = Math.min(h.h + healAmt, h.m);
}
});

S.gold += goldGain;
upd();
toast(`All heroes healed ${healAmt} HP!`, 1200);
toast(`Gained ${goldGain} Gold!`, 1200);

removeNeutralFromDeck('encampment');

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment2.png',
title: 'Abandoned Encampment',
description: 'The enemy got cocky and left their base undefended. You enter and rest safely.',
outcomes: [
`All heroes restored ${healAmt} HP!`,
`Found ${goldGain} Gold in supplies!`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 7. BETWEEN THE 20s =====
function showGambling1() {
const v = document.getElementById('gameView');
// Entry requirement: minimum 2 gold
if(S.gold < 2) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
description: 'A mysterious gambling den with glowing dice floating in the air. A sign reads: "Minimum 2 Gold to play."',
outcomes: ['<span style="color:#ef4444">You don\'t have enough gold to play.</span>'],
buttons: `<button class="btn safe" onclick="nextFloor()">Leave</button>`
});
return;
}

// Calculate wager: max 10, or highest even number player has
const maxWager = 10;
let wager = Math.min(maxWager, Math.floor(S.gold / 2) * 2);
if(wager < 2) wager = 2;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
description: `A mysterious gambling den beckons. Roll dice to set your range, then try to land between them. Wager: ${wager}G for a ${wager * 2}G payout.`,
outcomes: [],
buttons: `
<button class="btn safe" onclick="nextFloor()">Walk away</button>
<button class="btn risky" onclick="playBetween20s(1, ${wager})">Play (${wager}G)</button>
`
});
}

function playBetween20s(stage, wager) {
const v = document.getElementById('gameView');
const d20Level = S.sig.D20 || 1;

// PHASE 1: Establish Range
const boundsCount = stage === 1 ? (d20Level + 1) : 2; // Stage 1: level+1, Stage 2: always 2
const boundsRolls = [];
for(let i = 0; i < boundsCount; i++) {
boundsRolls.push(Math.floor(Math.random() * 20) + 1);
}
const minBound = Math.min(...boundsRolls);
const maxBound = Math.max(...boundsRolls);

// Format dice display
const diceDisplay = formatDiceRolls(boundsRolls);

// Check instant loss (bounds are equal)
if(minBound === maxBound) {
S.gold -= wager;
upd();
v.innerHTML = buildNeutralHTML({
bgImage: stage === 1 ? 'assets/neutrals/gambling1.png' : 'assets/neutrals/gambling2.jpeg',
title: stage === 1 ? 'Between the 20s' : 'Between the 20s Extreme',
description: `Rolling ${boundsCount} dice to set bounds...`,
outcomes: [
`${diceDisplay}`,
`<span style="color:#ef4444">INSTANT LOSS! Both bounds are ${minBound}!</span>`,
`Lost ${wager}G.`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Store game state for phase 2/3
window.between20sState = { stage, wager, minBound, maxBound, boundsRolls };

// PHASE 2: Decision Point (Stage 1 only)
if(stage === 1) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
description: `Rolling ${boundsCount} dice to set bounds...`,
outcomes: [
`${diceDisplay}`,
`Range set: <span style="color:#22c55e">${minBound}</span> to <span style="color:#22c55e">${maxBound}</span>`,
'You can back out for half your wager, or continue for a chance at double.'
],
buttons: `
<button class="btn risky" onclick="backOutBetween20s()">Back out (get ${Math.floor(wager / 2)}G back)</button>
<button class="btn danger" onclick="targetRollBetween20s()">Continue to target roll</button>
`
});
} else {
// Stage 2: No backing out, go straight to target roll
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling2.jpeg',
title: 'Between the 20s Extreme',
description: `Rolling ${boundsCount} dice to set bounds...`,
outcomes: [
`${diceDisplay}`,
`Range set: <span style="color:#22c55e">${minBound}</span> to <span style="color:#22c55e">${maxBound}</span>`,
'<span style="color:#3b82f6">NO BACKING OUT! Rolling for target...</span>'
],
buttons: `<button class="btn danger" onclick="targetRollBetween20s()">Roll target dice</button>`
});
}
}

function formatDiceRolls(rolls) {
return rolls.map(r => `<span style="display:inline-block;width:2.5rem;height:2.5rem;line-height:2.5rem;text-align:center;background:#1e293b;border:2px solid #475569;border-radius:0.5rem;margin:0.2rem;font-weight:bold;color:#f1f5f9;font-size:1.2rem;">${r}</span>`).join(' ');
}

function backOutBetween20s() {
const state = window.between20sState;
const refund = Math.floor(state.wager / 2);
S.gold -= state.wager;
S.gold += refund;
upd();

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
outcomes: [
'You decide to play it safe and back out.',
`Net loss: ${state.wager - refund}G`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function targetRollBetween20s() {
const state = window.between20sState;
const v = document.getElementById('gameView');
const d20Level = S.sig.D20 || 1;

// PHASE 3: Target Roll
const targetRolls = [];
for(let i = 0; i < d20Level; i++) {
targetRolls.push(Math.floor(Math.random() * 20) + 1);
}

// Check if ANY die lands between bounds (inclusive)
const winners = targetRolls.filter(r => r >= state.minBound && r <= state.maxBound);
const won = winners.length > 0;

const targetDisplay = formatDiceRolls(targetRolls);

if(won) {
// Calculate payout
let payout = state.wager * (state.stage === 1 ? 2 : 4);
if(state.stage === 2) {
payout = Math.min(payout, 40); // Cap at 40G for Stage 2
}
const netGain = payout - state.wager;
S.gold += payout;
upd();

// Unlock Stage 2 after Stage 1 win
if(state.stage === 1) {
replaceStage1WithStage2('gambling');
toast('Between the 20s Extreme unlocked!', 1800);
}

v.innerHTML = buildNeutralHTML({
bgImage: state.stage === 1 ? 'assets/neutrals/gambling1.png' : 'assets/neutrals/gambling2.jpeg',
title: state.stage === 1 ? 'Between the 20s - WIN!' : 'Between the 20s Extreme - WIN!',
description: `Rolling ${d20Level} target ${d20Level === 1 ? 'die' : 'dice'}...`,
outcomes: [
`${targetDisplay}`,
`<span style="color:#22c55e">SUCCESS! ${winners.map(w => `[${w}]`).join(' ')} landed in range [${state.minBound}-${state.maxBound}]!</span>`,
`Won ${payout}G! (Net: +${netGain}G)`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else {
S.gold -= state.wager;
upd();

v.innerHTML = buildNeutralHTML({
bgImage: state.stage === 1 ? 'assets/neutrals/gambling1.png' : 'assets/neutrals/gambling2.jpeg',
title: state.stage === 1 ? 'Between the 20s - Loss' : 'Between the 20s Extreme - Loss',
description: `Rolling ${d20Level} target ${d20Level === 1 ? 'die' : 'dice'}...`,
outcomes: [
`${targetDisplay}`,
`<span style="color:#ef4444">MISS! No dice landed in range [${state.minBound}-${state.maxBound}].</span>`,
`Lost ${state.wager}G.`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function showGambling2() {
const v = document.getElementById('gameView');
// Entry requirement: minimum 2 gold
if(S.gold < 2) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling2.jpeg',
title: 'Between the 20s Extreme',
description: 'The high-stakes gambling den glows with intense energy. A sign reads: "Minimum 2 Gold to play - 4x payout, capped at 40G."',
outcomes: ['<span style="color:#ef4444">You don\'t have enough gold to play.</span>'],
buttons: `<button class="btn safe" onclick="nextFloor()">Leave</button>`
});
return;
}

// Calculate wager: max 10, or highest even number player has
const maxWager = 10;
let wager = Math.min(maxWager, Math.floor(S.gold / 2) * 2);
if(wager < 2) wager = 2;

// Calculate potential payout (capped at 40)
const potentialPayout = Math.min(wager * 4, 40);

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling2.jpeg',
title: 'Between the 20s Extreme',
description: `The EXTREME version! Only 2 dice for bounds, NO backing out, but ${potentialPayout}G payout! High risk, high reward.`,
outcomes: ['<span style="color:#3b82f6">WARNING: No safety net here. You\'re all in once you start.</span>'],
buttons: `
<button class="btn safe" onclick="nextFloor()">Walk away</button>
<button class="btn danger" onclick="playBetween20s(2, ${wager})">Play EXTREME (${wager}G for ${potentialPayout}G)</button>
`
});
}

// ===== 8. GHOST =====
function showGhost1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Two Ghostly Boys Want to Play',
description: 'Two translucent boys appear before you, giggling. "Play with us! Play with us!" They reach out with spectral hands.',
buttons: `
<button class="btn danger" onclick="playWithGhostBoys()">Play with the ghost boys</button>
<button class="btn risky" onclick="nextFloor()">Avoid?</button>
`
});
}

let ghostEscapeDC = 18;
let ghostEscapeAttempts = 0;

function playWithGhostBoys() {
ghostEscapeDC = 18;
ghostEscapeAttempts = 0;
attemptGhostEscape();
}

function attemptGhostEscape() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= ghostEscapeDC) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Escaping the Ghost Boys',
diceRoll: rollText,
outcomes: ['You break free from their grip! The boys pout but let you go. "Come back and play sometime..."'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Failed - show hero selection
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="applyGhostDamage(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Trapped with the Ghost Boys',
diceRoll: rollText,
description: 'Choose which hero takes 1 damage:',
outcomes: ['You remain trapped! Time slips away...'],
buttons: heroButtons
});
}

function applyGhostDamage(heroIdx) {
const hero = S.heroes[heroIdx];
const hadGhostCharge = hero.g > 0;

hero.h -= 1;
if(hero.h <= 0) {
hero.h = 0;
if(hero.g > 0) {
hero.g--;
hero.h = hero.m;
// EASTER EGG: Ghost charge consumed during Ghost encounter triggers conversion
if(hadGhostCharge) {
replaceStage1WithStage2('ghost');
toast(`${hero.n} used Ghost charge! The boys realize the truth!`, 1800);
upd();
// Trigger the full Ghost Boys conversion (showGhost2)
showGhost2();
return;
}
} else {
hero.ls = true;
hero.lst = 0;
upd();
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Escaping the Ghost Boys',
outcomes: [
`${hero.n} took 1 damage and entered Last Stand! The shock breaks the ghost boys' hold!`,
'"Oops!" they say in unison, then fade away giggling.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}
}

toast(`${hero.n} took 1 damage!`);
ghostEscapeAttempts++;
ghostEscapeDC -= 2;
upd();

const v = document.getElementById('gameView');

if(ghostEscapeAttempts >= 9) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Finally Free',
outcomes: ['After many attempts, the ghost boys grow bored and fade away.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Try Again',
description: `<div style="font-size:0.9rem;margin:1rem 0">Attempts: ${ghostEscapeAttempts}/9 | Next DC: ${ghostEscapeDC}</div>`,
outcomes: [`${hero.n} took 1 damage!`],
buttons: `<button class="btn danger" onclick="attemptGhostEscape()">Try to Escape (DC ${ghostEscapeDC})</button>`
});
}

function showGhost2() {
S.ghostBoysConverted = true;
toast('Ghost Boys permanently converted to Empty Playroom!', 1800);
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost2.png',
title: 'The Boys Realize the Truth',
description: 'The ghost boys stare at each other, then at their translucent hands. "We\'re... we\'re dead. We\'re ghosts."',
outcomes: [
'Tears form in their spectral eyes. "We want to go home. We want to see Mommy and Daddy."',
'They hold hands and walk toward a light that appears. "Thank you for showing us." They vanish peacefully.',
'<span style="color:#22c55e">This room is now an Empty Playroom - you can pass safely in future runs.</span>'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showEmptyPlayroom() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost2.png',
title: 'Empty Playroom',
description: 'An empty chamber, dust motes drifting in pale light. It might have been a playroom once, but whatever haunted it is long gone. The air feels peaceful.',
outcomes: ['Nothing stops you here. You pass through quietly.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue to Floor ${S.floor + 1}</button>`
});
}

// ===== 9. FLUMMOXED PRINCE(SS) =====
function showPrince1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle1.png',
title: 'Help Recover the Ring',
description: `A flummoxed ${S.princeGender} paces anxiously: "Please, you must help! A creature in the next room ate my engagement ring! If you can stun it on the first turn of battle, I can retrieve it!"`,
buttons: `
<button class="btn" onclick="acceptPrinceQuest()">Accept the quest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`
});
}

function acceptPrinceQuest() {
toast('Stun any enemy Turn 1 of next combat!', 1800);
S.princeQuestActive = true;
S.princeQuestCompleted = false;
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle1.png',
outcomes: [`The ${S.princeGender} looks hopeful: "Thank you! I'll follow you and grab it when you stun the creature!"`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showPrince2() {
const v = document.getElementById('gameView');
// Check if quest was completed
if(!S.princeQuestCompleted) {
// Quest failed
S.princeQuestActive = false;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle1.png',
title: 'Quest Failed',
description: `The ${S.princeGender} returns, dejected: "The creature fled before I could retrieve the ring. I'll have to find another way..."`,
outcomes: [`The ${S.princeGender} departs sadly. No reward.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Quest succeeded - show wedding
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const eligible = allSigils.filter(s => (S.sig[s] || 0) < 4);

eligible.sort((a, b) => {
const costA = S.sig[a] || 0;
const costB = S.sig[b] || 0;
return costA - costB;
});

const sigil1 = eligible[0] || 'Attack';
const sigil2 = eligible[1] || 'Shield';

removeNeutralFromDeck('prince');
S.princeQuestActive = false;

let buttons = '';
buttons += `<div class="choice" onclick="choosePrinceSigil('${sigil1}')">
<strong>${sigilIcon(sigil1)}</strong> <span style="opacity:0.7">L${S.sig[sigil1] || 0} ‚Üí L${(S.sig[sigil1] || 0) + 1}</span>
</div>`;
buttons += `<div class="choice" onclick="choosePrinceSigil('${sigil2}')">
<strong>${sigilIcon(sigil2)}</strong> <span style="opacity:0.7">L${S.sig[sigil2] || 0} ‚Üí L${(S.sig[sigil2] || 0) + 1}</span>
</div>`;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/prince2.png',
title: 'The Wedding',
description: `The ${S.princeGender} proposes to their beloved. A beautiful wedding ceremony unfolds before you!`,
outcomes: ['Each wears a garment displaying a sigil of power. As thanks for your help, you may choose one:'],
buttons
});
}

function choosePrinceSigil(sig) {
S.sig[sig] = (S.sig[sig] || 0) + 1;
toast(`${sig} permanently upgraded to L${S.sig[sig]}!`, 1800);
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/prince2.png',
outcomes: [`The royal couple thanks you profusely. The ${sig} sigil glows and merges with your power!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== OLD TAPO ENCOUNTER (FLOOR 20) =====
function showOldTapo() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/old-tapo.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #8b5cf6;box-shadow:0 0 20px rgba(139,92,246,0.5)">
<div class="neutral-title" style="color:#8b5cf6;font-size:1.8rem">The Master of Space and Time</div>
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;background:rgba(139,92,246,0.1);border-radius:8px;margin:1rem 0">
"Tapo, you say? Yes‚Ä¶. I was called Tapo once, before I mastered the mysteries of space and time. Save me? Why, I need no saving‚Ä¶ In fact‚Ä¶."
</div>
<button class="btn" onclick="oldTapoTransform()" style="background:linear-gradient(135deg, #8b5cf6, #6366f1);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Continue</button>
</div>`;
}

function oldTapoTransform() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div style="text-align:center;margin:2rem 0">
<div style="font-size:3rem;animation:clap 0.5s ease-in-out 3;margin-bottom:2rem">üëè</div>
<img src="assets/tapo-nobg.png" style="max-width:100%;height:auto;max-width:300px;margin:0 auto 1rem auto;display:block;animation:bounce 1s ease-in-out 3">
<div style="font-size:2.5rem;font-weight:bold;color:#3b82f6;text-shadow:0 0 10px rgba(251,191,36,0.5);margin:2rem 0;animation:glow 1s ease-in-out infinite">
‚ú® Tapo Unlocked! ‚ú®
</div>
<div class="neutral-outcome" style="font-size:1.1rem;margin:1.5rem 0">
Baby Tapo has been added to your hero roster!<br>
<span style="color:#22c55e">Stats: 1 HP / 1 POW</span><br>
<span style="color:#8b5cf6">Starts with ALL active sigils!</span>
</div>
</div>
<button class="btn" onclick="completeTapoUnlock()" style="background:linear-gradient(135deg, #3b82f6, #f97316);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Victory!</button>
</div>
<style>
@keyframes clap {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.5); }
}
@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-20px); }
}
@keyframes glow {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}
</style>`;
}

function completeTapoUnlock() {
S.tapoUnlocked = true;
savePermanent();
win();
}

// ===== DEATH DIALOGUE SEQUENCE =====
function showDeathIntroDialogue() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="background:#2c2416;padding:2rem;border-radius:8px;max-width:800px;margin:2rem auto;color:#e8dcc4">
<img src="assets/neutrals/shopkeeper2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #dc2626;box-shadow:0 0 20px rgba(220,38,38,0.5)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:2rem;text-align:center">
"Oh hey, it's you! I'm the one who's been giving you tips along the way."
</p>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:2rem;text-align:center">
"I'm supposed to take you to the next life‚Ä¶ but you're not from this realm, are you?"
</p>
<div class="choice" onclick="showDeathResponseDialogue(true)" style="cursor:pointer">
<strong>Yes, I'm from a place called Ribbleton!</strong>
</div>
<div class="choice" onclick="showDeathResponseDialogue(false)" style="cursor:pointer">
<strong>No, I sure am from this realm!</strong>
</div>
</div>`;
}

function showDeathResponseDialogue(fromRibbleton) {
const v = document.getElementById('gameView');
const responseText = fromRibbleton
? "Ribbleton! I thought so. Not many travelers make it here from other realms."
: "Is that so? Well, regardless of where you're from...";

v.innerHTML = `
<div style="background:#2c2416;padding:2rem;border-radius:8px;max-width:800px;margin:2rem auto;color:#e8dcc4">
<img src="assets/neutrals/shopkeeper2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #dc2626;box-shadow:0 0 20px rgba(220,38,38,0.5)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:1.5rem;text-align:center">
"${responseText}"
</p>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:2rem;text-align:center">
"Well, it might be more profitable for <em>both</em> of us if I don't, you know‚Ä¶ kill you. I have another arrangement in mind."
</p>
<button class="btn danger" onclick="completeDeathIntro()" style="font-size:1.2rem;padding:1rem 2rem;margin:0 auto;display:block">Continue...</button>
</div>`;
}

function completeDeathIntro() {
// Mark the intro as seen
S.tutorialFlags.death_intro = true;
savePermanent();
// Show the actual death screen with upgrades
showDeathScreen();
}

// ===== DEATH SCREEN =====
function showDeathScreen() {
savePermanent(); // Save gold, goingRate, sig upgrades
// Recruits persist until killed - don't clear here

// Check if this is the first time meeting Death
if(!S.tutorialFlags.death_intro) {
showDeathIntroDialogue();
return;
}

const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];

// Select a random Death quote that hasn't been used yet
let deathQuote = "";
if(S.usedDeathQuotes.length >= DEATH_QUOTES.length) {
// All quotes used - reset the pool
S.usedDeathQuotes = [];
}
const availableQuotes = DEATH_QUOTES.filter((_, idx) => !S.usedDeathQuotes.includes(idx));
if(availableQuotes.length > 0) {
const randomIdx = Math.floor(Math.random() * availableQuotes.length);
deathQuote = availableQuotes[randomIdx];
// Mark this quote as used
const quoteIndex = DEATH_QUOTES.indexOf(deathQuote);
S.usedDeathQuotes.push(quoteIndex);
savePermanent(); // Save the updated usedDeathQuotes
}

let html = `
<style>
@keyframes marquee-flash {
  0%, 100% { border-color: #dc2626; box-shadow: 0 0 10px rgba(220,38,38,0.8), 0 0 20px rgba(220,38,38,0.5); }
  50% { border-color: #3b82f6; box-shadow: 0 0 15px rgba(251,191,36,0.9), 0 0 30px rgba(251,191,36,0.6); }
}
.going-rate-marquee {
  animation: marquee-flash 1.5s ease-in-out infinite;
  border: 4px solid #dc2626;
  padding: 1.5rem;
  border-radius: 12px;
  background: linear-gradient(135deg, rgba(220,38,38,0.1), rgba(251,191,36,0.1));
  margin: 1.5rem 0;
}
</style>
<div style="background:#f5f4ed;padding:2rem;border-radius:8px;max-width:900px;margin:0 auto;color:#2c2416;box-shadow:0 4px 12px rgba(0,0,0,0.15)">
<img src="assets/neutrals/shopkeeper2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #dc2626;box-shadow:0 0 20px rgba(220,38,38,0.5)">
<h1 style="text-align:center;margin-bottom:1rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
${deathQuote ? `<p style="text-align:center;margin-bottom:1rem;font-size:1rem;color:#666;font-style:italic">"${deathQuote}"</p>` : ''}
<div class="going-rate-marquee">
<p style="text-align:center;font-size:1.3rem;margin:0">Gold: <strong style="color:#d97706">${S.gold}</strong></p>
<p style="text-align:center;font-size:1.5rem;margin:0.5rem 0 0 0;font-weight:bold;color:#dc2626">‚ö° Going Rate: ${S.goingRate}G ‚ö°</p>
</div>`;

if(S.gold === 0) {
html += `<p style="text-align:center;margin:2rem 0;font-size:1.2rem;color:#dc2626;font-style:italic">"Nothing? Really? Come back when you have something to offer."</p>`;
} else {
html += `<h3 style="margin-bottom:1rem;text-align:center;font-size:1.3rem;color:#2c2416">Upgrade Sigilarium:</h3>`;
html += `<div style="display:grid;grid-template-columns:repeat(5,1fr);gap:1rem;margin-bottom:1.5rem;max-width:850px;margin-left:auto;margin-right:auto">`;

allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
// Actives show their effective level (perm + 1 for display)
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const nextLevel = currentLevel + 1;
if(currentLevel >= 5) return; // Max level (5 for display)

const upgradeCount = S.sigUpgradeCounts[sig] || 0;
const baseCost = S.goingRate;
const escalation = upgradeCount > 0 ? (upgradeCount * 50) : 0;
const cost = baseCost + escalation;

const canAfford = S.gold >= cost;
const colors = ['#666', '#000', '#0d9488', '#9333ea', '#d97706', '#ff00ff'];
const colorClass = colors[currentLevel] || '#666';
const nextColorClass = colors[nextLevel] || '#ff00ff';

html += `
<div style="background:#ffffff;padding:1rem;border-radius:8px;border:2px solid #2c2416;box-shadow:0 2px 4px rgba(0,0,0,0.1)">
<div style="font-weight:bold;margin-bottom:0.75rem;font-size:1.1rem">${sigilIconWithTooltip(sig, currentLevel, 750)}</div>
<div style="font-size:1rem;margin-bottom:0.75rem;font-weight:bold">
<span style="color:${colorClass}">L${currentLevel}</span> ‚Üí <span style="color:${nextColorClass}">L${nextLevel}</span>
</div>
<div style="font-size:0.9rem;margin-bottom:0.75rem;color:#666;font-weight:600">Cost: ${cost}G</div>
<button class="btn" ${!canAfford ? 'disabled style="opacity:0.4"' : ''} onclick="purchaseSigilUpgrade('${sig}', ${cost})" style="padding:0.5rem 1rem;font-size:0.9rem;width:100%">
${canAfford ? 'Purchase' : 'Too Expensive'}
</button>
</div>`;
});

html += `</div>`;
}

// Death Boys (only if Ghost Boys converted)
if(S.ghostBoysConverted) {
html += `
<div style="border-top:2px solid rgba(255,255,255,0.2);padding-top:2rem;margin-top:2rem">
<h2 style="text-align:center;margin-bottom:0.5rem;font-size:1.5rem;color:#a855f7">The Death Boys</h2>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;font-style:italic;opacity:0.8">"We work for Death now! He's WAY cooler than being ghosts!"</p>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-bottom:1.5rem">
<!-- Boy 1: Sell Back -->
<div style="background:rgba(34,197,94,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(34,197,94,0.3)">
<h3 style="color:#22c55e;margin-bottom:0.5rem">Death Boy 1: "Sell Back"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Remove one upgrade level from any sigil and get Gold equal to the current Going Rate (no +5G increase)</p>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G</div>`;

// List all sigils that can be sold back
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const canSellBack = permLevel > 0;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIconWithTooltip(sig, currentLevel, 750)} L${currentLevel}</span>
<button class="btn" ${!canSellBack ? 'disabled style="opacity:0.4"' : ''} onclick="deathBoySellBack('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSellBack ? `Sell for ${S.goingRate}G` : 'Cannot Sell'}
</button>
</div>`;
});

html += `</div>

<!-- Boy 2: Sacrifice for XP -->
<div style="background:rgba(168,85,247,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(168,85,247,0.3)">
<h3 style="color:#a855f7;margin-bottom:0.5rem">Death Boy 2: "Sacrifice"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Sacrifice one upgrade level to gain ${S.goingRate} Starting XP permanently. Going Rate decreases by 5G.</p>
<div style="font-size:0.8rem;margin-bottom:0.5rem;opacity:0.7">Current Starting XP: ${S.startingXP}</div>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G ‚Üí ${Math.max(1, S.goingRate - 5)}G</div>`;

// List all sigils that can be sacrificed
const actives2 = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives2.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const canSacrifice = permLevel > 0 && S.goingRate > 1;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIconWithTooltip(sig, currentLevel, 750)} L${currentLevel}</span>
<button class="btn" ${!canSacrifice ? 'disabled style="opacity:0.4"' : ''} onclick="deathBoySacrifice('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSacrifice ? `+${S.goingRate}XP` : 'Cannot'}
</button>
</div>`;
});

html += `</div>
</div>
</div>`;
}

html += `
<div style="text-align:center;margin-top:2rem">
<button class="btn danger" onclick="restartAfterDeath()" style="font-size:1.2rem;padding:1rem 2rem">Return to Ribbleton</button>
</div>
</div>`;

v.innerHTML = html;
}

function purchaseSigilUpgrade(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }

// Check max level: actives max at perm L4 (displays as L5), passives max at perm L5
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const permLevel = S.sig[sig] || 0;
const maxLevel = isActive ? 4 : 5;

if(permLevel >= maxLevel) {
toast('Already at maximum level!', 1800);
return;
}

S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
S.sigUpgradeCounts[sig] = (S.sigUpgradeCounts[sig] || 0) + 1;
S.goingRate += 5;
toast(`${sig} upgraded to L${S.sig[sig]}!`, 1200);
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySellBack(sig) {
const permLevel = S.sig[sig] || 0;
if(permLevel <= 0) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
// Sell back: get gold, lower sigil level, no going rate change
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const oldLevel = isActive ? permLevel + 1 : permLevel;
S.gold += S.goingRate;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
const newPermLevel = S.sig[sig];
const newLevel = isActive ? newPermLevel + 1 : newPermLevel;
toast(`Sold ${sig} L${oldLevel}‚ÜíL${newLevel} for ${S.goingRate}G!`, 1800);
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySacrifice(sig) {
const permLevel = S.sig[sig] || 0;
if(permLevel <= 0) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
if(S.goingRate <= 1) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
// Sacrifice: get starting XP, lower sigil level, decrease going rate
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const oldLevel = isActive ? permLevel + 1 : permLevel;
const xpGained = S.goingRate;
S.startingXP += xpGained;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
S.goingRate = Math.max(1, S.goingRate - 5);
const newPermLevel = S.sig[sig];
const newLevel = isActive ? newPermLevel + 1 : newPermLevel;
toast(`Sacrificed ${sig} L${oldLevel}‚ÜíL${newLevel} for +${xpGained}XP permanently!`, 1800);
savePermanent();
showDeathScreen(); // Refresh
}

function restartAfterDeath() {
// Check if player has unspent gold
if(S.gold >= S.goingRate && !S.tutorialFlags.death_exit_warning) {
showTutorialPop('death_exit_warning', "Are you sure? This is some great value, and you'll end up giving it to me sooner or later...", () => {
// After tutorial, ask for confirmation
if(confirm('Leave Death Screen with unspent gold?')) {
actuallyRestartAfterDeath();
} else {
showDeathScreen();
}
});
return;
}
actuallyRestartAfterDeath();
}

function actuallyRestartAfterDeath() {
// Increment run number
S.runNumber++;
savePermanent();
// Clear run-specific save (slot-specific)
if(S.currentSlot) {
localStorage.removeItem(`froggle8_slot${S.currentSlot}`);
}
// Also clear old save format for backwards compatibility
localStorage.removeItem('froggle8');
// Return to Ribbleton hub
toast('Returning to Ribbleton...', 1200);
setTimeout(() => transitionScreen(showRibbleton), ANIMATION_TIMINGS.ACTION_COMPLETE);
}

// ===== CHAMPIONS MENU =====
function showChampionsMenu() {
const v = document.getElementById('gameView');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;

let html = `
<div style="position:relative;max-width:800px;margin:0 auto">
<h1 style="text-align:center;margin:1rem 0;font-size:2rem;background:linear-gradient(135deg,#3b82f6,#f97316);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text">
üèÜ Champions of Floor 20 üèÜ
</h1>

<div style="position:relative;width:100%;margin:0 auto">
<img src="assets/victory-room.png" style="width:100%;display:block;border-radius:8px;border:3px solid #000">

<!-- Clickable pedestal hotspot (center) -->
<div onclick="showPedestal()" style="position:absolute;left:35%;top:30%;width:30%;height:50%;cursor:pointer" title="View Pedestal"></div>

<!-- Clickable left portal (blue portal - leads to Standard mode) -->
<div onclick="enterPortal('Standard')" style="position:absolute;left:5%;top:20%;width:20%;height:60%;cursor:pointer" title="${S.gameMode === 'Standard' ? 'Current Mode' : 'Enter Standard Realm'}"></div>

<!-- Clickable right portal (orange portal - leads to FU mode) -->
<div onclick="enterPortal('fu')" style="position:absolute;right:5%;top:20%;width:20%;height:60%;cursor:pointer" title="${S.gameMode === 'fu' ? 'Current Mode' : 'Enter Frogged Up Realm üî•'}"></div>
</div>

<div style="text-align:center;margin-top:1.5rem;padding:1rem;background:rgba(251,191,36,0.1);border:2px solid #3b82f6;border-radius:8px">
<p style="margin:0.5rem 0;font-size:1rem"><strong>Current Mode:</strong> <span style="color:${S.gameMode === 'fu' ? '#dc2626' : '#22c55e'}">${S.gameMode === 'Standard' ? 'Standard' : 'FROGGED UP üî•'}</span></p>
<p style="margin:0.5rem 0;font-size:0.9rem;opacity:0.8">Click the <strong>pedestal</strong> to manage figurines (${pedestalCount}/${maxSlots})</p>
<p style="margin:0.5rem 0;font-size:0.9rem;opacity:0.8">Click a <strong>portal</strong> to switch game modes</p>
</div>

<div style="text-align:center;margin-top:1rem">
<button class="btn secondary" onclick="title()">Back to Title</button>
</div>
</div>`;

v.innerHTML = html;
}

function enterPortal(targetMode) {
if(S.gameMode === targetMode) {
toast('You are already in this realm!');
return;
}
S.gameMode = targetMode;
toast(`Entered ${targetMode === 'Standard' ? 'Standard' : 'Frogged Up üî•'} Realm!`);
showChampionsMenu();
}

function toggleModeFromChampions() {
S.gameMode = S.gameMode === 'Standard' ? 'fu' : 'Standard';
showChampionsMenu();
}

// ===== PEDESTAL UI =====
function showPedestal() {
const v = document.getElementById('gameView');
const heroes = ['Warrior', 'Tank', 'Mage', 'Healer'];
const heroIcons = {'Warrior': '‚öî', 'Tank': 'üõ°', 'Mage': 'üìñ', 'Healer': '‚úö'};
const stats = ['POW', 'HP'];

// Build slot grid overlay on the pedestal image
let slotsHTML = '';
stats.forEach((stat, rowIdx) => {
heroes.forEach((hero, colIdx) => {
const slotted = S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
const isSlotted = !!slotted;

// Position slots in a 2x4 grid over the pedestal image
// Adjust these percentages to match the actual slot positions on the pedestal art
const left = 20 + (colIdx * 20); // Distribute 4 columns across width
const top = 40 + (rowIdx * 25); // Distribute 2 rows across height

slotsHTML += `
<div style="position:absolute;left:${left}%;top:${top}%;width:15%;height:20%;display:flex;align-items:center;justify-content:center;cursor:pointer" onclick="${isSlotted ? `removeFigurine('${hero}','${stat}')` : `slotFigurine('${hero}','${stat}')`}">
<div style="width:100%;height:100%;background:${isSlotted ? 'rgba(251,191,36,0.3)' : 'rgba(255,255,255,0.1)'};border:2px solid ${isSlotted ? '#3b82f6' : 'rgba(255,255,255,0.3)'};border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;backdrop-filter:blur(2px)">`;

if(isSlotted) {
const displayIcon = slotted.source === 'statuette' ? 'üóø' : heroIcons[hero];
slotsHTML += `<div style="font-size:2rem;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.5))">${displayIcon}</div>
<div style="font-size:0.7rem;background:#000;color:#fff;padding:2px 4px;border-radius:3px;margin-top:2px">${stat === 'POW' ? '+1' : '+5'}</div>`;
} else {
slotsHTML += `<div style="font-size:1.5rem;color:rgba(255,255,255,0.4);text-shadow:0 2px 4px rgba(0,0,0,0.5)">+</div>`;
}

slotsHTML += `</div></div>`;
});
});

// Add legend showing hero names at top
let legendHTML = '<div style="position:absolute;top:10%;left:0;right:0;display:flex;justify-content:space-around;padding:0 15%">';
heroes.forEach(hero => {
legendHTML += `<div style="text-align:center;color:#fff;text-shadow:0 2px 4px rgba(0,0,0,0.8)">
<div style="font-size:1.5rem;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.8))">${heroIcons[hero]}</div>
<div style="font-size:0.75rem;font-weight:bold">${hero}</div>
</div>`;
});
legendHTML += '</div>';

// Add stat labels on left
let statLabelsHTML = '<div style="position:absolute;left:5%;top:40%;display:flex;flex-direction:column;gap:25%">';
stats.forEach(stat => {
statLabelsHTML += `<div style="color:#fff;font-weight:bold;text-shadow:0 2px 4px rgba(0,0,0,0.8);font-size:1.2rem">${stat}</div>`;
});
statLabelsHTML += '</div>';

let html = `
<div class="neutral-container">
<div class="neutral-left" style="position:relative;min-height:600px">
<div class="neutral-header">
<div class="neutral-stats">üí∞ ${S.gold}G | üéØ Floor ${S.floor}</div>
<div class="neutral-narrative">
<h2 style="margin:0">‚ö±Ô∏è Pedestal of Champions</h2>
<p style="margin:0.5rem 0;font-size:0.9rem">${S.gameMode} Mode - Place figurines for permanent stat buffs</p>
</div>
</div>

${legendHTML}
${statLabelsHTML}
${slotsHTML}

${S.hasAncientStatuette ? `<div style="position:absolute;bottom:15%;left:10%;right:10%;padding:1rem;background:rgba(251,191,36,0.9);border-radius:6px;text-align:center;border:2px solid #000">
<p style="font-weight:bold;margin-bottom:0.5rem">üóø Ancient Statuette Available!</p>
<p style="font-size:0.9rem;margin:0">Click any empty slot to place it</p>
</div>` : ''}

<div style="position:absolute;bottom:5%;left:50%;transform:translateX(-50%)">
<button class="btn secondary" onclick="showChampionsMenu()">Back to Victory Room</button>
</div>
</div>
<div class="neutral-right" style="background-image:url('assets/neutrals/statue2.png')"></div>
</div>`;

v.innerHTML = html;
}

function slotFigurine(hero, stat) {
// Check if slot is available
if(S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode)) {
toast('Slot already filled!');
return;
}

// Check if we have 8 slots filled
const slotsUsed = S.pedestal.filter(p => p.mode === S.gameMode).length;
if(slotsUsed >= 8) {
toast('All 8 slots filled! Remove a figurine first.');
return;
}

// Use Ancient Statuette if available (can go in any slot)
if(S.hasAncientStatuette) {
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'statuette'});
S.hasAncientStatuette = false;
savePermanent();
toast(`Ancient Statuette placed on ${hero} ${stat}!`, 1800);
showPedestal();
return;
}

// Otherwise, check if this hero can have a figurine (max 2 per hero per mode)
const existingCount = S.pedestal.filter(p => p.hero === hero && p.mode === S.gameMode).length;
if(existingCount >= 2) {
toast(`${hero} already has 2 figurines in ${S.gameMode} mode!`, 1800);
return;
}

// Place the hero figurine
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'hero'});
savePermanent();
toast(`${hero} ${stat} figurine placed!`, 1800);
showPedestal();
}

function removeFigurine(hero, stat) {
const idx = S.pedestal.findIndex(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
if(idx >= 0) {
S.pedestal.splice(idx, 1);
savePermanent();
toast(`${hero} ${stat} figurine removed!`);
showPedestal();
}
}

// ===== WIN =====
function win() {
// Gold is lost on victory (reset to 0)
S.gold = 0;
savePermanent();

// Award figurines for heroes who survived (HP > 0, not Last Stand)
const survivedHeroes = S.heroes.filter(h => h.h > 0 && !h.ls);
const earnedFigurines = [];
survivedHeroes.forEach(h => {
// Check if this hero already has 2 figurines for this mode
const existingCount = S.pedestal.filter(slot => slot.hero === h.n && slot.mode === S.gameMode).length;
if(existingCount < 2) {
earnedFigurines.push(h.n);
}
});

// Unlock Frogged Up mode if Standard victory
const firstStandardVictory = S.gameMode === 'Standard' && !S.tutorialFlags.first_victory_sequence;
if(S.gameMode === 'Standard') {
S.fuUnlocked = true;
if(firstStandardVictory) {
S.tutorialFlags.first_victory_sequence = true;
}
}

const firstFU = S.gameMode === 'fu' && !S.tutorialFlags.first_fu_victory;
if(firstFU) {
S.tutorialFlags.first_fu_victory = true;
// Note: Tapo is now unlocked at Floor 20 via Old Tapo encounter
}

savePermanent();

// Store earned figurines for later display
window.earnedFigurines = earnedFigurines;

// FIRST STANDARD VICTORY: Show cutscene
if(firstStandardVictory) {
showFirstVictoryCutscene();
return;
}

// FIRST FU VICTORY: Show credits
if(firstFU) {
showFUVictoryCredits();
return;
}

// TAPO IN PARTY: Show heartfelt thank you (only if Tapo is alive)
const tapoInParty = S.heroes.some(h => h.n === 'Tapo' && h.h > 0 && !h.ls);
if(tapoInParty && !S.tutorialFlags.tapo_victory_message) {
S.tutorialFlags.tapo_victory_message = true;
savePermanent();
showTapoVictoryMessage();
return;
}

// SUBSEQUENT VICTORIES: Go directly to Pedestal if figurines earned
if(earnedFigurines.length > 0 || S.hasAncientStatuette) {
showStatueRoom();
return;
}

// No figurines earned: show simple victory screen
showSimpleVictoryScreen();
}

function showFirstVictoryCutscene() {
const slides = [
{text: "After 20 grueling floors, your heroes finally found him - Tapo the Tadpole, happily playing with a collection of strange glowing figurines!"},
{text: "The little tadpole squeaked excitedly as the heroes approached. Around him lay scattered statues - each one depicting a heroic frog warrior."},
{text: "The heroes carefully gathered the mysterious figurines. As they held them, the statues pulsed with magical energy..."},
{text: "They found an ancient pedestal nearby, covered in glowing runes. Instinctively, they placed the figurines upon it - and felt power surge through them!"},
{text: "With Tapo safely in the Warrior's arms and their new treasures secured, the heroes stepped back through the portal..."},
{text: "The portal deposited them back in Ribbleton's square. The townspeople erupted in cheers as the heroes emerged victorious!"},
{text: "Exhausted but triumphant, the heroes decided to rest and celebrate their victory. They set Tapo down for just a moment..."},
{text: "But when they turned around... Tapo was gone! The portal behind them shimmered ominously. That mischievous little tadpole must have hopped back through!"}
];

slides.onComplete = () => {
if(window.earnedFigurines && window.earnedFigurines.length > 0) {
showStatueRoom();
} else {
showSimpleVictoryScreen();
}
};

showNarrativeSlide(slides, 0);
}

function showFUVictoryCredits() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="max-width:600px;margin:2rem auto;padding:2rem;background:linear-gradient(135deg,#1e1b4b 0%,#7c2d12 100%);border-radius:12px;border:3px solid #3b82f6;color:#fff">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem">üî• FROGGED UP MODE CONQUERED! üî•</h1>

<div style="text-align:center;margin-bottom:2rem;font-size:1.2rem;line-height:1.8">
<p>You defeated the hardest challenge in FROGGLE.</p>
<p>I genuinely did not think anyone would beat this.</p>
<p style="margin-top:2rem;font-style:italic">Thank you for playing.</p>
<p style="font-size:2rem;margin:2rem 0">‚ù§Ô∏è</p>
</div>

<div style="background:rgba(0,0,0,0.3);padding:1.5rem;border-radius:8px;margin:2rem 0">
<h3 style="text-align:center;margin-bottom:1rem;color:#3b82f6">FROGGLE</h3>
<div style="text-align:center;font-size:0.9rem;line-height:2;opacity:0.9">
<p>A game by Preston Wesner</p>
<p>Design, Art, & Code: Preston</p>
<p>Playtesting: [Your Name Here]</p>
<p>Inspiration: Slay the Spire, Balatro, and too much coffee</p>
<p style="margin-top:1.5rem;font-style:italic">Made with love in 2024</p>
</div>
</div>

<div style="background:rgba(251,191,36,0.2);padding:1.5rem;border-radius:8px;margin:2rem 0;border:2px solid #3b82f6">
<h3 style="text-align:center;margin-bottom:1rem">üéâ TAPO UNLOCKED! üéâ</h3>
<img src="assets/tapo.png" style="max-width:200px;height:auto;display:block;margin:1rem auto;border-radius:8px">
<p style="text-align:center;margin-top:1rem">Tapo the Tadpole is now available as a playable hero!</p>
<p style="text-align:center;font-size:0.9rem;opacity:0.8;margin-top:0.5rem">Stats: 1 POW, 1 HP ‚Ä¢ Has access to ALL sigils in the Sigilarium</p>
<p style="text-align:center;font-size:0.85rem;opacity:0.6;margin-top:0.5rem;font-style:italic">(Glass cannon mode activated)</p>
</div>

<div style="text-align:center">
<button class="btn safe" onclick="showStatueRoom()" style="padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem">Place Figurines</button>
<button class="btn" onclick="title()" style="padding:1rem 2rem;font-size:1.1rem">Play Again</button>
</div>
</div>`;
}

function showTapoVictoryMessage() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="max-width:700px;margin:2rem auto;padding:3rem;background:linear-gradient(135deg,#22c55e 0%,#10b981 50%,#059669 100%);border-radius:16px;border:4px solid #3b82f6;color:#fff;box-shadow:0 8px 32px rgba(0,0,0,0.3)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:3rem;text-shadow:2px 2px 4px rgba(0,0,0,0.3)">üèÜ VICTORY! üèÜ</h1>

<div style="text-align:center;margin:2rem 0">
<img src="assets/tapo-nobg.png" style="max-width:250px;height:auto;display:block;margin:0 auto 2rem auto;animation:bounce 2s ease-in-out infinite">
</div>

<div style="background:rgba(0,0,0,0.2);padding:2rem;border-radius:12px;margin:2rem 0;border:2px solid rgba(251,191,36,0.5)">
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
Holy frog. I can't believe you put this much time into my silly little game.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
From the bottom of my heart, thank you for playing.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;font-weight:500">
I hope you had fun!
</p>
<p style="text-align:center;font-size:1.1rem;margin-top:2rem;font-style:italic;opacity:0.9">
-Preston
</p>
</div>

<div style="text-align:center;font-size:2.5rem;margin:2rem 0">
‚ù§Ô∏èüê∏‚ù§Ô∏è
</div>

<div style="text-align:center;margin-top:2rem">
${window.earnedFigurines && window.earnedFigurines.length > 0 ?
  '<button class="btn" onclick="showStatueRoom()" style="background:#3b82f6;color:#000;padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem;font-weight:bold">Place Figurines</button><br>' :
  ''}
<button class="btn" onclick="title()" style="background:#fff;color:#22c55e;padding:1rem 2rem;font-size:1.1rem;font-weight:bold">Play Again</button>
</div>
</div>`;
}

function showStatueRoom() {
// This redirects to the existing Pedestal UI
showTutorialPop('pedestal_first_placement', "Welcome to the Pedestal! Figurines are rewards for heroes who survive to victory. Place them here to permanently boost that hero's stats. Each hero can earn up to 2 figurines per difficulty mode.", () => {
showPedestal();
});
}

function showSimpleVictoryScreen() {
const v = document.getElementById('gameView');
let html = `
<h1 style="text-align:center;margin:2rem 0;font-size:2.5rem">üèÜ VICTORY! üèÜ</h1>`;

if(S.gameMode === 'fu') {
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1.2rem">You conquered the Frogged Up realm once again!<br>Impressive.</p>`;
} else {
html += `<img src="assets/tapo.png" style="max-width:100%;height:auto;max-width:400px;margin:1rem auto;display:block;border-radius:8px;border:3px solid #000">`;
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1.2rem;font-weight:bold">You saved Tapo the Tadpole!</p>`;
}

if(window.earnedFigurines && window.earnedFigurines.length > 0) {
html += `<div style="background:rgba(251,191,36,0.1);padding:1rem;border-radius:8px;margin:1rem auto;max-width:500px">
<h3 style="text-align:center;margin-bottom:0.5rem">üèÜ Hero Figurines Earned! üèÜ</h3>
<p style="text-align:center">The following heroes can place figurines:</p>
<ul style="list-style:none;padding:0;text-align:center">`;
window.earnedFigurines.forEach(name => {
html += `<li style="margin:0.5rem 0;font-weight:bold">${name}</li>`;
});
html += `</ul></div>`;
}

html += `<div style="text-align:center;margin-top:2rem">
<button class="btn" onclick="showRibbleton()" style="padding:1rem 2rem;font-size:1.1rem">Return to Ribbleton</button>
</div>`;

v.innerHTML = html;
}

// ===== RIBBLETON HUB =====
function showRibbleton() {
// Hide game header in Ribbleton
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'none';

const v = document.getElementById('gameView');
const bluePortalUnlocked = S.hasReachedFloor20;

// Show tutorial for first-time visitors to Ribbleton hub
const isFirstVisit = !S.tutorialFlags.ribbleton_hub_intro;
if(isFirstVisit && !S.helpTipsDisabled) {
  setTimeout(() => {
    showTutorialPop('ribbleton_hub_intro', "Welcome home to Ribbleton! This is your safe haven between adventures. Click the glowing red portal whenever you're ready to begin your next rescue mission!", () => {
      // Tutorial dismissed, player can now explore
    });
  }, 500);
}

let html = `
<div style="position:relative;max-width:1000px;margin:0 auto;padding:1rem">
<h1 style="text-align:center;margin-bottom:1rem;font-size:2rem;color:#22c55e;text-shadow:2px 2px 4px rgba(0,0,0,0.3)">
üê∏ Welcome Home to Ribbleton! üê∏
</h1>

<div style="position:relative;width:100%;margin:0 auto">
<img src="assets/ribbleton.png" style="width:100%;display:block;border-radius:8px;border:3px solid #000">

<!-- Red Portal (Always Available) - Left side of town square -->
<div onclick="enterRedPortal()" style="position:absolute;left:15%;top:40%;width:15%;height:25%;cursor:pointer;border-radius:50%"
     title="Enter the Red Portal - Begin a new adventure!">
  <div style="width:100%;height:100%;background:radial-gradient(circle, rgba(220, 38, 38, 0.7) 0%, rgba(220, 38, 38, 0.3) 50%, transparent 100%);border:3px solid #dc2626;border-radius:50%;display:flex;align-items:center;justify-content:center;animation:portalPulse 2s ease-in-out infinite">
    <div style="font-size:3rem;animation:portalGlow 2s ease-in-out infinite">üî¥</div>
  </div>
</div>

${bluePortalUnlocked ? `
<!-- Blue Portal (Unlocked after Floor 20) - Right side of town square -->
<div onclick="enterBluePortal()" style="position:absolute;right:15%;top:40%;width:15%;height:25%;cursor:pointer;border-radius:50%;transition:transform 0.2s"
     onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"
     title="Enter the Blue Portal - Return to Floor 20!">
  <div style="width:100%;height:100%;background:radial-gradient(circle, rgba(59, 130, 246, 0.7) 0%, rgba(59, 130, 246, 0.3) 50%, transparent 100%);border:3px solid #3b82f6;border-radius:50%;display:flex;align-items:center;justify-content:center;box-shadow:0 0 20px rgba(59, 130, 246, 0.8)">
    <div style="font-size:3rem;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.8))">üîµ</div>
  </div>
</div>
` : ''}
</div>

<div style="text-align:center;margin-top:1.5rem;padding:1rem;background:rgba(255,255,255,0.9);border:3px solid #22c55e;border-radius:8px;max-width:600px;margin-left:auto;margin-right:auto">
  <p style="font-size:1.1rem;margin-bottom:0.5rem"><strong>üî¥ Red Portal:</strong> Venture forth on a rescue mission!</p>
  ${bluePortalUnlocked ?
    `<p style="font-size:1.1rem;margin:0"><strong>üîµ Blue Portal:</strong> Visit the Champions Hall (Floor 20)</p>` :
    `<p style="font-size:0.9rem;margin:0;opacity:0.6"><em>A mysterious blue portal appears to be locked... Perhaps reaching Floor 20 will unlock it?</em></p>`
  }
</div>
</div>`;

v.innerHTML = html;
}

function enterRedPortal() {
toast('Entering the Red Portal...', 1200);
setTimeout(() => transitionScreen(title), ANIMATION_TIMINGS.ACTION_COMPLETE);
}

function enterBluePortal() {
if(!S.hasReachedFloor20) {
toast('The Blue Portal is locked!');
return;
}
toast('Entering the Blue Portal...', 1200);
setTimeout(() => transitionScreen(showChampionsMenu), ANIMATION_TIMINGS.ACTION_COMPLETE);
}

// ===== DEBUG MODE =====
function toggleDebugMode(enabled) {
S.debugMode = enabled;
toast(enabled ? 'Debug Mode ON' : 'Debug Mode OFF', 1200);
// Update debug button visibility in header
const debugBtn = document.getElementById('debugBtn');
if(debugBtn) debugBtn.style.display = enabled ? 'block' : 'none';
// Refresh settings menu if open to show/hide debug tools button
const settingsMenu = document.querySelector('[style*="z-index:30000"]');
if(settingsMenu) {
closeSettingsMenu();
showSettingsMenu();
}
}

function toggleOopsAll20s(enabled) {
S.oopsAll20s = enabled;
toast(enabled ? 'üé≤ Oops All 20s: ON (All D20 rolls = 20!)' : 'üé≤ Oops All 20s: OFF', 1500);
// Refresh debug menu to update checkbox
const debugMenu = document.querySelector('[style*="z-index:30000"]');
if(debugMenu && debugMenu.textContent.includes('DEBUG MENU')) {
closeDebugMenu();
showDebugMenu();
}
}

function showDebugMenu() {
const inCombat = S.enemies && S.enemies.length > 0;
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha'];
const heroNames = S.heroes.map((h, i) => ({name: h.n, idx: i}));

let html = `
<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);border:3px solid #3b82f6;border-radius:12px;padding:2rem;z-index:30000;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
<h2 style="text-align:center;color:#3b82f6;margin-bottom:1.5rem">üõ†Ô∏è DEBUG MENU üõ†Ô∏è</h2>

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Resources</h3>
<button class="btn" onclick="debugAddGold()" style="margin-bottom:0.5rem;background:#22c55e">+100 Gold</button>
<button class="btn" onclick="debugAddXP()" style="margin-bottom:0.5rem;background:#22c55e">+100 XP</button>

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Navigation</h3>
<div style="margin:0.5rem 0">
<label style="color:white;font-size:0.9rem">Jump to Floor:</label>
<input type="number" id="debugFloorInput" min="1" max="19" value="${S.floor}" style="width:60px;padding:0.25rem;margin:0 0.5rem;font-size:1rem">
<button class="btn" onclick="debugJumpFloor()" style="display:inline-block;width:auto;padding:0.5rem 1rem;margin:0;font-size:0.9rem;min-height:auto">Go</button>
</div>

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Sigil Levels</h3>
<div style="margin:0.5rem 0">
<select id="debugSigilSelect" style="padding:0.25rem;margin-right:0.5rem;font-size:0.9rem">
${allSigils.map(sig => `<option value="${sig}">${sig} (L${S.sig[sig] || 0})</option>`).join('')}
</select>
<input type="number" id="debugSigilLevel" min="0" max="5" value="1" style="width:50px;padding:0.25rem;margin:0 0.5rem;font-size:1rem">
<button class="btn" onclick="debugSetSigilLevel()" style="display:inline-block;width:auto;padding:0.5rem 1rem;margin:0;font-size:0.9rem;min-height:auto">Set</button>
</div>

${heroNames.length > 0 ? `
<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Hero Stats</h3>
<div style="margin:0.5rem 0">
<select id="debugHeroSelect" style="padding:0.25rem;margin-bottom:0.5rem;font-size:0.9rem;width:100%">
${heroNames.map(h => `<option value="${h.idx}">${h.name} (POW:${S.heroes[h.idx].p}, HP:${S.heroes[h.idx].h}/${S.heroes[h.idx].m})</option>`).join('')}
</select>
<div style="display:flex;gap:0.5rem;margin-bottom:0.5rem">
<div style="flex:1">
<label style="color:white;font-size:0.85rem;display:block">POW:</label>
<input type="number" id="debugHeroPOW" min="1" max="20" value="1" style="width:100%;padding:0.25rem;font-size:1rem">
</div>
<div style="flex:1">
<label style="color:white;font-size:0.85rem;display:block">Max HP:</label>
<input type="number" id="debugHeroMaxHP" min="1" max="50" value="5" style="width:100%;padding:0.25rem;font-size:1rem">
</div>
</div>
<button class="btn" onclick="debugSetHeroStats()" style="background:#3b82f6;margin-bottom:0.5rem">Update Hero Stats</button>
</div>
` : ''}

${inCombat ? `
<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Combat</h3>
<button class="btn danger" onclick="debugDealDamage()">Deal 50 DMG to Enemy</button>
` : ''}

<h3 style="color:#3b82f6;margin:1rem 0 0.5rem 0">Cheats</h3>
<label style="display:flex;align-items:center;cursor:pointer;user-select:none;color:white;background:rgba(251,191,36,0.2);padding:0.75rem;border-radius:6px;margin-bottom:0.5rem">
<input type="checkbox" ${S.oopsAll20s ? 'checked' : ''} onchange="toggleOopsAll20s(this.checked)" style="margin-right:0.5rem;transform:scale(1.2)">
<span>üé≤ Oops All 20s (Auto-succeed D20 rolls)</span>
</label>

<button class="btn" onclick="closeDebugMenu()" style="margin-top:1rem;background:#888">Close</button>
</div>
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:29999" onclick="closeDebugMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeDebugMenu() {
// Remove debug menu elements
const menus = document.querySelectorAll('[style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

// ===== SETTINGS MENU =====
function showSettingsMenu() {
const v = document.getElementById('gameView');
const inGame = S.heroes && S.heroes.length > 0;

let html = `
<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);border:3px solid #3b82f6;border-radius:12px;padding:2rem;z-index:30000;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
<h2 style="text-align:center;color:#3b82f6;margin-bottom:1.5rem">‚öôÔ∏è SETTINGS ‚öôÔ∏è</h2>

${inGame ? `
<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Game</h3>
<button class="btn" onclick="manualSave()" style="margin-bottom:0.5rem;background:#22c55e">üíæ Save Game</button>
<button class="btn" onclick="restartLevel()" style="margin-bottom:0.5rem;background:#dc2626">üîÑ Restart Level</button>
<button class="btn" onclick="resetTutorialFlags()" style="margin-bottom:0.5rem;background:#f97316">üîÑ Reset Tutorial</button>
` : ''}

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Help</h3>
<button class="btn" onclick="closeSettingsMenu();showFAQ()" style="margin-bottom:0.5rem;background:#9333ea">‚ùì Frequently Asked Questions</button>

<h3 style="color:#22c55e;margin:1rem 0 0.5rem 0">Display</h3>
<label style="display:flex;align-items:center;cursor:pointer;user-select:none;color:white;background:rgba(255,255,255,0.1);padding:0.75rem;border-radius:6px;margin-bottom:0.5rem">
<input type="checkbox" ${S.toastLogVisible ? 'checked' : ''} onchange="toggleToastLogVisibility(this.checked)" style="margin-right:0.5rem;transform:scale(1.2)">
<span>Show Toast Log</span>
</label>
<label style="display:flex;align-items:center;cursor:pointer;user-select:none;color:white;background:rgba(255,255,255,0.1);padding:0.75rem;border-radius:6px;margin-bottom:0.5rem">
<input type="checkbox" ${!S.helpTipsDisabled ? 'checked' : ''} onchange="toggleHelpTips(this.checked)" style="margin-right:0.5rem;transform:scale(1.2)">
<span>üí° Show Help/Tips</span>
</label>
<label style="display:flex;align-items:center;cursor:pointer;user-select:none;color:white;background:rgba(255,255,255,0.1);padding:0.75rem;border-radius:6px;margin-bottom:0.5rem">
<input type="checkbox" ${!S.tooltipsDisabled ? 'checked' : ''} onchange="toggleTooltips(this.checked)" style="margin-right:0.5rem;transform:scale(1.2)">
<span>üîç Show Sigil Tooltips</span>
</label>

<h3 style="color:#3b82f6;margin:1rem 0 0.5rem 0">Debug</h3>
<label style="display:flex;align-items:center;cursor:pointer;user-select:none;color:white;background:rgba(255,255,255,0.1);padding:0.75rem;border-radius:6px;margin-bottom:0.5rem">
<input type="checkbox" ${S.debugMode ? 'checked' : ''} onchange="toggleDebugMode(this.checked)" style="margin-right:0.5rem;transform:scale(1.2)">
<span>üõ†Ô∏è Enable Debug Mode</span>
</label>
${S.debugMode ? `<button class="btn" onclick="closeSettingsMenu();showDebugMenu()" style="margin-bottom:0.5rem;background:#3b82f6">üõ†Ô∏è Open Debug Tools</button>` : ''}

<button class="btn" onclick="closeSettingsMenu()" style="margin-top:1rem;background:#888">Close</button>
</div>
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:29999" onclick="closeSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeSettingsMenu() {
const menus = document.querySelectorAll('[style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

function manualSave() {
saveGame();
toast('Game Saved!', 1200);
closeSettingsMenu();
}

function restartLevel() {
if(confirm('Restart this floor? All progress on this floor will be lost.')) {
closeSettingsMenu();
toast('Restarting floor...', 1200);
setTimeout(() => {
if(S.floor % 2 === 1) {
// Odd floor = combat
combat(S.floor);
} else {
// Even floor = neutral
startFloor(S.floor);
}
}, 500);
}
}

function resetTutorialFlags() {
if(confirm('Reset tutorial? This will show all tutorial pop-ups again.')) {
S.tutorialFlags = {
ribbleton_intro: false,
ribbleton_warrior_attack: false,
ribbleton_targeting: false,
ribbleton_healer_d20: false,
ribbleton_d20_menu: false,
healer_expand_explain: false,
ribbleton_enemy_turn: false,
ribbleton_healer_heal: false,
ribbleton_expand: false,
ribbleton_finish_wolf: false,
enemies_get_sigils: false,
ribbleton_shield_sigil: false,
ribbleton_handoff: false,
ribbleton_tooltip_intro: false,
ribbleton_hub_intro: false,
levelup_intro: false,
levelup_stat_upgrade: false,
levelup_add_active: false,
levelup_upgrade_active: false,
levelup_upgrade_passive: false,
death_intro: false,
death_exit_warning: false,
neutral_intro: false,
neutral_d20_level: false,
faq_intro: false,
last_stand_intro: false,
recruit_intro: false,
run2_hero_lock: false,
first_victory_sequence: false,
first_fu_victory: false,
pedestal_first_placement: false,
tapo_victory_message: false
};
savePermanent();
toast('Tutorial reset! Will show again next run.', 2000);
closeSettingsMenu();
}
}

function toggleHelpTips(enabled) {
S.helpTipsDisabled = !enabled;
// If turning ON, reset all tutorial flags so they show again
if(enabled) {
S.tutorialFlags = {};
toast('Help/Tips enabled! All tips reset and will show again.', 2000);
// Re-trigger current screen to show relevant popups immediately
if(typeof render === 'function') {
try { render(); } catch(e) { /* render() not applicable in current state */ }
}
// If in Ribbleton hub, re-show to trigger ribbleton_hub_intro popup
if(document.querySelector('h1')?.textContent?.includes('Welcome Home to Ribbleton')) {
setTimeout(() => showRibbleton(), 100);
}
} else {
toast('Help/Tips disabled. No more popups!', 1200);
}
savePermanent();
}

function toggleTooltips(enabled) {
S.tooltipsDisabled = !enabled;
if(enabled) {
toast('Sigil tooltips enabled!', 1200);
} else {
toast('Sigil tooltips disabled!', 1200);
}
savePermanent();
}

function showFAQ() {
const v = document.getElementById('gameView');

const faqItems = [
{
q: "What are sigils?",
a: `Sigils are your heroes' special abilities! Each hero has sigils they can use in combat to attack enemies, defend the team, or perform special actions.<br><br>
<strong>Basic Sigils:</strong><br>
‚Ä¢ <strong>Attack</strong> - Deal damage to enemies<br>
‚Ä¢ <strong>Shield</strong> - Protect heroes from damage<br>
‚Ä¢ <strong>Heal</strong> - Restore HP to heroes<br>
‚Ä¢ <strong>D20</strong> - Roll the dice for risky gambit actions<br><br>
You can see your sigils at the bottom of your hero card during combat. Hover over (or long-press on mobile) any sigil icon to see what it does!`
},
{
q: "How do I level up sigils?",
a: `There are two ways to upgrade sigils:<br><br>
<strong>1. Level-Up Menu (Odd Floors - 1, 3, 5...)</strong><br>
‚Ä¢ Spend XP earned from battles<br>
‚Ä¢ Choose to upgrade a sigil, boost stats, or add new sigils<br>
‚Ä¢ These upgrades reset when you die<br><br>
<strong>2. Shop (Even Floors - 2, 4, 6...)</strong><br>
‚Ä¢ Spend Gold<br>
‚Ä¢ Permanently upgrade sigils that persist across all runs<br>
‚Ä¢ This is your long-term progression!<br><br>
Your total sigil level = Permanent (Gold) + Temporary (XP) upgrades.`
},
{
q: "Why does Attack show as L1 when I haven't upgraded it?",
a: `Active sigils (Attack, Shield, Heal, Grapple, Ghost, D20, Alpha) always display with a minimum level of 1 when equipped, even if their permanent storage level is 0. This is because they work at "Level 1" effectiveness when you first get them.<br><br>
<strong>Example:</strong> Attack storage level 0 = displays as L1 (1 attack per action)<br>
Attack storage level 1 = displays as L2 (2 attacks per action)<br><br>
The upgrade cost is based on <em>storage level</em>, not display level. So upgrading from display L1 to L2 costs the price for storage level 0‚Üí1.`
},
{
q: "What happens if I run out of enemies before using all my Expand targets?",
a: `If you have Expand and select targets for multi-instance actions (Attack, Shield, Heal), you might run out of valid targets mid-instance. When this happens, you'll see a "wasted targets" message.<br><br>
<strong>Example:</strong> You have Attack L2 with Expand L1 (3 total targets). There are only 2 enemies left. You can attack both enemies, but the 3rd target slot is wasted - you still get both attacks, but you can't use the extra Expand slot.<br><br>
This is intentional! Plan your actions carefully.`
},
{
q: "How does Last Stand work and how long does it last?",
a: `When a hero reaches 0 HP (and has no Ghost charges), they enter <strong>Last Stand</strong> instead of dying immediately. In Last Stand:<br><br>
‚Ä¢ They can ONLY use D20 gambits (no other actions)<br>
‚Ä¢ Each turn in Last Stand increases D20 difficulty by +1 DC (caps at +4)<br>
‚Ä¢ If healed, they revive with the healed HP amount<br>
‚Ä¢ After ~5 turns, DC penalties make success nearly impossible<br><br>
<strong>Last Stand Turn counter:</strong><br>
Turn 1: DC +0 (CONFUSE is DC 16)<br>
Turn 2: DC +1 (CONFUSE is DC 17)<br>
Turn 5: DC +4 (CONFUSE is DC 20 - nat 20 required!)<br><br>
You have a few turns to heal your Last Stand heroes before they become useless!`
},
{
q: "How many recruits can I have? What happens to them?",
a: `Recruits are enemies you've converted to your side via D20 RECRUIT (DC 20):<br><br>
‚Ä¢ Each hero can have <strong>1 recruit</strong> (recruiting another replaces the first)<br>
‚Ä¢ Maximum <strong>10 total recruits</strong> across all heroes<br>
‚Ä¢ Recruits persist between battles until killed<br>
‚Ä¢ Recruits fight in their hero's lane and attack enemies<br>
‚Ä¢ Recruits can gain sigils and act during enemy turns<br><br>
<strong>How they work:</strong> Recruits stand behind their hero and attack enemies during the "Recruit Phase" of the enemy turn. They're powerful allies but can die permanently!`
},
{
q: "Do shields carry over between battles?",
a: `<strong>Yes!</strong> Shields persist between battles and cap at max HP.<br><br>
This means you can "shield farm" by using Shield sigils on the last enemy of a floor to enter the next floor with full shields. Combined with Asterisk or Alpha, this can make you nearly invincible!<br><br>
<strong>Strategy tip:</strong> Before finishing a floor, use any remaining actions to shield up your team. The shields will carry over!`
},
{
q: "What's the difference between XP upgrades and Gold upgrades?",
a: `There are TWO types of sigil upgrades:<br><br>
<strong>1. Permanent (Gold) Upgrades</strong><br>
‚Ä¢ Purchased in the Shop (even floors)<br>
‚Ä¢ Persist through death and across all runs<br>
‚Ä¢ Stored in S.sig[sigilName]<br>
‚Ä¢ These are your permanent progression!<br><br>
<strong>2. Temporary (XP) Upgrades</strong><br>
‚Ä¢ Purchased during Level Ups (odd floors)<br>
‚Ä¢ Reset when you die or start a new run<br>
‚Ä¢ Stored in S.tempSigUpgrades[sigilName]<br>
‚Ä¢ These boost you during a single run only<br><br>
<strong>Display level = Permanent level + Temporary level</strong>`
},
{
q: "Why is Mage/Healer better than Warrior/Tank?",
a: `Mage and Healer get +1 Expand for free, which means their actions hit 1 extra target from the start. This is incredibly powerful early game!<br><br>
<strong>Example Floor 1 (2 Goblins):</strong><br>
‚Ä¢ Warrior Attack L1: Hits 1 enemy (takes 2 turns to clear)<br>
‚Ä¢ Mage Attack L1 + free Expand: Hits 2 enemies (takes 1 turn to clear!)<br><br>
This built-in advantage makes Mage/Healer objectively stronger early game. However, Warrior/Tank can scale well with the right upgrades!`
},
{
q: "What are Star and Asterisk sigils?",
a: `<strong>Star:</strong> Passive XP multiplier. Each hero with Star adds +0.5√ó XP bonus per Star level.<br>
‚Ä¢ 2 heroes with Star L1 = +1.0√ó bonus = 2√ó total XP<br>
‚Ä¢ Star is extremely powerful for long-term scaling!<br><br>
<strong>Asterisk:</strong> PASSIVE - Next action triggers +X times! Resets after each battle.<br>
‚Ä¢ Asterisk L1: First action triggers √ó2<br>
‚Ä¢ Asterisk L4: First action triggers √ó5<br>
‚Ä¢ Works with ANY action: Attack, Shield, Heal, D20 gambits, etc.<br>
‚Ä¢ No activation needed - happens automatically on your first action<br>
‚Ä¢ Can be combined with Alpha for devastating combos!`
},
{
q: "How does enemy difficulty scale?",
a: `Enemies scale based on floor number and game mode:<br><br>
<strong>Standard Mode:</strong><br>
‚Ä¢ Floor 1-5: Goblins (1 POW), Wolves (2 POW), Orcs (3 POW)<br>
‚Ä¢ Floor 9: First Dragon (5 POW, 25 HP, draws 2 sigils/turn)<br>
‚Ä¢ Floor 15: Three Dragons (brutal difficulty spike!)<br>
‚Ä¢ Floor 11: Goblin Ambush (stunned Turn 1)<br><br>
<strong>Frogged Up Mode:</strong><br>
‚Ä¢ All enemy stats √ó3!<br>
‚Ä¢ Floor 1 Goblins have 5 POW and 25 HP<br>
‚Ä¢ Designed for masochists only üê∏`
},
{
q: "What's the best strategy for surviving Dragon floors?",
a: `Dragons (Floors 9, 15, 19) are massive difficulty spikes. Here's how to survive:<br><br>
<strong>1. Stack Grapple:</strong> Dragons have high HP but Grapple stuns them for multiple turns<br>
<strong>2. Shield Early:</strong> Dragons deal 5 base damage (more with Attack sigils) - shields save lives<br>
<strong>3. Recruit Help:</strong> Recruited enemies can tank hits and deal damage<br>
<strong>4. Asterisk + Attack:</strong> Burst damage before they gain too many sigils<br>
<strong>5. Use Mend:</strong> D20 Mend can heal your heroes mid-combat to survive longer<br><br>
Dragons gain 2 sigils per turn and have permanent Attack L2 + Expand L5. Don't let combat drag on!`
}
];

let html = `
<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(#fff,#f7f1e3);border:3px solid #9333ea;border-radius:16px;padding:2rem;z-index:30000;max-width:700px;width:90%;max-height:85vh;overflow-y:auto">
<h2 style="text-align:center;color:#9333ea;margin-bottom:0.5rem">‚ùì Frequently Asked Questions ‚ùì</h2>
<p style="text-align:center;font-size:1rem;color:#6b4423;margin-bottom:1rem;line-height:1.5">Welcome to FROGGLE! üê∏ You'll lead heroes through floors of enemies, using sigils (special abilities) to attack, defend, and survive. Level up after each floor to get stronger. Your goal: reach the deepest floor you can!</p>
<p style="text-align:center;font-size:0.85rem;opacity:0.7;margin-bottom:1.5rem">Tap a question to expand/collapse the answer</p>
<div style="display:flex;flex-direction:column;gap:0.75rem;margin-bottom:1.5rem">
`;

faqItems.forEach((item, index) => {
html += `
<div style="background:white;border:3px solid #000;border-radius:12px;overflow:hidden;box-shadow:0 2px 6px rgba(0,0,0,0.15)">
<div onclick="toggleFAQItem(${index})" style="padding:1rem;cursor:pointer;user-select:none;display:flex;justify-content:space-between;align-items:center;background:linear-gradient(135deg, #f0f9ff, #e0f2fe);transition:background 0.2s">
<strong style="font-size:0.95rem;color:#1e40af">${item.q}</strong>
<span id="faq-arrow-${index}" style="font-size:1.2rem;transition:transform 0.3s;color:#1e40af">‚ñº</span>
</div>
<div id="faq-answer-${index}" style="display:none;padding:1rem;font-size:0.9rem;line-height:1.6;border-top:2px solid #ddd;background:rgba(0,0,0,0.02)">
${item.a}
</div>
</div>
`;
});

html += `
</div>
<button class="btn secondary" onclick="closeFAQ()" style="margin-top:0.5rem">Close</button>
</div>
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:29999" onclick="closeFAQ()"></div>
`;

v.insertAdjacentHTML('beforeend', html);
}

function toggleFAQItem(index) {
const answer = document.getElementById(`faq-answer-${index}`);
const arrow = document.getElementById(`faq-arrow-${index}`);

if (answer.style.display === 'none') {
answer.style.display = 'block';
arrow.style.transform = 'rotate(180deg)';
arrow.textContent = '‚ñ≤';
} else {
answer.style.display = 'none';
arrow.style.transform = 'rotate(0deg)';
arrow.textContent = '‚ñº';
}
}

function closeFAQ() {
const overlays = document.querySelectorAll('[style*="z-index:30000"], [style*="z-index:29999"]');
overlays.forEach(el => el.remove());
}

function showSigilarium() {
closeSettingsMenu();
const v = document.getElementById('gameView');
const activeSigils = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const passiveSigils = ['Expand', 'Asterisk', 'Star'];

const getLevelColor = (level) => {
if(level === 0) return '#666';
if(level === 1) return '#000';
if(level === 2) return '#0d9488';
if(level === 3) return '#9333ea';
if(level === 4) return '#d97706';
return '#ff0080'; // L5 gradient
};

let html = `
<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(#fff,#f7f1e3);border:3px solid #9333ea;border-radius:12px;padding:2rem;z-index:30000;max-width:600px;width:90%;max-height:80vh;overflow-y:auto">
<h2 style="text-align:center;color:#9333ea;margin-bottom:1rem">üìñ SIGILARIUM üìñ</h2>
<p style="text-align:center;font-size:0.9rem;opacity:0.8;margin-bottom:1.5rem">All Sigils and Their Permanent Upgrade Levels</p>

<!-- Active Sigils -->
<h3 style="color:#2c63c7;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #2c63c7;padding-bottom:0.25rem">‚öîÔ∏è Active Sigils</h3>
<div style="display:grid;gap:0.75rem;margin-bottom:1.5rem">
`;

activeSigils.forEach(sig => {
const level = S.sig[sig] || 0;
const cl = level===0?'l0':level===1?'l1':level===2?'l2':level===3?'l3':level===4?'l4':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(level);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl}" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Permanent Level: <span style="color:${levelColor};font-weight:bold">L${level}</span></div>
${level === 0 ? '<div style="font-size:0.75rem;color:#22c55e;font-style:italic">Starts at L1 when equipped</div>' : ''}
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>

<!-- Passive Sigils -->
<h3 style="color:#9333ea;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #9333ea;padding-bottom:0.25rem">‚ú® Passive Sigils</h3>
<div style="display:grid;gap:0.75rem">
`;

passiveSigils.forEach(sig => {
const level = S.sig[sig] || 0;
const cl = level===0?'l0':level===1?'l1':level===2?'l2':level===3?'l3':level===4?'l4':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(level);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl}" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Permanent Level: <span style="color:${levelColor};font-weight:bold">L${level}</span></div>
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>
<button class="btn" onclick="closeSigilarium()" style="margin-top:1.5rem;background:#9333ea;width:100%">Close</button>
</div>
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:29999" onclick="closeSigilarium()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeSigilarium() {
const menus = document.querySelectorAll('[style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

function debugAddGold() {
S.gold += 100;
upd();
toast('Added 100 Gold!', 1200);
closeDebugMenu();
}

function debugAddXP() {
S.xp += 100;
upd();
toast('Added 100 XP!', 1200);
closeDebugMenu();
}

function debugJumpFloor() {
const input = document.getElementById('debugFloorInput');
const targetFloor = parseInt(input.value);
if(targetFloor < 1 || targetFloor > 19 || isNaN(targetFloor)) {
toast('Invalid floor! Must be 1-19', 1200);
return;
}
closeDebugMenu();
S.floor = targetFloor;
upd();
startFloor(targetFloor);
toast(`Jumped to Floor ${targetFloor}!`, 1200);
}

function debugDealDamage() {
if(!S.enemies || S.enemies.length === 0) {
toast('No enemies in combat!', 1200);
return;
}
// Deal 50 damage to first enemy
const enemy = S.enemies[0];
enemy.h -= 50;
if(enemy.h < 0) enemy.h = 0;
upd();
toast(`Dealt 50 damage to ${enemy.n}!`, 1200);
closeDebugMenu();
// Check if combat is over
setTimeout(() => checkCombatEnd(), 100);
}

function debugSetSigilLevel() {
const sigilSelect = document.getElementById('debugSigilSelect');
const levelInput = document.getElementById('debugSigilLevel');
const sigil = sigilSelect.value;
const newLevel = parseInt(levelInput.value);

if(isNaN(newLevel) || newLevel < 0 || newLevel > 5) {
toast('Invalid level! Must be 0-5', 1200);
return;
}

S.sig[sigil] = newLevel;
savePermanent();
upd();
toast(`Set ${sigil} to Level ${newLevel}!`, 1200);
closeDebugMenu();
}

function debugSetHeroStats() {
const heroSelect = document.getElementById('debugHeroSelect');
const powInput = document.getElementById('debugHeroPOW');
const maxHPInput = document.getElementById('debugHeroMaxHP');
const heroIdx = parseInt(heroSelect.value);
const newPOW = parseInt(powInput.value);
const newMaxHP = parseInt(maxHPInput.value);

if(isNaN(newPOW) || newPOW < 1 || newPOW > 20) {
toast('Invalid POW! Must be 1-20', 1200);
return;
}
if(isNaN(newMaxHP) || newMaxHP < 1 || newMaxHP > 50) {
toast('Invalid Max HP! Must be 1-50', 1200);
return;
}

const hero = S.heroes[heroIdx];
hero.p = newPOW;
hero.m = newMaxHP;
// Also set current HP to max HP for convenience
hero.h = newMaxHP;
saveGame();
upd();
toast(`Updated ${hero.n}: POW=${newPOW}, HP=${newMaxHP}!`, 1200);
closeDebugMenu();
render();
}

// ===== INIT =====
window.onload = () => {
console.log('[FROGGLE] window.onload fired');
// Check for last used slot
const lastSlot = localStorage.getItem('froggle8_current_slot');
if(lastSlot) {
const slot = parseInt(lastSlot);
console.log('[FROGGLE] Found last used slot:', slot);
// Try to load slot-specific permanent data
const permData = localStorage.getItem(`froggle8_permanent_slot${slot}`);
if(permData) {
try {
const j = JSON.parse(permData);
S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.pedestal = j.pedestal || [];
S.hasReachedFloor20 = j.hasReachedFloor20 || false;
S.fuUnlocked = j.fuUnlocked || j.effedUnlocked || false; // Support old save format
S.tapoUnlocked = j.tapoUnlocked || false;
S.runNumber = j.runNumber || 1;
S.runsAttempted = j.runsAttempted || 0;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.tooltipsDisabled = j.tooltipsDisabled || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
if(j.tutorialFlags) Object.assign(S.tutorialFlags, j.tutorialFlags);
S.currentSlot = slot;
console.log('[FROGGLE] Loaded slot-specific permanent data');
} catch(e) {
console.warn('[FROGGLE] Failed to parse slot permanent data:', e);
loadPermanent(); // Fallback to old format
}
} else {
loadPermanent(); // No slot data, use old format
}
} else {
loadPermanent(); // No last slot, use old format
}
console.log('[FROGGLE] loadPermanent complete, S.runNumber:', S.runNumber, 'S.helpTipsDisabled:', S.helpTipsDisabled);
initToastLog(); // Initialize toast log UI
mainTitlePage();
console.log('[FROGGLE] mainTitlePage called');
};

// Global error handler for image loading failures
window.addEventListener('error', (e) => {
if(e.target && e.target.tagName === 'IMG') {
console.error('[FROGGLE] IMAGE LOAD FAILED:', e.target.src);
console.error('[FROGGLE] Current location:', window.location.href);
console.error('[FROGGLE] Image path:', e.target.getAttribute('src'));
} else if(e.message) {
console.error('[FROGGLE] JAVASCRIPT ERROR:', e.message);
console.error('[FROGGLE] File:', e.filename, 'Line:', e.lineno, 'Col:', e.colno);
console.error('[FROGGLE] Stack:', e.error ? e.error.stack : 'No stack trace');
}
}, true);

// Catch unhandled promise rejections
window.addEventListener('unhandledrejection', (e) => {
console.error('[FROGGLE] UNHANDLED PROMISE REJECTION:', e.reason);
});
</script>
</body>
</html>