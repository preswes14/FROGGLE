<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="apple-mobile-web-app-title" content="FROGGLE"/>
<meta name="theme-color" content="#22c55e"/>
<link rel="manifest" href="manifest.json"/>
<link rel="apple-touch-icon" href="assets/tapo-icon-180.png"/>
<link rel="icon" type="image/png" href="assets/tapo-icon.png"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<title>FROGGLE</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body { font-family: -apple-system, sans-serif; background: #1a1a1a; color: #f0f0f0; position: fixed; width: 100%; height: 100%; overflow: hidden; touch-action: manipulation; }
/* Hide cursor on Steam Deck / touch devices in Electron */
body.electron-app { cursor: none; }
body.electron-app * { cursor: none; }
body.electron-app .btn, body.electron-app button, body.electron-app [onclick] { cursor: none; }
body.fu-mode { background: linear-gradient(135deg, #2a231c 0%, #1a1612 100%); color: #e8d5c0; }
h1, h2, h3, .modal-title, .neutral-title { font-family: 'Fredoka One', cursive; }

/* Landscape orientation enforcement for mobile */
@media (max-width: 768px) and (orientation: portrait) {
  #rotatePrompt {
    display: flex !important;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
    z-index: 999999;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    padding: 2rem;
  }
  #gameView {
    display: none !important;
  }
  .header {
    display: none !important;
  }
}

@media (min-width: 769px), (orientation: landscape) {
  #rotatePrompt {
    display: none !important;
  }
}

.rotate-icon {
  font-size: 4rem;
  margin-bottom: 1.5rem;
  animation: rotatePhone 2s ease-in-out infinite;
}

@keyframes rotatePhone {
  0%, 100% { transform: rotate(0deg); }
  25% { transform: rotate(-15deg); }
  75% { transform: rotate(15deg); }
}

@keyframes portalPulse {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 0 20px rgba(220, 38, 38, 0.8);
  }
  50% {
    transform: scale(1.08);
    box-shadow: 0 0 40px rgba(220, 38, 38, 1), 0 0 60px rgba(220, 38, 38, 0.6);
  }
}

@keyframes portalGlow {
  0%, 100% {
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8)) drop-shadow(0 0 15px rgba(220, 38, 38, 0.8));
  }
  50% {
    filter: drop-shadow(0 2px 8px rgba(0,0,0,0.9)) drop-shadow(0 0 30px rgba(220, 38, 38, 1));
  }
}

.rotate-message {
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.rotate-submessage {
  font-size: 1rem;
  opacity: 0.9;
  text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

/* Z-INDEX LAYERING REFERENCE:
 * 999999 - Error overlay, Rotate device prompt
 * 100000 - Confirm modal
 *  99999 - Confirm modal overlay, Debug overlay
 *  99998 - Confetti container
 *  50000 - Tutorial modal backdrop, Controller prompts bar
 *  30000 - Settings/Debug menus, Loading/transition screens
 *  29999 - Settings/Debug backdrops (modal-overlay)
 *  25001 - Controller focus ring
 *  25000 - Tooltips, Damage/Heal/Shield previews
 *  15000 - D20 tutorial overlay
 *  10001 - Combo counter
 *  10000 - Toast notifications, Floating numbers
 *   9999 - Toast log, Autosave indicator
 *   1000 - Action execution bar, Heal cross animation
 *    100 - Long-press indicator
 *     20 - Hero selection click regions
 *     10 - Title buttons, Hero selection cards
 * Base (0-1) - Normal game elements, Backgrounds
 */

/* Modal system - consistent styling for Settings, Debug, Sigilarium, FAQ */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  z-index: 29999;
}
/* Hide targeting effects when modal/overlay is visible to prevent bleed-through */
body:has(.modal-overlay) .card.targetable,
body:has(.confirm-modal-overlay) .card.targetable,
body:has(.tutorial-modal-backdrop) .card.targetable {
  box-shadow: none !important;
}
body:has(.modal-overlay) .controller-focus,
body:has(.confirm-modal-overlay) .controller-focus,
body:has(.tutorial-modal-backdrop) .controller-focus {
  outline: none !important;
  box-shadow: none !important;
  animation: none !important;
}
.modal-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  border-radius: 12px;
  padding: 2rem;
  z-index: 30000;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}
.modal-container.dark {
  background: rgba(17,24,39,0.98);
  border: 3px solid #22c55e;
  color: white;
}
.modal-container.light {
  background: linear-gradient(#1f2937, #111827);
  border: 3px solid #22c55e;
  color: #f0f0f0;
}
.modal-container.faq {
  background: linear-gradient(#1f2937, #111827);
  border: 3px solid #22c55e;
  color: #f0f0f0;
  max-height: 90vh;
  max-width: 600px;
}
.modal-title {
  text-align: center;
  margin-bottom: 1rem;
  font-size: 1.3rem;
}
.modal-title.blue { color: #22c55e; }
.modal-title.purple { color: #a855f7; }
.modal-title.orange { color: #fbbf24; }
.modal-section-title {
  margin: 1rem 0 0.5rem 0;
}
.modal-section-title.green { color: #22c55e; }
.modal-section-title.blue { color: #3b82f6; }
.modal-checkbox-label {
  display: flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
  background: rgba(255,255,255,0.1);
  padding: 0.75rem;
  border-radius: 6px;
  margin-bottom: 0.5rem;
}
.modal-checkbox-label input {
  margin-right: 0.5rem;
  transform: scale(1.2);
}
.settings-back-btn {
  display: block;
  margin-top: 1.5rem;
  padding: 0.6rem 1.2rem;
  background: rgba(100, 100, 100, 0.8);
  color: white;
  border: 2px solid #666;
  border-radius: 8px;
  font-size: 0.9rem;
  cursor: pointer;
  text-align: center;
  width: auto;
  margin-left: auto;
  margin-right: auto;
}
.settings-back-btn:hover {
  background: rgba(120, 120, 120, 0.9);
}

/* Sigil description scaling indicator - shows level-dependent values */
.sig-scale { color: #f97316; text-decoration: underline; font-weight: bold; }

.header { padding: 0.5rem; background: linear-gradient(#1f2937, #111827); border-bottom: 2px solid #22c55e; display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; color: #f0f0f0; }
.header button { display: inline-flex; align-items: center; justify-content: center; line-height: 1; height: 28px; min-width: 28px; box-sizing: border-box; }
.game-area { height: calc(100vh - 44px); overflow-y: auto; padding: 0.5rem; -webkit-overflow-scrolling: touch; }
.game-area.no-scroll { overflow: hidden; padding: 0; }
.game-area.fade-out { animation: fadeOut 0.2s ease forwards; }
.game-area.fade-in { animation: fadeIn 0.2s ease forwards; }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
.btn { padding: 1rem; border: 3px solid #000; border-radius: 16px; background: #16a34a; color: white; font-weight: bold; font-size: 1.1rem; min-height: 56px; width: 100%; margin-bottom: 0.75rem; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 12px rgba(0,0,0,0.15); transition: all 0.15s ease; overflow: hidden; text-overflow: ellipsis; word-wrap: break-word; line-height: 1.3; }
.btn:hover { transform: translateY(-2px); box-shadow: 0 6px 0 rgba(0,0,0,0.3), 0 8px 16px rgba(0,0,0,0.2); }
.btn:focus-visible { outline: 3px solid #3b82f6; outline-offset: 2px; }
.btn:active { transform: translateY(4px) scale(0.98); opacity: 0.9; box-shadow: 0 0 0 rgba(0,0,0,0.3), 0 2px 6px rgba(0,0,0,0.15); }
.btn.primary { background: #16a34a; } /* Green */
.btn.safe { background: #22c55e; }
.btn.risky { background: #f97316; }
.btn.danger { background: #dc2626; }
.btn.secondary { background: #6b7280; }
.btn.disabled, .btn:disabled, button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  pointer-events: none;
}

/* Size variants */
.btn.small {
  padding: 0.5rem 0.75rem;
  font-size: 0.9rem;
  min-height: 40px;
}

.btn.large {
  padding: 1.5rem;
  font-size: 1.3rem;
  min-height: 70px;
}
.btn.icon {
  flex: 0 0 auto;
  width: auto;
  min-width: 48px;
  padding: 0.5rem;
  font-size: 1.3rem;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.choice { border: 3px solid #22c55e; padding: 1rem; margin-bottom: 0.75rem; border-radius: 16px; background: #1f2937; color: #f0f0f0; min-height: 60px; width: 100%; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 12px rgba(0,0,0,0.2); transition: all 0.15s ease; overflow: hidden; word-wrap: break-word; line-height: 1.3; }
.choice:hover { transform: translateY(-2px); background: #374151; box-shadow: 0 6px 0 rgba(0,0,0,0.3), 0 8px 16px rgba(0,0,0,0.25); }
.choice:focus-visible { outline: 3px solid #22c55e; outline-offset: 2px; }
.choice:active { transform: translateY(4px) scale(0.98); background: #111827; box-shadow: 0 0 0 rgba(0,0,0,0.3), 0 2px 6px rgba(0,0,0,0.2); }
.neutral-btn { padding: 0.5rem 0.75rem; margin-bottom: 0.5rem; border: 2px solid #22c55e; border-radius: 14px; background: #1f2937; color: #f0f0f0; font-weight: bold; cursor: pointer; font-size: 0.9rem; box-shadow: 0 3px 0 rgba(0,0,0,0.4), 0 4px 8px rgba(0,0,0,0.25); transition: all 0.15s ease; overflow: hidden; text-overflow: ellipsis; word-wrap: break-word; line-height: 1.3; }
.neutral-btn:hover { transform: translateY(-1px); opacity: 0.95; box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 10px rgba(0,0,0,0.2); }
.neutral-btn:focus-visible { outline: 3px solid #3b82f6; outline-offset: 2px; }
.neutral-btn:active { transform: translateY(3px) scale(0.98); opacity: 0.9; box-shadow: 0 0 0 rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.15); }
.neutral-btn.safe { background: #22c55e; color: white; }
.neutral-btn.risky { background: #f97316; color: white; }
.neutral-btn.danger { background: #dc2626; color: white; }
.neutral-btn.secondary { background: #6b7280; color: white; }
.neutral-btn:disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
.neutral-container {
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: row;
  background: #1a1a1a;
}
.neutral-left {
  flex: 1 1 55%;
  min-width: 45%;
  display: flex;
  flex-direction: column;
  padding: 1rem;
  overflow-y: auto;
  background: #1a1a1a;
}
.neutral-right {
  flex: 1 1 45%;
  min-width: 35%;
  height: auto;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-color: #2a2a2a;
}
@media (min-width: 768px) {
  .neutral-left {
    padding: 1.5rem;
  }
}
@media (min-width: 1400px) {
  .neutral-left {
    padding: 2rem;
  }
}
.neutral-header {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 1rem;
}
.neutral-stats {
  background: rgba(255,255,255,0.1);
  color: white;
  border-radius: 6px;
  padding: 0.4rem 0.75rem;
  font-size: 0.85rem;
  font-weight: bold;
  width: fit-content;
}
.neutral-narrative {
  background: rgba(255,255,255,0.05);
  color: white;
  border-radius: 8px;
  padding: 0.75rem;
  border: 1px solid rgba(255,255,255,0.1);
}
.neutral-title { font-size: 1.2rem; font-weight: bold; margin-bottom: 0.5rem; color: #60a5fa; }
.neutral-desc { font-size: 0.9rem; line-height: 1.4; margin-bottom: 0.5rem; max-width: 600px; color: #f5f5f5; }
.neutral-outcome { font-size: 0.85rem; padding: 0.5rem; background: rgba(255,255,255,0.15); border-radius: 4px; margin-bottom: 0.5rem; color: #f5f5f5; }
.neutral-content {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}
.neutral-footer {
  margin-top: auto;
  padding-top: 1rem;
}
.dice-roll { font-size: 1.2rem; font-weight: bold; text-align: center; padding: 1rem; background: #2c63c7; color: white; border-radius: 6px; margin: 1rem 0; }
/* Combat layout */
.combat-grid { display: flex; gap: 0.75rem; margin-bottom: 1rem; justify-content: center; }
.column { display: flex; flex-direction: column; gap: 0.5rem; align-items: center; }
.column.heroes { flex: 0 0 auto; }
.column.enemies { flex: 0 0 auto; }
.combat-lane {
  background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
  border: 3px solid #000;
  border-radius: 8px;
  padding: 0.5rem 0.6rem;
  margin: 0 auto 0.4rem auto;
  max-width: 800px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.1);
  position: relative;
}
.combat-lane:not(:last-child)::after {
  display: none;
}
/* Crowded lanes: scale down enemy cards when 3+ or 5+ enemies */
.combat-lane.crowded-3 .card.enemy { width: 130px; max-width: 130px; padding: 0.35rem; min-height: 55px; font-size: 0.75rem; }
.combat-lane.crowded-3 .card.enemy .sigil { width: 20px; height: 20px; font-size: 0.7rem; }
.combat-lane.crowded-5 .card.enemy { width: 105px; max-width: 105px; padding: 0.25rem; min-height: 45px; font-size: 0.65rem; }
.combat-lane.crowded-5 .card.enemy .sigil { width: 16px; height: 16px; font-size: 0.6rem; }
.combat-lane.crowded-5 .card.enemy .sigil-row { gap: 1px; }
.card { width: auto; max-width: 160px; border: 3px solid #000; border-radius: 8px; padding: 0.5rem; min-height: 70px; font-size: 0.85rem; position: relative; overflow: hidden; word-wrap: break-word; }
.card-stats { font-size: 0.8rem; text-align: center; line-height: 1.2; overflow: hidden; text-overflow: ellipsis; }
.card.hero { background: #15803d; color: white; width: 200px; max-width: 200px; border-radius: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
.card.hero .sigil-row { flex-wrap: nowrap; gap: 2px; }
.card.hero .sigil-row .sigil { flex-shrink: 1; min-width: 28px; min-height: 28px; padding: 4px; font-size: 0.9rem; }
.card.hero .sigil-row .sigil img { height: 1.3em; }
.card.enemy { background: #b64141; color: white; width: 170px; }
.enemy-art { border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
.card.active { box-shadow: 0 0 0 4px #22c55e; animation: pulse-glow 1s infinite; }
.card.hero.chosen-one { position: relative; overflow: visible; }
.card.hero.chosen-one::before {
  content: 'üåº';
  position: absolute;
  top: -14px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 1.3rem;
  filter: drop-shadow(0 0 4px #fbbf24) drop-shadow(0 0 8px #fbbf24);
  z-index: 1;
  animation: chosen-glow 2s ease-in-out infinite;
}
@keyframes chosen-glow {
  0%, 100% { filter: drop-shadow(0 0 4px #fbbf24) drop-shadow(0 0 8px #fbbf24); }
  50% { filter: drop-shadow(0 0 6px #fcd34d) drop-shadow(0 0 12px #fbbf24); }
}
.card.selectable { cursor: pointer; box-shadow: 0 0 0 3px #22c55e; }
.card.selectable:active { transform: scale(0.98); }
.card.targetable { cursor: pointer; }
.card.targetable:active { transform: scale(0.98); }
.card.targeted { box-shadow: 0 0 0 4px lime; }
.card.acted { opacity: 0.6; }
.card.stunned { opacity: 0.7; border-color: #ef4444 !important; }
.card.last-stand {
  border-color: #dc2626;
  box-shadow: 0 0 0 3px #dc2626;
  animation: pulse-last-stand 1.5s ease-in-out infinite;
}
.card.hero.targetable { box-shadow: 0 0 0 3px #3b82f6; }
.card.enemy.targetable { box-shadow: 0 0 0 3px #dc2626; }
.card.hero.targeted { box-shadow: 0 0 0 4px #60a5fa; }
.card.enemy.targeted { box-shadow: 0 0 0 4px #ef4444; }
.card.hero-selectable { transition: transform 0.15s ease, box-shadow 0.15s ease; }
.card.hero-selectable:hover { transform: scale(1.02); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
.card.hit-flash { animation: damage-stagger 0.4s ease !important; }
.card.attack-slide { animation: attack-slide 0.48s ease !important; }
.card.heal-flash { animation: heal-flash 0.48s ease !important; }
.card.shield-flash { animation: shield-flash 0.48s ease !important; }
@keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 0 4px #22c55e; } 50% { box-shadow: 0 0 0 8px #22c55e; } }
@keyframes pulse-last-stand {
  0%, 100% { box-shadow: 0 0 0 3px #dc2626, 0 0 15px rgba(220, 38, 38, 0.6); border-color: #dc2626; }
  50% { box-shadow: 0 0 0 6px #dc2626, 0 0 25px rgba(220, 38, 38, 0.9); border-color: #ef4444; }
}
@keyframes pulse-text {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.85; transform: scale(1.05); }
}
@keyframes damage-stagger {
  0% { transform: translateX(0) scale(1); filter: brightness(1); }
  15% { transform: translateX(-15px) scale(0.95); filter: brightness(2) saturate(2); background-color: rgba(220, 38, 38, 0.5); }
  30% { transform: translateX(8px) scale(0.97); filter: brightness(1.8) saturate(2); background-color: rgba(220, 38, 38, 0.4); }
  50% { transform: translateX(-5px) scale(0.98); filter: brightness(1.5) saturate(1.5); background-color: rgba(220, 38, 38, 0.2); }
  70% { transform: translateX(2px) scale(0.99); filter: brightness(1.2); background-color: rgba(220, 38, 38, 0.1); }
  100% { transform: translateX(0) scale(1); filter: brightness(1); background-color: transparent; }
}
@keyframes attack-slide {
  0% { transform: translateX(0) scale(1); }
  15% { transform: translateX(5px) scale(1.08); }
  40% { transform: translateX(25px) scale(1.1); }
  60% { transform: translateX(25px) scale(1.1); }
  80% { transform: translateX(5px) scale(1.02); }
  100% { transform: translateX(0) scale(1); }
}
@keyframes enemy-attack-slide {
  0% { transform: translateX(0) scale(1); }
  15% { transform: translateX(-5px) scale(1.08); }
  40% { transform: translateX(-25px) scale(1.1); }
  60% { transform: translateX(-25px) scale(1.1); }
  80% { transform: translateX(-5px) scale(1.02); }
  100% { transform: translateX(0) scale(1); }
}
.card.enemy-attack-slide { animation: enemy-attack-slide 0.48s ease !important; }
@keyframes heal-flash {
  0% { filter: brightness(1); transform: scale(1); }
  15% { filter: brightness(1.5) saturate(1.5); transform: scale(1.03); background-color: rgba(34, 197, 94, 0.3); }
  30% { filter: brightness(2) saturate(2) hue-rotate(20deg); transform: scale(1.05); background-color: rgba(34, 197, 94, 0.4); box-shadow: 0 0 25px rgba(34, 197, 94, 0.9); }
  50% { filter: brightness(1.8) saturate(2) hue-rotate(15deg); transform: scale(1.05); background-color: rgba(34, 197, 94, 0.3); box-shadow: 0 0 20px rgba(34, 197, 94, 0.8); }
  70% { filter: brightness(1.4) saturate(1.3); transform: scale(1.02); background-color: rgba(34, 197, 94, 0.2); }
  100% { filter: brightness(1); transform: scale(1); background-color: transparent; box-shadow: none; }
}
@keyframes shield-flash {
  0% { filter: brightness(1); transform: scale(1); }
  15% { filter: brightness(1.3) grayscale(0.2); transform: scale(1.02); background-color: rgba(156, 163, 175, 0.3); }
  30% { filter: brightness(1.6) grayscale(0.4); transform: scale(1.04); background-color: rgba(156, 163, 175, 0.45); box-shadow: 0 0 25px rgba(156, 163, 175, 0.9); }
  50% { filter: brightness(1.5) grayscale(0.3); transform: scale(1.04); background-color: rgba(156, 163, 175, 0.4); box-shadow: 0 0 20px rgba(156, 163, 175, 0.8); }
  70% { filter: brightness(1.2) grayscale(0.1); transform: scale(1.01); background-color: rgba(156, 163, 175, 0.2); }
  100% { filter: brightness(1); transform: scale(1); background-color: transparent; box-shadow: none; }
}
@keyframes heal-cross-fade {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
  50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
}
/* Bonus turn stack visuals for Asterisk/Alpha */
.bonus-turn-stack {
  position: absolute;
  top: 0;
  right: -5px;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: -1;
}
.bonus-turn-card {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  background: #3b82f6;
  border: 3px solid #f97316;
  border-radius: 8px;
  opacity: 0.7;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.bonus-turn-card.sliding-out {
  animation: stack-slide-out 0.3s ease forwards;
}
@keyframes stack-slide-out {
  0% { transform: translate(0, 0); opacity: 0.7; }
  100% { transform: translate(50px, -20px); opacity: 0; }
}
.sigil-row { display: flex !important; flex-direction: row !important; flex-wrap: wrap; gap: 6px; justify-content: center; align-items: center; margin-top: 4px; max-width: 100%; }
.sigil-row.compact { gap: 3px; }
.sigil-row.compact .sigil { padding: 6px; font-size: 0.75rem; min-width: 40px; min-height: 40px; }
.sigil-divider { width: 100%; height: 1px; background: rgba(255,255,255,0.3); margin: 4px 0; }
.sigil { border: none; border-radius: 6px; padding: 10px; font-size: 1.1rem; display: inline-flex; align-items: center; justify-content: center; margin: 2px; min-width: 44px; min-height: 44px; max-width: 56px; width: auto; font-weight: 900; background: transparent; text-shadow: none; flex-shrink: 0; }
.sigil img { width: auto; height: 1.6em; object-fit: contain; }
.sigil sup { font-size: 0.55em; font-weight: bold; margin-left: 1px; vertical-align: super; }
.sigil.clickable { cursor: pointer; }
.sigil.clickable:active { transform: scale(0.95); }
.sigil.active-action { box-shadow: 0 0 12px #22c55e; animation: pulse-action 0.8s infinite; }

/* Active sigils: transparent background, colored icon */
.sigil.l0 { color: #666; opacity: 0.5; }
.sigil.l0 img { filter: brightness(0) saturate(100%) opacity(0.35); }
.sigil.l1 { color: #1a1a1a; }
.sigil.l1 img { filter: brightness(0) saturate(100%); }
.sigil.l2 { color: #06b6d4; }
.sigil.l2 img { filter: invert(56%) sepia(81%) saturate(1239%) hue-rotate(166deg) brightness(95%) contrast(94%); }
.sigil.l3 { color: #9333ea; }
.sigil.l3 img { filter: invert(28%) sepia(97%) saturate(6144%) hue-rotate(262deg) brightness(82%) contrast(100%); }
.sigil.l4 { color: #d97706; }
.sigil.l4 img { filter: invert(44%) sepia(97%) saturate(950%) hue-rotate(22deg) brightness(97%) contrast(92%) drop-shadow(0 0 6px rgba(217,119,6,0.5)); }
.sigil.l5 {
  background: transparent;
  color: #ff0080;
}
.sigil.l5 img { filter: invert(24%) sepia(99%) saturate(6143%) hue-rotate(316deg) brightness(101%) contrast(102%) drop-shadow(0 0 6px rgba(255,0,128,0.8)); animation: rainbow-pulse 2s ease-in-out infinite; }

/* Passive sigils: colored background, white icon, rounder corners */
.sigil.passive { border: 2px solid rgba(0,0,0,0.5); border-radius: 12px; }
.sigil.passive img { filter: brightness(0) invert(1) !important; } /* White icon */
.sigil.passive.l0 { background: #6b7280; opacity: 0.7; } /* Darker Gray */
.sigil.passive.l1 { background: #1f2937; } /* Darker charcoal */
.sigil.passive.l2 { background: #0891b2; } /* Darker Cyan */
.sigil.passive.l3 { background: #7c3aed; } /* Darker Purple */
.sigil.passive.l4 { background: #b45309; box-shadow: 0 0 6px rgba(180,83,9,0.6); } /* Darker Orange with glow */
/* Passive sigil level numbers: white text on dark backgrounds */
.sigil.passive sup { color: #fff !important; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
.sigil.passive.l5 { background: linear-gradient(135deg, #db2777, #6d28d9, #0891b2); animation: rainbow-bg 2s ease-in-out infinite; } /* Darker Rainbow gradient */
@keyframes rainbow-bg {
  0%, 100% { background: linear-gradient(135deg, #ff0080, #7c3aed, #06b6d4); }
  50% { background: linear-gradient(135deg, #06b6d4, #ff0080, #7c3aed); }
}
@keyframes rainbow-pulse {
  0%, 100% { filter: invert(24%) sepia(99%) saturate(6143%) hue-rotate(316deg) brightness(101%) contrast(102%) drop-shadow(0 0 6px rgba(255,0,128,0.8)); }
  50% { filter: invert(69%) sepia(88%) saturate(1053%) hue-rotate(166deg) brightness(90%) contrast(88%) drop-shadow(0 0 8px rgba(64,224,208,0.8)); }
}
.sigil.asterisk-primed { box-shadow: 0 0 8px #a855f7; animation: pulse-asterisk 1s infinite; }
@keyframes pulse-asterisk { 0%, 100% { box-shadow: 0 0 8px #a855f7; } 50% { box-shadow: 0 0 16px #a855f7; } }
@keyframes pulse-action { 0%, 100% { box-shadow: 0 0 12px #3b82f6; } 50% { box-shadow: 0 0 20px #3b82f6; } }
.sigil.in-effect { animation: pulse-in-effect 0.8s infinite; }
@keyframes pulse-in-effect { 0%, 100% { transform: scale(1); filter: brightness(1.1); } 50% { transform: scale(1.08); filter: brightness(1.25); } }

/* FU Mode: Compact 3-hero layout */
.fu-mode .combat-lane {
  padding: 0.5rem;
  margin: 0 auto 0.6rem auto;
}
.fu-mode .combat-lane:not(:last-child)::after {
  display: none;
}
.fu-mode .card {
  padding: 0.35rem;
  min-height: 60px;
}
.fu-mode .card.hero,
.fu-mode .card.enemy {
  width: 120px;
}
.fu-mode .card img {
  width: 36px !important;
  height: 36px !important;
}
.fu-mode .sigil {
  padding: 6px;
  min-width: 32px;
  min-height: 32px;
  max-width: 40px;
  font-size: 0.9rem;
}
.fu-mode .sigil-row {
  gap: 3px;
  margin-top: 2px;
}
.fu-mode .sigil-divider {
  margin: 2px 0;
}
.fu-mode .combat-header {
  padding: 0.5rem;
  margin-bottom: 0.5rem;
}
.fu-mode .lane-content {
  gap: 1rem !important;
}
.fu-mode .card > div {
  font-size: 0.9em;
}
.fu-mode .card > div:first-child {
  font-size: 0.7rem;
}

.toast { position: fixed; bottom: 20px; right: 20px; background: linear-gradient(#1f2937, #111827); border: 2px solid #22c55e; border-radius: 6px; padding: 1rem 1.5rem; font-weight: bold; box-shadow: 0 4px 12px rgba(0,0,0,0.4); opacity: 0; transform: translateY(20px); transition: all 0.3s; z-index: 10000; max-width: 80%; color: #f0f0f0; }
.toast.show { opacity: 1; transform: translateY(0); }
.toast-log { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: linear-gradient(#1f2937, #111827); color: #f0f0f0; border: 3px solid #22c55e; border-radius: 8px; padding: 0.75rem; max-width: 400px; width: 90%; box-shadow: 0 8px 24px rgba(0,0,0,0.5); z-index: 9999; display: none; }
.toast-log.show { display: block; }
.toast-log-header { font-weight: bold; font-size: 0.85rem; margin-bottom: 0.25rem; padding: 0.25rem 0.5rem; display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
.toast-log-toggle { font-size: 1rem; }
.toast-log-entries { max-height: 200px; overflow-y: auto; font-size: 0.8rem; }
.toast-log-entry { padding: 0.4rem 0.5rem; border-top: 1px solid rgba(0,0,0,0.1); }
.toast-log-entry:first-child { border-top: none; }
.toast-log-entry.recent { font-weight: bold; }
.turn-locked { pointer-events: none; opacity: 0.7; }
.tutorial-modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 50000; display: flex; align-items: center; justify-content: center; }
.tutorial-modal { background: linear-gradient(#1f2937, #111827); border: 4px solid #22c55e; border-radius: 12px; padding: 2rem; max-width: 600px; box-shadow: 0 8px 32px rgba(0,0,0,0.7); text-align: center; color: #f0f0f0; }
.tutorial-modal h2 { margin-top: 0; color: #22c55e; }
.tutorial-modal p { margin: 1rem 0; font-size: 1.1rem; line-height: 1.6; background: rgba(34,197,94,0.15); padding: 0.75rem 1rem; border-radius: 8px; border: 1px solid rgba(34,197,94,0.4); color: #f0f0f0; }
.tutorial-modal button { margin-top: 1.5rem; padding: 0.75rem 2rem; font-size: 1.1rem; font-weight: bold; background: #22c55e; color: #fff; border: 2px solid #15803d; border-radius: 8px; cursor: pointer; }
.tutorial-modal button:hover { background: #15803d; }
.tutorial-modal button:active { transform: scale(0.98); }
.choice.disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }
.tooltip { position: fixed; z-index: 25000; background: rgba(0,0,0,0.95); color: #fff; padding: 1rem; border-radius: 8px; border: 2px solid #3b82f6; max-width: 320px; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
.tooltip.show { opacity: 1; }
.tooltip-green { background: rgba(34,197,94,0.85) !important; border-color: #22c55e !important; }
.tooltip-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem; color: #60a5fa; }
.tooltip-desc { font-size: 0.9rem; line-height: 1.4; }

/* Damage Preview Tooltip */
.damage-preview {
  position: fixed;
  z-index: 25000;
  background: rgba(0,0,0,0.92);
  color: #fff;
  padding: 0.5rem 0.75rem;
  border-radius: 6px;
  border: 2px solid #dc2626;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  text-align: center;
  min-width: 60px;
  box-shadow: 0 4px 12px rgba(220,38,38,0.4);
}
.damage-preview.show { opacity: 1; }
.damage-preview .dmg-total { font-size: 1.3rem; font-weight: bold; color: #ef4444; }
.damage-preview .dmg-shield { font-size: 0.75rem; color: #9ca3af; margin-top: 2px; }
.damage-preview .dmg-hp { font-size: 0.75rem; color: #fca5a5; margin-top: 2px; }
.damage-preview .dmg-blocked { font-size: 0.75rem; color: #60a5fa; margin-top: 2px; font-style: italic; }

/* Heal Preview Tooltip */
.heal-preview {
  position: fixed;
  z-index: 25000;
  background: rgba(0,0,0,0.92);
  color: #fff;
  padding: 0.5rem 0.75rem;
  border-radius: 6px;
  border: 2px solid #22c55e;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  text-align: center;
  min-width: 60px;
  box-shadow: 0 4px 12px rgba(34,197,94,0.4);
}
.heal-preview.show { opacity: 1; }
.heal-preview .heal-total { font-size: 1.3rem; font-weight: bold; color: #86efac; }
.heal-preview .heal-wasted { font-size: 0.75rem; color: #fbbf24; margin-top: 2px; font-style: italic; }
.heal-preview .heal-full { font-size: 0.75rem; color: #60a5fa; margin-top: 2px; font-style: italic; }

/* Shield Preview Tooltip */
.shield-preview {
  position: fixed;
  z-index: 25000;
  background: rgba(0,0,0,0.92);
  color: #fff;
  padding: 0.5rem 0.75rem;
  border-radius: 6px;
  border: 2px solid #60a5fa;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  text-align: center;
  min-width: 60px;
  box-shadow: 0 4px 12px rgba(96,165,250,0.4);
}
.shield-preview.show { opacity: 1; }
.shield-preview .shield-total { font-size: 1.3rem; font-weight: bold; color: #93c5fd; }
.shield-preview .shield-capped { font-size: 0.75rem; color: #fbbf24; margin-top: 2px; font-style: italic; }
.shield-preview .shield-full { font-size: 0.75rem; color: #60a5fa; margin-top: 2px; font-style: italic; }

/* Long-press indicator for mobile tooltips */
.long-press-indicator {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 3px solid transparent;
  border-top-color: #22c55e;
  pointer-events: none;
  opacity: 0;
  z-index: 100;
}
.long-press-indicator.active {
  opacity: 1;
  animation: long-press-spin 0.5s linear forwards;
}
@keyframes long-press-spin {
  0% { transform: translate(-50%, -50%) rotate(0deg); border-top-color: #22c55e; }
  25% { border-right-color: #22c55e; }
  50% { border-bottom-color: #22c55e; }
  75% { border-left-color: #22c55e; }
  100% { transform: translate(-50%, -50%) rotate(360deg); border-color: #22c55e; }
}

/* Larger touch targets for mobile sigils */
@media (max-width: 767px) {
  .sigil { min-width: 48px; min-height: 48px; padding: 10px; }
  .sigil img { height: 1.8em; }
  .sigil-row.compact .sigil { min-width: 44px; min-height: 44px; padding: 8px; }
  .card.hero .sigil-row .sigil { min-width: 36px; min-height: 36px; padding: 6px; }
}

/* Shield Bar - visual indicator for shield amount */
.shield-bar-container {
  width: 100%;
  height: 6px;
  background: rgba(0,0,0,0.3);
  border-radius: 3px;
  margin-top: 4px;
  overflow: hidden;
  position: relative;
}
.shield-bar {
  height: 100%;
  background: linear-gradient(90deg, #60a5fa, #3b82f6);
  border-radius: 3px;
  transition: width 0.3s ease;
  box-shadow: 0 0 6px rgba(59,130,246,0.6);
}
.shield-bar.full { background: linear-gradient(90deg, #22d3ee, #06b6d4); box-shadow: 0 0 8px rgba(34,211,238,0.8); }

/* Shield glow effect on cards */
.card.has-shield { box-shadow: 0 0 0 2px rgba(59,130,246,0.5), inset 0 0 15px rgba(59,130,246,0.15); }
.card.has-shield.hero { box-shadow: 0 4px 8px rgba(0,0,0,0.2), 0 0 0 2px rgba(59,130,246,0.6), inset 0 0 20px rgba(59,130,246,0.2); }
.card.has-shield.enemy { box-shadow: 0 0 0 2px rgba(59,130,246,0.5), inset 0 0 15px rgba(59,130,246,0.15); }
.card.has-shield.active { box-shadow: 0 0 0 4px #22c55e, 0 0 0 6px rgba(59,130,246,0.5); animation: pulse-glow-shield 1s infinite; }
@keyframes pulse-glow-shield {
  0%, 100% { box-shadow: 0 0 0 4px #22c55e, 0 0 0 6px rgba(59,130,246,0.5); }
  50% { box-shadow: 0 0 0 8px #22c55e, 0 0 0 10px rgba(59,130,246,0.4); }
}

/* Tablet improvements (768px-1023px) */
@media (min-width: 768px) {
  /* Base scaling for tablet */
  .header {
    font-size: 0.95rem;
    padding: 0.75rem 1rem;
  }

  .game-area {
    padding: 1rem;
    height: calc(100vh - 52px);
  }

  /* Cards medium scaling */
  .card {
    width: 180px !important;
    max-width: 180px;
    padding: 0.75rem;
    min-height: 85px;
    font-size: 0.95rem;
  }
  .card.hero { width: 220px !important; max-width: 220px; }
  .card.enemy { width: 180px; }

  /* Combat grid spacing */
  .combat-grid {
    gap: 1rem;
  }
  .column {
    gap: 0.75rem;
  }

  /* Combat lane */
  .combat-lane {
    padding: 1.25rem;
    max-width: 900px;
  }

  /* Sigils medium */
  .sigil {
    font-size: 0.95rem;
    padding: 8px;
    min-width: 36px;
    min-height: 36px;
  }
  .sigil-row {
    gap: 6px;
  }

  /* Buttons */
  .btn {
    font-size: 1.2rem;
    padding: 1.1rem;
    min-height: 60px;
  }

  .choice {
    font-size: 1.1rem;
    padding: 1.1rem;
    min-height: 65px;
  }

  .neutral-btn {
    font-size: 1rem;
    padding: 0.6rem 0.9rem;
  }

  /* Toast notifications */
  .toast {
    font-size: 1rem;
    padding: 1.25rem 1.75rem;
    max-width: 500px;
  }

  .toast-log {
    max-width: 480px;
    font-size: 0.9rem;
  }

  /* Tooltips */
  .tooltip {
    max-width: 380px;
    padding: 1.25rem;
  }
  .tooltip-title {
    font-size: 1.2rem;
  }
  .tooltip-desc {
    font-size: 1rem;
  }
}

/* Desktop improvements (1024px+) - Premium experience */
@media (min-width: 1024px) {
  /* Header scaling */
  .header {
    font-size: 1.1rem;
    padding: 1rem 1.5rem;
    height: 56px;
  }

  .header button {
    font-size: 0.85rem !important;
    padding: 0.4rem 0.75rem !important;
  }

  .game-area {
    padding: 1.5rem;
    height: calc(100vh - 56px);
  }

  /* Hero and Enemy Cards - Much larger on desktop */
  .card {
    width: 220px !important;
    max-width: 220px;
    padding: 1rem;
    min-height: 110px;
    font-size: 1.1rem;
    border-width: 4px;
  }
  .card.hero { width: 260px !important; max-width: 260px; }
  .card.enemy { width: 220px; }

  /* Hero/enemy images larger */
  .card img {
    width: 64px !important;
    height: 64px !important;
  }

  /* Card text scaling */
  .card > div {
    font-size: 1rem !important;
  }
  .card > div:first-child {
    font-size: 1.2rem !important;
    margin-bottom: 0.5rem !important;
  }

  /* Combat grid - More spacious */
  .combat-grid {
    gap: 1.5rem;
    padding: 1rem 0;
  }

  .column {
    gap: 1rem;
  }

  /* Combat lane - Use more screen */
  .combat-lane {
    padding: 1.5rem 2rem;
    max-width: 1200px;
    margin-bottom: 3rem;
  }

  .combat-lane:not(:last-child)::after {
    font-size: 1.5rem;
    bottom: -2.5rem;
  }

  /* Sigils - Properly sized for desktop */
  .sigil {
    font-size: 1.1rem;
    padding: 10px;
    min-width: 42px;
    min-height: 42px;
    margin: 3px;
  }

  .sigil img {
    width: auto;
    height: 1.4em !important;
    object-fit: contain;
  }

  .sigil-row {
    gap: 8px;
    margin-top: 8px;
  }

  .sigil-row.compact {
    gap: 4px;
  }
  .sigil-row.compact .sigil {
    font-size: 0.85rem;
    padding: 6px;
    min-width: 32px;
    min-height: 32px;
  }

  .sigil-divider {
    margin: 6px 0;
  }

  /* Buttons - Desktop appropriate */
  .btn {
    padding: 1.25rem 2rem;
    font-size: 1.4rem;
    min-height: 70px;
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 1rem;
    display: block;
    border-width: 4px;
  }

  .choice {
    padding: 1.25rem 2rem;
    font-size: 1.3rem;
    min-height: 75px;
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 1rem;
    display: block;
    border-width: 4px;
  }

  .neutral-btn {
    padding: 0.75rem 1.25rem;
    font-size: 1.15rem;
    border-width: 3px;
    margin-bottom: 0.75rem;
  }

  /* Neutral screens - Desktop scaling */
  .neutral-stats {
    font-size: 1.05rem;
    padding: 0.6rem 1rem;
  }

  .neutral-title {
    font-size: 1.5rem;
    margin-bottom: 0.75rem;
  }

  .neutral-desc {
    font-size: 1.1rem;
    line-height: 1.5;
  }

  .neutral-outcome {
    font-size: 1rem;
    padding: 0.75rem;
  }

  /* Dice roll */
  .dice-roll {
    font-size: 1.5rem;
    padding: 1.25rem;
  }

  /* Toast notifications */
  .toast {
    font-size: 1.15rem;
    padding: 1.5rem 2rem;
    max-width: 600px;
    bottom: 40px;
    right: 40px;
    border-width: 3px;
  }

  .toast-log {
    max-width: 600px;
    padding: 1rem;
  }

  .toast-log-header {
    font-size: 1rem;
    padding: 0.4rem 0.75rem;
  }

  .toast-log-toggle {
    font-size: 1.2rem;
  }

  .toast-log-entries {
    font-size: 0.95rem;
    max-height: 320px;
  }

  .toast-log-entry {
    padding: 0.5rem 0.75rem;
  }

  /* Tutorial modal */
  .tutorial-modal {
    padding: 2.5rem;
    max-width: 750px;
    border-width: 5px;
  }

  .tutorial-modal h2 {
    font-size: 1.8rem;
  }

  .tutorial-modal p {
    font-size: 1.25rem;
    line-height: 1.7;
  }

  .tutorial-modal button {
    padding: 1rem 2.5rem;
    font-size: 1.25rem;
    border-width: 3px;
  }

  /* Tooltips */
  .tooltip {
    max-width: 450px;
    padding: 1.5rem;
    border-width: 3px;
  }

  .tooltip-title {
    font-size: 1.3rem;
    margin-bottom: 0.75rem;
  }

  .tooltip-desc {
    font-size: 1.1rem;
    line-height: 1.5;
  }
}

/* Large Desktop improvements (1440px+) - Even more premium */
@media (min-width: 1440px) {
  /* Use even more screen real estate */
  .combat-lane {
    max-width: 1400px;
    padding: 2rem 2.5rem;
  }

  /* Cards can be even larger */
  .card {
    width: 240px !important;
    max-width: 240px;
    padding: 1.25rem;
    min-height: 120px;
    font-size: 1.15rem;
  }
  .card.hero { width: 290px !important; max-width: 290px; }
  .card.enemy { width: 240px; }

  /* Images scale up */
  .card img {
    width: 72px !important;
    height: 72px !important;
  }

  /* More generous spacing */
  .combat-grid {
    gap: 2rem;
  }

  .column {
    gap: 1.25rem;
  }

  /* Buttons use more width */
  .btn, .choice {
    max-width: 800px;
  }

  /* Larger game area padding */
  .game-area {
    padding: 2rem;
  }

  /* Neutral encounters - Scale up for large desktop */
  .neutral-stats {
    font-size: 1.2rem;
    padding: 0.75rem 1.25rem;
  }

  .neutral-title {
    font-size: 1.75rem;
    margin-bottom: 1rem;
  }

  .neutral-desc {
    font-size: 1.25rem;
    line-height: 1.6;
  }

  .neutral-outcome {
    font-size: 1.15rem;
    padding: 1rem;
  }

  .neutral-btn {
    padding: 1rem 1.5rem;
    font-size: 1.3rem;
    margin-bottom: 1rem;
  }

  .dice-roll {
    font-size: 1.75rem;
    padding: 1.5rem;
  }
}

/* Ultra-wide Desktop (1920px+) */
@media (min-width: 1920px) {
  .combat-lane {
    max-width: 1600px;
  }

  /* Cards at maximum size */
  .card {
    width: 260px !important;
    max-width: 260px;
  }
  .card.hero { width: 320px !important; max-width: 320px; }
  .card.enemy { width: 260px; }

  .btn, .choice {
    max-width: 900px;
  }

  /* Neutral encounters - Maximum scale for ultra-wide */
  .neutral-stats {
    font-size: 1.3rem;
    padding: 0.85rem 1.5rem;
  }

  .neutral-title {
    font-size: 2rem;
    margin-bottom: 1.25rem;
  }

  .neutral-desc {
    font-size: 1.4rem;
    line-height: 1.65;
  }

  .neutral-outcome {
    font-size: 1.25rem;
    padding: 1.25rem;
  }

  .neutral-btn {
    padding: 1.15rem 1.75rem;
    font-size: 1.45rem;
    margin-bottom: 1.25rem;
  }

  .dice-roll {
    font-size: 2rem;
    padding: 1.75rem;
  }
}

/* Dynamic element classes for inline styles */
.card-image {
  width: 48px;
  height: 48px;
  border-radius: 4px;
}

/* Flip neutral portraits that face the wrong direction */
img[src*="healerfull"],
img[src*="warriorfull"],
img[src*="tankfull"] {
  transform: scaleX(-1);
}

.card-emoji {
  text-align: center;
  font-size: 2rem;
  margin-bottom: 0.25rem;
}

.card-stats {
  text-align: center;
  font-size: 0.8rem;
  margin-top: 0.25rem;
  overflow: hidden;
  text-overflow: ellipsis;
  line-height: 1.2;
}

.combat-header {
  text-align: center;
  font-weight: bold;
  padding: 0.75rem;
  background: rgba(0,0,0,0.05);
  border-radius: 6px;
  margin-bottom: 0.75rem;
  position: relative;
}

.combat-header-title {
  font-size: 1.1rem;
  color: #dc2626;
}

.combat-header-subtitle {
  font-size: 0.85rem;
  margin-top: 0.25rem;
}

.combat-header-info {
  font-size: 0.75rem;
  opacity: 0.8;
  margin-top: 0.25rem;
}

.section-label {
  text-align: center;
  font-weight: bold;
  padding: 0.25rem;
  background: rgba(0,0,0,0.1);
  border-radius: 6px;
  margin-bottom: 0.5rem;
  font-size: 0.85rem;
}

.empty-slot {
  text-align: center;
  font-size: 0.75rem;
  padding: 0.5rem;
  opacity: 0.5;
  font-style: italic;
  margin-bottom: 0.5rem;
}

/* Tablet scaling for dynamic elements */
@media (min-width: 768px) {
  .card-image {
    width: 56px;
    height: 56px;
  }

  .card-emoji {
    font-size: 2.25rem;
  }

  .card-stats {
    font-size: 0.9rem;
  }

  .combat-header {
    padding: 1rem;
  }

  .combat-header-title {
    font-size: 1.25rem;
  }

  .combat-header-subtitle {
    font-size: 0.95rem;
  }

  .combat-header-info {
    font-size: 0.85rem;
  }

  .section-label {
    font-size: 0.95rem;
    padding: 0.35rem;
  }

  .empty-slot {
    font-size: 0.85rem;
  }
}

/* Desktop scaling for dynamic elements */
@media (min-width: 1024px) {
  .card-image {
    width: 64px;
    height: 64px;
  }

  .card-emoji {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
  }

  .card-stats {
    font-size: 1rem;
    margin-top: 0.35rem;
  }

  .combat-header {
    padding: 1.25rem;
  }

  .combat-header-title {
    font-size: 1.4rem;
  }

  .combat-header-subtitle {
    font-size: 1.05rem;
    margin-top: 0.35rem;
  }

  .combat-header-info {
    font-size: 0.95rem;
  }

  .section-label {
    font-size: 1.05rem;
    padding: 0.5rem 0.75rem;
  }

  .empty-slot {
    font-size: 0.95rem;
    padding: 0.75rem;
  }
}

/* Large desktop scaling */
@media (min-width: 1440px) {
  .card-image {
    width: 72px;
    height: 72px;
  }

  .card-emoji {
    font-size: 2.75rem;
  }

  .card-stats {
    font-size: 1.1rem;
  }

  .combat-header-title {
    font-size: 1.5rem;
  }

  .combat-header-subtitle {
    font-size: 1.15rem;
  }
}

/* Ultra-wide desktop */
@media (min-width: 1920px) {
  .card-image {
    width: 80px;
    height: 80px;
  }

  .card-emoji {
    font-size: 3rem;
  }
}

/* ===== JUICE & POLISH ENHANCEMENTS ===== */

/* Floating damage/heal numbers */
.floating-number {
  position: absolute;
  font-weight: 900;
  font-size: 1.8rem;
  text-shadow: 0 2px 4px rgba(0,0,0,0.8), 0 0 10px currentColor;
  pointer-events: none;
  z-index: 10000;
  animation: floatUp 0.8s ease-out forwards;
  white-space: nowrap;
}
.floating-number.damage { color: #ef4444; }
.floating-number.heal { color: #22c55e; }
.floating-number.shield { color: #94a3b8; }
.floating-number.gold { color: #fbbf24; }
.floating-number.xp { color: #a855f7; }
.floating-number.critical {
  font-size: 2.4rem;
  color: #ff6b6b;
  text-shadow: 0 2px 4px rgba(0,0,0,0.8), 0 0 20px #ff6b6b, 0 0 40px #ff0000;
}
.floating-number.miss { color: #888; font-size: 1.4rem; font-style: italic; }

@keyframes floatUp {
  0% {
    opacity: 1;
    transform: translateY(0) scale(0.5);
  }
  20% {
    opacity: 1;
    transform: translateY(-10px) scale(1.2);
  }
  100% {
    opacity: 0;
    transform: translateY(-60px) scale(0.8);
  }
}

/* Screen shake effect */
.screen-shake {
  animation: shake 0.3s ease-in-out;
}
.screen-shake-heavy {
  animation: shakeHeavy 0.4s ease-in-out;
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
  20%, 40%, 60%, 80% { transform: translateX(4px); }
}

@keyframes shakeHeavy {
  0%, 100% { transform: translate(0, 0) rotate(0deg); }
  10% { transform: translate(-8px, -2px) rotate(-1deg); }
  20% { transform: translate(8px, 2px) rotate(1deg); }
  30% { transform: translate(-6px, -1px) rotate(-0.5deg); }
  40% { transform: translate(6px, 1px) rotate(0.5deg); }
  50% { transform: translate(-4px, 0) rotate(0deg); }
  60% { transform: translate(4px, 0) rotate(0deg); }
  70% { transform: translate(-2px, 0) rotate(0deg); }
  80% { transform: translate(2px, 0) rotate(0deg); }
  90% { transform: translate(-1px, 0) rotate(0deg); }
}

/* Enemy card hover effects */
.card.enemy {
  transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
}
.card.enemy:hover {
  transform: scale(1.03);
  filter: brightness(1.1);
  box-shadow: 0 6px 16px rgba(0,0,0,0.4);
}
.card.enemy.targetable:hover {
  transform: scale(1.05);
  filter: brightness(1.15);
  box-shadow: 0 0 0 4px #dc2626, 0 8px 20px rgba(220,38,38,0.4);
}

/* Button ripple effect */
.btn, .choice, .neutral-btn {
  position: relative;
  overflow: hidden;
}
.btn::after, .choice::after, .neutral-btn::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  background: rgba(255,255,255,0.3);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  transition: width 0.3s ease, height 0.3s ease, opacity 0.3s ease;
  opacity: 0;
}
.btn:active::after, .choice:active::after, .neutral-btn:active::after {
  width: 300px;
  height: 300px;
  opacity: 0;
  transition: width 0s, height 0s, opacity 0.5s ease;
}

/* Sigil hover effects */
.sigil.clickable {
  transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
}
.sigil.clickable:hover {
  transform: scale(1.1) translateY(-2px);
  filter: brightness(1.2);
}

/* Victory confetti container */
.confetti-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 99998;
  overflow: hidden;
}
.confetti {
  position: absolute;
  width: 10px;
  height: 10px;
  animation: confettiFall 3s ease-out forwards;
}
@keyframes confettiFall {
  0% {
    transform: translateY(-20px) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: translateY(100vh) rotate(720deg);
    opacity: 0;
  }
}

/* Combo counter */
.combo-counter {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 4rem;
  font-weight: 900;
  color: #fbbf24;
  text-shadow: 0 4px 8px rgba(0,0,0,0.8), 0 0 30px #fbbf24;
  pointer-events: none;
  z-index: 10001;
  animation: comboPop 0.5s ease-out forwards;
}
@keyframes comboPop {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }
  30% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-30px); }
}

/* Enhanced status effects */
.card.stunned {
  animation: stunPulse 1s ease-in-out infinite;
}
@keyframes stunPulse {
  0%, 100% { filter: brightness(1) saturate(0.7); }
  50% { filter: brightness(0.8) saturate(0.5); }
}

.card.ghosted {
  animation: ghostFloat 2s ease-in-out infinite;
}
@keyframes ghostFloat {
  0%, 100% { transform: translateY(0); opacity: 0.9; }
  50% { transform: translateY(-5px); opacity: 0.7; }
}

.card.shielded::before {
  content: 'üõ°Ô∏è';
  position: absolute;
  top: -8px;
  right: -8px;
  font-size: 1.5rem;
  animation: shieldBob 1.5s ease-in-out infinite;
}
@keyframes shieldBob {
  0%, 100% { transform: translateY(0) scale(1); }
  50% { transform: translateY(-3px) scale(1.1); }
}

/* XP/Gold counter pop animation */
.counter-pop {
  animation: counterPop 0.3s ease-out;
}
@keyframes counterPop {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); color: #fbbf24; }
  100% { transform: scale(1); }
}


/* Death/knockout animation */
.card.knockout {
  animation: knockout 0.6s ease-out forwards;
}
@keyframes knockout {
  0% { transform: scale(1) rotate(0deg); opacity: 1; }
  30% { transform: scale(1.1) rotate(-5deg); }
  100% { transform: scale(0.5) rotate(15deg) translateY(20px); opacity: 0; }
}

/* Level up glow effect */
.level-up-glow {
  animation: levelUpGlow 1s ease-in-out infinite;
}
@keyframes levelUpGlow {
  0%, 100% { box-shadow: 0 0 20px rgba(251,191,36,0.5); }
  50% { box-shadow: 0 0 40px rgba(251,191,36,0.9), 0 0 60px rgba(251,191,36,0.5); }
}

/* Recruit card special styling */
.card.recruit {
  border-style: dashed;
  opacity: 0.85;
  animation: recruitPulse 2s ease-in-out infinite;
}
@keyframes recruitPulse {
  0%, 100% { border-color: #22c55e; box-shadow: 0 0 10px rgba(34,197,94,0.3); }
  50% { border-color: #16a34a; box-shadow: 0 0 20px rgba(34,197,94,0.6); }
}

/* ===== STEAM DECK / CONTROLLER SUPPORT ===== */
/* Controller focus indicator - glowing ring around focused element */
.controller-focus {
  outline: 3px solid #22c55e !important;
  outline-offset: 3px;
  box-shadow: 0 0 12px rgba(34, 197, 94, 0.5), 0 0 24px rgba(34, 197, 94, 0.25) !important;
  animation: controllerFocusPulse 2.5s ease-in-out infinite;
  position: relative;
  z-index: 25001; /* Above tooltips (25000) but below modals (29999) */
}

@keyframes controllerFocusPulse {
  0%, 100% { outline-color: #22c55e; box-shadow: 0 0 12px rgba(34, 197, 94, 0.5), 0 0 24px rgba(34, 197, 94, 0.25); }
  50% { outline-color: #4ade80; box-shadow: 0 0 18px rgba(34, 197, 94, 0.7), 0 0 36px rgba(34, 197, 94, 0.35); }
}

/* When controller is active, hide cursor and add focus-visible styles */
body.controller-active {
  cursor: none;
}
body.controller-active * {
  cursor: none;
}

/* Global game area adjustment for controller bar (all screen sizes) */
body.controller-active .game-area {
  height: calc(100vh - 44px - 56px); /* Account for header (44px) + controller prompts bar (~56px) */
}

/* Full-screen content (like Ribbleton hub) - adjusts for controller bar */
.full-screen-content {
  height: calc(100vh - 44px);
}
body.controller-active .full-screen-content {
  height: calc(100vh - 44px - 56px); /* Account for header + controller prompts bar */
}

/* Toast notification adjustment when controller bar is visible */
body.controller-active .toast {
  bottom: 70px; /* Move above controller bar */
}

/* Controller button prompts bar */
.controller-prompts {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.95), rgba(0,0,0,0.8));
  padding: 0.5rem 1rem;
  display: flex;
  justify-content: center;
  gap: 1.25rem;
  flex-wrap: wrap;
  z-index: 50000;
  border-top: 2px solid #3b82f6;
  font-size: 0.85rem;
  color: white;
}

.controller-prompt {
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.controller-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  font-weight: bold;
  font-size: 0.75rem;
  border: 2px solid currentColor;
}

.controller-btn.a { background: #22c55e; color: white; border-color: #16a34a; }
.controller-btn.b { background: #dc2626; color: white; border-color: #b91c1c; }
.controller-btn.x { background: #3b82f6; color: white; border-color: #2563eb; }
.controller-btn.y { background: #fbbf24; color: #1c1b19; border-color: #f59e0b; }
.controller-btn.lb, .controller-btn.rb, .controller-btn.lt, .controller-btn.rt {
  width: auto;
  padding: 0 0.4rem;
  border-radius: 6px;
  background: #6b7280;
  border-color: #4b5563;
}
.controller-btn.lt, .controller-btn.rt {
  background: #4b5563;
}
.controller-btn.start {
  width: auto;
  padding: 0 0.5rem;
  border-radius: 4px;
  background: #374151;
  border-color: #6b7280;
  font-size: 0.65rem;
}
.controller-btn.dpad {
  width: auto;
  padding: 0 0.5rem;
  border-radius: 6px;
  background: #374151;
  border-color: #4b5563;
}

/* Controller tooltip indicator */
.controller-tooltip-active {
  outline: 3px solid #22c55e !important;
  outline-offset: 2px;
}

/* ===== ACCESSIBILITY: FOCUS-VISIBLE STYLES ===== */
/* Global focus indicator for keyboard/controller users */
*:focus-visible {
  outline: 3px solid #22c55e;
  outline-offset: 2px;
}

.sigil:focus-visible,
.card:focus-visible {
  outline: 3px solid #22c55e;
  outline-offset: 2px;
  box-shadow: 0 0 12px rgba(34, 197, 94, 0.5);
}

/* ===== HIGH CONTRAST MODE ===== */
body.high-contrast {
  --bg-primary: #000000;
  --bg-secondary: #1a1a1a;
  --text-primary: #ffffff;
  --text-secondary: #e5e5e5;
  --accent-green: #00ff00;
  --accent-red: #ff0000;
  --accent-blue: #00aaff;
  --border-color: #ffffff;
}

body.high-contrast {
  background: var(--bg-primary);
  color: var(--text-primary);
}

body.high-contrast .header {
  background: var(--bg-primary);
  border-bottom: 3px solid var(--accent-green);
}

body.high-contrast .btn {
  border: 3px solid var(--border-color);
  background: var(--bg-secondary);
  color: var(--text-primary);
}

body.high-contrast .btn.safe,
body.high-contrast .btn.primary {
  background: #006600;
  border-color: var(--accent-green);
}

body.high-contrast .btn.danger {
  background: #660000;
  border-color: var(--accent-red);
}

body.high-contrast .card {
  border: 3px solid var(--border-color);
  background: var(--bg-secondary);
}

body.high-contrast .card.hero {
  border-color: var(--accent-green);
}

body.high-contrast .card.enemy {
  border-color: var(--accent-red);
}

body.high-contrast .card.targeted {
  border-color: var(--accent-blue);
  box-shadow: 0 0 15px var(--accent-blue);
}

body.high-contrast .modal-container {
  background: var(--bg-primary);
  border: 3px solid var(--accent-green);
}

body.high-contrast .choice {
  border: 3px solid var(--border-color);
  background: var(--bg-secondary);
}

body.high-contrast .sigil {
  border: 2px solid var(--border-color);
}

body.high-contrast .toast {
  background: var(--bg-primary);
  border: 2px solid var(--accent-green);
  color: var(--text-primary);
}

body.high-contrast *:focus-visible {
  outline: 4px solid var(--accent-blue);
  outline-offset: 3px;
}

/* Hero selection overlay buttons for controller navigation */
.hero-select-btn {
  position: absolute;
  bottom: 0;
  height: 100%;
  background: transparent;
  border: none;
  cursor: pointer;
  z-index: 20;
  transition: background 0.2s ease, box-shadow 0.2s ease;
}
.hero-select-btn:hover, .hero-select-btn:focus {
  background: rgba(34, 197, 94, 0.2);
}
.hero-select-btn.controller-focus {
  background: rgba(34, 197, 94, 0.35);
  box-shadow: inset 0 0 0 4px #22c55e;
}
/* Show hero name label on controller focus */
.hero-select-btn.controller-focus::after {
  content: attr(data-hero);
  position: absolute;
  bottom: 8%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.85);
  color: #22c55e;
  padding: 0.3rem 0.6rem;
  border-radius: 6px;
  font-size: 0.85rem;
  font-weight: bold;
  text-transform: capitalize;
  white-space: nowrap;
  pointer-events: none;
}
.hero-select-btn:nth-child(2) { left: 0; width: 25%; }
.hero-select-btn:nth-child(3) { left: 25%; width: 25%; }
.hero-select-btn:nth-child(4) { left: 50%; width: 25%; }
.hero-select-btn:nth-child(5) { left: 75%; width: 25%; }

/* Custom confirm modal for controller support */
.confirm-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.95);
  border: 3px solid #f97316;
  border-radius: 12px;
  padding: 2rem;
  z-index: 100000;
  max-width: 400px;
  width: 90%;
  text-align: center;
  color: white;
}
.confirm-modal h3 {
  margin-bottom: 1rem;
  color: #fbbf24;
}
.confirm-modal p {
  margin-bottom: 1.5rem;
  font-size: 1.1rem;
}
.confirm-modal-buttons {
  display: flex;
  gap: 1rem;
  justify-content: center;
}
.confirm-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 99999;
}

/* Title Screen - Fullscreen splash with mat */
.title-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #bfa76e; /* Brown/yellow beige mat color */
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Container that wraps image AND buttons - shrinks to image size */
.title-container {
  position: relative;
  display: inline-block;
  max-width: 100%;
  max-height: 100%;
}

.title-bg-image {
  display: block;
  /* Size set by JavaScript fitTitleImage() to fill one viewport dimension */
}

.title-version {
  position: absolute;
  top: 2%;
  right: 2%;
  background: rgba(0, 0, 0, 0.8);
  color: #3b82f6;
  padding: 0.3rem 0.6rem;
  border-radius: 6px;
  font-size: 0.75rem;
  font-weight: bold;
  border: 2px solid rgba(251, 191, 36, 0.7);
  z-index: 10;
}

.title-button-container {
  position: absolute;
  bottom: 8%;
  left: 5%;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  z-index: 10;
  width: 18%;
}

.title-secondary-btn {
  background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
  border: 3px solid #000;
  border-radius: 10px;
  color: white;
  font-family: 'Fredoka One', cursive;
  font-size: clamp(0.65rem, 1.2vw, 1rem);
  padding: 0.4rem 0.3rem;
  text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.3);
  box-shadow: 0 3px 0 #1d4ed8, 0 5px 10px rgba(0, 0, 0, 0.3);
  transition: all 0.15s ease;
  width: 100%;
}

.title-secondary-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 0 #1d4ed8, 0 7px 14px rgba(0, 0, 0, 0.4);
}

.title-secondary-btn:active {
  transform: translateY(2px);
  box-shadow: 0 1px 0 #1d4ed8, 0 3px 6px rgba(0, 0, 0, 0.2);
}

.title-play-btn {
  position: absolute;
  right: 5%;
  bottom: 8%;
  background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
  border: 4px solid #000;
  border-radius: 12px;
  color: white;
  font-family: 'Fredoka One', cursive;
  font-size: clamp(0.9rem, 1.8vw, 1.5rem);
  padding: clamp(1rem, 3%, 3rem) 0;
  text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
  box-shadow: 0 5px 0 #15803d, 0 8px 16px rgba(0, 0, 0, 0.4);
  transition: all 0.15s ease;
  z-index: 10;
  width: 18%;
  text-align: center;
}

.title-play-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 0 #15803d, 0 8px 16px rgba(0, 0, 0, 0.5);
}

.title-play-btn:active {
  transform: translateY(2px);
  box-shadow: 0 2px 0 #15803d, 0 4px 8px rgba(0, 0, 0, 0.3);
}

/* Steam Deck specific optimizations (1280x800 @ 7" screen) */
@media (min-width: 1200px) and (max-width: 1400px) and (min-height: 700px) and (max-height: 900px) {
  /* Larger touch targets for Steam Deck */
  .btn {
    min-height: 64px;
    font-size: 1.2rem;
    padding: 1.25rem;
  }

  .choice {
    min-height: 68px;
    font-size: 1.1rem;
    padding: 1.25rem;
  }

  /* Cards - keep reasonable touch targets but don't bloat */
  .card {
    min-width: 120px;
    min-height: 60px;
  }

  /* Sigils - touchable but compact */
  .sigil {
    min-width: 28px;
    min-height: 28px;
    font-size: 1rem;
  }

  .sigil.compact {
    min-width: 22px;
    min-height: 22px;
    font-size: 0.85rem;
  }

  /* Header adjustments for Steam Deck */
  .header {
    padding: 0.75rem 1rem;
    font-size: 0.95rem;
  }

  .header button {
    padding: 0.4rem 0.6rem !important;
    font-size: 0.85rem !important;
  }

  /* Combat layout optimizations - FIT ON ONE SCREEN */
  .combat-lane {
    padding: 0.5rem;
    margin-bottom: 0.5rem !important;
    gap: 0.5rem;
  }

  .combat-lane:not(:last-child)::after {
    display: none; /* Remove bulky separators */
  }

  .combat-lane .lane-content {
    gap: 1rem !important;
  }

  /* Compact hero cards for Steam Deck */
  .card.hero {
    width: 160px !important;
    max-width: 160px !important;
    padding: 0.4rem !important;
    min-height: auto !important;
  }

  .card.hero .sigil-row {
    gap: 1px !important;
  }

  .card.hero .sigil-row .sigil {
    min-width: 24px !important;
    min-height: 24px !important;
    padding: 2px !important;
    font-size: 0.8rem !important;
  }

  /* Compact enemy cards */
  .card.enemy {
    width: 130px !important;
    max-width: 130px !important;
    padding: 0.35rem !important;
    min-height: auto !important;
  }

  .card.enemy .sigil {
    width: 20px !important;
    height: 20px !important;
    font-size: 0.75rem !important;
  }

  /* Compact card content */
  .card .sigil-divider {
    margin: 0.2rem 0 !important;
  }

  /* Smaller portraits */
  .card.hero img, .card.enemy img {
    width: 40px !important;
    height: 40px !important;
  }

  /* Reduce header height */
  .combat-header, [style*="combat-header"] {
    padding: 0.3rem 0.5rem !important;
    margin-bottom: 0.3rem !important;
  }

  /* Modal adjustments */
  .modal-container {
    max-width: 600px;
    padding: 2.5rem;
  }

  .modal-container h2 {
    font-size: 1.5rem;
  }

  .modal-checkbox-label {
    padding: 1rem;
    font-size: 1.1rem;
  }

  .modal-checkbox-label input {
    transform: scale(1.5);
    margin-right: 0.75rem;
  }

  /* Reduce death screen scrolling */
  .death-screen-container {
    padding: 1rem !important;
  }
  .death-screen-container img {
    max-width: 250px !important;
    margin-bottom: 0.5rem !important;
  }
  .death-screen-container h1 {
    font-size: 1.8rem !important;
    margin-bottom: 0.5rem !important;
  }
  .going-rate-marquee {
    padding: 0.75rem !important;
    margin: 0.75rem 0 !important;
  }
  .death-screen-container h3, .death-screen-container h4 {
    margin: 0.5rem 0 0.25rem 0 !important;
    font-size: 1rem !important;
  }
  .death-screen-sigil-grid {
    gap: 0.5rem !important;
    margin-bottom: 0.75rem !important;
  }
  .death-screen-sigil-card {
    padding: 0.5rem !important;
  }
}

/* Focusable elements - add data attribute for controller navigation */
[data-focusable] {
  transition: outline 0.15s ease, box-shadow 0.15s ease;
}

/* Hide controller prompts when not in controller mode */
.controller-prompts {
  display: none;
}
body.controller-active .controller-prompts {
  display: flex;
}

/* ===== NON-COMBAT SCREEN READABILITY ===== */
/* Semi-opaque backgrounds for text on busy backgrounds */
.text-backdrop {
  background: rgba(0,0,0,0.75);
  padding: 1rem 1.5rem;
  border-radius: 12px;
  backdrop-filter: blur(4px);
  color: #f5f5f5;
}

/* Increase font sizes for Steam Deck/TV viewing */
.neutral-narrative {
  background: rgba(0,0,0,0.8) !important;
  font-size: 1.1rem;
  padding: 1rem 1.25rem;
  color: #f5f5f5;
}

.neutral-desc {
  background: rgba(0,0,0,0.7);
  padding: 0.75rem 1rem;
  border-radius: 8px;
  font-size: 1rem;
  line-height: 1.5;
  color: #f5f5f5;
}

/* Death screen text readability */
.death-screen-container p {
  background: rgba(255,255,255,0.9);
  padding: 0.5rem 0.75rem;
  border-radius: 6px;
  margin-bottom: 0.5rem;
}

.death-screen-container .going-rate-marquee {
  background: rgba(255,255,255,0.95);
  padding: 1rem;
  border-radius: 8px;
}

/* Ribbleton hub text */
.hub-desc, .location-desc {
  background: rgba(0,0,0,0.75);
  padding: 0.75rem 1rem;
  border-radius: 8px;
  font-size: 1.05rem;
  color: #f5f5f5;
}

/* Victory/narrative slides */
.narrative-text {
  background: rgba(0,0,0,0.8);
  padding: 1rem 1.5rem;
  border-radius: 10px;
  font-size: 1.15rem;
  line-height: 1.6;
  color: #f5f5f5;
}

/* General paragraph text on non-combat screens */
#gameView > div > p:not(.combat-lane *),
#gameView > p {
  font-size: 1.05rem;
  line-height: 1.5;
}

/* Steam Deck specific: larger text for non-combat screens */
@media (min-width: 1200px) and (max-height: 900px) {
  .neutral-desc {
    font-size: 1.15rem;
    line-height: 1.55;
  }

  .neutral-narrative {
    font-size: 1.2rem;
  }

  .death-screen-container p {
    font-size: 1.1rem;
  }

  .narrative-text {
    font-size: 1.25rem;
  }
}
</style>
</head>
<body>
<!-- Rotate device prompt (only shows on mobile in portrait) -->
<div id="rotatePrompt" style="display:none;">
<div class="rotate-icon">üì±‚ÜíüîÑ</div>
<div class="rotate-message">Please Rotate Your Device</div>
<div class="rotate-submessage">FROGGLE plays best in landscape mode</div>
</div>

<div class="header" id="gameHeader">
<div id="locationInfo"><span id="locationLabel">Floor</span> <span id="floor">1</span><span id="roundInfo"> | Round <span id="round">1</span></span></div>
<div style="display:flex;gap:0.25rem">
<button onclick="showSigilarium()" style="padding:0.25rem 0.5rem;background:#9333ea;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="Sigilarium">üåÄ</button>
<button onclick="toggleToastLog()" style="padding:0.25rem 0.5rem;background:#22c55e;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="Combat Log">ü™µ</button>
<button onclick="showFAQ()" style="padding:0.25rem 0.5rem;background:#f97316;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="FAQ/Help">‚ùì</button>
<button onclick="showSettingsMenu()" style="padding:0.25rem 0.5rem;background:#3b82f6;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="Settings">‚öôÔ∏è</button>
<div id="debugBtn" style="display:none"><button onclick="showDebugMenu()" style="padding:0.25rem 0.5rem;background:#3b82f6;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="Debug">üõ†Ô∏è</button></div>
</div>
<div><span id="gold">0</span>G | <span id="xp">0</span>XP</div>
</div>
<div class="game-area" id="gameView"></div>

<!-- Early error handler - catches parse errors in main script -->
<script>
// ===== VERSION CHECK =====
const GAME_VERSION = 'S_1.28';
console.log(`%cüê∏ FROGGLE v${GAME_VERSION} LOADED`, 'color: #22c55e; font-size: 20px; font-weight: bold;');

// Debug logging - only outputs when S.debugMode is true
function debugLog(...args) {
if(typeof S !== 'undefined' && S.debugMode) console.log(...args);
}

// ===== GAME DATA =====
// Hero images
const HERO_IMAGES = {
        warrior: 'assets/characters/warriorfull.png',
        tank: 'assets/characters/tankfull.png',
        mage: 'assets/characters/magefull.png',
        healer: 'assets/characters/healerfull.png',
        tapo: 'assets/characters/tapofull.png'
    };

// Hero reaction images (happy/pained expressions)
const HERO_REACTIONS = {
    warrior: {
        happy: 'assets/reactions/warrior-happy.jpeg',
        pained: 'assets/reactions/warrior-pained.jpeg'
    },
    tank: {
        happy: 'assets/reactions/tank-happy.jpeg',
        pained: 'assets/reactions/tank-pained.jpeg'
    },
    mage: {
        happy: 'assets/reactions/mage-happy.jpeg',
        pained: 'assets/reactions/mage-pained.jpeg'
    },
    healer: {
        happy: 'assets/reactions/healer-happy.jpeg',
        pained: 'assets/reactions/healer-pained.jpeg'
    }
    // Tapo doesn't have reaction images yet
};

// Get hero image based on current reaction state
function getHeroImage(hero) {
    const heroKey = hero.n.toLowerCase();
    const reactions = HERO_REACTIONS[heroKey];

    // Last stand always shows pained
    if (hero.ls && reactions?.pained) {
        return reactions.pained;
    }

    // Check for temporary reaction
    if (hero.reaction && reactions?.[hero.reaction]) {
        return reactions[hero.reaction];
    }

    // Default image
    return HERO_IMAGES[heroKey] || '';
}

// Set a temporary reaction on a hero (clears after duration)
function setHeroReaction(heroId, reaction, duration = 800) {
    const hero = S.heroes.find(h => h.id === heroId);
    if (!hero) return;

    const heroKey = hero.n.toLowerCase();
    if (!HERO_REACTIONS[heroKey]?.[reaction]) return; // No reaction image available

    hero.reaction = reaction;
    render();

    // Clear reaction after duration (unless it's permanent like last stand pained)
    if (duration > 0) {
        setTimeout(() => {
            if (hero.reaction === reaction) {
                hero.reaction = null;
                render();
            }
        }, duration);
    }
}

// Set reaction on all heroes
function setAllHeroesReaction(reaction, duration = 800) {
    S.heroes.forEach(h => {
        if (!h.ls) { // Don't override last stand
            setHeroReaction(h.id, reaction, duration);
        }
    });
}

// Death's dialogue lines (cycles through without repeating until all used)
const DEATH_QUOTES = [
    "Some days you're the sticky tongue, some days you're the fly.",
    "You must really like pain or something. Weirdo.",
    "Next time bring me a smoothie or something",
    "Hey, have you met those ghost boys in the dungeon? I can't get them to make.. you know.. the transition. Help them out, would you?",
    "Death death lemonade, 'round the coroner I parade. Hehe!",
    "Ribbit? Ribbbbbit? Rib bit?",
    "Oh man, a classic green. You just know he's a jumper.",
    "Hello my baby, hello my honey.",
    "If you refuse me, honey you'll lose me, and you'll be left alooooooone",
    "You guys should check out the Discovery Channel to see what normal frogs do",
    "Toadally froggin died, huh?",
    "Send me a kiss by wire, honey my heart's on fire",
    "Maybe try making a beer commercial or something?",
    "At least you don't have to cross a busy highway!",
    "Stay out of pots full of lukewarm water!",
    "Mark Twain keeps my mornings busy *rimshot*",
    "\"Analyzing humor is like dissecting a frog\". Know why? Look it up.",
    "Where does \"frog in your throat\" come from? Do you guys know?",
    "Is this tadpole really worth it?",
    "Ohh, it's pronounced Ta-po like Tad-pole, not Tah-po. Duh."
];

const H = {
warrior: {n:'Warrior', p:2, h:5, m:5, s:['Attack','D20']},
tank: {n:'Tank', p:1, h:10, m:10, s:['Attack','Shield','D20']},
mage: {n:'Mage', p:1, h:5, m:5, s:['Attack','D20','Expand']},
healer: {n:'Healer', p:1, h:5, m:5, s:['Heal','D20','Expand']},
tapo: {n:'Tapo', p:1, h:1, m:1, s:['D20']}
};

// Enemy sigil pools and level restrictions:
// - pool: array of sigils enemy can draw (Asterisk only eligible turn 1)
// - maxLevel: default max level for all sigils (default: 1)
// - sigilLevels: override max level for specific sigils {Attack:2, Shield:2, etc}
// - Star and D20 are NEVER available to enemies
const E = {
fly: { n:'Fly', p:1, h:2, m:2, goldDrop:0, x:0, pool:[], gainRate:999, startSigils:[{s:'Attack',l:1}] },
goblin: { n:'Goblin', p:1, h:5, m:5, goldDrop:1, x:2, pool:['Asterisk','Expand','Shield'], maxLevel:1, gainRate:3 },
wolf: { n:'Wolf', p:2, h:5, m:5, goldDrop:2, x:4, pool:['Asterisk','Expand','Shield','Grapple','Alpha'], maxLevel:1, gainRate:2 },
orc: { n:'Orc', p:2, h:10, m:10, goldDrop:3, x:6, pool:['Asterisk','Expand','Shield','Grapple','Alpha','Heal','Ghost'], maxLevel:1, gainRate:2, alternating: true, altSigil: {s:'Attack',l:2} },
giant: { n:'Giant', p:3, h:12, m:12, goldDrop:6, x:12, pool:['Asterisk','Expand','Shield','Grapple','Alpha','Heal','Ghost','Attack'], maxLevel:1, sigilLevels:{Attack:2,Shield:2,Heal:2}, gainRate:1, startSigils:[{s:'Shield',l:1}] },
caveTroll: { n:'Cave Troll', p:4, h:15, m:15, goldDrop:10, x:15, pool:['Expand','Shield','Grapple','Alpha','Heal','Ghost'], maxLevel:2, gainRate:1, rage: true, ragePattern: [1,2,3] },
dragon: { n:'Dragon', p:5, h:20, m:20, goldDrop:20, x:25, pool:['Expand','Shield','Grapple','Alpha','Heal','Ghost'], maxLevel:2, gainRate:1, drawsPerTurn:1, permSigils:[{s:'Attack',l:2},{s:'Expand',l:1}] },
flydra: { n:'Flydra', p:5, h:25, m:25, goldDrop:0, x:50, pool:['Shield','Grapple','Alpha','Heal','Ghost'], maxLevel:2, gainRate:1, isFlydra:true, permSigils:[{s:'Attack',l:2},{s:'Expand',l:2}] }
};

// Enemy emoji icons
const ENEMY_EMOJI = {
'Fly': 'ü™∞',
'Goblin': 'üë∫',
'Wolf': 'üê∫',
'Orc': 'üëπ',
'Giant': 'üóø',
'Cave Troll': 'üßå',
'Dragon': 'üêâ',
'Flydra': 'üê≤'
};

// Enemy artwork images (replaces emojis for main enemies)
// Fly keeps emoji (tutorial only), Flydra uses FLYDRA_HEADS
const ENEMY_IMAGES = {
'Goblin': 'assets/enemies/goblin.jpeg',
'Wolf': 'assets/enemies/wolf.jpeg',
'Giant': 'assets/enemies/giant.jpeg',
'Orc': 'assets/enemies/orc.png',
'Cave Troll': 'assets/enemies/cave_troll.png',
'Dragon': 'assets/enemies/dragon.jpeg'
};

// Flydra head images and names (for multi-headed boss)
// Standard mode (2 heroes): uses 'left' and 'right' heads (A, B)
// FU mode (3 heroes): uses all three heads (A, B, C)
const FLYDRA_HEADS = {
left: { name: 'Flydra A', image: 'assets/flydra_venomwing.png' },
center: { name: 'Flydra B', image: 'assets/flydra_dreadmaw.png' },
right: { name: 'Flydra C', image: 'assets/flydra_blightfang.png' }
};

// Sigil icons - now using extracted PNG images with transparent backgrounds
const SIGIL_IMAGES = {
'Attack': 'assets/sigils/attack.png',
'Shield': 'assets/sigils/shield.png',
'Heal': 'assets/sigils/heal.png',
'D20': 'assets/sigils/d20.png',
'Asterisk': 'assets/sigils/asterisk.png',
'Alpha': 'assets/sigils/alpha.png',
'Expand': 'assets/sigils/expand.png',
'Grapple': 'assets/sigils/grapple.png',
'Star': 'assets/sigils/star.png',
'Ghost': 'assets/sigils/ghost.png'
};

// Helper function to display sigil with icon
function sigilIcon(name) {
const imgPath = SIGIL_IMAGES[name];
if (!imgPath) return `<span>${name}</span>`;
return `<img src="${imgPath}" style="height:1em;vertical-align:middle;display:inline-block;margin-right:0.25em;filter:brightness(0);" alt="${name}">${name}`;
}

// Helper function to display just the icon
function sigilIconOnly(name, level = null) {
const imgPath = SIGIL_IMAGES[name];
if (!imgPath) return `<span>${name}</span>`;
// CSS handles coloring via .sigil.l0 img, .sigil.l1 img, etc.
const icon = `<img src="${imgPath}" style="height:1.4em;vertical-align:middle;display:inline-block;" alt="${name}">`;
// Add level number as superscript for all levels >= 1
if (level !== null && level >= 1) {
return `${icon}<sup>${level}</sup>`;
}
return icon;
}

// Sigil descriptions for tooltips
// Format: scaling values use <b class="sig-scale">ONE</b> to indicate level-dependent values
const SIGIL_DESCRIPTIONS = {
'Attack': 'Deal POW damage to target <b class="sig-scale">ONE</b> time. L2: twice. L3: 3√ó. L4: 4√ó.',
'Shield': 'Grant target <b class="sig-scale">+2√óPOW</b> shield. L2: +4√ó. L3: +6√ó. L4: +8√ó. Shields persist between battles (capped at max HP).',
'Heal': 'Restore <b class="sig-scale">2√óPOW</b> HP to target. L2: 4√ó. L3: 6√ó. L4: 8√ó. Cannot exceed max HP.',
'D20': 'Attempt a gambit! Roll <b class="sig-scale">ONE</b> d20. L2: 2 dice (take best). L3: 3 dice. L4: 4 dice.',
'Expand': 'PASSIVE (works automatically): Add <b class="sig-scale">+1</b> target per level to multi-target actions (Attack, Shield, Heal, Alpha, Grapple). Mage/Healer get +1 built-in.',
'Grapple': 'Stun target for <b class="sig-scale">ONE</b> turn. L2: 2 turns. L3: 3 turns. User takes recoil damage equal to target\'s POW. Stun stacks with existing stun!',
'Ghost': 'Gain <b class="sig-scale">ONE</b> Ghost charge. L2: 2 charges. L3: 3. L4: 4. Each charge prevents one lethal hit. Charges persist between combats (max 9).',
'Asterisk': 'PASSIVE (works automatically): Your first action each combat triggers <b class="sig-scale">ONE</b> extra time. L2: 2 extra. L3: 3 extra. L4: 4 extra.',
'Star': 'PASSIVE (works automatically): Multiply combat XP by <b class="sig-scale">1.5√ó</b>. L2: 2√ó. L3: 2.5√ó. L4: 3√ó. Stacks across all heroes!',
'Alpha': 'Grant target hero <b class="sig-scale">ONE</b> extra action this turn. L2: 2 actions. L3: 3 actions. L4: 4 actions.'
};

// ===== SIGIL ORDERING =====
// Define consistent sigil order for hero cards and displays
// Top row (actives): Attack, Shield, Heal, Grapple, D20 (D20 always top right)
// Bottom row: Alpha (bottom left), Ghost, Expand, Star, Asterisk (bottom right, passive)
const SIGIL_ORDER = ['Attack', 'Shield', 'Heal', 'Grapple', 'D20', 'Alpha', 'Ghost', 'Expand', 'Star', 'Asterisk'];

function sortSigils(sigils) {
if (!Array.isArray(sigils)) return sigils;
return [...sigils].sort((a, b) => {
const aName = typeof a === 'string' ? a : a.sig;
const bName = typeof b === 'string' ? b : b.sig;
const aIndex = SIGIL_ORDER.indexOf(aName);
const bIndex = SIGIL_ORDER.indexOf(bName);
// If not in order array, put at end
if (aIndex === -1 && bIndex === -1) return 0;
if (aIndex === -1) return 1;
if (bIndex === -1) return -1;
return aIndex - bIndex;
});
}

// Render sigils in proper 2-row formation
// Formation: 1-3 = 1 row, 4 = 2x2, 5 = 3+2, 6 = 3+3, 7 = 4+3, 8 = 4+4, 9 = 5+4, 10 = 5+5
function renderSigilRows(sigils, heroIdx, options = {}) {
const { compact = false, clickable = false, onClick = null } = options;
const sorted = sortSigils(sigils);
const count = sorted.length;

// Calculate row distribution
let row1Count, row2Count;
if (count <= 3) {
row1Count = count;
row2Count = 0;
} else if (count === 4) {
row1Count = 2;
row2Count = 2;
} else {
row1Count = Math.ceil(count / 2);
row2Count = count - row1Count;
}

const row1Sigils = sorted.slice(0, row1Count);
const row2Sigils = sorted.slice(row1Count);

// Determine if we need compact sizing for many sigils
const needsCompact = compact || count >= 7;
const sigilClass = needsCompact ? 'sigil-row compact' : 'sigil-row';

const renderSigil = (s) => {
const sigName = typeof s === 'string' ? s : s.sig;
const lvl = typeof heroIdx === 'number' ? getLevel(sigName, heroIdx) : (typeof s === 'object' && s.level !== undefined ? s.level : 1);
const cl = lvl===0?'l0':lvl===1?'l1':lvl===2?'l2':lvl===3?'l3':lvl===4?'l4':'l5';
const passiveClass = ['Expand', 'Asterisk', 'Star'].includes(sigName) ? 'passive' : '';
const clickableClass = clickable ? 'clickable' : '';
const clickHandler = onClick ? `onclick="${onClick}('${sigName}')"` : '';
const ariaRole = clickable || onClick ? 'role="button" tabindex="0"' : '';
const ariaLabel = `aria-label="${sigName} level ${lvl}"`;
return `<span class="sigil ${cl} ${passiveClass} ${clickableClass}" ${ariaRole} ${ariaLabel} ${clickHandler} onmouseenter="showTooltip('${sigName}', this, ${lvl})" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sigName}', this, ${lvl}), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly(sigName, lvl)}</span>`;
};

let html = `<div class="${sigilClass}">`;
row1Sigils.forEach(s => html += renderSigil(s));
html += '</div>';

if (row2Sigils.length > 0) {
html += `<div class="${sigilClass}">`;
row2Sigils.forEach(s => html += renderSigil(s));
html += '</div>';
}

return html;
}

// ===== UTILITY FUNCTIONS =====
// Unified dice rolling utility
function rollDice(count, sides = 20) {
// Play dice roll sound for D20s
if(sides === 20) SoundFX.play('d20roll');

// Debug mode: Oops All 20s
if(S.oopsAll20s && sides === 20) {
const rolls = Array(count).fill(20);
SoundFX.play('nat20');
return {rolls, best: 20};
}
const rolls = [];
for(let i = 0; i < count; i++) {
rolls.push(Math.ceil(Math.random() * sides));
}
const best = Math.max(...rolls);
const worst = Math.min(...rolls);

// Play special sounds for nat 20 and nat 1
if(sides === 20) {
if(best === 20) {
  setTimeout(() => SoundFX.play('nat20'), 350); // After dice roll sound
} else if(worst === 1 && best < 10) {
  setTimeout(() => SoundFX.play('nat1'), 350); // Sad trombone for bad rolls with a 1
}
}
return {rolls, best};
}

// Get display name for enemy with A, B, C suffix if there are duplicates
// Adds "FU " prefix in Frogged Up mode
function getEnemyDisplayName(enemy) {
if (!enemy || !S.enemies) return enemy?.n || '';
const prefix = S.gameMode === 'fu' ? 'FU ' : '';
// Count enemies with same base name
const sameName = S.enemies.filter(e => e.n === enemy.n);
if (sameName.length <= 1) return prefix + enemy.n;
// Find position of this enemy among same-named enemies
const index = sameName.findIndex(e => e.id === enemy.id);
if (index === -1) return prefix + enemy.n;
// Add suffix: A, B, C, etc.
const suffix = String.fromCharCode(65 + index); // 65 = 'A'
return `${prefix}${enemy.n} ${suffix}`;
}

// Helper for enemy attacks - handles targeting, damage, animations, and toast
function executeEnemyAttackOnHeroes(enemy, targetCount, attackName = 'Base Attack') {
// JUICE: Enemy attack slide animation (charges toward heroes)
triggerEnemyAttackAnimation(enemy.id);

const targets = selectEnemyTargets(enemy, targetCount);
if(targets.length === 0) return 0;

const damagedIds = [];
const targetDetails = [];
const dmg = enemy.p;
targets.forEach(target => {
if(target.h > 0) {
const hpBefore = target.h;
const shBefore = target.sh || 0;
damagedIds.push(target.id);
// Apply damage silently (we'll show one toast for all targets)
const result = applyDamageToTarget(target, dmg, {isHero: true, silent: true});
const hpAfter = target.h;
const shAfter = target.sh || 0;
targetDetails.push({name: target.n, hpBefore, hpAfter, shBefore, shAfter, shieldLost: result.shieldLost, hpLost: result.hpLost, dmg: dmg});
}
});

// Trigger hit animations when enemy "lands" the hit
setTimeout(() => {
damagedIds.forEach((id, idx) => {
triggerHitAnimation(id);
// JUICE: Floating damage numbers for hero damage
showFloatingNumber(id, `-${dmg}`, dmg >= 5 ? 'critical' : 'damage', idx * 15);
// Show pained reaction when hero takes damage
const hero = S.heroes.find(h => h.id === id);
if(hero) setHeroReaction(id, 'pained', hero.ls ? 0 : 600);
});

// JUICE: Sinister sound for enemy attacks on heroes + screen shake
if(damagedIds.length > 0) {
SoundFX.play(dmg >= 5 ? 'enemyCrit' : 'enemyHit');
triggerScreenShake(dmg >= 5); // Heavy shake for big hits
}
}, ANIMATION_TIMINGS.ATTACK_IMPACT);

if(targetDetails.length > 0) {
const targetStrings = targetDetails.map(t => {
let str = `${t.name} (`;
if(t.shieldLost > 0) str += `üõ°${t.shBefore}‚Üíüõ°${t.shAfter} `;
str += `‚ù§${t.hpBefore}‚Üí‚ù§${t.hpAfter})`;
return str;
});
toast(`${getEnemyDisplayName(enemy)}'s ${attackName} hit ${targetStrings.join(', ')}!`);
}

return targets.length;
}

// ===== RENDER HELPERS =====
// Render encampment enemy selection screen
function renderEncampmentSelection() {
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets.length;
let html = '<div class="combat-header">';
html += `<div class="combat-header-title">Encampment Early Kill</div>`;
html += `<div class="combat-header-subtitle">Click ${kills} enem${kills>1?'ies':'y'} to remove before combat (${selected}/${kills} selected)</div>`;
html += '</div>';
html += '<div class="combat-grid">';
html += '<div class="column heroes">';
html += '<div class="section-label">HEROES</div>';
S.heroes.forEach((h,i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
const heroImage = getHeroImage(h);
html += `<div class="card hero">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${h.n}</div>
${heroImage ? `<img src="${heroImage}" alt="${h.n}" class="card-image">` : ''}
<div class="sigil-divider"></div>`;
const activeSigils = [...h.s, ...(h.ts || [])];
html += renderSigilRows(activeSigils, i);
html += `<div class="card-stats">${h.p}üí• | ${hp}${extra.length>0?' | '+extra.join(' '):''}</div>`;
html += '</div>';
});
html += '</div>';
html += '<div class="column enemies">';
html += '<div class="section-label">ENEMIES</div>';
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });
S.heroes.forEach((hero, laneIdx) => {
const laneEnemies = enemyLanes[laneIdx] || [];
html += `<div class="combat-lane" data-lane="${laneIdx+1}">`;
if(laneEnemies.length === 0) {
html += `<div class="empty-slot">Empty</div>`;
} else {
laneEnemies.forEach(e => {
const isSelected = S.encampmentSelectedTargets.includes(e.id);
let cardClasses = 'card enemy targetable';
if(isSelected) cardClasses += ' targeted';
const extra = [];
if(e.sh > 0) extra.push(`${e.sh}üõ°`);
if(e.g > 0) extra.push(`${e.g}${sigilIconOnly('Ghost')}`);
if(isSelected) extra.push('‚ùå');
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
const enemyImageSrc = ENEMY_IMAGES[e.n];
html += `<div class="${cardClasses}" onclick="selectEncampmentTarget('${e.id}')">`;
if(enemyImageSrc) {
html += `<div class="card-emoji"><img src="${enemyImageSrc}" alt="${e.n}" style="width:40px;height:40px;object-fit:contain;border-radius:4px"></div>`;
} else {
html += `<div class="card-emoji">${enemyEmoji}</div>`;
}
html += `<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${getEnemyDisplayName(e)}</div>
<div class="card-stats">${e.p}üí• | ${e.h}/${e.m}‚ù§${extra.length>0?' | '+extra.join(' '):''}</div>
<div class="sigil-divider"></div>
<div class="sigil-row">`;
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
if(!hasAttackSigil) {
html += `<span class="sigil l1">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig, sigil.level)}</span>`;
});
html += '</div></div>';
});
}
html += '</div>';
});
html += '</div></div>';
if(selected >= kills) {
html += '<button class="btn danger" style="margin-top:1rem" onclick="confirmEncampmentKills()">Confirm Removals</button>';
}
return html;
}

// Render combat status header
function renderCombatStatusHeader() {
let html = '<div class="combat-header">';
if(S.turn!=='player') {
if(S.enemyTurnTotal && S.enemyTurnCurrent) {
html += `<div class="combat-header-title">Enemy Turn</div>`;
html += `<div class="combat-header-subtitle">Enemy ${S.enemyTurnCurrent}/${S.enemyTurnTotal} acting‚Ä¶</div>`;
} else {
html += 'Enemy Turn‚Ä¶';
}
} else if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
const selected = S.targets.length;
html += `<div class="combat-header-title">${S.d20Action} (DC ${S.d20DC})</div>`;
const targetText = maxTargets >= 2 ? `targets: ${selected}/${maxTargets}` : 'Select target';
html += `<div class="combat-header-subtitle">${targetText}</div>`;
} else if(S.pending) {
const targetsPerInstance = getTargetsPerInstance(S.pending, S.activeIdx);
const targetType = needsEnemyTarget(S.pending) ? 'enemy' : 'hero';
if(isMultiInstance(S.pending)) {
const targetsInInstance = S.currentInstanceTargets.length;
html += `<div class="combat-header-title">${S.pending}</div>`;
const targetText = targetsPerInstance >= 2 ? `targets: ${targetsInInstance}/${targetsPerInstance}` : `Select ${targetType}`;
html += `<div class="combat-header-subtitle">${targetText}</div>`;
html += `<div class="combat-header-info">${S.instancesRemaining} instance${S.instancesRemaining>1?'s':''} remaining</div>`;
} else {
const selected = S.targets.length;
const max = targetsPerInstance;
html += `<div class="combat-header-title">${S.pending}</div>`;
const targetText = max >= 2 ? `targets: ${selected}/${max}` : `Select ${targetType}`;
html += `<div class="combat-header-subtitle">${targetText}</div>`;
}
} else if(S.activeIdx === -1) {
const remaining = S.heroes.filter((h,i) => !S.acted.includes(i) && h.st === 0).length;
const allStunned = remaining === 0 && S.heroes.every(h => h.st > 0);
if(allStunned) {
html += `<div class="combat-header-title" style="color:#f97316">‚ö†Ô∏è AMBUSH! ‚ö†Ô∏è</div>`;
html += `<div class="combat-header-subtitle" style="opacity:0.9">All heroes are stunned!</div>`;
html += `<button class="btn" onclick="confirmAmbushSkip()" style="margin-top:0.5rem;padding:0.5rem 1.5rem">Continue to Enemy Turn</button>`;
} else {
html += `<div class="combat-header-title pulse-prompt">Tap a hero's sigil</div>`;
html += `<div class="combat-header-subtitle" style="opacity:0.8">${remaining} hero${remaining>1?'es':''} remaining</div>`;
}
} else {
const h = S.heroes[S.activeIdx];
if(h) {
if(h.ls) html += `${h.n} Last Stand (Turn ${h.lst + 1}) - D20 only!`;
else html += `${h.n}'s Turn`;
}
}
html += '</div>';

// Add action bar when we have targets selected - simplified for controller flow
// D20_TARGET uses S.targets, other actions use S.currentInstanceTargets
const hasTargetsForActionBar = S.pending === 'D20_TARGET'
? (S.targets && S.targets.length > 0)
: (S.currentInstanceTargets && S.currentInstanceTargets.length > 0);
if(S.turn === 'player' && S.pending && hasTargetsForActionBar) {
const targetArray = S.pending === 'D20_TARGET' ? S.targets : S.currentInstanceTargets;
const targetCount = targetArray.length;
const targetNames = targetArray.map(t => {
const unit = [...(S.heroes || []), ...(S.enemies || [])].find(u => u.id === t);
return unit ? unit.n : 'target';
}).join(', ');
html += '<div class="target-action-bar" style="display:flex;flex-direction:column;gap:0.25rem;align-items:center;margin-top:0.5rem">';
html += `<div style="font-size:0.85rem;opacity:0.9">Target${targetCount > 1 ? 's' : ''}: <strong>${targetNames}</strong></div>`;
html += '<div style="display:flex;gap:0.5rem">';
html += `<button class="btn safe" onclick="confirmTargets()" style="padding:0.4rem 1rem;font-size:0.9rem">‚úì Confirm (‚í∂/‚ä°)</button>`;
html += `<button class="btn secondary" onclick="cancelAction()" style="padding:0.4rem 1rem;font-size:0.9rem">‚úó Cancel (‚í∑)</button>`;
html += '</div>';
html += '</div>';
}

return html;
}

// Unified damage application with shield/ghost/laststand handling
function applyDamageToTarget(target, rawDamage, options = {}) {
let dmg = rawDamage;
let shieldLost = 0;
let hpLost = 0;

// Handle shield absorption
if(target.sh > 0) {
if(target.sh >= rawDamage) {
shieldLost = rawDamage;
target.sh -= rawDamage;
dmg = 0;
} else {
shieldLost = target.sh;
dmg = rawDamage - target.sh;
target.sh = 0;
}
}

// Apply damage to HP
hpLost = dmg;
target.h -= dmg;

// LAYER 1: Warning when hero drops below 30% HP (preventive Last Stand warning)
// Skip during tutorial - Tapo intervention handles this without explaining Last Stand
if(options.isHero && !target.ls && target.h > 0 && target.h < target.m * 0.3) {
// Check if this is the first time we're warning about low HP (and not in tutorial)
if(!S.tutorialFlags.last_stand_warning && !(tutorialState && S.floor === 0)) {
showTutorialPop('last_stand_warning', `${target.n} is in danger! If they reach 0 HP, they'll enter Last Stand mode - they can only use D20 gambits, and each turn makes survival harder. Use Ghost charges or heal up to avoid it!`);
}
}

// Handle lethal damage
if(target.h <= 0) {
if(target.g > 0) {
// Ghost charge fully negates the hit (restores HP and shield)
target.g--;
target.h += dmg;
target.sh += shieldLost;
hpLost = 0;
shieldLost = 0;
// QUEST TRACKING: Ghost blocked damage
if(options.isHero && typeof trackQuestProgress === 'function') trackQuestProgress('ghostBlock');
if(!options.silent) {
toast(`${target.n}'s Ghost charge cancelled the lethal hit!`, 1200);
}
} else {
// Death/Last Stand
target.h = 0;
if(options.isHero) {
// TUTORIAL PHASE 1: Override Last Stand with Tapo rescue
// IMPORTANT: Only trigger during ENEMY turn, not player turn (e.g., Grapple recoil)
if(tutorialState && S.floor === 0 && tutorialState.phase === 1 && S.turn === 'enemy') {
// Tapo saves the day! Prevent actual death
target.h = 1;
// Show the full Tapo rescue sequence with narrative and animated fly deaths
if(typeof showTapoRescueSequence === 'function') {
showTapoRescueSequence();
}
return {hpLost: 0, shieldLost, totalDamage: rawDamage};
}
// Heroes enter Last Stand (guard against re-entry resetting lst)
if(!target.ls) {
target.ls = true;
target.lst = 0;
triggerScreenShake(true); // Heavy shake on entering last stand
if(!options.silent) {
// LAYER 2: Extended toast duration (3000ms instead of default)
toast(`${target.n} entered Last Stand!`, 3000);
// Skip Last Stand explanation during tutorial - Tapo intervention prevents it
if(!(tutorialState && S.floor === 0)) {
showTutorialPop('last_stand_intro', "When a hero drops to 0 HP, they enter Last Stand! They can only use D20 gambits, and each turn makes success harder. Heal them to bring them back!");
}
}
}
} else {
// Enemies die - award gold/XP and schedule removal
// Skip rewards for Floor 0 tutorial
if(!options.skipRewards && S.floor !== 0) {
// FLYDRA: Skip gold on head "death" - heads can revive! Gold awarded at combat completion
if(!target.isFlydra) {
S.gold += target.goldDrop || 0;
S.combatGold += target.goldDrop || 0;
// QUEST TRACKING: Gold earned
if(target.goldDrop > 0 && typeof trackQuestProgress === 'function') trackQuestProgress('gold', target.goldDrop);
// JUICE: Coin sound for gold drops
if(target.goldDrop > 0) SoundFX.play('coinDrop');
}
// XP is fine to award per head (player can't spend it after victory anyway)
S.combatXP += target.x;
upd();
}
}
}
}

return {hpLost, shieldLost, totalDamage: rawDamage}; // Return detailed breakdown
}

// ===== TUTORIAL SYSTEM =====
// Centralized Tutorial Manager for Ribbleton combat tutorial
const TutorialManager = {
// Tutorial stage definitions
stages: {
// Phase 1 stages
'waiting_for_start': {allowedActions: []},
'catching_flies': {allowedActions: 'ALL'}, // Phase 1: Free-form fly catching
// Phase 2 stages
'warrior_attack': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'targeting_wolf': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'healer_d20': {allowedActions: [{hero: 'Healer', sig: 'D20'}]},
'd20_menu': {allowedActions: [{hero: 'Healer', sig: 'D20'}]},
'enemy_turn_wait': {allowedActions: []},
'enemy_turn_explained': {allowedActions: []},
'healer_heal': {allowedActions: [{hero: 'Healer', sig: 'Heal'}]},
'expand_targets': {allowedActions: [{hero: 'Healer', sig: 'Heal'}]},
'finish_wolf': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'shield_sigil': {allowedActions: []},
'free': {allowedActions: 'ALL'} // Tutorial complete, allow all actions
},

// Check if an action is allowed in current tutorial stage
canPerformAction(hero, sig) {
if(!tutorialState || S.floor !== 0) return true; // Not in tutorial
const stage = this.stages[tutorialState.stage];
if(!stage) return true; // Unknown stage, allow
if(stage.allowedActions === 'ALL') return true; // Free-form stage

const allowed = stage.allowedActions;
if(allowed.length === 0) return false; // No actions allowed in this stage

return allowed.some(a => a.hero === hero.n && a.sig === sig);
},

// Get descriptive message for current tutorial stage
getInstructionMessage() {
if(!tutorialState || S.floor !== 0) return "Follow the tutorial instructions!";
const stage = tutorialState.stage;

// Stage-specific messages
const messages = {
'waiting_for_start': "Wait for the tutorial to begin!",
'warrior_attack': "Click the Warrior's Attack sigil, then target the Wolf!",
'targeting_wolf': "Click the Wolf to target it with your Attack!",
'healer_d20': "Click the Healer's D20 for powerful gambit actions!",
'd20_menu': "Select a D20 gambit option!",
'enemy_turn_wait': "Wait for the enemy turn to complete!",
'enemy_turn_explained': "Wait for the next round to begin!",
'healer_heal': "Click the Healer's Heal sigil!",
'expand_targets': "Select targets for your Heal with Expand!",
'finish_wolf': "Use your abilities to defeat the remaining enemies!",
'shield_sigil': "Wait and watch what happens!"
};

return messages[stage] || "Follow the tutorial instructions!";
},

// Advance to next stage based on action completion
advanceStage(context) {
if(!tutorialState || S.floor !== 0) return;

const {action, hero, round} = context;

// Stage transitions based on completed actions
if((tutorialState.stage === 'warrior_attack' || tutorialState.stage === 'targeting_wolf') && tutorialState.wolfDamaged && hero === 'Warrior' && round === 1) {
tutorialState.stage = 'healer_d20';
showTutorialPop('ribbleton_healer_d20', "Healer doesn't start with the Attack Sigil, but they can still do some damage with a Gambit - a powerful action that depends on a die roll! Click the Healer's D20!", () => {
S.activeIdx = 1;
render();
});
}
else if(tutorialState.stage === 'd20_menu' && hero === 'Healer') {
tutorialState.stage = 'enemy_turn_wait';
}
else if(tutorialState.stage === 'expand_targets' && hero === 'Healer') {
tutorialState.stage = 'finish_wolf';
// REMOVED: "Finish Wolf" popup - trust player to continue combat after heal
}
},

// Handle round transitions during tutorial
onRoundStart(round) {
if(!tutorialState || S.floor !== 0) return;

debugLog('[TUTORIAL] Round transition - Round:', round, 'Stage:', tutorialState.stage);

// PHASE 1 (Fly Catching): Round 2 - Mage already has Expand, just continue
if(tutorialState.phase === 1 && round === 2) {
debugLog('[TUTORIAL] Phase 1 Round 2 - Continuing combat (Mage already has Expand)');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
upd();
render();
return;
}

// PHASE 2 (Ribbleton): Round 2: Healer Heal prompt (NOW BATCHED WITH EXPAND)
if(round === 2 && (tutorialState.stage === 'enemy_turn_explained' || tutorialState.stage === 'finish_wolf') && !S.tutorialFlags.ribbleton_healer_heal) {
debugLog('[TUTORIAL] Triggering PROMPT 4 - Healer Heal (stage:', tutorialState.stage, ')');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'healer_heal';
upd();
// Show healing prompt popup
showTutorialPop('ribbleton_healer_heal', "Yikes! Both of you took some damage - but Healer knows what she's doing! Tap her Heal sigil!", () => {
S.activeIdx = 1;
render();
});
} else if(round === 2 && !S.tutorialFlags.ribbleton_healer_heal) {
debugLog('[TUTORIAL] Round 2 but stage is:', tutorialState.stage, '(expected: enemy_turn_explained or finish_wolf) - forcing healer_heal anyway');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'healer_heal';
upd();
// Show healing prompt popup
showTutorialPop('ribbleton_healer_heal', "Yikes! Both of you took some damage - but Healer knows what she's doing! Tap her Heal sigil!", () => {
S.activeIdx = 1;
render();
});
}
// Round 3: Force Goblin to draw Shield, then PROMPT 5 (Enemy Sigils batched) + PROMPT 6 (Tooltip + Handoff batched)
else if(round === 3 && tutorialState.stage === 'finish_wolf') {
// Force Goblin to draw Shield
const goblin = S.enemies.find(e => e.n === 'Goblin');
if(goblin && !goblin.s.some(s => s.sig === 'Shield')) {
goblin.s.push({sig:'Shield', level:1, perm:false});
toast('Goblin drew Shield L1!');
}
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'shield_sigil';
upd();
render();
// PROMPT 5: Enemy Sigils + Shield
showTutorialPop('enemies_get_sigils', "Enemies draw sigils too! The Goblin drew Shield - he'll activate it AFTER attacking this turn, then it's gone. Try to defeat him before he can shield!", () => {
// Player can now act freely - handoff popup will show after they take an action
tutorialState.stage = 'free';
render();
});
}
},

// Handle enemy turn during tutorial - returns true if we're blocking for a popup
onEnemyTurnStart(onContinue) {
if(!tutorialState || S.floor !== 0) return false;
if(tutorialState.stage === 'enemy_turn_wait') {
S.locked = true;
tutorialState.stage = 'enemy_turn_explained';
showTutorialPop('ribbleton_enemy_turn', "Nice gambit! Both enemies hurt themselves! But the enemies are about to attack back...", () => {
S.locked = false;
if(onContinue) onContinue(); // Continue to enemy turn after popup
});
return true; // Blocking - don't start enemy turn yet
}
return false;
}
};

// Tutorial system
let tooltipTimeout = null;
let currentTooltip = null;

// Get level-specific description with colored/bolded numbers
function getLevelDescription(sigilName, level) {
const levelColors = {
0: '#666',
1: '#000',
2: '#06b6d4',
3: '#9333ea',
4: '#d97706',
5: '#ff0080'
};
const color = levelColors[level] || '#000';
const boldNum = (num) => `<strong style="color:${color}">${num}</strong>`;

// Level-specific descriptions
const descriptions = {
'Attack': level === 0 ? 'Not unlocked' : level === 1 ? 'Deal POW damage to target' : `Attack ${boldNum(level)} times for POW damage each`,
'Shield': level === 0 ? 'Not unlocked' : level === 1 ? 'Grant target 2√óPOW shield (persists between battles, capped at max HP)' : `Shield ${boldNum(level)} times for 2√óPOW each (persists between battles, capped at max HP)`,
'Heal': level === 0 ? 'Not unlocked' : level === 1 ? 'Restore 2√óPOW HP to target (cannot exceed max HP)' : `Heal ${boldNum(level)} times for 2√óPOW each (cannot exceed max HP)`,
'D20': `Roll ${boldNum(level)}d20, use best result. Choose gambit: Confuse (enemy hurts itself), Startle (stun), Mend (heal self), Steal (gold), Recruit (join team)`,
'Expand': level === 0 ? 'PASSIVE: Add +1 target to multi-target actions (Attack, Shield, Heal, Alpha, Grapple). Mage/Healer get +1 built-in' : `PASSIVE: Permanently add ${boldNum(level)} extra target${level > 1 ? 's' : ''} to multi-target actions (Attack, Shield, Heal, Alpha, Grapple). Mage/Healer get +1 built-in`,
'Grapple': level === 0 ? 'Not unlocked' : `Stun target for ${boldNum(level)} turn${level > 1 ? 's' : ''}. You take damage equal to target's POW`,
'Ghost': level === 0 ? 'Not unlocked' : `Gain ${boldNum(level)} charge${level > 1 ? 's' : ''}. Each charge prevents one death (persists between combats, max 9)`,
'Asterisk': level === 0 ? 'Not unlocked' : `PASSIVE: Next action triggers ${boldNum(level + 1)} times! Resets after each battle`,
'Star': level === 0 ? 'PASSIVE: Not unlocked' : `PASSIVE: Gain ${boldNum(level * 0.5)}√ó extra XP per battle (stacks with other heroes)`,
'Alpha': level === 0 ? 'Not unlocked' : `Grant target hero ${boldNum(level)} extra action${level > 1 ? 's' : ''} this turn`
};

return descriptions[sigilName] || 'No description available';
}

function showTooltip(sigilName, element, level = 1) {
// Check if tooltips are disabled
if(S.tooltipsDisabled) return;

// Tooltip display (tutorial explanation happens in Ribbleton combat)

const desc = getLevelDescription(sigilName, level);
if(!desc) return;

hideTooltip();

const tooltip = document.createElement('div');
tooltip.className = 'tooltip tooltip-green';
tooltip.innerHTML = `
<div class="tooltip-title">${sigilIcon(sigilName)}</div>
<div class="tooltip-desc">${desc}</div>`;

document.body.appendChild(tooltip);
currentTooltip = tooltip;

// Position tooltip near the element
const rect = element.getBoundingClientRect();
const tooltipRect = tooltip.getBoundingClientRect();
let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
let top = rect.top - tooltipRect.height - 10;

// Keep tooltip on screen horizontally
if(left < 10) left = 10;
if(left + tooltipRect.width > window.innerWidth - 10) left = window.innerWidth - tooltipRect.width - 10;

// Keep tooltip on screen vertically - prefer above, fallback to below
if(top < 10) {
top = rect.bottom + 10;
}
// If tooltip would go off bottom of screen, try above again or clamp
if(top + tooltipRect.height > window.innerHeight - 10) {
// Try putting it above
const aboveTop = rect.top - tooltipRect.height - 10;
if(aboveTop >= 10) {
top = aboveTop;
} else {
// Clamp to bottom of screen
top = window.innerHeight - tooltipRect.height - 10;
}
}

tooltip.style.left = left + 'px';
tooltip.style.top = top + 'px';

setTimeout(() => tooltip.classList.add('show'), 10);
}

function hideTooltip() {
// Clear any pending tooltip timers
if(tooltipTimeout) {
clearTimeout(tooltipTimeout);
tooltipTimeout = null;
}
// Immediately remove current tooltip
if(currentTooltip) {
currentTooltip.remove();
currentTooltip = null;
}
}

// Damage preview calculation - shows expected damage breakdown on hover
function calcDamagePreview(heroIdx, targetId) {
const h = S.heroes[heroIdx];
const target = S.enemies.find(e => e.id === targetId);
if(!h || !target) return null;

const attackLevel = getLevel('Attack', heroIdx);
const damagePerHit = h.p; // POW damage per hit
const hitsRemaining = S.instancesRemaining || attackLevel; // Instances left
const totalDamage = damagePerHit; // Single instance damage

// Calculate shield absorption
let shieldDmg = 0;
let hpDmg = 0;
if(target.sh > 0) {
if(target.sh >= totalDamage) {
shieldDmg = totalDamage;
hpDmg = 0;
} else {
shieldDmg = target.sh;
hpDmg = totalDamage - target.sh;
}
} else {
hpDmg = totalDamage;
}

return { totalDamage, shieldDmg, hpDmg, hitsRemaining, targetHp: target.h, targetSh: target.sh };
}

// Show damage preview tooltip on enemy hover during targeting
// DISABLED: Players can do the math themselves
let currentDmgPreview = null;
function showDamagePreview(targetId, element) {
return; // Disabled per user request
if(!S.pending || S.pending !== 'Attack' || S.activeIdx < 0) return;
hideDamagePreview();

const preview = calcDamagePreview(S.activeIdx, targetId);
if(!preview) return;

const tooltip = document.createElement('div');
tooltip.className = 'damage-preview';

let content = `<div class="dmg-total">-${preview.totalDamage}</div>`;
if(preview.shieldDmg > 0) {
content += `<div class="dmg-shield">-${preview.shieldDmg} shield</div>`;
}
if(preview.hpDmg > 0) {
content += `<div class="dmg-hp">-${preview.hpDmg} HP</div>`;
} else if(preview.shieldDmg > 0) {
content += `<div class="dmg-blocked">Blocked!</div>`;
}

tooltip.innerHTML = content;
document.body.appendChild(tooltip);
currentDmgPreview = tooltip;

// Position near element
const rect = element.getBoundingClientRect();
const tooltipRect = tooltip.getBoundingClientRect();
let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
let top = rect.top - tooltipRect.height - 8;

// Keep on screen
if(left < 5) left = 5;
if(left + tooltipRect.width > window.innerWidth - 5) left = window.innerWidth - tooltipRect.width - 5;
if(top < 5) top = rect.bottom + 8;

tooltip.style.left = left + 'px';
tooltip.style.top = top + 'px';
setTimeout(() => tooltip.classList.add('show'), 10);
}

function hideDamagePreview() {
if(currentDmgPreview) {
currentDmgPreview.remove();
currentDmgPreview = null;
}
}

// Heal preview calculation - shows expected heal breakdown on hover
function calcHealPreview(heroIdx, targetId) {
const h = S.heroes[heroIdx];
const target = S.heroes.find(hero => hero.id === targetId);
if(!h || !target) return null;

const healPerInstance = h.p * 2; // Heal is 2√óPOW
const currentHp = target.h;
const maxHp = target.m;
const actualHeal = Math.min(healPerInstance, maxHp - currentHp);
const overHeal = healPerInstance - actualHeal;

return { totalHeal: healPerInstance, actualHeal, overHeal, targetHp: currentHp, targetMaxHp: maxHp };
}

// Show heal preview tooltip on hero hover during targeting
// DISABLED: Players can do the math themselves
let currentHealPreview = null;
function showHealPreview(targetId, element) {
return; // Disabled per user request
if(!S.pending || S.pending !== 'Heal' || S.activeIdx < 0) return;
hideHealPreview();

const preview = calcHealPreview(S.activeIdx, targetId);
if(!preview) return;

const tooltip = document.createElement('div');
tooltip.className = 'heal-preview';

let content = `<div class="heal-total">+${preview.actualHeal}</div>`;
if(preview.targetHp === preview.targetMaxHp) {
content += `<div class="heal-full">Already full!</div>`;
}

tooltip.innerHTML = content;
document.body.appendChild(tooltip);
currentHealPreview = tooltip;

// Position near element
const rect = element.getBoundingClientRect();
const tooltipRect = tooltip.getBoundingClientRect();
let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
let top = rect.top - tooltipRect.height - 8;

// Keep on screen
if(left < 5) left = 5;
if(left + tooltipRect.width > window.innerWidth - 5) left = window.innerWidth - tooltipRect.width - 5;
if(top < 5) top = rect.bottom + 8;

tooltip.style.left = left + 'px';
tooltip.style.top = top + 'px';
setTimeout(() => tooltip.classList.add('show'), 10);
}

function hideHealPreview() {
if(currentHealPreview) {
currentHealPreview.remove();
currentHealPreview = null;
}
}

// Shield preview calculation - shows expected shield breakdown on hover
function calcShieldPreview(heroIdx, targetId) {
const h = S.heroes[heroIdx];
const target = S.heroes.find(hero => hero.id === targetId);
if(!h || !target) return null;

const shieldPerInstance = h.p * 2; // Shield is 2√óPOW
const currentShield = target.sh || 0;
const maxHp = target.m;
const maxShieldSpace = Math.max(0, maxHp - currentShield);
const actualShield = Math.min(shieldPerInstance, maxShieldSpace);
const overShield = shieldPerInstance - actualShield;

return { totalShield: shieldPerInstance, actualShield, overShield, currentShield, targetMaxHp: maxHp };
}

// Show shield preview tooltip on hero hover during targeting
// DISABLED: Players can do the math themselves
let currentShieldPreview = null;
function showShieldPreview(targetId, element) {
return; // Disabled per user request
if(!S.pending || S.pending !== 'Shield' || S.activeIdx < 0) return;
hideShieldPreview();

const preview = calcShieldPreview(S.activeIdx, targetId);
if(!preview) return;

const tooltip = document.createElement('div');
tooltip.className = 'shield-preview';

let content = `<div class="shield-total">+${preview.actualShield}üõ°</div>`;
if(preview.overShield > 0) {
content += `<div class="shield-capped">+${preview.overShield} capped</div>`;
} else if(preview.currentShield >= preview.targetMaxHp) {
content += `<div class="shield-full">Shield maxed!</div>`;
}

tooltip.innerHTML = content;
document.body.appendChild(tooltip);
currentShieldPreview = tooltip;

// Position near element
const rect = element.getBoundingClientRect();
const tooltipRect = tooltip.getBoundingClientRect();
let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
let top = rect.top - tooltipRect.height - 8;

// Keep on screen
if(left < 5) left = 5;
if(left + tooltipRect.width > window.innerWidth - 5) left = window.innerWidth - tooltipRect.width - 5;
if(top < 5) top = rect.bottom + 8;

tooltip.style.left = left + 'px';
tooltip.style.top = top + 'px';
setTimeout(() => tooltip.classList.add('show'), 10);
}

function hideShieldPreview() {
if(currentShieldPreview) {
currentShieldPreview.remove();
currentShieldPreview = null;
}
}

// Helper to create sigil with tooltip (for death screen with longer hover time)
function sigilIconWithTooltip(sig, level = 1, hoverDelay = 500) {
return `<span onmouseenter="showTooltip('${sig}', this, ${level})" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sig}', this, ${level}), ${hoverDelay})" ontouchend="hideTooltip()">${sigilIcon(sig)}</span>`;
}

function generateFibonacci(n) {
const fib = [1, 1];
for(let i = 2; i < n; i++) fib.push(fib[i-1] + fib[i-2]);
return fib;
}
const FIB = generateFibonacci(50);

// Get XP cost for level up - Fibonacci up to 89, then 100, 200, 300, etc.
function getXPCost(levelUpCount) {
// Find the index where Fibonacci reaches 89 (FIB[10] = 89)
if (levelUpCount >= 10) {
// After Fibonacci 89, increment by 100 each time
// levelUpCount 10 = 100, levelUpCount 11 = 200, levelUpCount 12 = 300, etc.
return (levelUpCount - 9) * 100;
}
return FIB[levelUpCount] || 100;
}

// ===== ANIMATION TIMING CONSTANTS =====
// Centralized timing values for easy tuning and consistency
const ANIMATION_TIMINGS = {
  // CSS animation durations (must match CSS @keyframes)
  DAMAGE_FLASH: 400,      // .hit-flash animation duration
  ATTACK_SLIDE: 480,      // .attack-slide animation duration
  ATTACK_IMPACT: 190,     // When attacker "lands" hit (40% of attack slide)
  HEAL_FLASH: 480,        // .heal-flash animation duration
  SHIELD_FLASH: 480,      // .shield-flash animation duration

  // Screen transition timings
  FADE_TRANSITION: 200,   // Screen fade in/out duration
  FLOOR_INTERSTITIAL: 2000, // Floor name display duration

  // Combat turn timings
  TURN_TRANSITION: 400,   // Hero turn ‚Üí Enemy turn delay
  PHASE_TRANSITION: 300,  // Between enemy phases (Alpha/Recruit/Normal)
  ALPHA_PHASE_START: 500, // Enemy turn start ‚Üí Alpha phase
  ENEMY_ACTION_DELAY: 400, // Stagger between enemy actions (slower for readability)
  ENEMY_TURN_END: 400,    // After last enemy action
  ACTION_COMPLETE: 600,   // After hero action completes

  // Toast message timings
  TOAST_SHORT: 1800,      // Short notification
  TOAST_MEDIUM: 2400,     // Medium notification
  TOAST_LONG: 3000,       // Long notification
  TOAST_FADE: 400,        // Toast fade out duration

  // Tooltip timings
  TOOLTIP_DELAY: 500,     // Long-press delay for mobile tooltips
  TOOLTIP_FADE: 200,      // Tooltip fade in/out

  // Special animations
  BONUS_TURN_STACK: 300,  // Bonus turn card animation
  VICTORY_DELAY: 1000,    // Delay before level up screen
  DEFEAT_DELAY: 1000,     // Delay before death screen
  TUTORIAL_DELAY: 800,    // Tutorial popup delays

  // Juice animations
  FLOATING_NUMBER: 800,   // Floating damage number duration
  SCREEN_SHAKE: 300,      // Screen shake duration
  SCREEN_SHAKE_HEAVY: 400, // Heavy screen shake duration
  CONFETTI_DURATION: 3000, // Confetti fall duration
  COMBO_DISPLAY: 500,     // Combo counter display time
  COUNTER_POP: 300,       // Counter pop animation
  KNOCKOUT: 600,          // Death animation

  // Hero reaction durations
  HERO_REACTION_BRIEF: 600,  // Brief reaction (quick acknowledgement)
  HERO_REACTION_NORMAL: 800, // Normal reaction duration
  HERO_REACTION_LONG: 1200,  // Long reaction (important events)
  HERO_REACTION_PAINED: 1000, // Pain reaction duration
};

// ===== ANIMATION SPEED SYSTEM =====
// Helper function to apply animation speed multiplier
// Speed: 1 = normal, 2 = 2x faster, 4 = 4x faster, 0 = instant
function T(baseTime) {
  const speed = (typeof S !== 'undefined' && S.animationSpeed) || 1;
  if (speed === 0) return 1; // Instant mode: 1ms minimum
  return Math.max(1, Math.round(baseTime / speed));
}

// Get current animation speed label
function getSpeedLabel() {
  const speed = (typeof S !== 'undefined' && S.animationSpeed) || 1;
  switch(speed) {
    case 0: return 'Instant';
    case 2: return '2x';
    case 4: return '4x';
    default: return 'Normal';
  }
}

// ===== JUICE & POLISH SYSTEM =====
// Floating damage/heal numbers
function showFloatingNumber(targetId, text, type = 'damage', offsetX = 0) {
  const card = document.getElementById(targetId);
  if (!card) return;

  const rect = card.getBoundingClientRect();
  const num = document.createElement('div');
  num.className = `floating-number ${type}`;
  num.textContent = text;

  // Random horizontal offset for variety
  const randomX = (Math.random() - 0.5) * 40 + offsetX;
  num.style.left = (rect.left + rect.width / 2 + randomX) + 'px';
  num.style.top = (rect.top + rect.height / 3) + 'px';

  document.body.appendChild(num);
  setTimeout(() => num.remove(), ANIMATION_TIMINGS.FLOATING_NUMBER);
}

// Screen shake effect
function triggerScreenShake(heavy = false) {
  const gameArea = document.getElementById('gameView');
  if (!gameArea) return;

  const className = heavy ? 'screen-shake-heavy' : 'screen-shake';
  gameArea.classList.add(className);
  setTimeout(() => gameArea.classList.remove(className),
    heavy ? ANIMATION_TIMINGS.SCREEN_SHAKE_HEAVY : ANIMATION_TIMINGS.SCREEN_SHAKE);
}

// Confetti celebration - with frog theme!
function spawnConfetti(count = 50) {
  const container = document.createElement('div');
  container.className = 'confetti-container';
  document.body.appendChild(container);

  // Frog-friendly colors (greens, golds, lily pad colors)
  const colors = ['#22c55e', '#16a34a', '#4ade80', '#fbbf24', '#84cc16', '#10b981', '#34d399', '#a3e635'];
  const frogEmojis = ['üê∏', 'üê∏', 'üê∏', 'ü™∑', 'üíö', '‚ú®'];

  for (let i = 0; i < count; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = Math.random() * 100 + '%';
    confetti.style.animationDelay = Math.random() * 0.5 + 's';
    confetti.style.animationDuration = (2 + Math.random() * 2) + 's';

    const rand = Math.random();
    if (rand < 0.2) {
      // 20% chance: Frog emoji
      confetti.style.backgroundColor = 'transparent';
      confetti.style.width = 'auto';
      confetti.style.height = 'auto';
      confetti.style.fontSize = (16 + Math.random() * 16) + 'px';
      confetti.textContent = frogEmojis[Math.floor(Math.random() * frogEmojis.length)];
    } else if (rand < 0.35) {
      // 15% chance: Tiny Tapo image
      confetti.style.backgroundColor = 'transparent';
      confetti.style.width = (20 + Math.random() * 15) + 'px';
      confetti.style.height = 'auto';
      const img = document.createElement('img');
      img.src = 'assets/tapo-icon.png';
      img.style.width = '100%';
      img.style.height = 'auto';
      confetti.appendChild(img);
    } else {
      // 65% chance: Colored shapes
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      if (Math.random() > 0.5) {
        confetti.style.borderRadius = '50%';
      } else if (Math.random() > 0.5) {
        confetti.style.width = '8px';
        confetti.style.height = '14px';
      }
    }

    container.appendChild(confetti);
  }

  setTimeout(() => container.remove(), ANIMATION_TIMINGS.CONFETTI_DURATION + 500);
}

// Damage counter display - shows cumulative damage during a hero's turn
function showDamageCounter(totalDamage) {
  if (totalDamage < 5) return;

  // Remove existing counter if any
  const existing = document.querySelector('.combo-counter');
  if (existing) existing.remove();

  const counter = document.createElement('div');
  counter.className = 'combo-counter';
  counter.textContent = `${totalDamage} DMG!`;

  // Scale up for bigger damage
  if (totalDamage >= 20) {
    counter.style.fontSize = '6rem';
    counter.style.color = '#ff6b6b';
    counter.style.textShadow = '0 4px 8px rgba(0,0,0,0.8), 0 0 40px #ff6b6b';
  } else if (totalDamage >= 15) {
    counter.style.fontSize = '5.5rem';
    counter.style.color = '#ff9f43';
  } else if (totalDamage >= 10) {
    counter.style.fontSize = '5rem';
    counter.style.color = '#feca57';
  }

  document.body.appendChild(counter);
  setTimeout(() => counter.remove(), ANIMATION_TIMINGS.COMBO_DISPLAY);
}

// Animate counter pop (for XP/gold changes)
function animateCounterPop(elementId) {
  const el = document.getElementById(elementId);
  if (!el) return;

  el.classList.add('counter-pop');
  setTimeout(() => el.classList.remove('counter-pop'), ANIMATION_TIMINGS.COUNTER_POP);
}

// Knockout animation for defeated enemies
function triggerKnockout(targetId) {
  const card = document.getElementById(targetId);
  if (!card) return;

  card.classList.add('knockout');
  // Don't remove - the card will be removed from DOM anyway
}


// Steam Integration Module
// Provides achievement unlocking and Steam API features
// Works via IPC when running in Electron, gracefully degrades in browser

const Steam = {
  initialized: false,
  achievements: new Set(), // Track unlocked achievements locally

  // Achievement API names (must match Steam dashboard config)
  ACHIEVEMENTS: {
    // Tier 1: First Steps
    FIRST_LAUNCH: 'FIRST_LAUNCH',
    TUTORIAL_COMPLETE: 'TUTORIAL_COMPLETE',
    FLOOR_1_COMPLETE: 'FLOOR_1_COMPLETE',
    FIRST_DRAGON: 'FIRST_DRAGON',
    FIRST_DEATH: 'FIRST_DEATH',
    FIRST_UPGRADE: 'FIRST_UPGRADE',
    GOLD_100: 'GOLD_100',
    GOLD_1000: 'GOLD_1000',
    NEUTRAL_STAGE2_UNLOCK: 'NEUTRAL_STAGE2_UNLOCK',
    SIGILS_5_ON_HERO: 'SIGILS_5_ON_HERO',
    SIGIL_MAXED_RUN: 'SIGIL_MAXED_RUN',
    XP_100_FLOOR: 'XP_100_FLOOR',
    ALL_PASSIVES: 'ALL_PASSIVES',
    FIRST_STATUETTE: 'FIRST_STATUETTE',
    ALL_STATUETTES: 'ALL_STATUETTES',

    // Tier 2: Core Progression
    STAGE2_CLEAR: 'STAGE2_CLEAR',
    ALL_STAGE2_UNLOCK: 'ALL_STAGE2_UNLOCK',
    ALL_STAGE2_CLEAR: 'ALL_STAGE2_CLEAR',
    ALL_SIGILS_L1: 'ALL_SIGILS_L1',
    SIGIL_MAXED_PERM: 'SIGIL_MAXED_PERM',
    ALL_SIGILS_MAXED: 'ALL_SIGILS_MAXED',
    MEET_GHOST_BOYS: 'MEET_GHOST_BOYS',
    WIN_ALL_HEROES: 'WIN_ALL_HEROES',

    // Tier 3: Challenge & Mastery
    RAPID_FIRE_20: 'RAPID_FIRE_20',
    GHOST_MAXED: 'GHOST_MAXED',
    AMBUSH_UNTOUCHABLE: 'AMBUSH_UNTOUCHABLE',
    BESTIARY_COMPLETE: 'BESTIARY_COMPLETE',

    // Tier 4: Prestige
    FIRST_STAND: 'FIRST_STAND',

    // Hidden/Secret
    GHOST_BOYS_REALIZE: 'GHOST_BOYS_REALIZE',

    // FU Mode
    FU_FLOOR_CLEAR: 'FU_FLOOR_CLEAR',
    RECRUITS_3: 'RECRUITS_3',
    FU_COMPLETE: 'FU_COMPLETE',
    FU_TAPO: 'FU_TAPO',
    FU_TRIPLE_TAPO: 'FU_TRIPLE_TAPO'
  },

  // Initialize Steam - call from electron-main via preload
  init() {
    // Check if we're in Electron with Steam bridge
    if (window.steamBridge) {
      this.initialized = window.steamBridge.initialized;
      if (this.initialized) {
        console.log('[Steam] Connected to Steam API');
        // Load already-unlocked achievements from Steam
        this.syncAchievements();
      }
    } else {
      console.log('[Steam] Running in browser mode - achievements disabled');
    }
    return this.initialized;
  },

  // Sync achievements from Steam (so we don't re-unlock)
  syncAchievements() {
    if (!this.initialized || !window.steamBridge) return;
    try {
      const unlocked = window.steamBridge.getUnlockedAchievements();
      if (unlocked && Array.isArray(unlocked)) {
        unlocked.forEach(a => this.achievements.add(a));
        console.log(`[Steam] Synced ${unlocked.length} achievements`);
      }
    } catch (e) {
      console.warn('[Steam] Failed to sync achievements:', e);
    }
  },

  // Unlock an achievement
  unlock(achievementId) {
    // Already unlocked locally? Skip
    if (this.achievements.has(achievementId)) {
      return false;
    }

    // Mark as unlocked locally (prevents duplicate calls)
    this.achievements.add(achievementId);

    // If Steam is connected, unlock via API
    if (this.initialized && window.steamBridge) {
      try {
        const result = window.steamBridge.unlockAchievement(achievementId);
        if (result) {
          console.log(`[Steam] Achievement unlocked: ${achievementId}`);
        }
        return result;
      } catch (e) {
        console.warn(`[Steam] Failed to unlock ${achievementId}:`, e);
        return false;
      }
    }

    // Not in Steam - just log it
    console.log(`[Steam] Achievement (offline): ${achievementId}`);
    return false;
  },

  // Check if achievement is unlocked
  isUnlocked(achievementId) {
    return this.achievements.has(achievementId);
  },

  // Get Steam user info (display name, Steam ID)
  getUserInfo() {
    if (!this.initialized || !window.steamBridge) {
      return null;
    }
    try {
      return window.steamBridge.getUserInfo();
    } catch (e) {
      return null;
    }
  },

  // Clear an achievement (for testing only)
  clearAchievement(achievementId) {
    if (!this.initialized || !window.steamBridge) return false;
    try {
      this.achievements.delete(achievementId);
      return window.steamBridge.clearAchievement(achievementId);
    } catch (e) {
      return false;
    }
  },

  // Clear ALL achievements (for testing only)
  clearAllAchievements() {
    if (!this.initialized || !window.steamBridge) return false;
    try {
      this.achievements.clear();
      return window.steamBridge.clearAllAchievements();
    } catch (e) {
      return false;
    }
  },

  // ============================================
  // STATS API
  // ============================================

  // Stat names (must match Steam dashboard config)
  STATS: {
    TOTAL_RUNS: 'total_runs',
    TOTAL_WINS: 'total_wins',
    TOTAL_DEATHS: 'total_deaths',
    TOTAL_GOLD_EARNED: 'total_gold_earned',
    TOTAL_XP_EARNED: 'total_xp_earned',
    TOTAL_ENEMIES_KILLED: 'total_enemies_killed',
    TOTAL_DRAGONS_KILLED: 'total_dragons_killed',
    TOTAL_FLYDRAS_KILLED: 'total_flydras_killed',
    HIGHEST_FLOOR: 'highest_floor',
    FASTEST_WIN_SECONDS: 'fastest_win_seconds',
    TOTAL_DAMAGE_DEALT: 'total_damage_dealt',
    TOTAL_HEALING_DONE: 'total_healing_done',
    TOTAL_SHIELD_GRANTED: 'total_shield_granted',
    TOTAL_D20_ROLLS: 'total_d20_rolls',
    TOTAL_RECRUITS: 'total_recruits',
    FU_WINS: 'fu_wins'
  },

  // Set a stat value
  setStat(statName, value) {
    if (!this.initialized || !window.steamBridge) {
      console.log(`[Steam] Stat (offline): ${statName} = ${value}`);
      return false;
    }
    try {
      return window.steamBridge.setStat(statName, value);
    } catch (e) {
      console.warn(`[Steam] Failed to set stat ${statName}:`, e);
      return false;
    }
  },

  // Get a stat value
  getStat(statName) {
    if (!this.initialized || !window.steamBridge) return 0;
    try {
      return window.steamBridge.getStat(statName);
    } catch (e) {
      return 0;
    }
  },

  // Increment a stat by amount (convenience method)
  incrementStat(statName, amount = 1) {
    const current = this.getStat(statName);
    return this.setStat(statName, current + amount);
  },

  // Set stat only if new value is higher (for high scores)
  setStatIfHigher(statName, value) {
    const current = this.getStat(statName);
    if (value > current) {
      return this.setStat(statName, value);
    }
    return false;
  },

  // Set stat only if new value is lower (for speed records)
  setStatIfLower(statName, value) {
    const current = this.getStat(statName);
    if (current === 0 || value < current) {
      return this.setStat(statName, value);
    }
    return false;
  },

  // Store stats to Steam (call after batch updates)
  storeStats() {
    if (!this.initialized || !window.steamBridge) return false;
    try {
      return window.steamBridge.storeStats();
    } catch (e) {
      return false;
    }
  },

  // ============================================
  // CLOUD SAVE API
  // ============================================

  // Cloud save file name
  CLOUD_SAVE_FILE: 'froggle_save.json',

  // Save game data to Steam Cloud
  cloudSave(data) {
    if (!this.initialized || !window.steamBridge) {
      console.log('[Steam] Cloud save (offline) - using localStorage only');
      return false;
    }
    try {
      const jsonStr = typeof data === 'string' ? data : JSON.stringify(data);
      const result = window.steamBridge.cloudSave(this.CLOUD_SAVE_FILE, jsonStr);
      if (result) {
        console.log('[Steam] Cloud save successful');
      }
      return result;
    } catch (e) {
      console.warn('[Steam] Cloud save failed:', e);
      return false;
    }
  },

  // Load game data from Steam Cloud
  cloudLoad() {
    if (!this.initialized || !window.steamBridge) {
      console.log('[Steam] Cloud load (offline) - using localStorage only');
      return null;
    }
    try {
      const data = window.steamBridge.cloudLoad(this.CLOUD_SAVE_FILE);
      if (data) {
        console.log('[Steam] Cloud load successful');
        return JSON.parse(data);
      }
      return null;
    } catch (e) {
      console.warn('[Steam] Cloud load failed:', e);
      return null;
    }
  },

  // Check if cloud save exists
  cloudExists() {
    if (!this.initialized || !window.steamBridge) return false;
    try {
      return window.steamBridge.cloudExists(this.CLOUD_SAVE_FILE);
    } catch (e) {
      return false;
    }
  },

  // Delete cloud save (for testing/reset)
  cloudDelete() {
    if (!this.initialized || !window.steamBridge) return false;
    try {
      return window.steamBridge.cloudDelete(this.CLOUD_SAVE_FILE);
    } catch (e) {
      return false;
    }
  },

  // Get cloud storage quota info
  cloudQuota() {
    if (!this.initialized || !window.steamBridge) return null;
    try {
      return window.steamBridge.cloudQuota();
    } catch (e) {
      return null;
    }
  }
};

// Make available globally
window.Steam = Steam;

// ===== SOUND EFFECTS SYSTEM (Web Audio API) =====
const SoundFX = {
  ctx: null,
  enabled: true,
  volume: 0.3,
  musicVolume: 0.2,
  audioBuffers: {},  // Cache for loaded audio files
  currentMusic: null, // Currently playing music source
  musicGain: null,    // Gain node for music volume control

  init() {
    if (this.ctx) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      // Create music gain node
      this.musicGain = this.ctx.createGain();
      this.musicGain.gain.setValueAtTime(this.musicVolume, this.ctx.currentTime);
      this.musicGain.connect(this.ctx.destination);
    } catch(e) {
      console.warn('Web Audio API not supported');
      this.enabled = false;
    }
  },

  // Load an audio file from URL or base64 data
  async loadAudio(name, source) {
    if (!this.ctx) this.init();
    if (!this.ctx) return false;

    try {
      let arrayBuffer;

      if (source.startsWith('data:')) {
        // Base64 encoded audio
        const base64 = source.split(',')[1];
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        arrayBuffer = bytes.buffer;
      } else {
        // URL-based audio file
        const response = await fetch(source);
        arrayBuffer = await response.arrayBuffer();
      }

      const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
      this.audioBuffers[name] = audioBuffer;
      return true;
    } catch (e) {
      console.warn(`Failed to load audio "${name}":`, e);
      return false;
    }
  },

  // Play a loaded audio file
  playAudio(name, options = {}) {
    if (!this.enabled || !this.ctx) return null;
    if (!this.audioBuffers[name]) {
      console.warn(`Audio "${name}" not loaded`);
      return null;
    }

    // Resume audio context if suspended
    if (this.ctx.state === 'suspended') {
      this.ctx.resume();
    }

    const source = this.ctx.createBufferSource();
    const gainNode = this.ctx.createGain();

    source.buffer = this.audioBuffers[name];
    source.loop = options.loop || false;

    const vol = (options.volume !== undefined ? options.volume : 1) * this.volume;
    gainNode.gain.setValueAtTime(vol, this.ctx.currentTime);

    source.connect(gainNode);
    gainNode.connect(this.ctx.destination);

    source.start(0);

    return { source, gainNode };
  },

  // Play music (with loop by default, separate volume control)
  playMusic(name, options = {}) {
    if (!this.enabled || !this.ctx) return null;

    // Stop current music if playing
    this.stopMusic();

    if (!this.audioBuffers[name]) {
      console.warn(`Music "${name}" not loaded`);
      return null;
    }

    if (this.ctx.state === 'suspended') {
      this.ctx.resume();
    }

    const source = this.ctx.createBufferSource();
    source.buffer = this.audioBuffers[name];
    source.loop = options.loop !== false; // Loop by default

    source.connect(this.musicGain);
    source.start(0);

    this.currentMusic = source;
    return source;
  },

  // Stop currently playing music
  stopMusic(fadeOut = 0) {
    if (!this.currentMusic) return;

    if (fadeOut > 0 && this.musicGain) {
      // Fade out
      const now = this.ctx.currentTime;
      this.musicGain.gain.setValueAtTime(this.musicVolume, now);
      this.musicGain.gain.exponentialRampToValueAtTime(0.01, now + fadeOut);
      const music = this.currentMusic;
      setTimeout(() => {
        try { music.stop(); } catch(e) {}
        this.musicGain.gain.setValueAtTime(this.musicVolume, this.ctx.currentTime);
      }, fadeOut * 1000);
    } else {
      try { this.currentMusic.stop(); } catch(e) {}
    }

    this.currentMusic = null;
  },

  // Set music volume (0-1)
  setMusicVolume(vol) {
    this.musicVolume = Math.max(0, Math.min(1, vol));
    if (this.musicGain && this.ctx) {
      this.musicGain.gain.setValueAtTime(this.musicVolume, this.ctx.currentTime);
    }
  },

  // Preload multiple audio files
  async preloadAudio(audioMap) {
    const results = await Promise.all(
      Object.entries(audioMap).map(([name, source]) =>
        this.loadAudio(name, source).then(success => ({ name, success }))
      )
    );
    return results;
  },

  // Play a synthesized sound effect
  play(type) {
    if (!this.enabled || !this.ctx) return;

    // Resume audio context if suspended (required for mobile)
    if (this.ctx.state === 'suspended') {
      this.ctx.resume();
    }

    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);

    const now = this.ctx.currentTime;
    gain.gain.setValueAtTime(this.volume, now);

    switch(type) {
      case 'hit':
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'square';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'crit':
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
        gain.gain.setValueAtTime(this.volume * 1.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.25);
        break;

      case 'enemyHit':
        // Sinister low rumble for enemy attacks on heroes
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
        gain.gain.setValueAtTime(this.volume * 1.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.25);
        break;

      case 'enemyCrit':
        // Heavy sinister impact for enemy crits
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
        gain.gain.setValueAtTime(this.volume * 1.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.35);
        break;

      case 'heal':
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.2);
        break;

      case 'shield':
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.setValueAtTime(400, now + 0.05);
        osc.frequency.setValueAtTime(350, now + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'triangle';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'click':
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.08);
        break;

      case 'victory':
        // Ascending arpeggio
        [523, 659, 784, 1047].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now);
          g.gain.setValueAtTime(this.volume * 0.7, now + i * 0.1);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.3);
          o.type = 'sine';
          o.start(now + i * 0.1);
          o.stop(now + i * 0.1 + 0.3);
        });
        break;

      case 'levelup':
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
        gain.gain.setValueAtTime(this.volume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.3);
        break;

      case 'death':
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.6);
        break;

      case 'gold':
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        gain.gain.setValueAtTime(this.volume * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'select':
        osc.frequency.setValueAtTime(500, now);
        osc.frequency.setValueAtTime(600, now + 0.03);
        gain.gain.setValueAtTime(this.volume * 0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.08);
        break;

      case 'error':
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.setValueAtTime(150, now + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.type = 'square';
        osc.start(now);
        osc.stop(now + 0.2);
        break;

      // ===== FROGGY SOUNDS =====
      case 'ribbit':
        // Classic frog croak - two-tone chirp
        osc.frequency.setValueAtTime(220, now);
        osc.frequency.exponentialRampToValueAtTime(180, now + 0.08);
        osc.frequency.setValueAtTime(260, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.2);
        gain.gain.setValueAtTime(this.volume * 0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.25);
        break;

      case 'splash':
        // Water splash for D20 rolls - very soft, stretched out
        osc.frequency.setValueAtTime(500, now);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.5);
        gain.gain.setValueAtTime(this.volume * 0.125, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.6);
        break;

      case 'hop':
        // Light hop - quick ascending blip
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(500, now + 0.06);
        osc.frequency.exponentialRampToValueAtTime(350, now + 0.1);
        gain.gain.setValueAtTime(this.volume * 0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.12);
        break;

      case 'croak':
        // Deep croak for enemy defeats - low rumble
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
        osc.frequency.setValueAtTime(100, now + 0.2);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.4);
        gain.gain.setValueAtTime(this.volume * 0.9, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        osc.type = 'triangle';
        osc.start(now);
        osc.stop(now + 0.45);
        break;

      case 'bubble':
        // Bubble pop for shields - playful bloop
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.15);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.18);
        break;

      case 'gulp':
        // Gulp/slurp for healing - descending then up
        osc.frequency.setValueAtTime(500, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.08);
        osc.frequency.exponentialRampToValueAtTime(700, now + 0.15);
        gain.gain.setValueAtTime(this.volume * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.2);
        break;

      case 'd20roll':
        // Dice tumbling - rapid frequency wobble
        osc.frequency.setValueAtTime(400, now);
        for(let i = 0; i < 8; i++) {
          osc.frequency.setValueAtTime(350 + Math.random() * 200, now + i * 0.04);
        }
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.35);
        gain.gain.setValueAtTime(this.volume * 0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.type = 'square';
        osc.start(now);
        osc.stop(now + 0.4);
        break;

      case 'portal':
        // Portal whoosh - sweeping mystical sound
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.5);
        gain.gain.setValueAtTime(this.volume * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.55);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.55);
        break;

      case 'nat20':
        // Natural 20! - triumphant ascending fanfare
        [400, 500, 600, 800].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now);
          g.gain.setValueAtTime(this.volume * 0.8, now + i * 0.08);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.25);
          o.type = 'sine';
          o.start(now + i * 0.08);
          o.stop(now + i * 0.08 + 0.25);
        });
        break;

      case 'nat1':
        // Natural 1 - sad descending trombone
        [300, 280, 250, 150].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now + i * 0.12);
          g.gain.setValueAtTime(this.volume * 0.6, now + i * 0.12);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.12 + 0.15);
          o.type = 'sawtooth';
          o.start(now + i * 0.12);
          o.stop(now + i * 0.12 + 0.15);
        });
        break;

      // ===== MORE FROGGY SOUNDS =====
      case 'tongueSnap':
        // Frog tongue lash attack - quick snap with wet ending
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.05);
        osc.frequency.setValueAtTime(150, now + 0.06);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.12);
        gain.gain.setValueAtTime(this.volume * 0.7, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'lilyPad':
        // Bouncing on lily pad - springy boing
        osc.frequency.setValueAtTime(250, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.08);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
        osc.frequency.exponentialRampToValueAtTime(350, now + 0.2);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.25);
        break;

      case 'flyCatch':
        // Catching a fly - quick zip and crunch
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.04);
        osc.frequency.setValueAtTime(100, now + 0.05);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(this.volume * 0.3, now + 0.04);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.type = 'square';
        osc.start(now);
        osc.stop(now + 0.1);
        break;

      case 'mudSquelch':
        // Stepping in mud - wet squelchy sound
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(120, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.25);
        gain.gain.setValueAtTime(this.volume * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.type = 'triangle';
        osc.start(now);
        osc.stop(now + 0.3);
        break;

      case 'waterDrip':
        // Single water droplet
        osc.frequency.setValueAtTime(1400, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.08);
        gain.gain.setValueAtTime(this.volume * 0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.12);
        break;

      case 'crickets':
        // Cricket chirps - rapid high frequency bursts
        [0, 0.15, 0.18, 0.35, 0.38].forEach((t) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(4000 + Math.random() * 500, now + t);
          g.gain.setValueAtTime(this.volume * 0.15, now + t);
          g.gain.exponentialRampToValueAtTime(0.01, now + t + 0.03);
          o.type = 'sine';
          o.start(now + t);
          o.stop(now + t + 0.03);
        });
        break;

      case 'frogChorus':
        // Multiple frogs croaking in celebration
        [
          { freq: 180, delay: 0, type: 'sine' },
          { freq: 220, delay: 0.1, type: 'triangle' },
          { freq: 160, delay: 0.15, type: 'sine' },
          { freq: 200, delay: 0.25, type: 'triangle' },
          { freq: 240, delay: 0.3, type: 'sine' }
        ].forEach(({ freq, delay, type }) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now + delay);
          o.frequency.exponentialRampToValueAtTime(freq * 0.7, now + delay + 0.15);
          g.gain.setValueAtTime(this.volume * 0.4, now + delay);
          g.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.2);
          o.type = type;
          o.start(now + delay);
          o.stop(now + delay + 0.2);
        });
        break;

      case 'splashBig':
        // Big splash - dramatic water entry
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.4);
        gain.gain.setValueAtTime(this.volume * 0.8, now);
        gain.gain.exponentialRampToValueAtTime(this.volume * 0.3, now + 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.5);
        break;

      case 'rain':
        // Rain ambiance - multiple water drops
        for (let i = 0; i < 12; i++) {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          const t = Math.random() * 0.8;
          o.frequency.setValueAtTime(800 + Math.random() * 1200, now + t);
          o.frequency.exponentialRampToValueAtTime(400 + Math.random() * 400, now + t + 0.06);
          g.gain.setValueAtTime(this.volume * (0.1 + Math.random() * 0.15), now + t);
          g.gain.exponentialRampToValueAtTime(0.01, now + t + 0.1);
          o.type = 'sine';
          o.start(now + t);
          o.stop(now + t + 0.1);
        }
        break;

      case 'treasure':
        // Finding treasure - magical shimmer
        [800, 1000, 1200, 1000, 1400].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now + i * 0.07);
          g.gain.setValueAtTime(this.volume * 0.5, now + i * 0.07);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.07 + 0.15);
          o.type = 'sine';
          o.start(now + i * 0.07);
          o.stop(now + i * 0.07 + 0.15);
        });
        break;

      case 'stun':
        // Stun/grapple effect - dizzy warble
        [0, 0.08, 0.15, 0.2].forEach((t, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(300 - i * 30, now + t);
          o.frequency.exponentialRampToValueAtTime(200, now + t + 0.08);
          g.gain.setValueAtTime(this.volume * 0.4, now + t);
          g.gain.exponentialRampToValueAtTime(0.01, now + t + 0.1);
          o.type = 'triangle';
          o.start(now + t);
          o.stop(now + t + 0.1);
        });
        break;

      case 'menuOpen':
        // Menu/UI panel opening - soft whoosh up
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.12);
        gain.gain.setValueAtTime(this.volume * 0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'menuClose':
        // Menu/UI panel closing - soft whoosh down
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        gain.gain.setValueAtTime(this.volume * 0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.12);
        break;

      case 'coinDrop':
        // Gold/coin pickup - bright metallic ding
        osc.frequency.setValueAtTime(1800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.15);
        // Add harmonic
        const coinHarm = this.ctx.createOscillator();
        const coinGain = this.ctx.createGain();
        coinHarm.connect(coinGain);
        coinGain.connect(this.ctx.destination);
        coinHarm.frequency.setValueAtTime(2400, now);
        coinHarm.frequency.exponentialRampToValueAtTime(1600, now + 0.06);
        coinGain.gain.setValueAtTime(this.volume * 0.25, now);
        coinGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        coinHarm.type = 'sine';
        coinHarm.start(now);
        coinHarm.stop(now + 0.1);
        break;

      case 'floorEnter':
        // Entering new floor - dramatic swoosh
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.2);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.4);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(this.volume * 0.3, now + 0.2);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        osc.type = 'triangle';
        osc.start(now);
        osc.stop(now + 0.45);
        break;

      case 'enemySpawn':
        // Enemy appearing - ominous rising tone
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
        gain.gain.setValueAtTime(this.volume * 0.4, now);
        gain.gain.exponentialRampToValueAtTime(this.volume * 0.6, now + 0.2);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.35);
        break;

      case 'powerUp':
        // Power up acquired - ascending sparkle
        [400, 600, 800, 1000, 1200].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now + i * 0.05);
          g.gain.setValueAtTime(this.volume * 0.4, now + i * 0.05);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.1);
          o.type = 'sine';
          o.start(now + i * 0.05);
          o.stop(now + i * 0.05 + 0.1);
        });
        break;
    }
  }
};

// Initialize sound on first user interaction
document.addEventListener('click', () => SoundFX.init(), { once: true });
document.addEventListener('touchstart', () => SoundFX.init(), { once: true });

// ===== PROCEDURAL MUSIC SYSTEM =====
const ProceduralMusic = {
  ctx: null,
  enabled: true,
  volume: 0.15,
  currentMode: null,
  oscillators: [],
  gainNodes: [],
  intervalIds: [],

  init() {
    if (!SoundFX.ctx) SoundFX.init();
    this.ctx = SoundFX.ctx;
  },

  stopAll() {
    // Stop all oscillators
    this.oscillators.forEach(osc => {
      try { osc.stop(); } catch(e) {}
    });
    this.oscillators = [];

    // Disconnect gain nodes
    this.gainNodes.forEach(g => {
      try { g.disconnect(); } catch(e) {}
    });
    this.gainNodes = [];

    // Clear intervals
    this.intervalIds.forEach(id => clearInterval(id));
    this.intervalIds = [];

    this.currentMode = null;
  },

  // Ambient swamp drone - mysterious, atmospheric
  startAmbient() {
    if (!this.enabled || this.currentMode === 'ambient') return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    this.currentMode = 'ambient';
    const now = this.ctx.currentTime;

    // Create master gain for ambient
    const masterGain = this.ctx.createGain();
    masterGain.gain.setValueAtTime(0, now);
    masterGain.gain.linearRampToValueAtTime(this.volume, now + 2); // Fade in
    masterGain.connect(this.ctx.destination);
    this.gainNodes.push(masterGain);

    // Deep drone - fundamental (D2, ~73Hz)
    const drone1 = this.ctx.createOscillator();
    const drone1Gain = this.ctx.createGain();
    drone1.frequency.setValueAtTime(73, now);
    drone1.type = 'sine';
    drone1Gain.gain.setValueAtTime(0.4, now);
    drone1.connect(drone1Gain);
    drone1Gain.connect(masterGain);
    drone1.start(now);
    this.oscillators.push(drone1);
    this.gainNodes.push(drone1Gain);

    // Fifth harmonic (A2, ~110Hz) - adds richness
    const drone2 = this.ctx.createOscillator();
    const drone2Gain = this.ctx.createGain();
    drone2.frequency.setValueAtTime(110, now);
    drone2.type = 'sine';
    drone2Gain.gain.setValueAtTime(0.2, now);
    drone2.connect(drone2Gain);
    drone2Gain.connect(masterGain);
    drone2.start(now);
    this.oscillators.push(drone2);
    this.gainNodes.push(drone2Gain);

    // Subtle LFO modulation for "breathing" effect on volume
    const breatheInterval = setInterval(() => {
      if (this.currentMode !== 'ambient' || !this.ctx) return;
      const t = this.ctx.currentTime;
      // Slow breathing (8 second cycle)
      const breath = 0.7 + 0.3 * Math.sin(t * 0.4);
      drone1Gain.gain.setTargetAtTime(0.4 * breath, t, 0.5);
      drone2Gain.gain.setTargetAtTime(0.2 * breath, t, 0.5);
    }, 500);
    this.intervalIds.push(breatheInterval);

    // Occasional water drip sounds
    const dripInterval = setInterval(() => {
      if (this.currentMode !== 'ambient' || !this.ctx) return;
      if (Math.random() < 0.3) { // 30% chance every 2 seconds
        SoundFX.play('waterDrip');
      }
    }, 2000);
    this.intervalIds.push(dripInterval);

    // Occasional cricket chirps (less frequent)
    const cricketInterval = setInterval(() => {
      if (this.currentMode !== 'ambient' || !this.ctx) return;
      if (Math.random() < 0.15) {
        SoundFX.play('crickets');
      }
    }, 4000);
    this.intervalIds.push(cricketInterval);
  },

  // Froggy beat - same drums as combat but with splash and ribbit sounds
  // Used for title screen and Ribbleton (froggy areas)
  startFroggyBeat() {
    if (!this.enabled || this.currentMode === 'froggy') return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    this.currentMode = 'froggy';
    const now = this.ctx.currentTime;
    const bpm = 100;
    const beatDuration = 60 / bpm;

    // Create master gain for froggy beat
    const masterGain = this.ctx.createGain();
    masterGain.gain.setValueAtTime(0, now);
    masterGain.gain.linearRampToValueAtTime(this.volume * 1.0, now + 0.5);
    masterGain.connect(this.ctx.destination);
    this.gainNodes.push(masterGain);

    // Helper: create noise buffer for percussive sounds
    const createNoise = (duration) => {
      const bufferSize = this.ctx.sampleRate * duration;
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      return buffer;
    };

    // 16-step patterns (two measures of 8)
    // Kick pattern: same as combat but extended to 16 steps
    const kickPattern = [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0];
    // Snare on beats 3, 7, 11, 15 (backbeat) - 0-indexed: 2, 6, 10, 14
    const snarePattern = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0];
    // Hi-hat on every step for steady pulse
    const hatPattern = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    // Splash on beats 3, 7, 11 (0-indexed: 2, 6, 10)
    const splashPattern = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0];
    // Ribbit on beat 16 (0-indexed: 15)
    const ribbitPattern = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
    let step = 0;

    const beatInterval = setInterval(() => {
      if (this.currentMode !== 'froggy' || !this.ctx) return;

      const t = this.ctx.currentTime;

      // Kick drum - low thump (slightly quieter than combat)
      if (kickPattern[step]) {
        const kickOsc = this.ctx.createOscillator();
        const kickGain = this.ctx.createGain();
        kickOsc.connect(kickGain);
        kickGain.connect(masterGain);
        kickOsc.frequency.setValueAtTime(150, t);
        kickOsc.frequency.exponentialRampToValueAtTime(40, t + 0.08);
        kickGain.gain.setValueAtTime(0.5, t);
        kickGain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);
        kickOsc.type = 'sine';
        kickOsc.start(t);
        kickOsc.stop(t + 0.12);
      }

      // Snare drum - mid punch (slightly quieter)
      if (snarePattern[step]) {
        const snareOsc = this.ctx.createOscillator();
        const snareGain = this.ctx.createGain();
        snareOsc.connect(snareGain);
        snareGain.connect(masterGain);
        snareOsc.frequency.setValueAtTime(180, t);
        snareOsc.frequency.exponentialRampToValueAtTime(120, t + 0.05);
        snareGain.gain.setValueAtTime(0.25, t);
        snareGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        snareOsc.type = 'triangle';
        snareOsc.start(t);
        snareOsc.stop(t + 0.1);

        // Noise rattle
        const snareNoise = this.ctx.createBufferSource();
        snareNoise.buffer = createNoise(0.15);
        const snareNoiseGain = this.ctx.createGain();
        const snareNoiseFilter = this.ctx.createBiquadFilter();
        snareNoiseFilter.type = 'highpass';
        snareNoiseFilter.frequency.value = 2000;
        snareNoise.connect(snareNoiseFilter);
        snareNoiseFilter.connect(snareNoiseGain);
        snareNoiseGain.connect(masterGain);
        snareNoiseGain.gain.setValueAtTime(0.18, t);
        snareNoiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);
        snareNoise.start(t);
      }

      // Hi-hat - quiet tick (quieter than combat for more chill vibe)
      if (hatPattern[step]) {
        const hatNoise = this.ctx.createBufferSource();
        hatNoise.buffer = createNoise(0.04);
        const hatGain = this.ctx.createGain();
        const hatFilter = this.ctx.createBiquadFilter();
        hatFilter.type = 'highpass';
        hatFilter.frequency.value = 7000;
        hatNoise.connect(hatFilter);
        hatFilter.connect(hatGain);
        hatGain.connect(masterGain);
        const accent = (step === 0 || step === 8) ? 0.08 : 0.04;
        hatGain.gain.setValueAtTime(accent, t);
        hatGain.gain.exponentialRampToValueAtTime(0.01, t + 0.03);
        hatNoise.start(t);
      }

      // Water splash on beats 3, 7, 11 (swapped - 'ribbit' synthesis sounds like splash to users)
      if (splashPattern[step]) {
        SoundFX.play('ribbit');
      }

      // Frog ribbit on beat 16 (swapped - 'splash' synthesis sounds like ribbit to users)
      if (ribbitPattern[step]) {
        SoundFX.play('splash');
      }

      step = (step + 1) % 16;
    }, beatDuration * 1000);
    this.intervalIds.push(beatInterval);
  },

  // Title funky beat - laid-back groovy funk with froggy sounds
  // Used for title screen, victory screen, and credits
  startTitleBeat() {
    if (!this.enabled || this.currentMode === 'title') return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    this.currentMode = 'title';
    const now = this.ctx.currentTime;
    const bpm = 88; // Slower, more chill
    const beatDuration = 60 / bpm;

    // Create master gain for title beat
    const masterGain = this.ctx.createGain();
    masterGain.gain.setValueAtTime(0, now);
    masterGain.gain.linearRampToValueAtTime(this.volume * 0.7, now + 1); // Gentler fade in
    masterGain.connect(this.ctx.destination);
    this.gainNodes.push(masterGain);

    // Helper: create noise buffer for percussive sounds
    const createNoise = (duration) => {
      const bufferSize = this.ctx.sampleRate * duration;
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      return buffer;
    };

    // 16-step pattern (two measures) - simplified and more spacious
    //                        steps: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
    // Simpler kick: just 1, 4, 9, 12 (four-on-the-floor with slight syncopation)
    const kickPattern =           [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0];
    // Snare only on 7 and 15 (half as often)
    const snarePattern =          [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
    // Sparse hi-hat - just on 1, 5, 9, 13 (quarter notes only)
    const hatPattern =            [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0];
    // LilyPad boing on beat 8 only (signature sound)
    const lilyPadPattern =        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0];
    // Gentle ribbit on beat 16 to close the phrase
    const ribbitPattern =         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];

    let step = 0;
    let measureCount = 0;

    const beatInterval = setInterval(() => {
      if (this.currentMode !== 'title' || !this.ctx) return;

      const t = this.ctx.currentTime;

      // Kick drum - softer and warmer
      if (kickPattern[step]) {
        const kickOsc = this.ctx.createOscillator();
        const kickGain = this.ctx.createGain();
        kickOsc.connect(kickGain);
        kickGain.connect(masterGain);
        kickOsc.frequency.setValueAtTime(100, t);
        kickOsc.frequency.exponentialRampToValueAtTime(50, t + 0.12);
        kickGain.gain.setValueAtTime(0.4, t);
        kickGain.gain.exponentialRampToValueAtTime(0.01, t + 0.18);
        kickOsc.type = 'sine';
        kickOsc.start(t);
        kickOsc.stop(t + 0.18);
      }

      // Snare - softer, more like a rim tap
      if (snarePattern[step]) {
        const snareOsc = this.ctx.createOscillator();
        const snareGain = this.ctx.createGain();
        snareOsc.connect(snareGain);
        snareGain.connect(masterGain);
        snareOsc.frequency.setValueAtTime(180, t);
        snareOsc.frequency.exponentialRampToValueAtTime(120, t + 0.03);
        snareGain.gain.setValueAtTime(0.2, t);
        snareGain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
        snareOsc.type = 'triangle';
        snareOsc.start(t);
        snareOsc.stop(t + 0.08);

        // Light noise brush
        const snareNoise = this.ctx.createBufferSource();
        snareNoise.buffer = createNoise(0.08);
        const snareNoiseGain = this.ctx.createGain();
        const snareNoiseFilter = this.ctx.createBiquadFilter();
        snareNoiseFilter.type = 'highpass';
        snareNoiseFilter.frequency.value = 3000;
        snareNoise.connect(snareNoiseFilter);
        snareNoiseFilter.connect(snareNoiseGain);
        snareNoiseGain.connect(masterGain);
        snareNoiseGain.gain.setValueAtTime(0.1, t);
        snareNoiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.06);
        snareNoise.start(t);
      }

      // Soft hi-hat tick
      if (hatPattern[step]) {
        const hatNoise = this.ctx.createBufferSource();
        hatNoise.buffer = createNoise(0.02);
        const hatGain = this.ctx.createGain();
        const hatFilter = this.ctx.createBiquadFilter();
        hatFilter.type = 'highpass';
        hatFilter.frequency.value = 8000;
        hatNoise.connect(hatFilter);
        hatFilter.connect(hatGain);
        hatGain.connect(masterGain);
        hatGain.gain.setValueAtTime(0.03, t);
        hatGain.gain.exponentialRampToValueAtTime(0.01, t + 0.02);
        hatNoise.start(t);
      }

      // LilyPad boing - the signature froggy sound
      if (lilyPadPattern[step]) {
        SoundFX.play('lilyPad');
      }

      // Gentle ribbit to close the phrase (every other measure for variety)
      if (ribbitPattern[step] && measureCount % 2 === 1) {
        SoundFX.play('ribbit');
      }

      // Track measures
      if (step === 15) {
        measureCount++;
      }

      step = (step + 1) % 16;
    }, beatDuration * 1000);
    this.intervalIds.push(beatInterval);
  },

  // Combat beat - percussive, drum-focused
  startCombat() {
    if (!this.enabled || this.currentMode === 'combat') return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    this.currentMode = 'combat';
    const now = this.ctx.currentTime;
    const bpm = 100;
    const beatDuration = 60 / bpm;

    // Create master gain for combat
    const masterGain = this.ctx.createGain();
    masterGain.gain.setValueAtTime(0, now);
    masterGain.gain.linearRampToValueAtTime(this.volume * 1.2, now + 0.5);
    masterGain.connect(this.ctx.destination);
    this.gainNodes.push(masterGain);

    // Helper: create noise buffer for percussive sounds
    const createNoise = (duration) => {
      const bufferSize = this.ctx.sampleRate * duration;
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      return buffer;
    };

    // Kick pattern: 1-0-0-1-0-1-0-0 (8 steps) - punchy drum hits
    const kickPattern = [1, 0, 0, 1, 0, 1, 0, 0];
    // Snare on beats 3 and 7 (backbeat)
    const snarePattern = [0, 0, 1, 0, 0, 0, 1, 0];
    // Hi-hat on every step for steady pulse
    const hatPattern = [1, 1, 1, 1, 1, 1, 1, 1];
    let step = 0;

    const beatInterval = setInterval(() => {
      if (this.currentMode !== 'combat' || !this.ctx) return;

      const t = this.ctx.currentTime;

      // Kick drum - low thump with noise click
      if (kickPattern[step]) {
        // Low frequency body
        const kickOsc = this.ctx.createOscillator();
        const kickGain = this.ctx.createGain();
        kickOsc.connect(kickGain);
        kickGain.connect(masterGain);
        kickOsc.frequency.setValueAtTime(150, t);
        kickOsc.frequency.exponentialRampToValueAtTime(40, t + 0.08);
        kickGain.gain.setValueAtTime(0.7, t);
        kickGain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);
        kickOsc.type = 'sine';
        kickOsc.start(t);
        kickOsc.stop(t + 0.12);

        // Noise click for attack
        const kickNoise = this.ctx.createBufferSource();
        kickNoise.buffer = createNoise(0.03);
        const kickNoiseGain = this.ctx.createGain();
        const kickNoiseFilter = this.ctx.createBiquadFilter();
        kickNoiseFilter.type = 'lowpass';
        kickNoiseFilter.frequency.value = 200;
        kickNoise.connect(kickNoiseFilter);
        kickNoiseFilter.connect(kickNoiseGain);
        kickNoiseGain.connect(masterGain);
        kickNoiseGain.gain.setValueAtTime(0.3, t);
        kickNoiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.03);
        kickNoise.start(t);
      }

      // Snare drum - mid punch with noise burst
      if (snarePattern[step]) {
        // Body tone
        const snareOsc = this.ctx.createOscillator();
        const snareGain = this.ctx.createGain();
        snareOsc.connect(snareGain);
        snareGain.connect(masterGain);
        snareOsc.frequency.setValueAtTime(180, t);
        snareOsc.frequency.exponentialRampToValueAtTime(120, t + 0.05);
        snareGain.gain.setValueAtTime(0.35, t);
        snareGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        snareOsc.type = 'triangle';
        snareOsc.start(t);
        snareOsc.stop(t + 0.1);

        // Noise rattle
        const snareNoise = this.ctx.createBufferSource();
        snareNoise.buffer = createNoise(0.15);
        const snareNoiseGain = this.ctx.createGain();
        const snareNoiseFilter = this.ctx.createBiquadFilter();
        snareNoiseFilter.type = 'highpass';
        snareNoiseFilter.frequency.value = 2000;
        snareNoise.connect(snareNoiseFilter);
        snareNoiseFilter.connect(snareNoiseGain);
        snareNoiseGain.connect(masterGain);
        snareNoiseGain.gain.setValueAtTime(0.25, t);
        snareNoiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);
        snareNoise.start(t);
      }

      // Hi-hat - quiet tick for steady metronome pulse
      if (hatPattern[step]) {
        const hatNoise = this.ctx.createBufferSource();
        hatNoise.buffer = createNoise(0.04);
        const hatGain = this.ctx.createGain();
        const hatFilter = this.ctx.createBiquadFilter();
        hatFilter.type = 'highpass';
        hatFilter.frequency.value = 7000;
        hatNoise.connect(hatFilter);
        hatFilter.connect(hatGain);
        hatGain.connect(masterGain);
        // Accent on downbeats
        const accent = (step === 0 || step === 4) ? 0.12 : 0.06;
        hatGain.gain.setValueAtTime(accent, t);
        hatGain.gain.exponentialRampToValueAtTime(0.01, t + 0.03);
        hatNoise.start(t);
      }

      // Single splash at end of pattern (step 7)
      if (step === 7) {
        SoundFX.play('ribbit'); // 'ribbit' synthesis sounds like splash to users
      }

      step = (step + 1) % 8;
    }, beatDuration * 1000);
    this.intervalIds.push(beatInterval);
  },

  // Victory fanfare - celebratory, ascending
  playVictory() {
    if (!this.enabled) return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    const now = this.ctx.currentTime;

    // Triumphant chord progression: C -> G -> Am -> F -> C (simplified fanfare)
    const fanfare = [
      { notes: [262, 330, 392], time: 0, duration: 0.3 },      // C major
      { notes: [294, 370, 440], time: 0.35, duration: 0.3 },   // D major
      { notes: [330, 415, 494], time: 0.7, duration: 0.3 },    // E major
      { notes: [392, 494, 587], time: 1.05, duration: 0.5 },   // G major (resolve)
      { notes: [523, 659, 784], time: 1.6, duration: 0.8 },    // C major (octave up, finale)
    ];

    fanfare.forEach(chord => {
      chord.notes.forEach((freq, i) => {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.frequency.setValueAtTime(freq, now + chord.time);
        gain.gain.setValueAtTime(this.volume * 0.6, now + chord.time);
        gain.gain.exponentialRampToValueAtTime(0.01, now + chord.time + chord.duration);
        osc.type = i === 0 ? 'sine' : 'triangle'; // Root is fuller
        osc.start(now + chord.time);
        osc.stop(now + chord.time + chord.duration + 0.1);
      });
    });

    // Add a final sparkle
    setTimeout(() => SoundFX.play('frogChorus'), 1800);
  },

  // Death/defeat sound - somber, descending
  playDefeat() {
    if (!this.enabled) return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    const now = this.ctx.currentTime;

    // Descending minor progression
    const lament = [
      { freq: 220, time: 0 },
      { freq: 196, time: 0.4 },
      { freq: 175, time: 0.8 },
      { freq: 147, time: 1.2 },
    ];

    lament.forEach(note => {
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      osc.frequency.setValueAtTime(note.freq, now + note.time);
      gain.gain.setValueAtTime(this.volume * 0.5, now + note.time);
      gain.gain.exponentialRampToValueAtTime(0.01, now + note.time + 0.5);
      osc.type = 'sawtooth';
      osc.start(now + note.time);
      osc.stop(now + note.time + 0.6);
    });
  },

  setVolume(vol) {
    this.volume = Math.max(0, Math.min(1, vol));
  }
};

// ===== VOLUME SETTINGS =====
// Apply volume settings from S state to audio systems
function applyVolumeSettings() {
  // Calculate effective volumes (master * individual)
  const effectiveSfx = (S.masterVolume || 1) * (S.sfxVolume || 1);
  const effectiveMusic = (S.masterVolume || 1) * (S.musicVolume || 1);

  // Apply to SoundFX (SFX)
  SoundFX.volume = 0.3 * effectiveSfx; // Base SFX volume is 0.3

  // Apply to SoundFX music (loaded audio files)
  SoundFX.musicVolume = 0.2 * effectiveMusic; // Base music volume is 0.2
  if (SoundFX.musicGain && SoundFX.ctx) {
    SoundFX.musicGain.gain.setValueAtTime(SoundFX.musicVolume, SoundFX.ctx.currentTime);
  }

  // Apply to ProceduralMusic
  ProceduralMusic.volume = 0.15 * effectiveMusic; // Base procedural music volume is 0.15

  // Update currently playing procedural music volume if active
  if (ProceduralMusic.gainNodes && ProceduralMusic.gainNodes.length > 0 && ProceduralMusic.ctx) {
    const masterGain = ProceduralMusic.gainNodes[0];
    if (masterGain && masterGain.gain) {
      masterGain.gain.setValueAtTime(ProceduralMusic.volume, ProceduralMusic.ctx.currentTime);
    }
  }
}

// Set master volume and apply
function setMasterVolume(vol) {
  S.masterVolume = Math.max(0, Math.min(1, vol));
  applyVolumeSettings();
  savePermanent();
}

// Set SFX volume and apply
function setSfxVolume(vol) {
  S.sfxVolume = Math.max(0, Math.min(1, vol));
  applyVolumeSettings();
  savePermanent();
}

// Set music volume and apply
function setMusicVolume(vol) {
  S.musicVolume = Math.max(0, Math.min(1, vol));
  applyVolumeSettings();
  savePermanent();
}


// ===== GAME STATE =====
let S = {
// ===== HERO STATE =====
heroes: [],
sig: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
tempSigUpgrades: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
sigUpgradeCounts: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},

// ===== GAME PROGRESSION =====
floor: 1,
gameMode: 'Standard', // 'Standard' or 'fu'
runNumber: 1,
currentSlot: null,
gold: 0,
xp: 0,
levelUpCount: 0,
goingRate: 1,
runsAttempted: 0,
startingXP: 0,
chosenHeroIdx: -1, // Index of "chosen one" hero (-1 = none, only set on run 2+)

// ===== COMBAT STATE (resets each combat) =====
activeIdx: -1,      // Currently acting hero index (-1 = none)
acted: [],          // Array of hero indices that have acted this turn
locked: false,      // UI locked during enemy turn
pending: null,      // Currently selected action (e.g., 'Attack', 'Shield')
targets: [],        // Selected target IDs for action
currentInstanceTargets: [], // Targets for current multi-instance iteration
instancesRemaining: 0,      // How many instances left to target
totalInstances: 0,          // Total instances for this action
lastActions: {},            // Last action taken by each hero (for Asterisk)
enemies: [],        // Current enemy array
recruits: [],       // Recruited enemies (fight for player)
round: 1,           // Current combat round
turn: 'player',     // 'player' or 'enemy'
combatXP: 0,        // XP earned this combat
combatGold: 0,      // Gold earned this combat
selectingEncampmentTargets: false, // Special state for Encampment encounter
encampmentEarlyKills: 0,           // Number of enemies to kill early
d20HeroIdx: -1,     // Hero index for D20 action targeting
d20Action: null,    // Current D20 gambit selected (CONFUSE/STARTLE/MEND/STEAL/RECRUIT)
d20DC: 0,           // Difficulty class for active D20 action
grappleRepeats: 0,  // Number of grapple repeats for recoil calculation
grappleLevel: 0,    // Grapple level for recoil calculation
turnDamage: 0,      // Damage dealt during current hero's turn (for damage counter)
inCombat: false,    // Whether player is currently in combat
combatEnding: false, // Guard flag to prevent double combat-end processing
combatStartSnapshot: null, // Snapshot of heroes/enemies at combat start (for restart)
alphaGrantedActions: [],   // Hero IDs receiving Alpha-granted bonus actions
alphaCurrentAction: 0,     // Current index in alpha granted actions sequence
alphaLevel: 0,             // Total Alpha actions to grant
alphaTargetsNeeded: 0,     // Number of targets for Alpha selection
asteriskD20Repeats: 1,     // Number of D20 repeats due to Asterisk
asteriskD20Count: 0,       // Current D20 execution count in repeat chain
enemyTurnCurrent: 0,       // Current enemy index being processed (UI progress)
enemyTurnTotal: 0,         // Total enemies in turn (UI progress)
encampmentSelectedTargets: [], // Enemy IDs selected for Encampment pre-combat kill

// ===== NEUTRAL ENCOUNTER STATE (resets each encounter) =====
neutralDeck: [],    // Deck of neutral encounter IDs
lastNeutral: null,  // Last neutral encountered (for non-repeat)
ambushed: false,    // Whether current combat is an ambush

// ===== TEMPORARY NEUTRAL STATE (resets on death) =====
silverKeyHeld: false,     // Silver key from Ghost Boys
oracleHero: null,         // Hero chosen at Oracle
oracleRoll: null,         // Roll result at Oracle
oracleStat: null,         // Stat chosen at Oracle
wizardSigil: null,        // Sigil being tested at Wizard
wizardHero: null,         // Hero index for wizard challenge encounter
wizardChallenges: null,   // Array of challenge thresholds for wizard
wizardChallengeIndex: 0,  // Current challenge index (0-3)
wizardUpgradedSigils: [], // Sigil names upgraded during wizard encounter
royalQuestActive: false,  // Whether a royal quest is currently active
royalQuestCompleted: false, // Whether current royal quest was completed
royalAskerTitle: null,    // Title of noble asking for royal quest
royalBelovedTitle: null,  // Title of beloved in royal quest
pendingNewRecruit: null,  // New recruit waiting for slot conflict resolution
pendingOldRecruitId: null, // ID of existing recruit being replaced

// ===== PERSISTENT STATE (survives death, saved in permanent storage) =====
ancientStatueDeactivated: false, // Ancient Statue one-time choice made
ghostBoysConverted: false,       // Ghost Boys converted (no longer hostile)
pedestal: [],                    // Champion hero figurines [{hero, mode, stats}]
hasReachedFloor20: false,        // Unlocks blue portal in Ribbleton
fuUnlocked: false,
forcedFUEntry: false,            // True after first Standard win, forces FU run
tapoUnlocked: false,             // Unlocked after first FU victory
advancedSigilsUnlocked: false,   // Death screen: Advanced sigils (Ghost, Alpha, Grapple) purchasable
passiveSigilsUnlocked: false,    // Death screen: Passive sigils (Expand, Asterisk, Star) purchasable
pondHistory: [],                 // Run history for "The Pond" - [{runNumber, heroes, floorReached, gameMode, outcome, killedBy, timestamp}]

// ===== QUEST BOARD STATE (persistent) =====
questsCompleted: {},             // Quest IDs that have been turned in: {quest_id: true}
questsClaimed: {},               // Quest IDs that have been claimed (rewards collected): {quest_id: true}
questProgress: {
  // Combat stats
  enemiesKilled: 0,
  totalDamageDealt: 0,
  maxDamageOneAction: 0,
  maxTargetsOneAction: 0,
  lastStandSurvived: false,

  // Action usage (ever)
  d20Used: false,
  shieldApplied: false,
  healUsed: false,
  grappleUsed: false,
  alphaUsed: false,
  ghostBlocked: false,

  // Per-hero tracking
  heroesPlayed: { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 },
  heroWins: { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 },

  // Neutral encounters completed (by base name, any stage)
  neutralsCompleted: {
    shopkeeper: false, wishingwell: false, treasurechest: false,
    wizard: false, oracle: false, encampment: false,
    gambling: false, ghost: false, royal: false
  },

  // Enemy types defeated
  enemyTypesDefeated: {
    Goblin: false, Wolf: false, Orc: false, Giant: false,
    'Cave Troll': false, Dragon: false, Flydra: false
  },

  // Milestone tracking
  highestFloor: 0,
  totalGoldEarned: 0,
  totalRunsCompleted: 0,
  standardWins: 0,
  fuWins: 0,
  maxRecruitsHeld: 0,
  purchasedUpgrade: false,

  // Repeatable quest tiers completed
  slayerTier: 0,
  goldDiggerTier: 0,
  veteranTier: 0
},

// ===== UI STATE =====
toastHistory: [],               // Array of recent toast messages
toastLogLocked: false,          // Whether toast log is locked open (persistent)
toastLogVisible: true,          // Whether toast log button is shown in header
tooltipsDisabled: false,        // Whether sigil tooltips are disabled
helpTipsDisabled: false,        // Whether tutorial help tips are disabled
highContrastMode: false,        // Whether high contrast accessibility mode is enabled
animationSpeed: 1,              // Animation speed: 1 (normal), 2 (fast), 4 (faster), 0 (instant)
masterVolume: 1.0,              // Master volume (0-1) - scales all audio
sfxVolume: 1.0,                 // SFX volume (0-1)
musicVolume: 1.0,               // Music volume (0-1)
controllerDisabled: false,      // Whether gamepad/controller support is disabled
inRibbleton: false,             // Whether player is in Ribbleton hub

// ===== DEBUG STATE =====
debugMode: false,       // Debug mode toggle
oopsAll20s: false,      // Debug cheat: all d20 rolls = 20

// ===== TUTORIAL STATE (permanent flags) =====
tutorialFlags: {
ribbleton_intro: false,
ribbleton_warrior_attack: false,
ribbleton_targeting: false,
ribbleton_healer_d20: false,
ribbleton_d20_menu: false,
healer_expand_explain: false,
ribbleton_enemy_turn: false,
ribbleton_healer_heal: false,
stun_intro: false,
ribbleton_expand: false,
ribbleton_finish_wolf: false,
enemies_get_sigils: false,
ribbleton_shield_sigil: false,
ribbleton_handoff: false,
ribbleton_tooltip_intro: false,
ribbleton_hub_intro: false,
levelup_intro: false,
levelup_stat_upgrade: false,
levelup_add_active: false,
levelup_upgrade_active: false,
levelup_upgrade_passive: false,
death_intro: false,
death_exit_warning: false,
neutral_intro: false,
neutral_d20_level: false,
faq_intro: false,
last_stand_intro: false,
last_stand_warning: false,
shield_persistence: false,
ghost_intro: false,
grapple_intro: false,
alpha_intro: false,
recruit_intro: false,
chosen_hero_intro: false,
run2_hero_lock: false,
first_victory_sequence: false,
first_fu_victory: false,
pedestal_first_placement: false,
tapo_victory_message: false,
tapo_first_attack: false,
auto_target_intro: false,
steam_controller_setup: false,
tutorial_fly_munched: false  // Killed a fly during tutorial (for 1G quest)
},
usedDeathQuotes: [], // Track which death quotes have been shown

// ===== SUSPEND/AUTOSAVE STATE =====
suspended: false,         // Whether game is currently suspended
lastAutosave: 0,          // Timestamp of last autosave
inCombat: false,          // Whether player is in active combat (for autosave)
combatEnding: false       // Guard flag to prevent multiple checkCombatEnd calls
};

let sel = [];

// ===== QUEST PROGRESS TRACKING =====
// Helper function to track quest progress
function trackQuestProgress(type, value) {
  if(!S.questProgress) return; // Guard against undefined
  // Don't track quest progress during tutorial (Floor 0)
  if(S.floor === 0) return;

  switch(type) {
    case 'enemyKill':
      S.questProgress.enemiesKilled++;
      // Track enemy type
      if(value && S.questProgress.enemyTypesDefeated.hasOwnProperty(value)) {
        S.questProgress.enemyTypesDefeated[value] = true;
      }
      break;
    case 'd20':
      S.questProgress.d20Used = true;
      break;
    case 'shield':
      S.questProgress.shieldApplied = true;
      break;
    case 'heal':
      S.questProgress.healUsed = true;
      break;
    case 'grapple':
      S.questProgress.grappleUsed = true;
      break;
    case 'alpha':
      S.questProgress.alphaUsed = true;
      break;
    case 'ghostBlock':
      S.questProgress.ghostBlocked = true;
      break;
    case 'lastStandSurvive':
      S.questProgress.lastStandSurvived = true;
      break;
    case 'damage':
      S.questProgress.totalDamageDealt += value;
      if(value > S.questProgress.maxDamageOneAction) {
        S.questProgress.maxDamageOneAction = value;
      }
      break;
    case 'targets':
      if(value > S.questProgress.maxTargetsOneAction) {
        S.questProgress.maxTargetsOneAction = value;
      }
      break;
    case 'floor':
      if(value > S.questProgress.highestFloor) {
        S.questProgress.highestFloor = value;
      }
      // Track FU mode floor progress separately
      if(S.gameMode === 'fu' && value > (S.questProgress.highestFUFloor || 0)) {
        S.questProgress.highestFUFloor = value;
      }
      break;
    case 'gold':
      S.questProgress.totalGoldEarned += value;
      break;
    case 'upgrade':
      S.questProgress.purchasedUpgrade = true;
      break;
    case 'recruits':
      if(value > S.questProgress.maxRecruitsHeld) {
        S.questProgress.maxRecruitsHeld = value;
      }
      break;
    case 'runComplete':
      S.questProgress.totalRunsCompleted++;
      break;
    case 'standardWin':
      S.questProgress.standardWins++;
      break;
    case 'fuWin':
      S.questProgress.fuWins++;
      break;
    case 'heroPlayed':
      if(value && S.questProgress.heroesPlayed.hasOwnProperty(value)) {
        S.questProgress.heroesPlayed[value]++;
      }
      break;
    case 'heroWin':
      if(value && S.questProgress.heroWins.hasOwnProperty(value)) {
        S.questProgress.heroWins[value]++;
      }
      break;
    case 'neutral':
      if(value && S.questProgress.neutralsCompleted.hasOwnProperty(value)) {
        S.questProgress.neutralsCompleted[value] = true;
      }
      break;
  }
  savePermanent();
}

// ===== RIBBLETON TUTORIAL STATE =====
let tutorialState = null;
// Tutorial state tracks scripted Ribbleton tutorial progress
// {
//   stage: 'warrior_attack' | 'targeting_wolf' | 'healer_d20' | 'd20_menu' | 'enemy_turn_explained' |
//          'healer_heal' | 'expand_targets' | 'finish_wolf' | 'shield_sigil' | 'handoff' | 'free',
//   wolfDamaged: boolean,
//   wolfKilled: boolean,
//   goblinKilled: boolean,
//   round: number
// }

// ===== HELPERS =====
function getFloorBackground(floor) {
// Progressive darkening from floor 1 (light brown) to floor 19 (black)
const colors = [
'#d9cab1', // Floor 1 - light brown (default)
'#cfc0a9', '#c5b6a1', '#bbac99', '#b1a291', '#a79889', // Floors 2-6
'#9d8e81', '#938479', '#897a71', '#7f7069', '#756661', // Floors 7-11
'#6b5c59', '#615251', '#574849', '#4d3e41', '#433439', // Floors 12-16
'#392a31', '#2f2029', '#251621', '#1b0c19' // Floors 17-20
];
return colors[Math.min(floor - 1, colors.length - 1)] || colors[0];
}

function renderHeroCard(hero, idx, onclickHandler, extraInfo = '') {
const hp = hero.ls ? `Last Stand (T${hero.lst+1})` : `${hero.h}/${hero.m}‚ù§`;
const extra = [];
if(hero.sh > 0) extra.push(`${hero.sh}üõ°`);
if(hero.g > 0) extra.push(`${hero.g}${sigilIconOnly('Ghost')}`);
return `<div class="card hero hero-selectable" onclick="${onclickHandler}" style="cursor:pointer;margin-bottom:0.75rem">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${hero.n}</div>
<div class="card-stats">${hero.p}üí• | ${hp}${extra.length>0?' | '+extra.join(' '):''}${extraInfo}</div>
</div>`;
}

function upd() {
const floorEl = document.getElementById('floor');
const roundEl = document.getElementById('round');
const roundInfoEl = document.getElementById('roundInfo');
const locationLabelEl = document.getElementById('locationLabel');

// Ensure floor is a valid number (fix for "Session 0 undefined floor" bug)
if(S.floor === undefined || S.floor === null) {
S.floor = 1;
}

// Update location display based on game state
if(S.floor === 0 && tutorialState) {
// Tutorial mode
floorEl.textContent = '';
locationLabelEl.textContent = 'Tutorial';
roundInfoEl.style.display = S.round > 0 ? '' : 'none';
roundEl.textContent = S.round || '';
} else if(S.floor === 0) {
// Floor 0 without tutorial - show as Ribbleton (pre-game state)
floorEl.textContent = '';
locationLabelEl.textContent = 'Ribbleton';
roundInfoEl.style.display = 'none';
} else if(S.inRibbleton) {
// In Ribbleton hub (before entering dungeon)
floorEl.textContent = '';
locationLabelEl.textContent = 'Ribbleton';
roundInfoEl.style.display = 'none';
} else if(!S.heroes || S.heroes.length === 0) {
// Hero selection screen (no heroes chosen yet)
floorEl.textContent = '';
locationLabelEl.textContent = 'Hero Select';
roundInfoEl.style.display = 'none';
} else if((S.enemies && S.enemies.length > 0) || S.inCombat) {
// In combat - show round indicator
floorEl.textContent = S.floor || 1;
locationLabelEl.textContent = 'Floor';
roundInfoEl.style.display = '';
roundEl.textContent = S.round || 1;
} else {
// Between combats (neutral floors, level up, etc.)
floorEl.textContent = S.floor || 1;
locationLabelEl.textContent = 'Floor';
roundInfoEl.style.display = 'none';
}

document.getElementById('gold').textContent = S.gold;
// Show combat XP during combat, cumulative XP otherwise
if(S.combatXP !== undefined && S.combatXP > 0) {
document.getElementById('xp').textContent = `${S.xp} (+${S.combatXP})`;
} else {
document.getElementById('xp').textContent = S.xp;
}
// Show/hide debug button
const debugBtn = document.getElementById('debugBtn');
if(debugBtn) debugBtn.style.display = S.debugMode ? 'block' : 'none';
// Update background color based on floor
const gameArea = document.getElementById('gameView');
if(gameArea) gameArea.style.background = getFloorBackground(S.floor);
// Toggle sinister FU mode background on body
document.body.classList.toggle('fu-mode', S.gameMode === 'fu');
}

function triggerHitAnimation(targetId) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('hit-flash');
setTimeout(() => {
const el = document.getElementById(targetId);
if(el) el.classList.remove('hit-flash');
}, ANIMATION_TIMINGS.DAMAGE_FLASH);
}
}

function triggerAttackAnimation(attackerId) {
const card = document.getElementById(attackerId);
if(card) {
card.classList.add('attack-slide');
setTimeout(() => {
const el = document.getElementById(attackerId);
if(el) el.classList.remove('attack-slide');
}, ANIMATION_TIMINGS.ATTACK_SLIDE);
}
}

function triggerEnemyAttackAnimation(attackerId) {
const card = document.getElementById(attackerId);
if(card) {
card.classList.add('enemy-attack-slide');
setTimeout(() => {
const el = document.getElementById(attackerId);
if(el) el.classList.remove('enemy-attack-slide');
}, ANIMATION_TIMINGS.ATTACK_SLIDE);
}
}

function triggerHealAnimation(targetId, healAmount = 0) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('heal-flash');
// JUICE: Sound effects - froggy gulp + heal chime
SoundFX.play('gulp');
setTimeout(() => SoundFX.play('heal'), 100);
// JUICE: Floating heal number
if (healAmount > 0) {
  showFloatingNumber(targetId, `+${healAmount}`, 'heal');
}
// Add healing cross overlay
const cross = document.createElement('div');
cross.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:3rem;color:#22c55e;text-shadow:0 0 10px #22c55e;pointer-events:none;z-index:1000;animation:heal-cross-fade 0.48s ease';
cross.textContent = '‚úö';
card.appendChild(cross);
setTimeout(() => {
const el = document.getElementById(targetId);
if(el) el.classList.remove('heal-flash');
if(cross.parentNode) cross.remove();
}, ANIMATION_TIMINGS.HEAL_FLASH);
}
}

function triggerShieldAnimation(targetId, shieldAmount = 0) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('shield-flash');
// JUICE: Sound effects - froggy bubble + shield chime
SoundFX.play('bubble');
setTimeout(() => SoundFX.play('shield'), 80);
// JUICE: Floating shield number
if (shieldAmount > 0) {
  showFloatingNumber(targetId, `+${shieldAmount}üõ°`, 'shield');
}
setTimeout(() => {
const el = document.getElementById(targetId);
if(el) el.classList.remove('shield-flash');
}, ANIMATION_TIMINGS.SHIELD_FLASH);
}
}

function addBonusTurnStack(cardId, count) {
const card = document.getElementById(cardId);
if(!card || count <= 0) return;
// Remove existing stack if any
removeBonusTurnStack(cardId);
// Create stack container
const stackContainer = document.createElement('div');
stackContainer.className = 'bonus-turn-stack';
stackContainer.id = `stack-${cardId}`;
// Add stacked cards (show just the corners)
for(let i = 0; i < Math.min(count, 5); i++) {
const stackCard = document.createElement('div');
stackCard.className = 'bonus-turn-card';
stackCard.style.transform = `translate(${-3 - i*3}px, ${-3 - i*3}px)`;
stackCard.style.zIndex = -1 - i;
stackContainer.appendChild(stackCard);
}
card.appendChild(stackContainer);
}

function removeBonusTurnStack(cardId, animated = false) {
const stack = document.getElementById(`stack-${cardId}`);
if(!stack) return;
if(animated && stack.children.length > 0) {
// Animate the top card sliding out
const topCard = stack.children[0];
topCard.classList.add('sliding-out');
setTimeout(() => {
topCard.remove();
// If no more cards, remove the whole stack
if(stack.children.length === 0) {
stack.remove();
}
}, 300);
} else {
stack.remove();
}
}

function updateBonusTurnStack(cardId, count) {
if(count <= 0) {
removeBonusTurnStack(cardId, true);
} else {
const stack = document.getElementById(`stack-${cardId}`);
if(!stack) {
addBonusTurnStack(cardId, count);
} else {
// Adjust stack size
const currentCount = stack.children.length;
if(currentCount > count) {
// Remove excess cards with animation
removeBonusTurnStack(cardId, true);
setTimeout(() => addBonusTurnStack(cardId, count), ANIMATION_TIMINGS.BONUS_TURN_STACK);
} else if(currentCount < count) {
// Add more cards
addBonusTurnStack(cardId, count);
}
}
}
}

// Track active toasts for stacking
let activeToasts = [];

// Reposition all toasts based on their actual heights
function repositionToasts() {
const baseBottom = document.body.classList.contains('controller-active') ? 70 : 20;
const gap = 8;
let currentBottom = baseBottom;
activeToasts.forEach(t => {
t.style.bottom = `${currentBottom}px`;
currentBottom += t.offsetHeight + gap;
});
}

function toast(msg, dur=1800) {
// Add to history (strip HTML for text log)
const textMsg = msg.replace(/<[^>]*>/g, '');
S.toastHistory.unshift(textMsg);
if(S.toastHistory.length > 20) S.toastHistory = S.toastHistory.slice(0, 20); // Keep last 20
updateToastLog();
// Show toast popup (supports HTML)
const t = document.createElement('div');
t.className = 'toast';
t.innerHTML = msg;
t.style.bottom = '-100px'; // Start off-screen
document.body.appendChild(t);
activeToasts.push(t);
// Wait for render then position based on actual heights
requestAnimationFrame(() => {
repositionToasts();
setTimeout(() => t.classList.add('show'), 10);
});
setTimeout(() => {
t.classList.remove('show');
setTimeout(() => {
t.remove();
activeToasts = activeToasts.filter(toast => toast !== t);
repositionToasts();
}, ANIMATION_TIMINGS.TOAST_FADE);
}, dur);
}

// Controller-friendly confirm modal to replace browser confirm()
let confirmModalCallback = null;
function showConfirmModal(message, onConfirm, onCancel) {
  // Remove existing modal if any
  const existingOverlay = document.querySelector('.confirm-modal-overlay');
  const existingModal = document.querySelector('.confirm-modal');
  if (existingOverlay) existingOverlay.remove();
  if (existingModal) existingModal.remove();

  // Create overlay
  const overlay = document.createElement('div');
  overlay.className = 'confirm-modal-overlay';

  // Create modal
  const modal = document.createElement('div');
  modal.className = 'confirm-modal';
  modal.innerHTML = `
    <h3>Confirm</h3>
    <p>${message}</p>
    <div class="confirm-modal-buttons">
      <button class="btn confirm-btn-yes" style="background:linear-gradient(135deg,#22c55e,#16a34a);min-width:100px">Yes</button>
      <button class="btn confirm-btn-no" style="background:linear-gradient(135deg,#ef4444,#dc2626);min-width:100px">No</button>
    </div>
  `;

  document.body.appendChild(overlay);
  document.body.appendChild(modal);

  const yesBtn = modal.querySelector('.confirm-btn-yes');
  const noBtn = modal.querySelector('.confirm-btn-no');

  function cleanup() {
    overlay.remove();
    modal.remove();
    confirmModalCallback = null;
    // Restore controller focus
    if (typeof GamepadController !== 'undefined' && GamepadController.active) {
      GamepadController.updateFocusableElements();
    }
  }

  yesBtn.onclick = () => {
    cleanup();
    if (onConfirm) onConfirm();
  };

  noBtn.onclick = () => {
    cleanup();
    if (onCancel) onCancel();
  };

  // Store callback for controller B button to cancel
  confirmModalCallback = () => {
    cleanup();
    if (onCancel) onCancel();
  };

  // Keyboard support for desktop users
  function handleKeydown(e) {
    if (e.key === 'Escape') {
      e.preventDefault();
      cleanup();
      document.removeEventListener('keydown', handleKeydown);
      if (onCancel) onCancel();
    }
    // Trap focus within modal (Tab cycles between Yes and No)
    if (e.key === 'Tab') {
      const focusedEl = document.activeElement;
      if (e.shiftKey && focusedEl === yesBtn) {
        e.preventDefault();
        noBtn.focus();
      } else if (!e.shiftKey && focusedEl === noBtn) {
        e.preventDefault();
        yesBtn.focus();
      }
    }
  }
  document.addEventListener('keydown', handleKeydown);

  // Update cleanup to remove keyboard listener
  const originalCleanup = cleanup;
  cleanup = function() {
    document.removeEventListener('keydown', handleKeydown);
    originalCleanup();
  };

  // Focus the Yes button for controller navigation
  if (typeof GamepadController !== 'undefined' && GamepadController.active) {
    GamepadController.updateFocusableElements();
    GamepadController.setFocus(yesBtn);
  } else {
    yesBtn.focus();
  }
}

function initToastLog() {
const existing = document.getElementById('toastLog');
if(existing) return;
const log = document.createElement('div');
log.id = 'toastLog';
log.className = 'toast-log';
document.body.appendChild(log);
updateToastLog();
}

function toggleToastLog() {
// Toggle the locked state
S.toastLogLocked = !S.toastLogLocked;
const log = document.getElementById('toastLog');
if(!log) return;
if(S.toastLogLocked) {
log.classList.add('show', 'locked');
} else {
log.classList.remove('show', 'locked');
}
updateToastLog();
}

function minimizeToastLog() {
// Minimize without changing locked state preference
S.toastLogLocked = false;
const log = document.getElementById('toastLog');
if(log) {
log.classList.remove('show', 'locked');
}
}

function updateToastLog() {
const log = document.getElementById('toastLog');
if(!log) return;
let html = `<div class="toast-log-header">
<span style="font-size:1rem">ü™µ Combat Log</span>
<button onclick="minimizeToastLog()" style="background:#ef4444;border:2px solid #000;border-radius:4px;padding:0.25rem 0.5rem;font-weight:bold;cursor:pointer;font-size:0.8rem">‚úï</button>
</div>`;
html += '<div class="toast-log-entries">';
S.toastHistory.forEach((msg, idx) => {
html += `<div class="toast-log-entry ${idx === 0 ? 'recent' : ''}">${msg}</div>`;
});
if(S.toastHistory.length === 0) {
html += '<div class="toast-log-entry">No messages yet</div>';
}
html += '</div>';
log.innerHTML = html;
}

function showTutorialPop(flagName, message, onDismiss) {
debugLog('[TUTORIAL] showTutorialPop called:', flagName, 'Already shown:', S.tutorialFlags[flagName]);
if(S.helpTipsDisabled || S.tutorialFlags[flagName]) {
debugLog('[TUTORIAL] Skipping pop (disabled or already shown), calling callback directly');
if(onDismiss) onDismiss();
return;
}
// Prevent creating new backdrop while one exists (avoid stacking)
const existingBackdrop = document.querySelector('.tutorial-modal-backdrop');
if(existingBackdrop) {
debugLog('[TUTORIAL] Backdrop already exists, queuing callback');
// Queue this popup for after current one is dismissed
const existingCallback = window.tutorialCallback;
window.tutorialCallback = () => {
if(existingCallback) existingCallback();
// Delay slightly to prevent rapid-fire popups
setTimeout(() => showTutorialPop(flagName, message, onDismiss), 100);
};
return;
}
// Add tutorial message to toast log for reference
S.toastHistory.unshift(`üìñ ${message}`);
if(S.toastHistory.length > 20) S.toastHistory = S.toastHistory.slice(0, 20);
updateToastLog();
// Create blocking modal
const backdrop = document.createElement('div');
backdrop.className = 'tutorial-modal-backdrop';
backdrop.innerHTML = `
<div class="tutorial-modal">
<h2>Tip!</h2>
<p>${message}</p>
<button onclick="dismissTutorialPop('${flagName}')">Got it!</button>
<div class="controller-hint" style="margin-top:0.5rem;font-size:0.8rem;opacity:0.7">‚í∂ to continue</div>
</div>`;
document.body.appendChild(backdrop);
debugLog('[TUTORIAL] Backdrop created and appended');
// Auto-focus the button for keyboard accessibility
const btn = backdrop.querySelector('button');
if(btn) setTimeout(() => btn.focus(), 50);
// Store callback for later
window.tutorialCallback = onDismiss;
}

function dismissTutorialPop(flagName) {
debugLog('[TUTORIAL] dismissTutorialPop called:', flagName);
S.tutorialFlags[flagName] = true;
savePermanent();

// Set cooldown to prevent click-through to game elements behind popup
// This prevents controller A button from selecting sigils after dismissing popup
window.tutorialDismissTime = Date.now();

// Capture callback before removal (prevent race conditions)
const callback = window.tutorialCallback;
window.tutorialCallback = null;

// Remove ALL backdrops synchronously and aggressively
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
allBackdrops.forEach(b => b.remove());

// Use requestAnimationFrame to ensure DOM is updated before callback
requestAnimationFrame(() => {
// Double-check for any zombie backdrops
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
remaining.forEach(r => r.remove());

// Execute callback if exists
if(callback) {
try {
callback();
} catch (error) {
console.error('[TUTORIAL] Callback error:', error);
}
}
});
}

function showRecruitReplaceConfirm(oldName, newName, onKeep, onReplace) {
const backdrop = document.createElement('div');
backdrop.className = 'tutorial-modal-backdrop';
backdrop.innerHTML = `
<div class="tutorial-modal">
<h2>Replace Recruit?</h2>
<p>You already have <strong>${oldName}</strong>. Replace with <strong>${newName}</strong>?</p>
<div style="display:flex;gap:0.5rem;justify-content:center;margin-top:1rem">
<button onclick="confirmRecruitReplace(false)" style="background:#666;padding:0.5rem 1rem">Keep ${oldName}</button>
<button onclick="confirmRecruitReplace(true)" style="background:#4a4;padding:0.5rem 1rem">Replace with ${newName}</button>
</div>
</div>`;
document.body.appendChild(backdrop);
window.recruitReplaceCallback = { onKeep, onReplace };
}

function confirmRecruitReplace(replace) {
const callbacks = window.recruitReplaceCallback;
document.querySelectorAll('.tutorial-modal-backdrop').forEach(b => b.remove());
window.recruitReplaceCallback = null;
if(replace && callbacks && callbacks.onReplace) callbacks.onReplace();
else if(!replace && callbacks && callbacks.onKeep) callbacks.onKeep();
}

// LEGACY: Pre-slot save functions. Overridden by slot-based versions below (line ~1270).
// Kept as fallback for loadPermanent()/loadGame() which read from these keys for migration.
function savePermanent() {
try {
// Create backup of existing save before overwriting
const existing = localStorage.getItem('froggle8_permanent');
if(existing) {
localStorage.setItem('froggle8_permanent_backup', existing);
}
localStorage.setItem('froggle8_permanent', JSON.stringify({
version: GAME_VERSION,
gold: S.gold,
goingRate: S.goingRate,
startingXP: S.startingXP,
sig: S.sig,
sigUpgradeCounts: S.sigUpgradeCounts,
ancientStatueDeactivated: S.ancientStatueDeactivated,
ghostBoysConverted: S.ghostBoysConverted,
pedestal: S.pedestal,
hasReachedFloor20: S.hasReachedFloor20,
fuUnlocked: S.fuUnlocked,
forcedFUEntry: S.forcedFUEntry,
tapoUnlocked: S.tapoUnlocked,
advancedSigilsUnlocked: S.advancedSigilsUnlocked,
passiveSigilsUnlocked: S.passiveSigilsUnlocked,
runNumber: S.runNumber,
runsAttempted: S.runsAttempted,
tutorialFlags: S.tutorialFlags,
helpTipsDisabled: S.helpTipsDisabled,
tooltipsDisabled: S.tooltipsDisabled,
toastLogVisible: S.toastLogVisible,
toastLogLocked: S.toastLogLocked,
highContrastMode: S.highContrastMode,
usedDeathQuotes: S.usedDeathQuotes,
controllerDisabled: S.controllerDisabled,
animationSpeed: S.animationSpeed,
masterVolume: S.masterVolume,
sfxVolume: S.sfxVolume,
musicVolume: S.musicVolume,
pondHistory: S.pondHistory,
questsCompleted: S.questsCompleted,
questsClaimed: S.questsClaimed,
questProgress: S.questProgress
}));
} catch(e) {
console.warn('[SAVE] Failed to save permanent data:', e);
if(e.name === 'QuotaExceededError' || (e.code && e.code === 22)) {
toast('Storage full! Go to title screen > Save Manager to delete old slots.', 3500);
} else {
toast('Save failed. Check browser storage in Settings > Privacy.', 2500);
}
}
}

// Validate save data has required structure
function validateSaveData(data, type = 'permanent') {
if(typeof data !== 'object' || data === null) {
throw new Error('Save data is not an object');
}
if(type === 'permanent') {
// Check core permanent data structure
if(data.sig && typeof data.sig !== 'object') throw new Error('Invalid sig structure');
if(data.pedestal && !Array.isArray(data.pedestal)) throw new Error('Invalid pedestal structure');
}
if(type === 'run') {
// Check core run data structure
if(typeof data.f !== 'number') throw new Error('Invalid floor value');
if(data.h && !Array.isArray(data.h)) throw new Error('Invalid heroes structure');
}
return true;
}

function loadPermanent() {
try {
const d = localStorage.getItem('froggle8_permanent');
if(!d) return;
const j = JSON.parse(d);

// Validate data structure
try {
validateSaveData(j, 'permanent');
} catch(validationError) {
console.warn('[SAVE] Validation failed, attempting backup restore:', validationError.message);
const backup = localStorage.getItem('froggle8_permanent_backup');
if(backup) {
const backupData = JSON.parse(backup);
validateSaveData(backupData, 'permanent');
localStorage.setItem('froggle8_permanent', backup);
toast('Save data was corrupted. Restored from backup.', 3000);
return loadPermanent(); // Retry with restored backup
}
throw validationError;
}

// Log version info if present
if(j.version) {
debugLog(`[SAVE] Loading save from version ${j.version}`);
}

S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// One-time fix: Detect and repair old saves with starter actives at L1 (should be L0)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
let needsFix = false;
starterActives.forEach(sig => {
if(S.sig[sig] === 1 && S.sigUpgradeCounts[sig] === 0) {
// Starter active at L1 with no upgrades = old save format, fix it
S.sig[sig] = 0;
needsFix = true;
}
});
if(needsFix) {
debugLog('[SAVE] Fixed old save format: starter actives L1‚ÜíL0');
savePermanent(); // Save the fix
}
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.pedestal = j.pedestal || [];
S.hasReachedFloor20 = j.hasReachedFloor20 || false;
S.fuUnlocked = j.fuUnlocked || false;
S.forcedFUEntry = j.forcedFUEntry || false;
S.tapoUnlocked = j.tapoUnlocked || false;
S.advancedSigilsUnlocked = j.advancedSigilsUnlocked || false;
S.passiveSigilsUnlocked = j.passiveSigilsUnlocked || false;
S.runNumber = j.runNumber || 1;
S.runsAttempted = j.runsAttempted || 0;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.tooltipsDisabled = j.tooltipsDisabled || false;
S.toastLogVisible = j.toastLogVisible !== undefined ? j.toastLogVisible : true;
S.toastLogLocked = j.toastLogLocked || false;
S.highContrastMode = j.highContrastMode || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
S.controllerDisabled = j.controllerDisabled || false;
S.animationSpeed = j.animationSpeed !== undefined ? j.animationSpeed : 1;
S.masterVolume = j.masterVolume !== undefined ? j.masterVolume : 1.0;
S.sfxVolume = j.sfxVolume !== undefined ? j.sfxVolume : 1.0;
S.musicVolume = j.musicVolume !== undefined ? j.musicVolume : 1.0;
// Apply volume settings to audio systems
applyVolumeSettings();
S.pondHistory = j.pondHistory || [];
// Apply high contrast mode if enabled
if(S.highContrastMode) document.body.classList.add('high-contrast');
// Load quest data with defaults
S.questsCompleted = j.questsCompleted || {};
S.questsClaimed = j.questsClaimed || {};
if(j.questProgress) {
  // Merge loaded progress with defaults to handle new fields
  Object.assign(S.questProgress, j.questProgress);
  // Ensure nested objects exist
  if(!S.questProgress.heroesPlayed) S.questProgress.heroesPlayed = { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 };
  if(!S.questProgress.heroWins) S.questProgress.heroWins = { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 };
  if(!S.questProgress.neutralsCompleted) S.questProgress.neutralsCompleted = { shopkeeper: false, wishingwell: false, treasurechest: false, wizard: false, oracle: false, encampment: false, gambling: false, ghost: false, royal: false };
  if(!S.questProgress.enemyTypesDefeated) S.questProgress.enemyTypesDefeated = { Goblin: false, Wolf: false, Orc: false, Giant: false, 'Cave Troll': false, Dragon: false, Flydra: false };
}
if(j.tutorialFlags) {
Object.assign(S.tutorialFlags, j.tutorialFlags);
}
} catch(e) {
console.warn('[SAVE] Failed to load permanent data:', e);
// Continue with defaults if load fails
}
}

// LEGACY: Pre-slot saveGame. Overridden by slot-based version below (line ~1330).
function saveGame() {
try {
localStorage.setItem('froggle8', JSON.stringify({
f:S.floor, x:S.xp, luc:S.levelUpCount,
h:S.heroes,
neutralDeck:S.neutralDeck, lastNeutral:S.lastNeutral,
tempSigUpgrades: S.tempSigUpgrades,
gameMode: S.gameMode,
chosenHeroIdx: S.chosenHeroIdx
}));
savePermanent();
} catch(e) {
console.warn('[SAVE] Failed to save game:', e);
if(e.name === 'QuotaExceededError' || (e.code && e.code === 22)) {
toast('Storage full! Go to title screen > Save Manager to delete old slots.', 3500);
} else {
toast('Game save failed. Try clearing old slots in Save Manager.', 2500);
}
}
}

function loadGame() {
loadPermanent(); // Load persistent data first
try {
const d = localStorage.getItem('froggle8');
if(!d) return;
const j = JSON.parse(d);
S.floor=j.f; S.xp=j.x; S.levelUpCount=j.luc || 0;
S.heroes=j.h;
S.neutralDeck=j.neutralDeck || [];
S.lastNeutral=j.lastNeutral || null;
S.tempSigUpgrades = j.tempSigUpgrades || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.gameMode = j.gameMode || 'Standard';
S.chosenHeroIdx = j.chosenHeroIdx !== undefined ? j.chosenHeroIdx : -1;
S.recruits = []; // Recruits don't persist across saves
S.heroes.forEach(h => {
if(!h.ts) h.ts = [];
// Migration fix: Remove Attack from Healer (was removed from starting sigils)
if(h.n === 'Healer' && h.s.includes('Attack')) {
h.s = h.s.filter(sig => sig !== 'Attack');
debugLog('[SAVE] Migrated Healer: removed Attack from saved sigils');
}
});
// CRITICAL: Check for invalid save state (all heroes in Last Stand)
// This can happen if game was closed during/after defeat before reaching death screen
const allHeroesInLastStand = S.heroes.length > 0 && S.heroes.every(h => h.ls);
if(allHeroesInLastStand) {
debugLog('[SAVE] Detected invalid save: all heroes in Last Stand, going to death screen');
// Clear the corrupted run save
localStorage.removeItem('froggle8');
// Clear temp upgrades
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
upd();
toast('Continuing from last defeat...', 1800);
setTimeout(() => transitionScreen(showDeathScreen), 500);
return;
}
upd();
startFloor(S.floor);
toast('Loaded!');
} catch(e) {
console.warn('[SAVE] Failed to load game:', e);
toast('Error loading saved game. Starting new game...', ANIMATION_TIMINGS.TOAST_LONG);
setTimeout(() => transitionScreen(title), ANIMATION_TIMINGS.TOAST_LONG);
}
}

// ===== SAVE SLOT SYSTEM =====
// Get metadata for a save slot (without loading it)
function getSlotMetadata(slot) {
try {
// Try new slot system first
let d = localStorage.getItem(`froggle8_permanent_slot${slot}`);
if(d) {
const j = JSON.parse(d);
const runData = localStorage.getItem(`froggle8_slot${slot}`);
let activeFloor = null;
if(runData) {
try {
const r = JSON.parse(runData);
activeFloor = r.f || null;
} catch(e) {}
}
return {
exists: true,
runsAttempted: j.runsAttempted || j.runNumber || 1,
goingRate: j.goingRate || 1,
hasActiveRun: !!runData,
activeFloor: activeFloor,
lastSaved: j.lastSaved || null
};
}
// Check old system for migration
if(slot === 1) {
d = localStorage.getItem('froggle8_permanent');
if(d) {
const j = JSON.parse(d);
const oldRunData = localStorage.getItem('froggle8');
let activeFloor = null;
if(oldRunData) {
try {
const r = JSON.parse(oldRunData);
activeFloor = r.f || null;
} catch(e) {}
}
return {
exists: true,
runsAttempted: j.runNumber || 1,
goingRate: j.goingRate || 1,
hasActiveRun: !!oldRunData,
activeFloor: activeFloor,
needsMigration: true
};
}
}
return { exists: false };
} catch(e) {
console.warn(`[SAVE] Error reading slot ${slot}:`, e);
return { exists: false };
}
}

// Migrate old save to slot 1
function migrateOldSave() {
try {
const oldPerm = localStorage.getItem('froggle8_permanent');
const oldRun = localStorage.getItem('froggle8');
if(oldPerm) {
// Parse and fix old save data before migrating
const j = JSON.parse(oldPerm);
// Fix starter actives that were incorrectly at L1 (should be L0 for storage)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
if(j.sig) {
starterActives.forEach(sig => {
if(j.sig[sig] === 1) {
j.sig[sig] = 0;
// Also adjust sigUpgradeCounts if it exists
if(j.sigUpgradeCounts && j.sigUpgradeCounts[sig] > 0) {
j.sigUpgradeCounts[sig] = Math.max(0, j.sigUpgradeCounts[sig] - 1);
}
}
});
}
localStorage.setItem('froggle8_permanent_slot1', JSON.stringify(j));
localStorage.removeItem('froggle8_permanent');
debugLog('[SAVE] Migrated and fixed old save to slot 1');
}
if(oldRun) {
localStorage.setItem('froggle8_slot1', oldRun);
localStorage.removeItem('froggle8');
}
} catch(e) {
console.warn('[SAVE] Migration failed:', e);
}
}

// Load a specific slot
function loadSlot(slot) {
S.currentSlot = slot;
localStorage.setItem('froggle8_current_slot', slot.toString());
// Load permanent data
try {
const d = localStorage.getItem(`froggle8_permanent_slot${slot}`);
if(d) {
const j = JSON.parse(d);

// Validate and potentially restore from backup
try {
validateSaveData(j, 'permanent');
} catch(validationError) {
console.warn(`[SAVE] Slot ${slot} validation failed:`, validationError.message);
const backup = localStorage.getItem(`froggle8_permanent_slot${slot}_backup`);
if(backup) {
const backupData = JSON.parse(backup);
validateSaveData(backupData, 'permanent');
localStorage.setItem(`froggle8_permanent_slot${slot}`, backup);
toast('Save corrupted. Restored from backup.', 3000);
return loadSlot(slot); // Retry with restored backup
}
throw validationError;
}

// Log version info
if(j.version) {
debugLog(`[SAVE] Slot ${slot} from version ${j.version}`);
}

S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.runsAttempted = j.runsAttempted || j.runNumber || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// One-time fix: Detect and repair old saves with starter actives at L1 (should be L0)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
let needsFix = false;
starterActives.forEach(sig => {
if(S.sig[sig] === 1 && S.sigUpgradeCounts[sig] === 0) {
// Starter active at L1 with no upgrades = old save format, fix it
S.sig[sig] = 0;
needsFix = true;
}
});
if(needsFix) {
debugLog('[SAVE] Fixed old save format: starter actives L1‚ÜíL0');
savePermanent(); // Save the fix
}
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.pedestal = j.pedestal || [];
S.hasReachedFloor20 = j.hasReachedFloor20 || false;
S.fuUnlocked = j.fuUnlocked || false;
S.forcedFUEntry = j.forcedFUEntry || false;
S.tapoUnlocked = j.tapoUnlocked || false;
S.advancedSigilsUnlocked = j.advancedSigilsUnlocked || false;
S.passiveSigilsUnlocked = j.passiveSigilsUnlocked || false;
S.runNumber = j.runNumber || 1;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.tooltipsDisabled = j.tooltipsDisabled || false;
S.toastLogVisible = j.toastLogVisible !== undefined ? j.toastLogVisible : true;
S.toastLogLocked = j.toastLogLocked || false;
S.highContrastMode = j.highContrastMode || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
// Apply high contrast mode if enabled
if(S.highContrastMode) document.body.classList.add('high-contrast');
if(j.tutorialFlags) Object.assign(S.tutorialFlags, j.tutorialFlags);
// Load quest data with defaults
S.questsCompleted = j.questsCompleted || {};
S.questsClaimed = j.questsClaimed || {};
if(j.questProgress) {
  Object.assign(S.questProgress, j.questProgress);
  if(!S.questProgress.heroesPlayed) S.questProgress.heroesPlayed = { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 };
  if(!S.questProgress.heroWins) S.questProgress.heroWins = { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 };
  if(!S.questProgress.neutralsCompleted) S.questProgress.neutralsCompleted = { shopkeeper: false, wishingwell: false, treasurechest: false, wizard: false, oracle: false, encampment: false, gambling: false, ghost: false, royal: false };
  if(!S.questProgress.enemyTypesDefeated) S.questProgress.enemyTypesDefeated = { Goblin: false, Wolf: false, Orc: false, Giant: false, 'Cave Troll': false, Dragon: false, Flydra: false };
}
}
// Try to load active run
const runData = localStorage.getItem(`froggle8_slot${slot}`);
if(runData) {
const r = JSON.parse(runData);
S.floor = r.f;
S.xp = r.x;
S.levelUpCount = r.luc || 0;
S.heroes = r.h;
S.neutralDeck = r.neutralDeck || [];
S.lastNeutral = r.lastNeutral || null;
S.tempSigUpgrades = r.tempSigUpgrades || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.gameMode = r.gameMode || 'Standard';
S.chosenHeroIdx = r.chosenHeroIdx !== undefined ? r.chosenHeroIdx : -1;
S.recruits = []; // Recruits don't persist across saves
S.heroes.forEach(h => {
if(!h.ts) h.ts = [];
// Migration fix: Remove Attack from Healer (was removed from starting sigils)
if(h.n === 'Healer' && h.s.includes('Attack')) {
h.s = h.s.filter(sig => sig !== 'Attack');
debugLog('[SAVE] Migrated Healer: removed Attack from saved sigils');
}
});
// CRITICAL: Check for invalid save state (all heroes in Last Stand)
// This can happen if game was closed during/after defeat before reaching death screen
const allHeroesInLastStand = S.heroes.length > 0 && S.heroes.every(h => h.ls);
if(allHeroesInLastStand) {
debugLog('[SAVE] Detected invalid save: all heroes in Last Stand, going to death screen');
// Clear the corrupted run save
localStorage.removeItem(`froggle8_slot${slot}`);
// Clear temp upgrades
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
upd();
toast('Continuing from last defeat...', 1800);
setTimeout(() => transitionScreen(showDeathScreen), 500);
return true;
}
// CRITICAL: Check for invalid tutorial floor save (floor 0)
// Tutorial shouldn't be saved mid-combat - advance to floor 1
if(S.floor === 0) {
debugLog('[SAVE] Detected invalid tutorial save: floor 0, advancing to floor 1');
S.floor = 1;
// Clear the corrupted save and re-save with correct floor
localStorage.removeItem(`froggle8_slot${slot}`);
}
upd();
startFloor(S.floor);
toast('Slot loaded!');
return true;
}
} catch(e) {
console.warn('[SAVE] Failed to load slot:', e);
}
return false;
}

// Update save functions to use current slot
savePermanent = function() {
if(!S.currentSlot) {
console.warn('[SAVE] No currentSlot set, defaulting to slot 1');
S.currentSlot = 1;
localStorage.setItem('froggle8_current_slot', '1');
}
try {
// Create backup of existing slot save before overwriting
const existingSlot = localStorage.getItem(`froggle8_permanent_slot${S.currentSlot}`);
if(existingSlot) {
localStorage.setItem(`froggle8_permanent_slot${S.currentSlot}_backup`, existingSlot);
}
localStorage.setItem(`froggle8_permanent_slot${S.currentSlot}`, JSON.stringify({
version: GAME_VERSION,
lastSaved: Date.now(),
gold: S.gold,
goingRate: S.goingRate,
runsAttempted: S.runsAttempted,
startingXP: S.startingXP,
sig: S.sig,
sigUpgradeCounts: S.sigUpgradeCounts,
ancientStatueDeactivated: S.ancientStatueDeactivated,
ghostBoysConverted: S.ghostBoysConverted,
pedestal: S.pedestal,
hasReachedFloor20: S.hasReachedFloor20,
fuUnlocked: S.fuUnlocked,
forcedFUEntry: S.forcedFUEntry,
tapoUnlocked: S.tapoUnlocked,
advancedSigilsUnlocked: S.advancedSigilsUnlocked,
passiveSigilsUnlocked: S.passiveSigilsUnlocked,
runNumber: S.runNumber,
tutorialFlags: S.tutorialFlags,
helpTipsDisabled: S.helpTipsDisabled,
tooltipsDisabled: S.tooltipsDisabled,
toastLogVisible: S.toastLogVisible,
toastLogLocked: S.toastLogLocked,
highContrastMode: S.highContrastMode,
usedDeathQuotes: S.usedDeathQuotes,
controllerDisabled: S.controllerDisabled,
animationSpeed: S.animationSpeed,
masterVolume: S.masterVolume,
sfxVolume: S.sfxVolume,
musicVolume: S.musicVolume,
pondHistory: S.pondHistory,
questsCompleted: S.questsCompleted,
questsClaimed: S.questsClaimed,
questProgress: S.questProgress
}));
} catch(e) {
console.warn('[SAVE] Failed to save permanent data:', e);
if(e.name === 'QuotaExceededError' || (e.code && e.code === 22)) {
toast('Storage full! Go to title screen > Save Manager to delete old slots.', 3500);
} else {
toast('Save failed. Check browser storage in Settings > Privacy.', 2500);
}
}
};

saveGame = function() {
if(!S.currentSlot) {
console.warn('[SAVE] No currentSlot set, defaulting to slot 1');
S.currentSlot = 1;
localStorage.setItem('froggle8_current_slot', '1');
}
try {
localStorage.setItem(`froggle8_slot${S.currentSlot}`, JSON.stringify({
f:S.floor, x:S.xp, luc:S.levelUpCount,
h:S.heroes,
neutralDeck:S.neutralDeck, lastNeutral:S.lastNeutral,
tempSigUpgrades: S.tempSigUpgrades,
gameMode: S.gameMode,
chosenHeroIdx: S.chosenHeroIdx
}));
savePermanent();
} catch(e) {
console.warn('[SAVE] Failed to save game:', e);
if(e.name === 'QuotaExceededError' || (e.code && e.code === 22)) {
toast('Storage full! Go to title screen > Save Manager to delete old slots.', 3500);
} else {
toast('Game save failed. Try clearing old slots in Save Manager.', 2500);
}
}
};

// ===== AUTOSAVE SYSTEM =====
const AUTOSAVE_THROTTLE = 5000; // Minimum 5 seconds between autosaves

function autosave() {
// Only autosave if we have an active slot and are in combat (not during tutorial)
if(!S.currentSlot || !S.inCombat || S.floor === 0) return;

// Throttle autosaves
const now = Date.now();
if(now - S.lastAutosave < AUTOSAVE_THROTTLE) return;

S.lastAutosave = now;
saveGame();
showAutosaveIndicator();
debugLog('[AUTOSAVE] Game autosaved');
}

function showAutosaveIndicator() {
// Show a subtle "‚úì Saved" indicator in the corner
let indicator = document.getElementById('autosave-indicator');
if(!indicator) {
indicator = document.createElement('div');
indicator.id = 'autosave-indicator';
indicator.style.cssText = 'position:fixed;top:8px;right:8px;background:rgba(34,197,94,0.9);color:white;padding:4px 10px;border-radius:4px;font-size:0.75rem;font-weight:bold;opacity:0;transition:opacity 0.3s;z-index:9999;pointer-events:none';
document.body.appendChild(indicator);
}
indicator.textContent = '‚úì Saved';
indicator.style.opacity = '1';
setTimeout(() => { indicator.style.opacity = '0'; }, 1500);
}

// ===== SUSPEND/RESUME SYSTEM =====
function suspendGame() {
if(S.suspended) return;
S.suspended = true;

// Immediately save if we have an active run
if(S.currentSlot && S.heroes.length > 0) {
saveGame();
debugLog('[SUSPEND] Game saved on suspend');
}

// Show suspend overlay
showSuspendOverlay();
}

function resumeGame() {
if(!S.suspended) return;
S.suspended = false;

// Hide suspend overlay
hideSuspendOverlay();

// Resume audio context if needed
if(typeof SoundFX !== 'undefined' && SoundFX.ctx && SoundFX.ctx.state === 'suspended') {
SoundFX.ctx.resume();
}

debugLog('[RESUME] Game resumed');
}

// Global reference for suspend keyboard handler cleanup
let suspendKeyHandler = null;

function showSuspendOverlay() {
// Remove any existing overlay
hideSuspendOverlay();

const overlay = document.createElement('div');
overlay.id = 'suspend-overlay';
overlay.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.9);
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
z-index: 10000;
color: white;
font-family: inherit;
`;
overlay.innerHTML = `
<div style="text-align:center">
<div style="font-size:3rem;margin-bottom:1rem">üê∏</div>
<h2 style="font-size:1.5rem;margin:0 0 0.5rem 0;color:#22c55e">FROGGLE SUSPENDED</h2>
<p style="font-size:1rem;opacity:0.8;margin:0 0 1.5rem 0">Game saved. Tap or press any button to resume.</p>
<div style="font-size:0.9rem;opacity:0.6">Progress has been saved automatically.</div>
</div>
`;

// Resume on any interaction
overlay.addEventListener('click', resumeGame);
overlay.addEventListener('touchstart', resumeGame);

// Also handle keyboard for Steam Deck
suspendKeyHandler = (e) => {
resumeGame();
};
document.addEventListener('keydown', suspendKeyHandler);

// Store handler reference for cleanup (backup)
overlay._keyHandler = suspendKeyHandler;

document.body.appendChild(overlay);
}

function hideSuspendOverlay() {
// Clean up keyboard handler using global reference (most reliable)
if(suspendKeyHandler) {
document.removeEventListener('keydown', suspendKeyHandler);
suspendKeyHandler = null;
}
const overlay = document.getElementById('suspend-overlay');
if(overlay) {
// Backup cleanup via overlay reference
if(overlay._keyHandler) {
document.removeEventListener('keydown', overlay._keyHandler);
}
overlay.remove();
}
}

// Initialize visibility change listener
function initSuspendSystem() {
// Handle page visibility changes (tab switch, minimize, Steam Deck suspend)
document.addEventListener('visibilitychange', () => {
if(document.hidden) {
suspendGame();
} else {
resumeGame();
}
});

// Handle page unload (close tab, navigate away)
window.addEventListener('pagehide', () => {
if(S.currentSlot && S.heroes.length > 0) {
saveGame();
debugLog('[PAGEHIDE] Game saved before unload');
}
});

// Also handle beforeunload for older browsers
window.addEventListener('beforeunload', () => {
if(S.currentSlot && S.heroes.length > 0) {
saveGame();
}
});

debugLog('[SUSPEND] Suspend system initialized');
}


// ===== FLOOR MANAGEMENT =====
function getFloorName(f) {
const floorNames = {
1: 'Goblin Stragglers',
3: 'Wolf Pack',
5: 'Orc Wall',
7: 'Fe Fi Fo Fum',
9: 'Just Trolling',
11: 'Goblin Legion',
13: 'Too Many Wolves',
15: 'Territorial Dragon',
17: 'Chaos Legion',
19: 'Lair of the Flydra'
};
return floorNames[f] || null;
}

function showFloorInterstitial(f, callback) {
const floorName = getFloorName(f);
if(!floorName) {
callback();
return;
}
// JUICE: Floor enter sound
SoundFX.play('floorEnter');
const v = document.getElementById('gameView');

// Special boss intro for Floor 19 (Flydra)
if(f === 19) {
v.innerHTML = `
<div style="position:fixed;top:0;left:0;width:100%;height:100vh;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:30000">
<div style="text-align:center;color:#fff;animation:fadeIn 0.8s ease">
<div style="font-size:2rem;font-weight:bold;margin-bottom:0.5rem;color:#e94560">Floor ${f}</div>
<div style="font-size:1.5rem;font-style:italic;margin-bottom:1rem;color:#fbbf24">${floorName}</div>
<img src="assets/Flydra Boss.png" alt="The Flydra" style="max-width:90vw;max-height:60vh;object-fit:contain;border-radius:8px;box-shadow:0 0 40px rgba(233,69,96,0.6);animation:flydraReveal 1.2s ease">
</div>
</div>
<style>
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes flydraReveal {
  0% { opacity: 0; transform: scale(0.8); filter: brightness(0); }
  50% { opacity: 1; filter: brightness(1.3); }
  100% { opacity: 1; transform: scale(1); filter: brightness(1); }
}
</style>`;
// Longer display time for boss intro
setTimeout(callback, T(ANIMATION_TIMINGS.FLOOR_INTERSTITIAL * 2));
return;
}

// Floor 11 ambush warning
const isAmbush = f === 11;
const ambushWarning = isAmbush ? `
<div style="margin-top:1.5rem;padding:0.75rem 1.5rem;background:rgba(239,68,68,0.3);border:2px solid #ef4444;border-radius:8px;animation:pulseWarning 1s ease infinite">
<div style="font-size:1.2rem;font-weight:bold;color:#fca5a5">‚ö†Ô∏è AMBUSH! ‚ö†Ô∏è</div>
<div style="font-size:0.95rem;color:#fca5a5;margin-top:0.25rem">All heroes stunned Turn 1!</div>
</div>
` : '';

v.innerHTML = `
<div style="position:fixed;top:0;left:0;width:100%;height:100vh;background:#000;display:flex;align-items:center;justify-content:center;z-index:30000">
<div style="text-align:center;color:#fff;animation:fadeIn 0.5s ease">
<div style="font-size:2.5rem;font-weight:bold;margin-bottom:1rem">Floor ${f}</div>
<div style="font-size:1.8rem;font-style:italic">${floorName}</div>
${ambushWarning}
</div>
</div>
<style>
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes pulseWarning {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}
</style>`;
// Extend duration for ambush floors so players can read the warning
const interstitialDuration = isAmbush ? ANIMATION_TIMINGS.FLOOR_INTERSTITIAL * 1.5 : ANIMATION_TIMINGS.FLOOR_INTERSTITIAL;
setTimeout(callback, T(interstitialDuration));
}

function startFloor(f) {
debugLog(`[FLOOR] startFloor(${f}) called, isOdd=${f % 2 === 1}`);
S.floor=f;
// QUEST TRACKING: Floor reached
trackQuestProgress('floor', f);
upd();
// Special: Floor 20 in Frogged Up mode shows Old Tapo encounter
if(f === 20 && S.gameMode === 'fu') {
showOldTapo();
return;
}
if(f >= 20) { win(); return; }
// Floor 11 is always ambushed (Goblin Army)
if(f === 11) {
S.ambushed = true;
}
// Show interstitial for combat floors
if(f % 2 === 1) {
showFloorInterstitial(f, () => combat(f));
} else {
neutral(f);
}
}

function getEnemyComp(f) {
const heroCount = S.heroes.length;
if(f===0) {
// Tutorial floor - check phase
if(tutorialState && tutorialState.phase === 1) {
return ['fly', 'fly', 'fly']; // Phase 1: Tapo's Birthday (3 flies)
} else {
return ['goblin', 'wolf']; // Phase 2: Portal Invasion
}
}
if(f===1) return Array(heroCount).fill('goblin');
if(f===3) return Array(heroCount).fill('wolf');
if(f===5) return Array(heroCount * 2).fill('orc');
if(f===7) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('giant', 'wolf', 'goblin');
return comp;
}
if(f===9) return Array(heroCount).fill('caveTroll');
if(f===11) return Array(heroCount * 5).fill('goblin');
if(f===13) return Array(heroCount * 5).fill('wolf');
if(f===15) return Array(heroCount).fill('dragon');
if(f===17) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('caveTroll', 'giant', 'orc', 'wolf', 'goblin');
return comp;
}
if(f===19) return Array(heroCount).fill('flydra'); // 1 Flydra head per hero
return ['goblin'];
}

// ===== COMBAT (v7.2 PERFECT COMBAT - UNCHANGED) =====
/**
 * Initializes combat encounter for given floor.
 *
 * Combat Initialization:
 * - Resets turn state (round=1, turn='player', no actions)
 * - Shields persist from previous combat (capped at max HP)
 * - Ghost charges persist between combats
 * - Stun counters reset to 0
 * - Creates enemies based on floor composition
 * - Handles Ribbleton tutorial special cases
 * - Applies Frogged Up mode multipliers (3x stats and rewards)
 *
 * @param {number} f - Floor number (1-19, or 0 for tutorial)
 */
function combat(f) {
// Show header during combat
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';
S.inCombat = true; // Mark that we're in active combat for autosave
// JUICE: Start combat music
ProceduralMusic.startCombat();
S.combatEnding = false; // Reset combat ending guard flag
S.round=1; S.turn='player'; S.activeIdx=-1; S.acted=[]; S.locked=false;
S.lastActions={};
S.combatXP=0; S.combatGold=0; // Track combat rewards separately
S.pending=null; S.targets=[]; S.currentInstanceTargets=[]; S.instancesRemaining=0; S.totalInstances=0; S.turnDamage=0;
// Clear Alpha state from any previous combat
S.alphaGrantedActions = null; S.alphaCurrentAction = 0; S.alphaLevel = 0;
// Don't clear recruits here - they may have been added before combat (e.g., Encampment straggler)
if(!S.recruits) S.recruits = [];
S.heroes.forEach(h => {
// Shields now persist between battles, but cap at max HP
if(h.sh > h.m) h.sh = h.m;
h.st=0;
if(!h.ts) h.ts=[];
// Passive Asterisk: Reset first action flag each combat
h.firstActionUsed = false;
// If ambushed, stun all heroes turn 1
if(S.ambushed) h.st = 1;
});

// Save combat start snapshot for restart functionality
S.combatStartSnapshot = {
heroes: S.heroes.map(h => ({
id: h.id, n: h.n, p: h.p, h: h.h, m: h.m, sh: h.sh, g: h.g,
st: h.st, ls: h.ls, lst: h.lst, s: [...h.s], ts: [...(h.ts || [])],
firstActionUsed: h.firstActionUsed
})),
recruits: S.recruits ? S.recruits.map(r => ({...r, s: [...r.s]})) : [],
floor: f,
ambushed: S.ambushed
};

let comp = getEnemyComp(f);

S.enemies = comp.map((t,i) => {
const base = E[t];
const fuMultiplier = S.gameMode === 'fu' ? 3 : 1;
const enemy = {
id:`e-${crypto.randomUUID()}`, n:base.n,
p:base.p * fuMultiplier,
h:base.h * fuMultiplier,
m:base.m * fuMultiplier,
goldDrop:(base.goldDrop || 0) * fuMultiplier, x:(base.x || 0) * fuMultiplier, s: [], pool: base.pool,
maxLevel: base.maxLevel || 1, sigilLevels: base.sigilLevels || {},
gainRate: base.gainRate || 3, turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st:0, li: i % S.heroes.length, sh:0, g:0, alphaActed: false
};
// FLYDRA: Set up state and use dynamic sigil level based on hero count
if(base.isFlydra) {
enemy.isFlydra = true;
enemy.flydraState = 'alive'; // 'alive', 'dying', 'reviving'
enemy.flydraReviveTimer = 0;
enemy.flydraLevel = S.heroes.length; // L2 normal, L3 in Frogged Up
// Assign head position based on hero count:
// 2 heroes (Standard): left, right
// 3 heroes (FU): left, center, right
const headOrder = S.heroes.length === 2 ? ['left', 'right'] : ['left', 'center', 'right'];
const headPosition = headOrder[i % headOrder.length];
const headData = FLYDRA_HEADS[headPosition];
enemy.flydraHead = headPosition;
enemy.flydraHeadImage = headData.image;
enemy.n = headData.name; // Override name with head-specific name
}
// Add permanent sigils (Flydra uses hero count for level)
if(base.permSigils) {
base.permSigils.forEach(ps => {
const level = base.isFlydra ? S.heroes.length : ps.l;
enemy.s.push({sig:ps.s, level:level, perm:true});
});
}
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
// Array format: [{s:'Shield', l:1}]
base.startSigils.forEach(ss => enemy.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
// Numeric format: draw N random sigils
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(enemy, base);
}
}
}
// Handle startRandom: draw additional random L1 sigils (used by Troll)
if(base.startRandom) {
for(let j = 0; j < base.startRandom; j++) {
drawEnemyStartSigil(enemy, base, true); // true = force level 1
}
}
// ORC ALTERNATING: Start with either Attack L2 or random pool sigil
if(base.alternating && base.altSigil) {
enemy.alternating = true;
enemy.altSigil = base.altSigil;
// Randomly choose which to start with (true = altSigil/Attack, false = pool)
enemy.altState = Math.random() < 0.5;
if(enemy.altState) {
enemy.s.push({sig: base.altSigil.s, level: base.altSigil.l, perm: false});
} else {
drawEnemyStartSigil(enemy, base, false);
}
}
// CAVE TROLL RAGE: Rolling Attack L1‚ÜíL2‚ÜíL3‚ÜíL1 pattern
if(base.rage && base.ragePattern) {
enemy.rage = true;
enemy.ragePattern = base.ragePattern;
enemy.rageIndex = 0; // Start at first level (L1)
// Start with Attack at first level of pattern
enemy.s.push({sig: 'Attack', level: base.ragePattern[0], perm: true});
}
return enemy;
});
// Shuffle enemies for variety within lanes (Fisher-Yates)
for(let i = S.enemies.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[S.enemies[i], S.enemies[j]] = [S.enemies[j], S.enemies[i]];
}
if(S.ambushed) {
toast('AMBUSHED! All heroes stunned Turn 1!', 1800);
S.ambushed = false; // Clear flag after use
}
// Check if we need to show Encampment enemy selection
if(S.encampmentEarlyKills && S.encampmentEarlyKills > 0) {
S.selectingEncampmentTargets = true;
S.encampmentSelectedTargets = [];
}
upd(); // Ensure background color is set before first render
render();
// Auto-target tutorial: show on second+ run, floor 1
if(S.runNumber >= 2 && f === 1 && !S.tutorialFlags.auto_target_intro) {
const isTouchDevice = 'ontouchstart' in window;
const inputHint = isTouchDevice ? "Press ‚ìç on controller" : "Right-click any sigil (or ‚ìç on controller)";
showTutorialPop('auto_target_intro', `Right-click any sigil (or press ‚ìç on controller) to auto-target the best enemy! This quickly attacks the lowest-HP target without manual selection.<br><br><em style="font-size:0.85em;opacity:0.9">(Pro tip: Use this to speed through easy fights!)</em>`);
}
}

// Restart combat from the beginning of the current floor
function restartCombat() {
if(!S.combatStartSnapshot) {
toast('No restart point saved!');
return;
}

// Confirm restart
showConfirmModal(
'Restart this battle from the beginning?',
() => {
// Restore hero state from snapshot
S.heroes = S.combatStartSnapshot.heroes.map(h => ({
  ...h,
  s: [...h.s],
  ts: [...(h.ts || [])]
}));

// Restore recruits from snapshot
S.recruits = S.combatStartSnapshot.recruits.map(r => ({...r, s: [...r.s]}));

// Restore ambush state
S.ambushed = S.combatStartSnapshot.ambushed;

// Clear any pending actions
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.alphaGrantedActions = null;
S.alphaCurrentAction = 0;

toast('Restarting battle...', 800);
setTimeout(() => {
  combat(S.combatStartSnapshot.floor);
}, 400);
},
() => {} // Cancel - do nothing
);
}

function getLevel(sig, heroIdx) {
const h = S.heroes[heroIdx];
// Calculate total level (permanent + temporary XP upgrades)
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
// Star, Asterisk, and Expand are global passives - all heroes get them when upgraded
if(sig === 'Star' || sig === 'Asterisk' || sig === 'Expand') {
// Special case: Mage and Healer get +1 to Expand
if(sig === 'Expand' && h && (h.n === 'Mage' || h.n === 'Healer')) {
return totalLevel + 1;
}
return totalLevel;
}
// For other sigils, check if hero has it
if(!h) return 0;
const hasSigil = h.s.includes(sig) || (h.ts && h.ts.includes(sig));
if(!hasSigil) return 0;
// Actives always display +1 higher (perm 0 = L1, perm 1 = L2, etc.)
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
if(actives.includes(sig)) return totalLevel + 1;
return totalLevel;
}

function getTargetsPerInstance(action, heroIdx) {
// Safeguard: if heroIdx is invalid, check if we're in tutorial with single Mage
if(heroIdx < 0 || heroIdx >= S.heroes.length) {
  // Tutorial Phase 1: Mage should always have 2 targets
  if(tutorialState && tutorialState.phase === 1 && S.heroes.length === 1 && S.heroes[0].n === 'Mage') {
    return 2;
  }
  return 1; // Default fallback
}
const expandLevel = getLevel('Expand', heroIdx);
return 1 + expandLevel;
}

function needsEnemyTarget(action) { return ['Attack', 'Grapple'].includes(action); }
function needsHeroTarget(action) { return ['Heal', 'Shield', 'Alpha'].includes(action); }
function isMultiInstance(action) { return ['Attack', 'Shield', 'Heal'].includes(action); }

function getD20DC(baseDC, heroIdx, gambitName) {
const h = S.heroes[heroIdx];
if(!h || !h.ls) return baseDC;
// Last Stand: No penalty on first turn, then +2 each turn after
// h.lst is incremented at end of player turn, so first action has lst=0
const lastStandBonus = h.lst * 2;
// Confuse caps at DC 20, all other gambits continue increasing
if(gambitName === 'CONFUSE') {
return Math.min(baseDC + lastStandBonus, 20);
}
return baseDC + lastStandBonus;
}

function selectHero(idx) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending) return;
const h = S.heroes[idx];
if(!h) return;
if(S.acted.includes(idx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
S.activeIdx = idx;
// Show happy reaction when hero is selected for their turn
if(!h.ls) setHeroReaction(h.id, 'happy', 1200);
if(h.ls) toast(`${h.n} in Last Stand - D20 only!`);
render();
}

function act(sig, heroIdx) {
// Hide any pending tooltips when action is selected
hideTooltip();

// RIBBLETON TUTORIAL: Check for scripted actions using TutorialManager
const h = S.heroes[heroIdx];
if(!h) return;
if(!TutorialManager.canPerformAction(h, sig)) {
toast(TutorialManager.getInstructionMessage());
return;
}

if(S.locked) { toast('Wait for enemy turn!'); return; }
// Allow switching actions only if no instances have been completed yet
if(S.pending) {
// Check if any instances have been completed
if(S.instancesRemaining > 0 && S.totalInstances && S.instancesRemaining < S.totalInstances) {
toast('Must complete remaining instances!');
return;
}
// Allow switching if no instances completed yet
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
}
if(S.acted.includes(heroIdx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
if(h.ls && sig !== 'D20') { toast('Last Stand - D20 only!'); return; }
S.activeIdx = heroIdx;

// PASSIVE ASTERISK: Auto-apply on first action per combat
const asteriskLevel = getLevel('Asterisk', heroIdx);
const hasAsterisk = asteriskLevel > 0;
const firstAction = !h.firstActionUsed;
let repeats = 1;

if(hasAsterisk && firstAction) {
repeats = asteriskLevel + 1;
// NOTE: firstActionUsed is set in finishAction(), not here
// This allows players to cancel and still keep their Asterisk benefit
toast(`Asterisk activated! ${sig} √ó${repeats}!`, 1500);
}

if(sig === 'Ghost') {
const level = getLevel('Ghost', heroIdx);
if(level === 0) { toast(`${h.n} doesn't have Ghost! Add it in Level-Up menu (costs XP).`); return; }
// Ghost tutorial: show first time player clicks Ghost
showTutorialPop('ghost_intro', "Ghost prevents the next lethal hit! Each charge blocks one otherwise-fatal blow, and charges persist between battles. Max 9 charges per hero.");
const totalCharges = level * repeats;
h.g = Math.min((h.g || 0) + totalCharges, 9);
toast(`${h.n} gained ${totalCharges} Ghost charge${totalCharges>1?'s':''}!`);
finishAction(heroIdx);
} else if(sig === 'D20') {
S.pending = 'D20';
S.asteriskD20Repeats = repeats;
S.asteriskD20Count = 0;
d20Menu(heroIdx);
} else if(isMultiInstance(sig)) {
const level = getLevel(sig, heroIdx);
if(level === 0) { toast(`${h.n} doesn't have ${sig}! Add it in Level-Up menu (costs XP).`); return; }
S.pending = sig;
S.instancesRemaining = level * repeats;
S.totalInstances = level * repeats; // Track for color roll-down
S.targets = [];
S.currentInstanceTargets = [];
// Shield persistence tutorial: show first time player clicks Shield
if(sig === 'Shield') {
showTutorialPop('shield_persistence', "Shields cap at max HP, but persist between battles! Hint - shield up before finishing a fight, and you'll enter the next fight with protection!");
}
render();
// Auto-focus target for controller users
if(sig === 'Attack') {
autoFocusTargetForController(heroIdx, 'enemy');
} else {
autoFocusTargetForController(heroIdx, 'hero');
}
} else if(sig === 'Grapple') {
const level = getLevel('Grapple', heroIdx);
if(level === 0) { toast(`${h.n} doesn't have Grapple! Add it in Level-Up menu (costs XP).`); return; }
// Grapple tutorial: show first time player clicks Grapple
showTutorialPop('grapple_intro', "Grapple stuns an enemy for 1 or more turns, but your hero takes recoil damage equal to the target's POW. Worth it... sometimes.");
S.pending = 'Grapple';
S.grappleRepeats = repeats;
S.grappleLevel = level;
S.targets = [];
render();
autoFocusTargetForController(heroIdx, 'enemy');
} else if(sig === 'Alpha') {
const level = getLevel('Alpha', heroIdx);
if(level === 0) { toast(`${h.n} doesn't have Alpha! Add it in Level-Up menu (costs XP).`); return; }
// Alpha tutorial: show first time player clicks Alpha
showTutorialPop('alpha_intro', "Alpha lets a hero give their turn to an ally. At higher Alpha levels, one use can grant another hero multiple turns! Great ROI.");
const expandLevel = getLevel('Expand', heroIdx);
const targetsNeeded = 1 + expandLevel;
S.pending = 'Alpha';
// Apply Asterisk multiplier: total actions = level √ó repeats
S.alphaLevel = level * repeats;
S.alphaTargetsNeeded = targetsNeeded;
S.targets = [];
const totalActions = level * repeats;
toast(`Alpha: Grant ${totalActions} action${totalActions>1?'s':''} to ${targetsNeeded} hero${targetsNeeded>1?'es':''}!`);
render();
autoFocusTargetForController(heroIdx, 'hero');
}
}

// Right-click on sigil: select action AND auto-target
function actAndAutoTarget(sig, heroIdx) {
// First, select the action normally
act(sig, heroIdx);

// Then auto-target after a brief delay to let state update
setTimeout(() => {
if (!S.pending) return; // Action didn't set pending (e.g., Ghost completes instantly)

const hero = S.heroes[heroIdx];
if (!hero) return;

// Calculate targets needed (getLevel already includes Mage/Healer +1 bonus)
const expandLevel = getLevel('Expand', heroIdx);
const totalTargets = 1 + expandLevel;
const targetsNeeded = Math.max(1, totalTargets - (S.currentInstanceTargets ? S.currentInstanceTargets.length : 0));

if (['Attack', 'Grapple'].includes(S.pending)) {
  // Target enemies - prioritize lowest HP
  const aliveEnemies = S.enemies.filter(e => e.h > 0);
  if (aliveEnemies.length === 0) return;

  aliveEnemies.sort((a, b) => {
    if (a.h !== b.h) return a.h - b.h;
    const aLaneDist = Math.abs((a.li !== undefined ? a.li : 0) - heroIdx);
    const bLaneDist = Math.abs((b.li !== undefined ? b.li : 0) - heroIdx);
    return aLaneDist - bLaneDist;
  });

  const toTarget = aliveEnemies.slice(0, targetsNeeded);
  for (const enemy of toTarget) {
    const card = document.getElementById(enemy.id);
    if (card) card.click();
  }
  if (toTarget.length > 0) {
    toast(`Auto-targeted ${toTarget.length} enem${toTarget.length === 1 ? 'y' : 'ies'}!`, 1200);
  }

} else if (['Heal', 'Shield', 'Alpha'].includes(S.pending)) {
  let aliveHeroes = S.heroes.filter(h => h.h > 0 || h.ls);
  if (aliveHeroes.length === 0) return;

  if (S.pending === 'Heal') {
    aliveHeroes.sort((a, b) => {
      if (a.ls && !b.ls) return -1;
      if (!a.ls && b.ls) return 1;
      return (a.h / a.m) - (b.h / b.m);
    });
  } else if (S.pending === 'Shield') {
    aliveHeroes.sort((a, b) => {
      const aShield = a.sh || 0;
      const bShield = b.sh || 0;
      if (aShield !== bShield) return aShield - bShield;
      return a.h - b.h;
    });
  } else if (S.pending === 'Alpha') {
    aliveHeroes.sort((a, b) => b.p - a.p);
  }

  const toTarget = aliveHeroes.slice(0, targetsNeeded);
  for (const h of toTarget) {
    const card = document.getElementById(h.id);
    if (card) card.click();
  }
  if (toTarget.length > 0) {
    toast(`Auto-targeted ${toTarget.length} hero${toTarget.length === 1 ? '' : 'es'}!`, 1200);
  }
}
}, 50);
}

function d20Menu(heroIdx) {
if(S.locked) return;

// RIBBLETON TUTORIAL: PROMPT 2 - Explain D20 gambit
if(tutorialState && S.floor === 0 && tutorialState.stage === 'healer_d20') {
tutorialState.stage = 'd20_menu';
showTutorialPop('ribbleton_d20_menu', "Choose a gambit! Each has a DC (Difficulty Check) - you need to roll that number or higher to succeed. Pick CONFUSE to damage the Wolf!", () => {
// After prompt, show the d20 menu
renderD20MenuAfterTutorial(heroIdx);
});
return;
}

renderD20MenuAfterTutorial(heroIdx);
}

function renderD20MenuAfterTutorial(heroIdx) {
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];

// RIBBLETON TUTORIAL: Special D20 menu that doesn't block view
const isTutorial = tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu';

let html = '';
if(isTutorial) {
// Tutorial version: overlay on left side only, keep enemies visible
html = '<div style="position:fixed;top:50%;left:10px;transform:translateY(-50%);z-index:15000;max-width:380px;background:white;border:4px solid #3b82f6;border-radius:12px;padding:1.5rem;box-shadow:0 8px 32px rgba(0,0,0,0.5)">';
html += '<h3 style="margin-bottom:1rem;color:#6b4423">D20: Attempt A Gambit</h3>';
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, 10, 'CONFUSE')" style="margin-bottom:0.5rem;background:#3b82f6;border:3px solid #f97316;font-size:1.1rem;cursor:pointer">
<strong style="font-size:1.2rem">‚úÖ DC 10: CONFUSE</strong><br>
<span style="font-size:0.95rem">Target deals its own POW to itself</span>
</div>`;
// Show other options greyed out
const lockedOptions = [
{dc:12, name:'MEND', desc:'Heal self for POW'},
{dc:15, name:'STARTLE', desc:'Stun for 1 turn (doesn\'t stack)'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
lockedOptions.forEach(opt => {
html += `<div style="margin-bottom:0.5rem;background:#e0e0e0;border:2px solid #999;border-radius:8px;padding:0.75rem;opacity:0.5;cursor:not-allowed">
<strong style="font-size:0.95rem">üîí DC ${opt.dc}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
html += '</div>';
// Tutorial: Append as overlay, don't replace combat view
render(); // First render combat view
v.insertAdjacentHTML('beforeend', html);
return;
} else {
// Normal D20 menu (centered, blocks view)
html = '<div style="text-align:center;padding:1rem;background:white;border:3px solid #000;border-radius:8px;margin:1rem auto;max-width:400px;color:#1a1a1a">';
html += '<h3 style="margin-bottom:1rem;color:#1a1a1a">D20: Attempt A Gambit</h3>';
const expandLevel = getLevel('Expand', heroIdx);
const maxTargets = 1 + expandLevel;
if(expandLevel > 0) html += `<p style="margin-bottom:0.75rem;color:#22c55e;font-weight:bold;font-size:1.05rem;background:rgba(34,197,94,0.1);padding:0.5rem;border-radius:6px;border:2px solid #22c55e">‚ú® Expand L${expandLevel} Active: Target up to ${maxTargets} enemies!</p>`;
if(S.asteriskD20Repeats > 1) {
html += `<p style="margin-bottom:0.5rem;color:#f97316">Asterisk Active: Pick ${S.asteriskD20Repeats} actions!</p>`;
html += `<p style="margin-bottom:1rem;font-size:0.85rem">(${S.asteriskD20Count}/${S.asteriskD20Repeats} used)</p>`;
}
if(h.ls && h.lst > 0) {
const lsBonus = h.lst * 2;
html += `<p style="margin-bottom:0.5rem;color:#dc2626;font-weight:bold">Last Stand Turn ${h.lst + 1}: DCs +${lsBonus}</p>`;
}
const options = [
{dc:10, name:'CONFUSE', desc:'Target deals its own POW to itself'},
{dc:12, name:'MEND', desc:'Heal self for POW'},
{dc:15, name:'STARTLE', desc:'Stun for 1 turn (doesn\'t stack)'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
options.forEach(opt => {
const adjustedDC = getD20DC(opt.dc, heroIdx, opt.name);
const dcText = adjustedDC > opt.dc ? `DC ${adjustedDC} (${opt.dc}+${adjustedDC - opt.dc})` : `DC ${opt.dc}`;
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, ${adjustedDC}, '${opt.name}')" style="margin-bottom:0.5rem">
<strong>${dcText}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
if(S.asteriskD20Count > 0) html += `<button class="btn safe" onclick="finishD20Asterisk(${heroIdx})">Finish (${S.asteriskD20Count} used)</button>`;
else html += `<button class="btn secondary" onclick="cancelAction()">Cancel</button>`;
html += '</div>';
v.innerHTML = html;
}
}

function selectD20Action(heroIdx, dc, actionName) {
if(S.locked) return;
S.d20Action = actionName;
S.d20DC = dc;
S.d20HeroIdx = heroIdx;

// RIBBLETON TUTORIAL: Show Expand explanation after choosing CONFUSE
if(tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu' && actionName === 'CONFUSE') {
showTutorialPop('healer_expand_explain', "Healer has Expand, which adds extra targets to actions! This lets you Confuse multiple enemies at once. Try selecting 2 enemies!", () => {
// Allow free targeting after popup - stage stays 'd20_menu' for fudged roll but targeting is unrestricted
S.pending = 'D20_TARGET';
S.targets = [];
S.locked = false; // Ensure game is not locked after popup
render();
});
return;
}

// RECRUIT TUTORIAL: Show explanation when first selecting Recruit
if(actionName === 'RECRUIT') {
showTutorialPop('recruit_intro', "Recruited enemies will stand behind the hero who recruited them and fight alongside you until death! Each hero can have 1 recruit.", () => {
S.pending = 'D20_TARGET';
S.targets = [];
render();
});
return;
}

// MEND is self-targeting, execute immediately
if(actionName === 'MEND') {
const d20Level = getLevel('D20', heroIdx);
const {rolls, best} = rollDice(d20Level, 20);
const rollText = formatD20Compact(rolls, best);
const h = S.heroes[heroIdx];
if(best >= dc) {
const healAmount = h.p;
h.h = Math.min(h.h + healAmount, h.m);
toast(`${rollText} <span style="color:#22c55e;font-weight:bold">SUCCESS!</span> ${h.n} healed for ${healAmount} HP!`, 2000);
} else {
toast(`${rollText} needed ${dc} - <span style="color:#ef4444;font-weight:bold">FAILED!</span>`, 1800);
}
// Handle Asterisk repeats for MEND
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null;
render();
setTimeout(() => d20Menu(heroIdx), ANIMATION_TIMINGS.TUTORIAL_DELAY);
return;
}
}
finishD20Asterisk(heroIdx);
return;
}

S.pending = 'D20_TARGET';
S.targets = [];
render();
// Auto-focus the enemy across from the active hero for controller users
autoFocusTargetForController(S.d20HeroIdx);
}

// Auto-focus an enemy/hero target for controller navigation
function autoFocusTargetForController(heroIdx, targetType = 'enemy') {
if (typeof GamepadController === 'undefined' || !GamepadController.active) return;

setTimeout(() => {
if (targetType === 'enemy') {
// Find the enemy at the same index as the hero (or first enemy)
const enemyCards = Array.from(document.querySelectorAll('.card.enemy:not(.dead)'));
if (enemyCards.length > 0) {
const targetIdx = Math.min(heroIdx || 0, enemyCards.length - 1);
GamepadController.setFocus(enemyCards[targetIdx]);
}
} else {
// For hero targeting (Heal, Shield, Alpha), focus the hero themselves or first other hero
const heroCards = Array.from(document.querySelectorAll('.card.hero:not(.dead)'));
if (heroCards.length > 0) {
// Try to focus the acting hero first (for self-targeting like Heal)
GamepadController.setFocus(heroCards[heroIdx] || heroCards[0]);
}
}
}, 100);
}

function rollD20() {
if(S.locked) return;
const heroIdx = S.d20HeroIdx;
const h = S.heroes[heroIdx];
const dc = S.d20DC;
const actionName = S.d20Action;
const d20Level = getLevel('D20', heroIdx);
let rolls, best;

// RIBBLETON TUTORIAL: Fudge roll to always succeed (17-18)
if(tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu') {
const fudgedRoll = 17 + Math.floor(Math.random() * 2); // 17 or 18
rolls = [fudgedRoll];
best = fudgedRoll;
} else {
({rolls, best} = rollDice(d20Level, 20));
}
const rollText = formatD20Compact(rolls, best);
// QUEST TRACKING: D20 used
trackQuestProgress('d20');

if(best >= dc) {
toast(`${rollText} <span style="color:#22c55e;font-weight:bold">SUCCESS!</span>`, 1800);
const targetNames = S.targets.map(id => {
const e = S.enemies.find(e => e.id === id);
return e ? e.n : null;
}).filter(n => n);
S.targets.forEach(targetId => executeD20ActionOnTarget(targetId, actionName));
if(targetNames.length > 0) {
const actionDesc = {'CONFUSE': 'confused', 'STARTLE': 'startled and stunned', 'STEAL': 'robbed', 'RECRUIT': 'recruited'};
if(actionName !== 'STEAL') toast(`${targetNames.join(', ')} ${actionDesc[actionName]}!`, 2500);
}
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), ANIMATION_TIMINGS.TUTORIAL_DELAY);
return;
}
}
finishD20Asterisk(heroIdx);
} else {
toast(`${rollText} needed ${dc} - <span style="color:#ef4444;font-weight:bold">FAILED!</span>`, ANIMATION_TIMINGS.TOAST_MEDIUM);
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), ANIMATION_TIMINGS.TUTORIAL_DELAY);
return;
}
}
finishD20Asterisk(heroIdx);
}
}

function executeD20ActionOnTarget(enemyId, action) {
const enemy = S.enemies.find(e => e.id === enemyId);
if(!enemy) return;
if(action === 'CONFUSE') {
// Confused enemy deals its own POW damage to itself
const dmg = enemy.p;
toast(`Confuse: ${getEnemyDisplayName(enemy)} hits itself for ${dmg}!`, 1800);
dealDamageToEnemy(enemy, dmg);
} else if(action === 'STARTLE') {
enemy.st = Math.max(enemy.st, 1);
// Show stun tutorial popup first time
showTutorialPop('stun_intro', "Nice stun! Enemies won't attack when stunned, and any other sigils they have are wasted while stunned!");
// Check royal quest completion
if(S.royalQuestActive && S.round === 1 && !S.royalQuestCompleted) {
S.royalQuestCompleted = true;
toast(`Royal Quest completed! Ring retrieved!`, 1800);
}
} else if(action === 'STEAL') {
const gold = enemy.p;
S.gold += gold;
upd();
toast(`Stole ${gold} Gold from ${getEnemyDisplayName(enemy)}!`);
} else if(action === 'RECRUIT') {
const heroIdx = S.d20HeroIdx;
const hero = S.heroes[heroIdx];
const recruitName = getEnemyDisplayName(enemy);
// Remove enemy from enemies array immediately
S.enemies = S.enemies.filter(e => e.id !== enemyId);
if(!S.recruits) S.recruits = [];
const existingRecruit = S.recruits.find(r => r.recruitedBy === heroIdx);
if(existingRecruit) {
// Show choice popup: keep current or replace
render();
showRecruitReplaceConfirm(existingRecruit.n, recruitName, () => {
// KEEP current
toast(`Kept ${existingRecruit.n}.`, 1200);
render();
checkCombatEnd();
}, () => {
// REPLACE with new
S.recruits = S.recruits.filter(r => r.recruitedBy !== heroIdx);
const recruit = {...enemy, recruitedBy: heroIdx, isRecruit: true};
S.recruits.push(recruit);
toast(`${recruitName} replaces ${existingRecruit.n}!`, 1500);
render();
checkCombatEnd();
});
} else {
// No existing recruit, just add
const MAX_RECRUITS = 10;
if(S.recruits.length < MAX_RECRUITS) {
const recruit = {...enemy, recruitedBy: heroIdx, isRecruit: true};
S.recruits.push(recruit);
toast(`${recruitName} recruited by ${hero.n}!`, 1500);
// QUEST TRACKING: Recruits held
trackQuestProgress('recruits', S.recruits.length);
} else {
toast(`Squad full! Cannot recruit ${recruitName}.`, 1500);
}
setTimeout(() => {
render();
checkCombatEnd();
}, 300);
}
}
}

function finishD20Asterisk(heroIdx) {
S.pending = null;
S.targets = [];
S.asteriskD20Repeats = 1;
S.asteriskD20Count = 0;
// Use finishAction to properly handle Alpha-granted turns
finishAction(heroIdx);
}

function cancelAction() {
if(S.locked) return;
// If we have targets selected, just clear targets (stay in pending mode)
if(S.currentInstanceTargets && S.currentInstanceTargets.length > 0) {
// Remove targets from S.targets as well
S.currentInstanceTargets.forEach(id => {
  const idx = S.targets.indexOf(id);
  if(idx > -1) S.targets.splice(idx, 1);
});
S.currentInstanceTargets = [];
render();
return;
}
// No targets - fully cancel the action
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
render();
}

// Confirm and execute the currently selected targets
function confirmTargets() {
if(S.locked) return;
if(!S.pending) return;

// D20_TARGET uses S.targets, not S.currentInstanceTargets - check before instancesRemaining guard
if(S.pending === 'D20_TARGET') {
if(!S.targets || S.targets.length === 0) {
  toast('Select at least one target first!');
  return;
}
rollD20();
return;
}

// Guard against fast tapping causing negative instances
if(S.instancesRemaining <= 0) return;

// For other actions, check S.currentInstanceTargets
if(!S.currentInstanceTargets || S.currentInstanceTargets.length === 0) {
toast('Select at least one target first!');
return;
}
const heroIdx = S.activeIdx;

if(S.pending === 'Attack') {
// SAFEGUARD: Make a copy of targets before clearing
const targetsToExecute = [...S.currentInstanceTargets];
debugLog('[CONFIRM] Attack with', targetsToExecute.length, 'targets:', targetsToExecute.join(', '));
if(targetsToExecute.length === 0) {
  toast('No targets selected!');
  return;
}
executeInstance(S.pending, heroIdx, targetsToExecute);
S.instancesRemaining = Math.max(0, S.instancesRemaining - 1);
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) {
  setTimeout(() => finishAction(heroIdx), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
} else {
  setTimeout(() => render(), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}
} else if(S.pending === 'Grapple') {
// Safety check for grapple
const hero = S.heroes[heroIdx];
const totalRecoil = S.currentInstanceTargets.reduce((sum, tgtId) => {
  const enemy = S.enemies.find(e => e.id === tgtId);
  return sum + (enemy ? enemy.p : 0);
}, 0) * S.grappleRepeats;
const effectiveHP = (hero.h || 0) + (hero.sh || 0);
if(totalRecoil >= effectiveHP && !hero.g && !hero.ls) {
  toast('Grapple would kill you! Pick weaker targets.', 2000);
  return;
}
for(let i = 0; i < S.grappleRepeats; i++) executeGrapple(heroIdx, [...S.currentInstanceTargets], S.grappleLevel);
S.currentInstanceTargets = [];
finishAction(heroIdx);
} else if(S.pending === 'Shield' || S.pending === 'Heal') {
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining = Math.max(0, S.instancesRemaining - 1);
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) {
  setTimeout(() => finishAction(heroIdx), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
} else {
  setTimeout(() => render(), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}
} else if(S.pending === 'Alpha') {
executeAlphaAction(heroIdx, [...S.currentInstanceTargets]);
S.currentInstanceTargets = [];
// Note: Don't call finishAction here - executeAlphaAction handles everything
// including marking the Alpha user as acted and setting up granted turns
}
}

// Debounce tracking for target clicks to prevent double-fire issues in Proton/touch
let lastTargetTime = 0;
let lastTargetId = null;

function tgtEnemy(id) {
// Debounce: prevent double-fire within 100ms on same target
const now = Date.now();
if(id === lastTargetId && now - lastTargetTime < 100) {
  debugLog('[TARGET] Debounced duplicate click on', id);
  return;
}
lastTargetTime = now;
lastTargetId = id;

if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
// Toggle: if already targeted, remove it
if(S.targets.includes(id)) {
  S.targets = S.targets.filter(t => t !== id);
  render();
  return;
}
// Check if we can add more
if(S.targets.length >= maxTargets) {
  toast(`Max ${maxTargets} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
// Auto-confirm when targets are full OR all available enemies selected (manual only, not auto-select)
const aliveEnemies = S.enemies.filter(e => e.h > 0 && !S.targets.includes(e.id)).length;
const shouldAutoConfirm = (S.targets.length >= maxTargets || aliveEnemies === 0) && !S.autoSelectInProgress;
if(shouldAutoConfirm) {
  rollD20();
} else {
  render();
}
return;
}
if(!S.pending || !needsEnemyTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
if(S.pending === 'Attack') {
debugLog('[TARGET] Attack target clicked:', id, 'Hero:', S.heroes[heroIdx]?.n, 'targetsPerInstance:', targetsPerInstance);
// Toggle: if already targeted, remove it
if(S.currentInstanceTargets.includes(id)) {
  S.currentInstanceTargets = S.currentInstanceTargets.filter(t => t !== id);
  S.targets = S.targets.filter(t => t !== id);
  debugLog('[TARGET] Target removed. currentInstanceTargets:', S.currentInstanceTargets.length);
  render();
  return;
}
// Check if we can add more
if(S.currentInstanceTargets.length >= targetsPerInstance) {
  toast(`Max ${targetsPerInstance} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
S.currentInstanceTargets.push(id);
debugLog('[TARGET] Target added. currentInstanceTargets now:', S.currentInstanceTargets.length, S.currentInstanceTargets);
// Count available targets (enemies not yet targeted)
const availableEnemies = S.enemies.filter(e => e.h > 0 && !S.currentInstanceTargets.includes(e.id)).length;
// Auto-confirm when targets are full OR all available enemies selected (manual only, not auto-select)
const shouldAutoConfirm = (S.currentInstanceTargets.length >= targetsPerInstance || availableEnemies === 0) && !S.autoSelectInProgress;
debugLog('[TARGET] shouldAutoConfirm:', shouldAutoConfirm, '(targets:', S.currentInstanceTargets.length, '>=', targetsPerInstance, 'or available:', availableEnemies, '=== 0)');
if(shouldAutoConfirm) {
  debugLog('[TARGET] Auto-confirming with targets:', [...S.currentInstanceTargets]);
  confirmTargets();
} else {
  render();
}
} else if(S.pending === 'Grapple') {
// Toggle: if already targeted, remove it
if(S.currentInstanceTargets.includes(id)) {
  S.currentInstanceTargets = S.currentInstanceTargets.filter(t => t !== id);
  S.targets = S.targets.filter(t => t !== id);
  render();
  return;
}
// Check if we can add more
if(S.currentInstanceTargets.length >= targetsPerInstance) {
  toast(`Max ${targetsPerInstance} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
S.currentInstanceTargets.push(id);
// Grapple L2+ NEVER auto-confirms - player may want to stun fewer targets (less recoil damage)
const grappleLevel = getLevel('Grapple', heroIdx);
const availableEnemiesForGrapple = S.enemies.filter(e => e.h > 0 && !S.currentInstanceTargets.includes(e.id)).length;
// Only auto-confirm for Grapple L1 when all available targets selected
const shouldAutoConfirmGrapple = grappleLevel <= 1 && availableEnemiesForGrapple === 0 && !S.autoSelectInProgress;
if(shouldAutoConfirmGrapple) {
  confirmTargets();
} else {
  render();
}
}
}

function tgtHero(id) {
// Debounce: prevent double-fire within 100ms on same target (reuse enemy debounce vars)
const now = Date.now();
if(id === lastTargetId && now - lastTargetTime < 100) {
  debugLog('[TARGET] Debounced duplicate click on', id);
  return;
}
lastTargetTime = now;
lastTargetId = id;

if(S.locked) { toast('Wait for enemy turn!'); return; }
if(!S.pending || !needsHeroTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const h = S.heroes[heroIdx];
const target = S.heroes.find(x => x.id === id);
if(!target) return;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
if(S.pending === 'Shield' || S.pending === 'Heal') {
// Last Stand heroes can only be targeted by Heal, not Shield
if(S.pending === 'Shield' && target.ls) { toast(`${target.n} is in Last Stand - can't gain shields!`); return; }
// Toggle: if already targeted, remove it
if(S.currentInstanceTargets.includes(id)) {
  S.currentInstanceTargets = S.currentInstanceTargets.filter(t => t !== id);
  S.targets = S.targets.filter(t => t !== id);
  render();
  return;
}
// Check if we can add more
if(S.currentInstanceTargets.length >= targetsPerInstance) {
  toast(`Max ${targetsPerInstance} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
S.currentInstanceTargets.push(id);
// Count available heroes (alive heroes not yet targeted; Shield excludes LS heroes)
const availableHeroes = S.heroes.filter(hero => {
  if(S.currentInstanceTargets.includes(hero.id)) return false;
  if(S.pending === 'Shield') return hero.h > 0 && !hero.ls;
  return hero.h > 0 || hero.ls;
}).length;
// Auto-confirm when targets are full OR all available heroes selected (manual only, not auto-select)
const shouldAutoConfirm = (S.currentInstanceTargets.length >= targetsPerInstance || availableHeroes === 0) && !S.autoSelectInProgress;
if(shouldAutoConfirm) {
  confirmTargets();
} else {
  render();
}
} else if(S.pending === 'Alpha') {
// Alpha: can't target self, already-acted heroes, or Last Stand heroes
const alphaUser = S.heroes[S.activeIdx];
if(!alphaUser) return; // Guard against invalid activeIdx
if(id === alphaUser.id) { toast('Cannot Alpha yourself!'); return; }
if(target.ls) { toast(`${target.n} is in Last Stand - can only use D20!`); return; }
const targetIdx = S.heroes.findIndex(x => x.id === id);
if(S.acted.includes(targetIdx)) { toast('That hero already acted!'); return; }
// Toggle: if already targeted, remove it
if(S.currentInstanceTargets.includes(id)) {
  S.currentInstanceTargets = S.currentInstanceTargets.filter(t => t !== id);
  S.targets = S.targets.filter(t => t !== id);
  render();
  return;
}
// Check if we can add more
if(S.currentInstanceTargets.length >= S.alphaTargetsNeeded) {
  toast(`Max ${S.alphaTargetsNeeded} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
S.currentInstanceTargets.push(id);
// Count available Alpha targets (alive heroes who haven't acted, not self, not already targeted)
const availableAlphaTargets = S.heroes.filter((hero, idx) => {
  if(hero.id === alphaUser.id) return false; // Can't target self
  if(S.acted.includes(idx)) return false; // Already acted
  if(hero.h <= 0 && !hero.ls) return false; // Dead
  if(S.currentInstanceTargets.includes(hero.id)) return false; // Already targeted
  return true;
}).length;
// Auto-confirm when targets are full OR all available heroes selected (manual only, not auto-select)
const shouldAutoConfirmAlpha = (S.currentInstanceTargets.length >= S.alphaTargetsNeeded || availableAlphaTargets === 0) && !S.autoSelectInProgress;
if(shouldAutoConfirmAlpha) {
  confirmTargets();
} else {
  render();
}
}
}

function executeAlphaAction(alphaUserIdx, targetIds) {
const alphaUser = S.heroes[alphaUserIdx];
const actionsToGrant = S.alphaLevel;
// Mark Alpha user as acted (forfeits ALL actions)
S.acted.push(alphaUserIdx);
// Mark first action as used (for Asterisk) - prevents Asterisk from triggering on Round 2+
if(alphaUser && !alphaUser.firstActionUsed) alphaUser.firstActionUsed = true;
S.pending = null;
S.targets = [];
toast(`${alphaUser.n} used Alpha! Granting ${actionsToGrant} action${actionsToGrant>1?'s':''} to ${targetIds.length} hero${targetIds.length>1?'es':''}!`);
// QUEST TRACKING: Alpha used
trackQuestProgress('alpha');
// Set up multi-action state for granted heroes
S.alphaGrantedActions = [];
targetIds.forEach(id => {
const targetIdx = S.heroes.findIndex(h => h.id === id);
if(targetIdx >= 0) {
for(let i = 0; i < actionsToGrant; i++) {
S.alphaGrantedActions.push(targetIdx);
}
}
});
S.alphaCurrentAction = 0;
// Start first granted action
if(S.alphaGrantedActions.length > 0) {
const nextHeroIdx = S.alphaGrantedActions[0];
S.activeIdx = nextHeroIdx;
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
}
render();
}

function selectEncampmentTarget(enemyId) {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const currentSelected = S.encampmentSelectedTargets;
// Toggle selection
if(currentSelected.includes(enemyId)) {
S.encampmentSelectedTargets = currentSelected.filter(id => id !== enemyId);
} else {
if(currentSelected.length >= kills) {
toast(`Already selected ${kills} enem${kills>1?'ies':'y'}!`);
return;
}
S.encampmentSelectedTargets.push(enemyId);
}
render();
}

function confirmEncampmentKills() {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets;
if(selected.length !== kills) {
toast(`Select ${kills} enem${kills>1?'ies':'y'} to remove!`);
return;
}
// Remove selected enemies from S.enemies
S.enemies = S.enemies.filter(e => !selected.includes(e.id));
toast(`${kills} enem${kills>1?'ies':'y'} removed!`, 1200);
// Clear flags
S.selectingEncampmentTargets = false;
S.encampmentEarlyKills = 0;
S.encampmentSelectedTargets = [];
// Start combat normally
render();
}

function executeInstance(action, heroIdx, targets) {
const h = S.heroes[heroIdx];
const pow = h.p;
// SAFEGUARD: Ensure targets is a valid array
if(!Array.isArray(targets)) {
  console.error('[ATTACK] targets is not an array:', targets);
  targets = [];
}
debugLog('[EXECUTE] executeInstance called - action:', action, 'targets:', targets.length, targets);
if(action === 'Attack') {
// Trigger attacker animation
triggerAttackAnimation(h.id);

// DEBUG: Log attack targets
debugLog('[ATTACK] Processing attack with', targets.length, 'targets:', JSON.stringify(targets));

const targetDetails = [];
const damagedEnemyIds = [];
// First pass: Apply damage to all targets
targets.forEach(tgtId => {
debugLog('[ATTACK] Processing target:', tgtId);
const e = S.enemies.find(x => x.id === tgtId);
debugLog('[ATTACK] Found enemy:', e ? e.n : 'NOT FOUND', e ? `HP: ${e.h}/${e.m}` : '');
if(!e) return;
const hpBefore = e.h;
damagedEnemyIds.push(e.id);
// Apply damage (without animation yet)
applyDamageToTarget(e, pow, {isHero: false, skipRewards: false});
const hpAfter = e.h;
debugLog('[ATTACK] Damage applied to', e.n, '- HP:', hpBefore, '->', hpAfter);
targetDetails.push({name: e.n, before: hpBefore, after: hpAfter});
// Track turn damage for damage counter
S.turnDamage += pow;
// RIBBLETON TUTORIAL: Track Wolf damage/death
if(tutorialState && S.floor === 0 && e.n === 'Wolf') {
debugLog('[TUTORIAL] Wolf took damage! HP now:', e.h, 'wolfDamaged was:', tutorialState.wolfDamaged);
if(e.h > 0 && !tutorialState.wolfDamaged) {
tutorialState.wolfDamaged = true;
debugLog('[TUTORIAL] Set wolfDamaged = true');
}
}
});
// Second pass: Trigger hit animations when attacker "lands" the hit
setTimeout(() => {
damagedEnemyIds.forEach((id, idx) => {
triggerHitAnimation(id);
// JUICE: Floating damage numbers
const isBigHit = pow >= 5;
showFloatingNumber(id, `-${pow}`, isBigHit ? 'critical' : 'damage', idx * 15);
});

// JUICE: Sound (screen shake only on defeat/last stand)
if(damagedEnemyIds.length > 0) {
SoundFX.play(pow >= 5 ? 'crit' : 'hit');
// Show cumulative damage counter for this hero's turn
showDamageCounter(S.turnDamage);
// Show happy reaction when hero lands a hit
setHeroReaction(h.id, 'happy', 1000);
}
}, ANIMATION_TIMINGS.ATTACK_IMPACT);
// Third pass: Handle deaths and cleanup
const deadEnemies = [];
const dyingFlydras = [];
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
if(e.h <= 0 && e.g === 0) {
// FLYDRA: Special death handling
if(e.isFlydra && e.flydraState === 'alive') {
handleFlydraDeath(e);
dyingFlydras.push(e);
} else if(!e.isFlydra) {
// JUICE: Knockout animation and death sound
triggerKnockout(e.id);
deadEnemies.push(e);
// RIBBLETON TUTORIAL: Track Wolf/Goblin kills
if(tutorialState && S.floor === 0) {
if(e.n === 'Wolf') tutorialState.wolfKilled = true;
if(e.n === 'Goblin') tutorialState.goblinKilled = true;
}
}
}
});
// Remove dead enemies after short delay for knockout animation
if(deadEnemies.length > 0) {
SoundFX.play('croak'); // Froggy croak for enemy defeat
triggerScreenShake(true); // Heavy shake on enemy defeat
// All heroes smile when enemy is killed (gold/xp awarded)
setAllHeroesReaction('happy', 1200);
setTimeout(() => {
deadEnemies.forEach(e => {
S.enemies = S.enemies.filter(enemy => enemy.id !== e.id);
});
render();
// Check combat end AFTER enemies are removed
checkCombatEnd();
}, 200);
}
// FLYDRA: Check if all heads are now dying (victory condition)
if(dyingFlydras.length > 0 && isFlydraDefeated()) {
SoundFX.play('croak');
triggerScreenShake(true);
setTimeout(() => {
S.enemies = S.enemies.filter(e => !e.isFlydra);
render();
checkCombatEnd();
}, 300);
} else if(dyingFlydras.length > 0) {
render(); // Re-render to show flipped cards
}
if(targetDetails.length > 0) {
const targetStrings = targetDetails.map(t => `${t.name} (‚ù§${t.before}‚Üí‚ù§${t.after})`);
toast(`${h.n} attacked ${targetStrings.join(', ')}!`);
}
// Combat end check now happens inside the setTimeout after enemies are removed
} else if(action === 'Shield') {
const targetNames = [];
const shieldedIds = [];
const shieldAmt = 2 * pow;
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
target.sh += shieldAmt;
if(target.sh > target.m) target.sh = target.m;
targetNames.push(target.n);
shieldedIds.push(target.id);
});
// Trigger all shield animations simultaneously with amounts
shieldedIds.forEach(id => triggerShieldAnimation(id, shieldAmt));
if(targetNames.length > 0) {
toast(`${targetNames.join(' and ')} gained ${shieldAmt} shield!`);
// QUEST TRACKING: Shield applied
trackQuestProgress('shield');
trackQuestProgress('targets', targetNames.length);
}
} else if(action === 'Heal') {
const healed = [];
const revived = [];
const healedIds = [];
const healAmt = 2 * pow;
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
healedIds.push(target.id);
if(target.ls) {
target.ls = false;
target.lst = 0;
target.h = healAmt;
revived.push(target.n);
} else {
target.h += healAmt;
if(target.h > target.m) target.h = target.m;
healed.push(target.n);
}
});
// Trigger all heal animations simultaneously with amounts
healedIds.forEach(id => triggerHealAnimation(id, healAmt));
// Show happy reaction on the healer
setHeroReaction(h.id, 'happy', 1000);
// Healed targets also smile
healedIds.forEach(id => setHeroReaction(id, 'happy', 1200));
if(healed.length > 0) toast(`${healed.join(' and ')} restored ${healAmt} HP!`);
if(revived.length > 0) toast(`${revived.join(' and ')} revived with ${healAmt} HP!`);
// QUEST TRACKING: Heal used
trackQuestProgress('heal');
trackQuestProgress('targets', healedIds.length);
}
}

function executeGrapple(heroIdx, targets, stunDuration) {
const h = S.heroes[heroIdx];
// Trigger attacker animation (grapple uses same animation as attack)
triggerAttackAnimation(h.id);
// JUICE: Stun/grapple sound effect
SoundFX.play('stun');
let totalDmg = 0;
const targetNames = [];
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
totalDmg += e.p;
e.st += stunDuration;
targetNames.push(e.n);
// Show stun tutorial popup first time
showTutorialPop('stun_intro', "Nice stun! Enemies won't attack when stunned, and any other sigils they have are wasted while stunned!");
// Check royal quest completion
if(S.royalQuestActive && S.round === 1 && !S.royalQuestCompleted) {
S.royalQuestCompleted = true;
toast(`Royal Quest completed! Ring retrieved!`, 1800);
}
});
if(targetNames.length > 0) {
toast(`${h.n} grappled ${targetNames.join(', ')} - stunned ${stunDuration} turn${stunDuration>1?'s':''}!`);
// QUEST TRACKING: Grapple used
trackQuestProgress('grapple');
trackQuestProgress('targets', targetNames.length);
}
if(totalDmg > 0) {
// Hero takes recoil damage - trigger hit animation
triggerHitAnimation(h.id);
const damage = applyDamageToTarget(h, totalDmg, {isHero: true, silent: true});
let msg = `${h.n} took Grapple recoil:`;
if(damage.shieldLost > 0 && damage.hpLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è -${damage.hpLost}‚ù§Ô∏è`;
} else if(damage.shieldLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è`;
} else if(damage.hpLost > 0) {
msg += ` -${damage.hpLost}‚ù§Ô∏è`;
}
toast(msg);
}
}

function dealDamageToEnemy(enemy, dmg) {
triggerHitAnimation(enemy.id);
const hpBefore = enemy.h;

// Apply damage using unified function
applyDamageToTarget(enemy, dmg, {isHero: false, skipRewards: false});
const hpAfter = enemy.h;

// JUICE: Floating damage number
const isBigHit = dmg >= 10;
showFloatingNumber(enemy.id, `-${dmg}`, isBigHit ? 'critical' : 'damage');

// JUICE: Sound effect (screen shake only on defeat/last stand)
SoundFX.play(isBigHit ? 'crit' : 'hit');

// Show damage toast
toast(`${getEnemyDisplayName(enemy)} took ${dmg} damage (‚ù§${hpBefore}‚Üí‚ù§${hpAfter})!`);

// RIBBLETON TUTORIAL: Track Wolf damage/death
if(tutorialState && S.floor === 0 && enemy.n === 'Wolf') {
debugLog('[TUTORIAL] Wolf took damage! HP now:', enemy.h, 'wolfDamaged was:', tutorialState.wolfDamaged);
if(enemy.h > 0 && !tutorialState.wolfDamaged) {
tutorialState.wolfDamaged = true;
debugLog('[TUTORIAL] Set wolfDamaged = true');
}
}

// Handle enemy death
if(enemy.h <= 0 && enemy.g === 0) {
// FLYDRA: Special death handling
if(enemy.isFlydra && enemy.flydraState === 'alive') {
handleFlydraDeath(enemy);
// Check if all Flydra heads are now dying
if(isFlydraDefeated()) {
SoundFX.play('croak');
triggerScreenShake(true);
setTimeout(() => {
S.enemies = S.enemies.filter(e => !e.isFlydra);
render();
checkCombatEnd();
}, 300);
} else {
render(); // Re-render to show flipped card
}
} else if(!enemy.isFlydra) {
// JUICE: Knockout animation and death sound
triggerKnockout(enemy.id);
SoundFX.play('death');
triggerScreenShake(true); // Heavy shake on enemy defeat

// RIBBLETON TUTORIAL: Track Wolf/Goblin/Fly kills
if(tutorialState && S.floor === 0) {
if(enemy.n === 'Wolf') tutorialState.wolfKilled = true;
if(enemy.n === 'Goblin') tutorialState.goblinKilled = true;
// Tutorial fly quest: "Munch on a Fly" (1G reward)
if(enemy.n === 'Fly' && !S.tutorialFlags.tutorial_fly_munched) {
S.tutorialFlags.tutorial_fly_munched = true;
savePermanent();
}
}

// QUEST TRACKING: Enemy killed
trackQuestProgress('enemyKill', enemy.n);

// Remove enemy after knockout animation
setTimeout(() => {
  S.enemies = S.enemies.filter(e => e.id !== enemy.id);
  render();
  checkCombatEnd();
}, 300);
}
}
}

function finishAction(heroIdx) {
// Check if this is an Alpha-granted action
if(S.alphaGrantedActions && S.alphaGrantedActions.length > 0) {
S.alphaCurrentAction++;
// Remove one bonus turn stack from the current hero
const currentHero = S.heroes[heroIdx];
if(currentHero) {
removeBonusTurnStack(currentHero.id, true);
}
if(S.alphaCurrentAction < S.alphaGrantedActions.length) {
// More Alpha-granted actions remain
const nextHeroIdx = S.alphaGrantedActions[S.alphaCurrentAction];
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = nextHeroIdx;
// Keep turnDamage - Alpha bonus turns count as same turn for damage counter
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
render();
return;
} else {
// All Alpha-granted actions complete - DON'T consume recipient's normal turn
S.alphaGrantedActions = [];
S.alphaCurrentAction = 0;
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = -1;
S.turnDamage = 0;
autosave();
checkTurnEnd();
render();
return;
}
}
// Normal action finish
S.acted.push(heroIdx);
// Mark first action as used (for Asterisk) only when action commits
const h = S.heroes[heroIdx];
if(h && !h.firstActionUsed) h.firstActionUsed = true;
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = -1;
S.turnDamage = 0; // Reset damage counter for next hero's turn

// RIBBLETON TUTORIAL: Check advancement after action using TutorialManager
TutorialManager.advanceStage({action: 'finish', hero: h.n, round: S.round});

// Autosave after each hero action
autosave();

checkTurnEnd();
render();
}

// Handle ambush situation where all heroes are stunned - player confirms to proceed to enemy turn
function confirmAmbushSkip() {
// Mark all stunned heroes as having "acted" (they skip their turn)
S.heroes.forEach((h, idx) => {
if(h.st > 0 && !S.acted.includes(idx)) {
S.acted.push(idx);
}
});
toast('Heroes skip their turn!', 1000);
checkTurnEnd();
render();
}

function checkTurnEnd() {
// First check if combat has ended (all enemies dead or all heroes in last stand)
// This prevents continuing turn progression after victory/defeat
if(S.enemies.length === 0 || S.heroes.every(h => h.ls)) {
checkCombatEnd(); // Trigger defeat/victory handling (e.g., all heroes LS from Grapple recoil)
return;
}

// Check if all non-stunned heroes have acted (optimized single-pass)
const allActedIncludingLS = S.heroes.every((h, idx) => {
return h.st > 0 || S.acted.includes(idx);
});
if(allActedIncludingLS) {
S.heroes.forEach(h => { if(h.ls) h.lst++; });

// RIBBLETON TUTORIAL: Handle enemy turn start using TutorialManager
// If tutorial is showing a popup, delay enemy turn until popup is dismissed
const tutorialBlocking = TutorialManager.onEnemyTurnStart(() => {
setTimeout(() => { S.locked = true; enemyTurn(); }, T(ANIMATION_TIMINGS.TURN_TRANSITION));
});
if(!tutorialBlocking) {
setTimeout(() => { S.locked = true; enemyTurn(); }, T(ANIMATION_TIMINGS.TURN_TRANSITION));
}
}
}

// ===== FLYDRA MECHANICS =====
/**
 * Handle Flydra death - grants ghost charges to other heads, enters dying state
 * Returns true if this was a Flydra (death handled specially), false otherwise
 */
function handleFlydraDeath(flydra) {
if(!flydra.isFlydra) return false;

// Grant ghost charges to all OTHER living Flydra heads
const ghostCharges = S.heroes.length;
const otherFlydras = S.enemies.filter(e => e.isFlydra && e.id !== flydra.id && e.flydraState === 'alive');

otherFlydras.forEach(other => {
other.g = Math.min((other.g || 0) + ghostCharges, 9);
});

if(otherFlydras.length > 0) {
toast(`${flydra.n} falls! Grants ${ghostCharges} Ghost to ${otherFlydras.length} other head${otherFlydras.length > 1 ? 's' : ''}!`, 2000);
}

// Enter dying state - card will flip
flydra.flydraState = 'dying';
flydra.h = 0;

return true;
}

/**
 * Check if dying Flydras should revive (called at start of enemy turn)
 */
function checkFlydraRevival() {
const dyingFlydras = S.enemies.filter(e => e.isFlydra && e.flydraState === 'dying');
const aliveFlydras = S.enemies.filter(e => e.isFlydra && e.flydraState === 'alive');

if(dyingFlydras.length === 0) return;

// If any Flydras are still alive, revive the dying ones
if(aliveFlydras.length > 0) {
dyingFlydras.forEach(flydra => {
const reviveHP = Math.ceil(flydra.m / 2); // 50% HP
flydra.h = reviveHP;
flydra.flydraState = 'alive';
toast(`${flydra.n} regenerates with ${reviveHP} HP!`, 1800);
triggerHealAnimation(flydra.id, reviveHP);
});
} else {
// All Flydras are dying - they all die for real
// Award flat 150 gold for defeating the Flydra (entire boss, not per-head)
const flydraGold = 150 * (S.gameMode === 'fu' ? 3 : 1); // Frogged Up multiplier
S.gold += flydraGold;
S.combatGold += flydraGold;
SoundFX.play('coinDrop');
upd();
dyingFlydras.forEach(flydra => {
flydra.flydraState = 'dead';
// QUEST TRACKING: Flydra head killed
trackQuestProgress('enemyKill', 'Flydra');
});
// Remove all dead Flydras
S.enemies = S.enemies.filter(e => !e.isFlydra || e.flydraState !== 'dead');
toast('All Flydra heads defeated!', 2000);
checkCombatEnd();
}
}

/**
 * Check if Flydra fight is won (all heads dying/dead simultaneously)
 */
function isFlydraDefeated() {
const flydras = S.enemies.filter(e => e.isFlydra);
if(flydras.length === 0) return false; // No Flydras in this fight

// Victory if all Flydras are in 'dying' state (none alive)
const aliveFlydras = flydras.filter(f => f.flydraState === 'alive');
return aliveFlydras.length === 0;
}

function enemyTurn() {
// FLYDRA: Check for revival at start of enemy turn
checkFlydraRevival();

// Safety check: don't start enemy turn if combat has ended
if(S.enemies.length === 0 || S.heroes.every(h => h.ls)) {
checkCombatEnd();
return;
}

S.turn = 'enemy';
S.acted = [];
S.activeIdx = -1;
render();
S.enemies.forEach(e => {
// NOTE: Stun decrement moved to endEnemyTurn() so enemies actually skip their turn
e.turnsSinceGain++;
e.alphaActed = false;
});
// Process recruits - increment turnsSinceGain (stun decrement moved to endEnemyTurn)
if(S.recruits) {
S.recruits.forEach(r => {
if(!r.turnsSinceGain) r.turnsSinceGain = 0;
r.turnsSinceGain++;
});
}
setTimeout(() => executeAlphaPhase(), ANIMATION_TIMINGS.ALPHA_PHASE_START);
}

function drawEnemyStartSigil(enemy, base, forceLevel1 = false) {
const pool = base.pool;
if(!pool || !Array.isArray(pool) || pool.length === 0) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
// Filter to available sigils (not already held)
const availableSigils = pool.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
// Pick random sigil
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
// Calculate level: use sigilLevels override if defined, otherwise maxLevel
let level;
if(forceLevel1) {
level = 1;
} else {
const maxLvl = (base.sigilLevels && base.sigilLevels[sig]) || base.maxLevel || 1;
level = maxLvl === 1 ? 1 : 1 + Math.floor(Math.random() * maxLvl);
}
enemy.s.push({sig, level, perm:false});
}

function drawEnemySigil(enemy) {
const pool = enemy.pool;
if(!pool || !Array.isArray(pool) || pool.length === 0) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
// Filter pool: exclude held sigils AND Asterisk (only allowed turn 1)
const availableSigils = pool.filter(s => !heldSigils.includes(s) && s !== 'Asterisk');
if(availableSigils.length === 0) return;
// Pick random sigil
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
// Calculate level based on enemy type
let level;
if(enemy.isFlydra) {
// Flydra: level = number of heroes (L2 normal, L3 in Frogged Up)
level = enemy.flydraLevel || S.heroes.length;
} else {
// Other enemies: use sigilLevels override if defined, otherwise maxLevel
const maxLvl = (enemy.sigilLevels && enemy.sigilLevels[sig]) || enemy.maxLevel || 1;
level = maxLvl === 1 ? 1 : 1 + Math.floor(Math.random() * maxLvl);
}
enemy.s.push({sig, level, perm:false});
toast(`${getEnemyDisplayName(enemy)} drew ${sig} L${level}!`);
}

/**
 * Executes Alpha phase of enemy turn.
 *
 * Alpha Mechanic:
 * - Enemies with Alpha sigil grant bonus actions to allies
 * - Alpha enemy does NOT act themselves (skips normal turn)
 * - Chooses strongest ally (highest POW, then most sigils)
 * - Grants Level √ó Attack actions to chosen ally
 * - All Alpha actions resolve before Recruit/Normal phases
 *
 * Execution Order:
 * 1. Find all non-stunned enemies with Alpha sigil
 * 2. For each Alpha enemy: Grant attacks to best ally
 * 3. Mark Alpha enemy as "acted" (skips normal phase)
 * 4. Continue to Recruit phase
 */
function executeAlphaPhase() {
const alphaEnemies = S.enemies.filter(e => e.st === 0 && e.s.some(sigil => sigil.sig === 'Alpha' && !sigil.perm));
if(alphaEnemies.length === 0) { setTimeout(executeRecruitPhase, T(ANIMATION_TIMINGS.PHASE_TRANSITION)); return; }
// Execute all Alpha enemies in reading order with minimal stagger
let delay = 0;
alphaEnemies.forEach((alphaEnemy, idx) => {
setTimeout(() => {
const allies = S.enemies.filter(e => e.id !== alphaEnemy.id && e.h > 0 && !e.s.some(s => s.sig === 'Alpha' && !s.perm));
if(allies.length === 0) { toast(`${alphaEnemy.n}'s Alpha has no valid allies!`); alphaEnemy.alphaActed = true; return; }
allies.sort((a, b) => { if(b.p !== a.p) return b.p - a.p; return b.s.length - a.s.length; });
const bestAlly = allies[0];
const alphaSigil = alphaEnemy.s.find(s => s.sig === 'Alpha');
const attacks = alphaSigil.level;
toast(`${alphaEnemy.n} grants ${bestAlly.n} ${attacks} attack${attacks>1?'s':''}!`);
for(let i = 0; i < attacks; i++) executeEnemyBaseAttack(bestAlly);
alphaEnemy.alphaActed = true;
}, delay);
delay += T(ANIMATION_TIMINGS.ENEMY_ACTION_DELAY); // Minimal stagger (was 600ms)
});
// Wait for longest animation to complete
setTimeout(() => executeRecruitPhase(), delay + T(600));
}

function executeRecruitPhase() {
if(!S.recruits || S.recruits.length === 0) { setTimeout(executeNormalEnemyPhase, T(ANIMATION_TIMINGS.PHASE_TRANSITION)); return; }
// Execute all recruits in reading order with minimal stagger
let delay = 0;
S.recruits.forEach((recruit, idx) => {
setTimeout(() => executeRecruitTurn(recruit), delay);
delay += T(ANIMATION_TIMINGS.ENEMY_ACTION_DELAY); // Minimal stagger (was 600ms)
});
// Wait for longest animation to complete
setTimeout(() => executeNormalEnemyPhase(), delay + T(600));
}

function executeRecruitTurn(recruit) {
if(recruit.st > 0) {
toast(`${recruit.n} (Recruit) is stunned!`);
// Clear drawn sigils even when stunned - they don't persist
recruit.s = recruit.s.filter(s => s.perm);
return;
}
if(recruit.h <= 0) return; // Dead recruit
// Recruit attacks enemies (not heroes)
executeRecruitBaseAttack(recruit);
const drawnSigils = recruit.s.filter(s => !s.perm && s.sig !== 'Alpha');
drawnSigils.forEach(sigil => executeRecruitSigil(recruit, sigil));
recruit.s = recruit.s.filter(s => s.perm);
render();
}

function executeRecruitBaseAttack(recruit) {
// Target lowest HP enemy
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) attacked ${target.n} for ${recruit.p}!`);
}

function executeRecruitSigil(recruit, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
for(let i = 0; i < level; i++) {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) ${sig} attacked ${target.n} for ${recruit.p}!`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * recruit.p * level;
recruit.sh = (recruit.sh || 0) + shieldAmt;
if(recruit.sh > recruit.m) recruit.sh = recruit.m;
toast(`${recruit.n} (Recruit) gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * recruit.p * level;
// Heal lowest HP hero (prioritize Last Stand heroes for revive)
const targets = S.heroes.filter(h => (h.h > 0 && !h.ls) || h.ls);
if(targets.length > 0) {
targets.sort((a, b) => {
if(a.ls && !b.ls) return -1;
if(!a.ls && b.ls) return 1;
return a.h - b.h;
});
const healTarget = targets[0];
if(healTarget.ls) {
healTarget.ls = false;
healTarget.lst = 0;
healTarget.h = Math.min(healAmt, healTarget.m);
toast(`${recruit.n} (Recruit) revived ${healTarget.n}!`);
} else {
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${recruit.n} (Recruit) healed ${healTarget.n} for ${healAmt}!`);
}
}
} else if(sig === 'Grapple') {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
const dmgToRecruit = target.p;
// Use applyDamageToTarget so shields/ghost are respected
const recoil = applyDamageToTarget(recruit, dmgToRecruit, {isHero: false, skipRewards: true, silent: true});
toast(`${recruit.n} (Recruit) grappled ${target.n}!`);
if(recruit.h <= 0) {
recruit.h = 0;
toast(`${recruit.n} (Recruit) defeated by grapple recoil!`);
S.recruits = S.recruits.filter(r => r.id !== recruit.id);
} else {
target.st = Math.max(target.st, level);
toast(`${target.n} stunned for ${level} turns!`);
}
} else if(sig === 'Ghost') {
recruit.g = (recruit.g || 0) + level;
if(recruit.g > 9) recruit.g = 9;
toast(`${recruit.n} (Recruit) gained ${level} Ghost charge!`);
}
}

function executeNormalEnemyPhase() {
// Execute all enemies in reading order (top-down, left-right) with minimal stagger
const allEnemies = [...S.enemies].sort((a, b) => a.li - b.li); // Sort by lane index

// Track enemy turn progress for UI
S.enemyTurnTotal = allEnemies.length;
S.enemyTurnCurrent = 0;

let delay = 0;
allEnemies.forEach((enemy, idx) => {
setTimeout(() => {
S.enemyTurnCurrent = idx + 1;
render(); // Update header to show progress
executeEnemyTurn(enemy);
}, delay);
delay += T(ANIMATION_TIMINGS.ENEMY_ACTION_DELAY); // Just enough stagger for visual clarity (was 600ms)
});

// Wait for longest animation to complete (600ms per enemy action + stagger)
setTimeout(() => endEnemyTurn(), delay + T(600));
}

function executeEnemyTurn(enemy) {
// FLYDRA: Dying Flydras don't act
if(enemy.isFlydra && enemy.flydraState === 'dying') { return; }
if(enemy.st > 0) {
toast(`${getEnemyDisplayName(enemy)} is stunned!`);
// Clear drawn sigils even when stunned - they don't persist
enemy.s = enemy.s.filter(s => s.perm);
return;
}
if(enemy.alphaActed) {
toast(`${getEnemyDisplayName(enemy)} used Alpha (skipping normal turn)`);
enemy.s = enemy.s.filter(s => s.perm);
return;
}
// Filter out Attack sigil - the base attack mechanism handles it
// Attack sigil is a marker indicating the enemy attacks, not an additional action
const drawnSigils = enemy.s.filter(s => !s.perm && s.sig !== 'Alpha' && s.sig !== 'Attack');

// Filter out suicidal grapples - enemies skip grapple if recoil would kill them
// (after shields absorb), but will spend ghost charges to survive it
const safeSigils = drawnSigils.filter(sigil => {
if(sigil.sig === 'Grapple') {
const target = S.heroes[enemy.li];
if(target && target.h > 0) {
const recoilDamage = target.p;
const shieldAbsorb = Math.min(enemy.sh || 0, recoilDamage);
const hpDamage = recoilDamage - shieldAbsorb;
// Ghost charges let the enemy survive - they'll spend one on the recoil hit
if(enemy.g > 0) {
// Allow grapple - ghost charge will absorb lethal hit via applyDamageToTarget
} else if(enemy.h <= hpDamage) {
// Would die from recoil with no ghost charges - sigil falls off
return false;
}
}
}
return true;
});
// Execute drawn sigils first (so Grapple stuns before attack)
safeSigils.forEach(sigil => executeEnemySigil(enemy, sigil));
// Check if enemy died from Grapple recoil before executing base attack
if(enemy.h <= 0 && (!enemy.g || enemy.g === 0)) return;
// Then execute base attack
executeEnemyBaseAttack(enemy);
enemy.s = enemy.s.filter(s => s.perm);
render();
}

function getEnemyExpandLevel(enemy) {
const expandSigil = enemy.s.find(s => s.sig === 'Expand');
return expandSigil ? expandSigil.level : 0;
}

function selectEnemyTargets(enemy, count) {
// Priority:
// 1. Hero directly across (lane index)
// 2. That hero's recruited ally (if present)
// 3. Heroes nearest to that first hero
// 4. Any remaining heroes
// 5. Nearest hero's recruited ally
// 6. Any remaining allies

let targets = [];
const added = new Set();

// 1. Primary target: Hero in enemy's lane
const primaryHero = S.heroes[enemy.li];
if(primaryHero && primaryHero.h > 0) {
targets.push(primaryHero);
added.add(primaryHero.id);
}
if(targets.length >= count) return targets;

// 2. That hero's recruited ally (if present) - use recruitedBy to match the hero in this lane
if(S.recruits && S.recruits.length > 0) {
const primaryRecruit = S.recruits.find(r => r.recruitedBy === enemy.li && r.h > 0);
if(primaryRecruit) {
targets.push(primaryRecruit);
added.add(primaryRecruit.id);
}
}
if(targets.length >= count) return targets;

// 3-4. Expand to nearby heroes by distance from primary lane
const aliveHeroes = S.heroes.filter(h => h.h > 0 && !added.has(h.id));
// Sort by distance from enemy lane
aliveHeroes.sort((a, b) => {
const aIdx = S.heroes.indexOf(a);
const bIdx = S.heroes.indexOf(b);
return Math.abs(aIdx - enemy.li) - Math.abs(bIdx - enemy.li);
});

for(const hero of aliveHeroes) {
if(targets.length >= count) break;
targets.push(hero);
added.add(hero.id);
}
if(targets.length >= count) return targets;

// 5-6. Recruited allies of nearby heroes, then any remaining
if(S.recruits && S.recruits.length > 0) {
const aliveRecruits = S.recruits.filter(r => r.h > 0 && !added.has(r.id));
// Sort by proximity to enemy's lane (using recruitedBy for correct hero association)
aliveRecruits.sort((a, b) => Math.abs(a.recruitedBy - enemy.li) - Math.abs(b.recruitedBy - enemy.li));

for(const recruit of aliveRecruits) {
if(targets.length >= count) break;
targets.push(recruit);
added.add(recruit.id);
}
}

return targets;
}

function executeEnemyBaseAttack(enemy) {
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;
// Check for Attack sigil level (permanent or drawn) to determine attack count
const attackSigil = enemy.s.find(s => s.sig === 'Attack');
const attackLevel = attackSigil ? attackSigil.level : 1;
for(let i = 0; i < attackLevel; i++) {
executeEnemyAttackOnHeroes(enemy, targetCount, attackLevel > 1 ? `Attack ${i+1}/${attackLevel}` : 'Attack');
}
}

function executeEnemySigil(enemy, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;

for(let i = 0; i < level; i++) {
executeEnemyAttackOnHeroes(enemy, targetCount, `Attack ${i+1}/${level}`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * enemy.p * level;
enemy.sh = (enemy.sh || 0) + shieldAmt;
if(enemy.sh > enemy.m) enemy.sh = enemy.m;
toast(`${getEnemyDisplayName(enemy)} gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * enemy.p * level;
// Include self as heal candidate - heal the most injured ally or self
const allies = S.enemies.filter(e => e.h > 0 && e.h < e.m);
if(allies.length > 0) {
allies.sort((a,b) => a.h - b.h);
const healTarget = allies[0];
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${getEnemyDisplayName(enemy)} healed ${getEnemyDisplayName(healTarget)} for ${healAmt}!`);
}
} else if(sig === 'Grapple') {
const target = S.heroes[enemy.li];
if(target && target.h > 0) {
const dmgToEnemy = target.p;
// Use applyDamageToTarget so enemy shield/ghost are respected
applyDamageToTarget(enemy, dmgToEnemy, {isHero: false, skipRewards: true, silent: true});
toast(`${getEnemyDisplayName(enemy)} grappled ${target.n}!`);
if(enemy.h <= 0 && enemy.g === 0) {
toast(`${getEnemyDisplayName(enemy)} defeated by grapple recoil!`);
S.enemies = S.enemies.filter(e => e.id !== enemy.id);
} else {
// Use Math.max to avoid overwriting a higher existing stun value
target.st = Math.max(target.st, level);
toast(`${target.n} stunned for ${level} turns!`);
}
}
} else if(sig === 'Ghost') {
enemy.g = (enemy.g || 0) + level;
if(enemy.g > 9) enemy.g = 9;
toast(`${getEnemyDisplayName(enemy)} gained ${level} Ghost charge!`);
} else if(sig === 'Expand') {
toast(`${getEnemyDisplayName(enemy)} used Expand (affects their attacks)`);
} else if(sig === 'Asterisk') {
// Asterisk for enemies: Multiply attacks by (level + 1)
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;
const multiplier = level + 1;
toast(`${getEnemyDisplayName(enemy)} used Asterisk: √ó${multiplier} attacks!`);
for(let i = 0; i < multiplier; i++) {
executeEnemyAttackOnHeroes(enemy, targetCount, `Asterisk Attack ${i+1}/${multiplier}`);
}
}
}

function dealDamageToHero(hero, dmg, source) {
triggerHitAnimation(hero.id);
const hpBefore = hero.h;
const damage = applyDamageToTarget(hero, dmg, {isHero: true});
const hpAfter = hero.h;
// Show pained reaction when hero takes damage (flash briefly, permanent if last stand)
if(damage.hpLost > 0 || damage.shieldLost > 0) {
setHeroReaction(hero.id, 'pained', hero.ls ? 0 : 600);
}
// Build detailed damage message with HP change
let msg = `${source} hit ${hero.n} (‚ù§${hpBefore}‚Üí‚ù§${hpAfter}):`;
if(damage.shieldLost > 0 && damage.hpLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è -${damage.hpLost}‚ù§Ô∏è`;
} else if(damage.shieldLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è`;
} else if(damage.hpLost > 0) {
msg += ` -${damage.hpLost}‚ù§Ô∏è`;
}
toast(msg);
}

function endEnemyTurn() {
// Decrement hero stun at end of enemy turn (heroes skip player turn, then decrement)
S.heroes.forEach(h => {
if(h.st > 0) {
h.st--;
if(h.st === 0) toast(`${h.n} is no longer stunned!`);
}
});
// Decrement enemy stun at end of enemy turn (enemies skip their turn, then decrement)
S.enemies.forEach(e => {
if(e.st > 0) {
e.st--;
if(e.st === 0) toast(`${getEnemyDisplayName(e)} is no longer stunned!`);
}
});
// Decrement recruit stun at end of enemy turn (recruits act during enemy turn)
if(S.recruits) {
S.recruits.forEach(r => {
if(r.st > 0) {
r.st--;
if(r.st === 0) toast(`${r.n} (Recruit) is no longer stunned!`);
}
});
}
if(checkCombatEnd()) return;
S.round++;

// Enemies draw sigils at start of player turn (so player can strategize)
S.enemies.forEach(e => {
// RIBBLETON TUTORIAL: Enemies don't gain sigils (except Goblin on Round 3)
const isTutorial = tutorialState && S.floor === 0;
const isGoblinRound3 = isTutorial && e.n === 'Goblin' && S.round === 3;

// CAVE TROLL RAGE: Rolling Attack L1‚ÜíL2‚ÜíL3‚ÜíL1 pattern (every turn)
if(e.rage && !isTutorial) {
const oldIndex = e.rageIndex;
e.rageIndex = (e.rageIndex + 1) % e.ragePattern.length;
const isReset = oldIndex === e.ragePattern.length - 1; // Was at L3, now at L1

// Update Attack level to match current rage index
const attackSigil = e.s.find(sig => sig.sig === 'Attack');
if(attackSigil) {
attackSigil.level = e.ragePattern[e.rageIndex];
}

// Draw additional sigil every turn EXCEPT on reset turns
if(!isReset) {
drawEnemySigil(e);
}
render();
}
// ORC ALTERNATING: Toggle between Attack L2 and random pool sigil
else if(e.alternating && e.turnsSinceGain >= e.gainRate && (!isTutorial || isGoblinRound3)) {
e.turnsSinceGain = 0;
e.altState = !e.altState; // Toggle
// Clear non-permanent sigils and set the new one
e.s = e.s.filter(sig => sig.perm);
if(e.altState) {
e.s.push({sig: e.altSigil.s, level: e.altSigil.l, perm: false});
} else {
drawEnemySigil(e);
}
render();
}
// Normal sigil drawing for other enemies
else if(e.turnsSinceGain >= e.gainRate && (!isTutorial || isGoblinRound3)) {
e.turnsSinceGain = 0;
// Draw multiple sigils per turn if specified (Dragons draw 2)
const draws = e.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(e);
}
// Immediately render to show new sigils
render();
}
});
// Process recruit sigil drawing
if(S.recruits) {
S.recruits.forEach(r => {
if(r.turnsSinceGain >= r.gainRate) {
r.turnsSinceGain = 0;
const draws = r.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(r);
}
// Immediately render to show new sigils
render();
}
});
}

// RIBBLETON TUTORIAL: Handle round transitions using TutorialManager
if(tutorialState && S.floor === 0) {
tutorialState.round = S.round;
TutorialManager.onRoundStart(S.round);
// If onRoundStart handled the transition (showed a popup), return early
if(S.turn === 'player') {
return;
}
}

S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
S.enemyTurnCurrent = 0; // Clear enemy turn progress tracking
S.enemyTurnTotal = 0;
upd();

// Show "Your turn!" toast to indicate player can act again
const aliveHeroes = S.heroes.filter(h => h.h > 0);
if(aliveHeroes.length > 0) {
toast('Your turn!', ANIMATION_TIMINGS.TOAST_SHORT);
}

// Auto-skip stunned heroes
S.heroes.forEach((h, idx) => {
if(h.st > 0 && !S.acted.includes(idx)) {
S.acted.push(idx);
toast(`${h.n} is stunned and skips their turn!`);
}
});

// Autosave at start of each new round (after enemy turn completes)
autosave();

checkTurnEnd();
render();
}

/**
 * Checks for combat victory or defeat conditions.
 *
 * Victory Conditions:
 * - All enemies defeated (S.enemies.length === 0)
 * - Tutorial Floor 0: Special handling with no rewards
 * - Normal combat: Awards XP with Star bonus multipliers
 *
 * Defeat Conditions:
 * - All heroes in Last Stand mode (allDead check)
 * - Clears temporary XP upgrades immediately for clean Death screen
 *
 * @returns {boolean} - True if combat ended (victory or defeat), false if ongoing
 */
function checkCombatEnd() {
// Guard against multiple simultaneous calls (race condition from async death handling)
if(S.combatEnding) return false;

// Clean up any lingering tooltips when combat ends
if(typeof hideTooltip === 'function') hideTooltip();
if(S.enemies.length === 0) {
S.combatEnding = true; // Prevent duplicate victory handling
S.inCombat = false; // Combat ended - disable autosave
// Tutorial Floor 0: Special ending (no XP/Gold rewards)
if(S.floor === 0) {
S.combatXP = 0;
S.combatGold = 0;
setTimeout(() => {
toast('Victory!');
if(tutorialState && tutorialState.phase === 1) {
// Phase 1 complete: Transition to Phase 2
setTimeout(finishTaposBirthdayPhase, T(ANIMATION_TIMINGS.VICTORY_DELAY));
} else {
// Phase 2 complete: Show handoff popup, then finish tutorial
setTimeout(() => {
showTutorialPop('ribbleton_handoff', "Hover / long-press any sigil to see what it does, and check out the FAQ and Sigilarium for tips. You're on your own after this - don't croak... Heh", () => {
finishRibbletonTutorial();
});
}, T(ANIMATION_TIMINGS.VICTORY_DELAY));
}
}, 500);
return true;
}

// Normal combat victory
// JUICE: Victory celebration!
spawnConfetti(60);
ProceduralMusic.playVictory(); // Victory fanfare!
SoundFX.play('ribbit'); // Celebratory frog croak!

setTimeout(() => {
const combatXP = S.combatXP || 0;
let starBonus = 0;
S.heroes.forEach(h => {
const starLevel = getLevel('Star', S.heroes.indexOf(h));
starBonus += starLevel * 0.5;
});
const bonusXP = Math.floor(combatXP * (1 + starBonus));
S.xp += bonusXP;
S.combatXP = 0; // Reset combat XP
// Recruits persist until killed - don't clear here
if(starBonus > 0) toast(`Star Bonus! ${combatXP} √ó ${(1 + starBonus).toFixed(1)} = ${bonusXP} XP`, 3000);
// JUICE: Counter pop for XP gain
animateCounterPop('xp');
upd();
toast('Victory!');
// Reset the level up warning flag for this new level up session
S.levelUpWarningShown = false;
setTimeout(levelUp, T(ANIMATION_TIMINGS.VICTORY_DELAY));
}, 500);
return true;
}
const allDead = S.heroes.every(h => h.ls);
if(allDead) {
S.combatEnding = true; // Prevent duplicate defeat handling
S.inCombat = false; // Combat ended - disable autosave
// Clear temporary XP upgrades immediately so Death screen shows clean permanent levels
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// CRITICAL: Clear run save immediately to prevent loading into invalid state
// This ensures player can't reload into a battle where all heroes are in Last Stand
if(S.currentSlot) {
localStorage.removeItem(`froggle8_slot${S.currentSlot}`);
}
localStorage.removeItem('froggle8'); // Also clear old format for backwards compatibility
// Record to The Pond - determine what killed the heroes
const killedBy = S.enemies.length > 0 ? S.enemies[0].n : 'Unknown';
recordPondHistory('defeat', killedBy);
// JUICE: Defeat sound and music
ProceduralMusic.playDefeat();
SoundFX.play('death');
setTimeout(() => {
toast('Defeated!');
setTimeout(() => transitionScreen(showDeathScreen), T(ANIMATION_TIMINGS.DEFEAT_DELAY));
}, ANIMATION_TIMINGS.ACTION_COMPLETE);
return true;
}
return false;
}

/**
 * Smoothly transitions between major game screens with fade effect.
 *
 * Animation Flow:
 * 1. Fade out current screen (200ms)
 * 2. Execute callback to update content
 * 3. Fade in new screen (200ms)
 *
 * Total transition time: 400ms
 *
 * Used for: error‚Üítitle, tutorial skip‚Üítitle, defeat‚Üídeath, etc.
 *
 * @param {Function} callback - Function to call during fade (updates screen content)
 */
function transitionScreen(callback) {
// Clean up tooltips and stale modals before screen transition
if(typeof hideTooltip === 'function') hideTooltip();
// Remove any body-appended modals that might linger across transitions
document.querySelectorAll('.steam-deck-help-overlay, .steam-deck-help-modal').forEach(el => el.remove());
const v = document.getElementById('gameView');
v.classList.add('fade-out');
setTimeout(() => {
v.classList.remove('fade-out');
callback();
v.classList.add('fade-in');
setTimeout(() => v.classList.remove('fade-in'), ANIMATION_TIMINGS.FADE_TRANSITION);
}, ANIMATION_TIMINGS.FADE_TRANSITION);
}

function render() {
// Save controller focus state before DOM update
if (typeof GamepadController !== 'undefined' && GamepadController.active) {
GamepadController.saveFocusState();
}

const v = document.getElementById('gameView');
// Combat screens are scrollable (no-scroll is for narrative/cutscene screens)
v.classList.remove('no-scroll');
// Toggle FU mode class for compact 3-hero layout and sinister background
v.classList.toggle('fu-mode', S.gameMode === 'fu');
document.body.classList.toggle('fu-mode', S.gameMode === 'fu');
// Special state: Encampment enemy selection
if(S.selectingEncampmentTargets) {
v.innerHTML = renderEncampmentSelection();
// Restore controller focus after DOM update
if (typeof GamepadController !== 'undefined' && GamepadController.active) {
GamepadController.restoreFocusState();
}
return;
}

// RIBBLETON TUTORIAL: Show targeting prompts
if(tutorialState && S.floor === 0 && S.pending) {
// Auto-advance stage when Attack is pending (targeting info now in earlier popup)
if(tutorialState.stage === 'warrior_attack' && S.pending === 'Attack' && S.targets.length === 0) {
tutorialState.stage = 'targeting_wolf';
}
// PROMPT 4: Heal + Expand (BATCHED)
else if(tutorialState.stage === 'healer_heal' && S.pending === 'Heal' && S.currentInstanceTargets.length === 0 && S.targets.length === 0) {
tutorialState.stage = 'expand_targets';
showTutorialPop('ribbleton_expand', "Remember how Healer was able to target 2 earlier? She can do that with her Heal, too! Try it out!", () => {
render();
});
return;
}
}

let html = renderCombatStatusHeader();
// New layout: Each hero and their enemies in a horizontal lane
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });

S.heroes.forEach((h,i) => {
// Add class for crowded lanes (many enemies)
const laneEnemyCount = (enemyLanes[i] || []).length;
const crowdedClass = laneEnemyCount >= 5 ? 'crowded-5' : laneEnemyCount >= 3 ? 'crowded-3' : '';
html += `<div class="combat-lane ${crowdedClass}">`;
html += '<div class="lane-content" style="display:flex;gap:0.75rem;justify-content:flex-start;align-items:stretch">';

// Hero section (right side of their zone, 38% width) - row-reverse so recruits (rendered after) appear to the LEFT of hero
html += '<div style="flex:0 0 38%;display:flex;flex-direction:row-reverse;gap:0.3rem;align-items:flex-start;justify-content:flex-start">';

// LAST STAND: Flipped card visual (similar to dying Flydra)
if(h.ls) {
// Last Stand heroes can only be targeted by Heal (not Shield or Alpha)
const isTargetable = S.pending === 'Heal';
const hasActed = S.acted.includes(i);
const isActive = S.activeIdx === i;
let lsClasses = 'card hero last-stand-flipped';
if(S.chosenHeroIdx === i) lsClasses += ' chosen-one';
if(isActive) lsClasses += ' active';
if(isTargetable) lsClasses += ' targetable';
if(hasActed) lsClasses += ' acted';
const isTargeted = S.targets.includes(h.id);
if(isTargeted) lsClasses += ' targeted';
let onclick = '';
if(isTargetable) onclick = `onclick="tgtHero('${h.id}')"`;
else if(!hasActed && h.st === 0 && !S.pending) onclick = `onclick="selectHero(${i})"`;
const heroImage = getHeroImage(h);
html += `<div id="${h.id}" class="${lsClasses}" style="background:linear-gradient(135deg,#450a0a,#7f1d1d);border:3px solid #dc2626" ${onclick}>`;
html += `<div style="text-align:center;font-size:0.7rem;font-weight:bold;color:#fca5a5;margin-bottom:0.25rem;animation:pulse-text 1s infinite">‚ö†Ô∏è LAST STAND ‚ö†Ô∏è</div>`;
html += `<div style="text-align:center;font-size:0.8rem;font-weight:bold;color:#f1f5f9;margin-bottom:0.25rem">${h.n}</div>`;
if(heroImage) html += `<div style="text-align:center"><img src="${heroImage}" alt="${h.n}" style="width:48px;height:48px;border-radius:4px;object-fit:contain;background:#d4c4a8;filter:sepia(30%) brightness(0.8);border:2px solid #dc2626"></div>`;
html += `<div style="text-align:center;font-size:1.5rem;margin:0.3rem 0">üíÄ</div>`;
html += `<div style="text-align:center;font-size:0.75rem;color:#fca5a5;line-height:1.3;padding:0.25rem">`;
html += `<div style="font-weight:bold;color:#fbbf24">Turn ${h.lst + 1}</div>`;
html += `<div style="font-size:0.65rem;opacity:0.8;margin-top:0.2rem">Heal to revive</div>`;
html += `</div>`;
// Render clickable D20 sigil for Last Stand hero
const d20Level = getLevel('D20', i);
const d20Cl = d20Level===0?'l0':d20Level===1?'l1':d20Level===2?'l2':d20Level===3?'l3':d20Level===4?'l4':'l5';
const canUseD20 = !hasActed && h.st === 0 && !S.pending;
const isD20Active = ((S.pending === 'D20' || S.pending === 'D20_TARGET') && S.activeIdx === i) || (S.pending === 'D20_TARGET' && S.d20HeroIdx === i);
html += `<div class="sigil-row" style="justify-content:center;margin:0.3rem 0">`;
html += `<span class="sigil ${d20Cl} ${isD20Active?'active-action':''} ${canUseD20?'clickable':''}" ${canUseD20?`onclick="act('D20', ${i})"`:''}
style="font-size:1.5rem" onmouseenter="showTooltip('D20', this, ${d20Level})" onmouseleave="hideTooltip()"
ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('D20', this, ${d20Level}), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly('D20', d20Level)}</span>`;
html += `</div>`;
// Shield bar (if shielded) in Last Stand
if(h.sh > 0) {
const shieldPct = Math.min(100, (h.sh / h.m) * 100);
const fullShield = h.sh >= h.m;
html += `<div class="shield-bar-container" style="margin-top:4px"><div class="shield-bar${fullShield?' full':''}" style="width:${shieldPct}%"></div></div>`;
html += `<div style="text-align:center;font-size:0.65rem;color:#60a5fa;margin-top:1px">${h.sh}üõ°</div>`;
}
// Show ghost/acted if any
const lsExtra = [];
if(h.g > 0) lsExtra.push(`${h.g}${sigilIconOnly('Ghost')}`);
if(hasActed) lsExtra.push('‚úì');
if(lsExtra.length > 0) html += `<div style="text-align:center;font-size:0.7rem;color:#f1f5f9">${lsExtra.join(' ')}</div>`;
html += `</div>`;
} else {
// Normal hero card
const hp = `${h.h}/${h.m}‚ù§`;
const isActive = S.activeIdx === i;
const isTargetable = S.pending && needsHeroTarget(S.pending);
const hasActed = S.acted.includes(i);
const isStunned = h.st > 0;
let cardClasses = 'card hero';
if(S.chosenHeroIdx === i) cardClasses += ' chosen-one';
if(isActive) cardClasses += ' active';
if(isTargetable) cardClasses += ' targetable';
if(hasActed) cardClasses += ' acted';
if(isStunned) cardClasses += ' stunned';
if(h.sh > 0) cardClasses += ' has-shield';
const isTargeted = S.targets.includes(h.id);
if(isTargeted) cardClasses += ' targeted';
const extra = [];
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
if(h.st > 0) extra.push(`üí•${h.st}T`);
// Show alpha-granted bonus turns remaining for this hero
if(S.alphaGrantedActions && S.alphaGrantedActions.length > 0) {
const alphaRemaining = S.alphaGrantedActions.slice(S.alphaCurrentAction || 0).filter(idx => idx === i).length;
if(alphaRemaining > 0) extra.push(`‚ö°${alphaRemaining}`);
}
if(hasActed) extra.push('‚úì');
let onclick = '';
if(isTargetable) onclick = `onclick="tgtHero('${h.id}')"`;
else if(!hasActed && h.st === 0 && !S.pending) onclick = `onclick="selectHero(${i})"`;
const heroImage = getHeroImage(h);
// Heal/Shield preview on hover during targeting
const isHealTargetable = S.pending === 'Heal' && isTargetable;
const isShieldTargetable = S.pending === 'Shield' && isTargetable;
const healHoverEvents = isHealTargetable ? `onmouseenter="showHealPreview('${h.id}', this)" onmouseleave="hideHealPreview()"` : '';
const shieldHoverEvents = isShieldTargetable ? `onmouseenter="showShieldPreview('${h.id}', this)" onmouseleave="hideShieldPreview()"` : '';
html += `<div id="${h.id}" class="${cardClasses}" ${onclick} ${healHoverEvents} ${shieldHoverEvents}>`;
// Status banner for stunned/acted heroes
if(isStunned && !isTargetable) {
html += `<div style="text-align:center;font-size:0.65rem;font-weight:bold;color:#fff;background:#ef4444;padding:2px 6px;border-radius:4px;margin-bottom:4px">STUNNED ${h.st}T</div>`;
} else if(hasActed && !isTargetable) {
html += `<div style="text-align:center;font-size:0.65rem;font-weight:bold;color:#fff;background:#6b7280;padding:2px 6px;border-radius:4px;margin-bottom:4px">DONE</div>`;
}
// Name at top
html += `<div style="text-align:center;font-size:0.75rem;font-weight:bold;margin-bottom:0.25rem;opacity:0.8">${h.n}</div>`;
// POW - portrait - HP (horizontal)
html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.25rem;gap:0.25rem">`;
html += `<div style="font-size:1.3rem;font-weight:bold;min-width:35px;text-align:center">${h.p}üí•</div>`;
if(heroImage) html += `<img src="${heroImage}" alt="${h.n}" style="width:48px;height:48px;border-radius:4px;object-fit:contain;background:#d4c4a8">`;
html += `<div style="min-width:50px;text-align:center"><div style="font-size:0.85rem">${h.h}/${h.m}</div><div style="font-size:0.9rem">‚ù§</div></div>`;
html += `</div>`;
// Shield bar (if shielded) - placed below HP, above sigils
if(h.sh > 0) {
const shieldPct = Math.min(100, (h.sh / h.m) * 100);
const fullShield = h.sh >= h.m;
html += `<div class="shield-bar-container"><div class="shield-bar${fullShield?' full':''}" style="width:${shieldPct}%"></div></div>`;
html += `<div style="text-align:center;font-size:0.65rem;color:#60a5fa;margin-top:1px">${h.sh}üõ°</div>`;
}
// Extra info (ghost, stun, alpha, acted)
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils with proper 2-row formation
const activeSigils = sortSigils([...h.s, ...(h.ts || [])]);
const sigilCount = activeSigils.length;

// Calculate row distribution for 2-row max
let row1Count, row2Count;
if (sigilCount <= 3) {
row1Count = sigilCount;
row2Count = 0;
} else if (sigilCount === 4) {
row1Count = 2;
row2Count = 2;
} else {
row1Count = Math.ceil(sigilCount / 2);
row2Count = sigilCount - row1Count;
}

const row1Sigils = activeSigils.slice(0, row1Count);
const row2Sigils = activeSigils.slice(row1Count);
const needsCompact = sigilCount >= 7;
const rowClass = needsCompact ? 'sigil-row compact' : 'sigil-row';

const renderCombatSigil = (s) => {
const lvl = getLevel(s, i);
// Calculate visual level for roll-down effect
let visualLvl = lvl;
let isInEffect = false;

// Check if this hero is the active one with a pending action
const isActiveHero = S.activeIdx === i || (S.pending === 'D20_TARGET' && S.d20HeroIdx === i);
const pendingAction = S.pending;
const hasActiveAction = isActiveHero && pendingAction;

// === ACTIVE SIGILS ===

// Attack/Shield/Heal (multi-instance): Roll down based on instances used within current repeat cycle
if(S.activeIdx === i && S.pending === s && isMultiInstance(s) && S.totalInstances) {
const baseLevel = lvl; // Level of the action (e.g., Attack L3 = 3)
const totalRepeats = S.totalInstances / baseLevel; // How many repeat cycles (from Asterisk)
const usedInstances = S.totalInstances - S.instancesRemaining;
// Calculate position within current repeat cycle
const instancesInCurrentCycle = usedInstances % baseLevel;
visualLvl = Math.max(0, baseLevel - instancesInCurrentCycle);
isInEffect = true;
}

// Grapple: Level = stun turns, doesn't roll down. Expand applies to targeting.
if(s === 'Grapple' && S.activeIdx === i && S.pending === 'Grapple') {
isInEffect = true;
// Grapple level stays constant (stun duration), no roll-down
}

// Alpha: Level = actions granted, doesn't roll down. Expand applies to targeting.
if(s === 'Alpha' && S.activeIdx === i && S.pending === 'Alpha') {
isInEffect = true;
// Alpha level stays constant, no roll-down
}

// D20: Pulse when D20 menu is active or targeting
if(s === 'D20' && isActiveHero && (pendingAction === 'D20' || pendingAction === 'D20_TARGET')) {
isInEffect = true;
// D20 level determines dice rolled, no roll-down
}

// Ghost: Instant action, no roll-down (charges granted immediately)
if(s === 'Ghost' && S.activeIdx === i && S.pending === 'Ghost') {
isInEffect = true;
}

// === PASSIVE SIGILS ===

// Expand: Roll down based on targets selected for current instance/action
// Applies to: Attack, Shield, Heal, Grapple, Alpha, D20_TARGET
if(s === 'Expand' && hasActiveAction && lvl > 0) {
const expandActions = ['Attack', 'Shield', 'Heal', 'Grapple', 'Alpha', 'D20_TARGET'];
if(expandActions.includes(pendingAction)) {
// For D20_TARGET, targets are in S.targets; for others, S.currentInstanceTargets
const currentTargets = pendingAction === 'D20_TARGET'
  ? (S.targets || []).length
  : (S.currentInstanceTargets || []).length;
// Visual = Expand level - targets already selected (shows remaining expand capacity)
visualLvl = Math.max(0, lvl - currentTargets);
isInEffect = true;
}
}

// Asterisk: Roll down based on repeats completed
// Only active during first action of combat (before h.firstActionUsed is set)
if(s === 'Asterisk' && lvl > 0) {
// Check if this is the first action and we're currently using it
const isFirstActionActive = hasActiveAction && !h.firstActionUsed;
// OR if we're mid-action and Asterisk was activated (repeats > 1)
const isMidAsteriskAction = hasActiveAction && (
  (isMultiInstance(pendingAction) && S.totalInstances > getLevel(pendingAction, i)) ||
  (pendingAction === 'D20_TARGET' && S.asteriskD20Repeats > 1) ||
  (pendingAction === 'D20' && S.asteriskD20Repeats > 1)
);

if(isFirstActionActive || isMidAsteriskAction) {
  isInEffect = true;

  if(isMultiInstance(pendingAction) && S.totalInstances) {
    // Calculate completed repeat cycles
    const baseLevel = getLevel(pendingAction, i);
    const usedInstances = S.totalInstances - S.instancesRemaining;
    const completedRepeats = Math.floor(usedInstances / baseLevel);
    visualLvl = Math.max(0, lvl - completedRepeats);
  } else if(pendingAction === 'D20' || pendingAction === 'D20_TARGET') {
    // D20 uses separate asterisk tracking
    visualLvl = Math.max(0, lvl - (S.asteriskD20Count || 0));
  }
  // For other actions (Grapple, Alpha, Ghost), all repeats execute at once
  // so visual stays at full level until action completes
}
}

// Star: XP multiplier, no roll-down needed
// (Star doesn't pulse during combat, it's always passive)

const cl = visualLvl===0?'l0':visualLvl===1?'l1':visualLvl===2?'l2':visualLvl===3?'l3':visualLvl===4?'l4':'l5';
// Allow clicking sigils if: hero hasn't acted, not stunned, and either (no pending action OR pending but no instances committed yet)
const canSwitchAction = !S.pending || (S.instancesRemaining === S.totalInstances);
const canClick = !S.acted.includes(i) && h.st === 0 && canSwitchAction && ['Attack','Shield','Grapple','Heal','Ghost','D20','Alpha'].includes(s);
const isActiveAction = (S.pending === s && S.activeIdx === i);
const isPassive = ['Expand', 'Star', 'Asterisk'].includes(s);
// Asterisk expended indicator: red X overlay when first action used
const asteriskExpended = (s === 'Asterisk' && h.firstActionUsed);
const asteriskOverlay = asteriskExpended ? '<span style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.2rem;color:#dc2626;text-shadow:0 0 3px #000;pointer-events:none">‚ùå</span>' : '';
const sigilStyle = asteriskExpended ? 'position:relative;opacity:0.5' : '';
return `<span class="sigil ${cl} ${isPassive?'passive':''} ${isActiveAction?'active-action':''} ${isInEffect?'in-effect':''} ${canClick?'clickable':''}" ${canClick?`onclick="act('${s}', ${i})" oncontextmenu="actAndAutoTarget('${s}', ${i}); return false;"`:''}
${sigilStyle ? `style="${sigilStyle}"` : ''}
onmouseenter="showTooltip('${s}', this, ${visualLvl})" onmouseleave="hideTooltip()"
ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${s}', this, ${visualLvl}), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly(s, visualLvl)}${asteriskOverlay}</span>`;
};

html += `<div class="${rowClass}">`;
row1Sigils.forEach(s => html += renderCombatSigil(s));
html += '</div>';
if (row2Sigils.length > 0) {
html += `<div class="${rowClass}">`;
row2Sigils.forEach(s => html += renderCombatSigil(s));
html += '</div>';
}
html += '</div>';
} // End of else (normal hero card)

// Show recruit BEHIND (after) hero if exists
if(S.recruits) {
const heroRecruits = S.recruits.filter(r => r.recruitedBy === i);
if(heroRecruits.length > 0) {
// Sort by POW descending, then by current HP descending
heroRecruits.sort((a, b) => {
if(b.p !== a.p) return b.p - a.p;
return b.h - a.h;
});
const recruit = heroRecruits[0];
const recruitExtra = [];
if(recruit.g > 0) recruitExtra.push(`${recruit.g}${sigilIconOnly('Ghost')}`);
if(recruit.st > 0) recruitExtra.push(`üí•${recruit.st}T`);
const recruitShieldClass = recruit.sh > 0 ? ' has-shield' : '';
html += `<div id="${recruit.id}" class="card hero recruit${recruitShieldClass}">`;
// Power at top
html += `<div style="text-align:center;font-size:1rem;font-weight:bold;margin-bottom:0.25rem">${recruit.p}</div>`;
// Enemy image or emoji (retain original enemy type)
const recruitEmoji = ENEMY_EMOJI[recruit.n] || 'üëæ';
const recruitImageSrc = ENEMY_IMAGES[recruit.n];
if(recruitImageSrc) {
html += `<div style="width:50px;height:50px;margin:0 auto 0.25rem;display:flex;align-items:center;justify-content:center"><img src="${recruitImageSrc}" alt="${recruit.n}" class="enemy-art" style="max-width:100%;max-height:100%;object-fit:contain;border-radius:4px"></div>`;
} else {
html += `<div style="text-align:center;font-size:1.5rem;margin-bottom:0.25rem">${recruitEmoji}</div>`;
}
// HP
html += `<div style="text-align:center;font-size:0.85rem;margin-bottom:0.25rem">${recruit.h}/${recruit.m}</div>`;
// Shield bar (if shielded)
if(recruit.sh > 0) {
const shieldPct = Math.min(100, (recruit.sh / recruit.m) * 100);
const fullShield = recruit.sh >= recruit.m;
html += `<div class="shield-bar-container"><div class="shield-bar${fullShield?' full':''}" style="width:${shieldPct}%"></div></div>`;
html += `<div style="text-align:center;font-size:0.65rem;color:#60a5fa;margin-top:1px">${recruit.sh}üõ°</div>`;
}
// Extra info (ghost, stun)
if(recruitExtra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${recruitExtra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils
const recruitTotalSigils = recruit.s.length + 1;
const compactClass = recruitTotalSigils >= 4 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">
<span class="sigil l1">${sigilIconOnly('Attack')}</span>`;
recruit.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sigil.sig}', this), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly(sigil.sig, sigil.level)}</span>`;
});
html += '</div></div>';
}
}

html += '</div>'; // Close hero section

// Divider between heroes and enemies
html += '<div style="width:2px;background:linear-gradient(to bottom,transparent,rgba(0,0,0,0.25) 15%,rgba(0,0,0,0.25) 85%,transparent);flex-shrink:0"></div>';

// Enemy section (right side of lane, 60% width)
html += '<div style="flex:1 1 60%;display:flex;flex-wrap:wrap;gap:0.25rem;justify-content:flex-start;align-items:flex-start;align-content:flex-start;min-height:60px">';
const laneEnemies = enemyLanes[i] || [];
if(laneEnemies.length === 0) {
html += `<div style="flex:1;text-align:center;font-size:1rem;padding:0.8rem;background:rgba(0,0,0,0.08);border:2px dashed rgba(0,0,0,0.25);border-radius:6px;color:rgba(0,0,0,0.35);font-style:italic;display:flex;align-items:center;justify-content:center">Clear</div>`;
} else {
laneEnemies.forEach(e => {
// FLYDRA: Check if this is a dying Flydra - render flipped card
if(e.isFlydra && e.flydraState === 'dying') {
html += `<div id="${e.id}" class="card enemy flydra-dying" style="background:linear-gradient(135deg,#1a1a2e,#16213e);border:3px solid #e94560;opacity:0.9">`;
html += `<div style="text-align:center;font-size:0.8rem;font-weight:bold;color:#e94560;margin-bottom:0.5rem">‚ö†Ô∏è ${e.n} ‚ö†Ô∏è</div>`;
// Show greyed-out head image if available
if(e.flydraHeadImage) {
html += `<div style="text-align:center;margin:0.5rem 0"><img src="${e.flydraHeadImage}" alt="${e.n}" style="width:50px;height:50px;object-fit:contain;filter:grayscale(80%) brightness(0.5);border-radius:4px"></div>`;
} else {
html += `<div style="text-align:center;font-size:2.5rem;margin:0.5rem 0;filter:grayscale(50%)">üíÄ</div>`;
}
html += `<div style="text-align:center;font-size:0.75rem;color:#f1f5f9;line-height:1.4;padding:0.5rem">`;
html += `<div style="font-weight:bold;color:#fbbf24;margin-bottom:0.3rem">REGENERATING...</div>`;
html += `<div>Revives at ${Math.ceil(e.m/2)} HP next turn unless ALL heads are defeated!</div>`;
html += `</div></div>`;
return;
}
const isTargetable = (S.pending && needsEnemyTarget(S.pending)) || S.pending === 'D20_TARGET';
const isAttackTargetable = S.pending === 'Attack' && isTargetable;
const selectCount = S.targets.filter(t => t === e.id).length;
let cardClasses = 'card enemy';
if(e.isFlydra) cardClasses += ' flydra';
if(isTargetable) cardClasses += ' targetable';
if(selectCount > 0) cardClasses += ' targeted';
if(e.sh > 0) cardClasses += ' has-shield';
const extra = [];
// Show ghost charges if enemy has them
if(e.g > 0) extra.push(`${e.g}${sigilIconOnly('Ghost')}`);
if(e.st > 0) extra.push(`üí•${e.st}T`);
if(selectCount > 0) extra.push(`√ó${selectCount}`);
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
// Add damage preview hover for Attack targeting
const hoverEvents = isAttackTargetable ? `onmouseenter="showDamagePreview('${e.id}', this)" onmouseleave="hideDamagePreview()"` : '';
html += `<div id="${e.id}" class="${cardClasses}" ${isTargetable?`onclick="tgtEnemy('${e.id}')"`:''} ${hoverEvents}>`;
// Name at top
html += `<div style="text-align:center;font-size:0.75rem;font-weight:bold;margin-bottom:0.25rem;opacity:0.8">${getEnemyDisplayName(e)}</div>`;
// POW - image/emoji - HP row (horizontal)
html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.25rem;gap:0.25rem">`;
html += `<div style="font-size:1rem;font-weight:bold;min-width:30px;text-align:center">${e.p}</div>`;
// Show enemy image: Flydra head > artwork image > emoji fallback
const enemyImageSrc = ENEMY_IMAGES[e.n];
if(e.isFlydra && e.flydraHeadImage) {
html += `<div style="width:50px;height:50px;display:flex;align-items:center;justify-content:center"><img src="${e.flydraHeadImage}" alt="${e.n}" class="flydra-head-img" style="max-width:100%;max-height:100%;object-fit:contain;border-radius:4px"></div>`;
} else if(enemyImageSrc) {
html += `<div style="width:60px;height:60px;display:flex;align-items:center;justify-content:center"><img src="${enemyImageSrc}" alt="${e.n}" class="enemy-art" style="max-width:100%;max-height:100%;object-fit:contain;border-radius:4px"></div>`;
} else {
html += `<div style="font-size:2rem">${enemyEmoji}</div>`;
}
html += `<div style="min-width:65px;text-align:center"><div style="font-size:0.8rem">${e.h}/${e.m}</div><div style="font-size:0.9rem">‚ù§</div></div>`;
html += `</div>`;
// Shield bar (if shielded)
if(e.sh > 0) {
const shieldPct = Math.min(100, (e.sh / e.m) * 100);
const fullShield = e.sh >= e.m;
html += `<div class="shield-bar-container"><div class="shield-bar${fullShield?' full':''}" style="width:${shieldPct}%"></div></div>`;
html += `<div style="text-align:center;font-size:0.65rem;color:#60a5fa;margin-top:1px">${e.sh}üõ°</div>`;
}
// Extra info (ghost, stun, target count)
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils with smart wrapping
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
const totalSigils = e.s.length + (hasAttackSigil ? 0 : 1);
const compactClass = totalSigils >= 4 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">`;
if(!hasAttackSigil) {
html += `<span class="sigil l1">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig, sigil.level)}</span>`;
});
html += '</div></div>';
});
}
html += '</div>'; // Close enemy section
html += '</div>'; // Close flex container
html += '</div>'; // Close combat-lane
});

// D20_TARGET: Add targeting overlay with Roll/Cancel buttons
if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const h = S.heroes[heroIdx];
const expandLevel = getLevel('Expand', heroIdx);
const maxTargets = 1 + expandLevel;
const currentTargets = S.targets ? S.targets.length : 0;
const canRoll = currentTargets >= 1;
const actionName = S.d20Action || 'D20';
const adjustedDC = S.d20DC || 10;

html += `<div style="position:fixed;bottom:0;left:0;right:0;background:linear-gradient(to top,rgba(30,30,30,0.98),rgba(30,30,30,0.9));border-top:3px solid #3b82f6;padding:1rem;z-index:1000;text-align:center">`;
html += `<div style="margin-bottom:0.5rem;color:#fff;font-weight:bold;font-size:1.1rem">${h.n}: ${actionName} (DC ${adjustedDC})</div>`;
if(expandLevel > 0) {
html += `<div style="margin-bottom:0.5rem;color:#22c55e;font-size:0.9rem">‚ú® Expand: Select up to ${maxTargets} targets</div>`;
}
html += `<div style="margin-bottom:0.75rem;color:#fbbf24;font-size:1rem">${currentTargets}/${maxTargets} target${currentTargets !== 1 ? 's' : ''} selected</div>`;
html += `<div style="display:flex;gap:1rem;justify-content:center">`;
html += `<button class="btn secondary" onclick="cancelAction()" style="min-width:100px">Cancel</button>`;
html += `<button class="btn ${canRoll ? 'safe' : ''}" onclick="${canRoll ? 'confirmTargets()' : ''}" style="min-width:140px;${canRoll ? '' : 'opacity:0.5;cursor:not-allowed'}">üé≤ Roll D20!</button>`;
html += `</div></div>`;
}

v.innerHTML = html;

// Apply bonus turn stacks after DOM is updated
setTimeout(() => {
// Show Alpha-granted action stacks
if(S.alphaGrantedActions && S.alphaGrantedActions.length > 0) {
// Count remaining actions for each hero
const actionCounts = {};
for(let i = S.alphaCurrentAction || 0; i < S.alphaGrantedActions.length; i++) {
const heroIdx = S.alphaGrantedActions[i];
actionCounts[heroIdx] = (actionCounts[heroIdx] || 0) + 1;
}
// Apply stacks to heroes
Object.keys(actionCounts).forEach(heroIdx => {
const hero = S.heroes[heroIdx];
if(hero) {
addBonusTurnStack(hero.id, actionCounts[heroIdx]);
}
});
}

// Restore controller focus after DOM update
if (typeof GamepadController !== 'undefined' && GamepadController.active) {
GamepadController.restoreFocusState();
}
}, 0);
}

// ===== LEVEL UP =====
function levelUp() {
// JUICE: Level up sound
SoundFX.play('levelup');

// Unlock blue portal after completing Floor 19 (combat before floor 20)
if(S.floor === 19) {
S.hasReachedFloor20 = true;
savePermanent();
toast('The blue portal in Ribbleton has awakened!', 2500);
// Skip level up menu on floor 19 - no point spending XP before victory
setTimeout(() => nextFloor(), 2000);
return;
}

const v = document.getElementById('gameView');
const nextCost = getXPCost(S.levelUpCount);
const canAfford = S.xp >= nextCost;
const spendStyle = canAfford
  ? 'background:linear-gradient(135deg,#fbbf24,#f59e0b);color:#000;font-size:1.3rem;font-weight:bold;border:2px solid #fcd34d;box-shadow:0 0 15px rgba(251,191,36,0.5);text-align:center'
  : 'opacity:0.5;text-align:center';
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Level Up!</h2>
<p style="text-align:center;margin-bottom:0.5rem">Floor ${S.floor} Complete</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Current XP: ${S.xp} | Next Level: ${nextCost}XP</p>
<div class="choice" onclick="levelUpMenu()" style="${spendStyle}">Spend XP${canAfford ? ' ‚ú®' : ''}</div>
<button class="btn secondary" onclick="viewHeroCards()">View Heroes</button>
<button class="btn safe" onclick="tryAdvanceFromLevelUp()">Next Floor</button>`;
}

// Check if player should be warned about unspent XP before advancing
function tryAdvanceFromLevelUp() {
const nextCost = getXPCost(S.levelUpCount);
const canAfford = S.xp >= nextCost;

// If player can afford an upgrade and hasn't been warned this floor, show confirmation
if (canAfford && !S.levelUpWarningShown) {
  S.levelUpWarningShown = true;
  showConfirmModal(
    `You have enough XP (${S.xp}) to spend on an upgrade (costs ${nextCost}). Continue anyway?`,
    () => nextFloor(),
    () => levelUp() // Go back to level up screen
  );
  return;
}

// Otherwise proceed normally
nextFloor();
}

// View hero cards from level up screen
function viewHeroCards() {
const v = document.getElementById('gameView');
let html = '<div style="display:flex;flex-direction:column;align-items:center;padding:1rem;gap:1rem">';
html += '<h2 style="text-align:center;margin:0">Your Heroes</h2>';
html += '<div style="display:flex;flex-wrap:wrap;justify-content:center;gap:1rem">';

S.heroes.forEach((h, idx) => {
const heroImage = getHeroImage(h);
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
if(h.st > 0) extra.push(`üí•${h.st}T`);

let cardStyle = 'background:linear-gradient(135deg,#1e3a5f,#2563eb);border:3px solid #60a5fa';
if(h.ls) cardStyle = 'background:linear-gradient(135deg,#450a0a,#7f1d1d);border:3px solid #dc2626';

html += `<div class="card hero" style="${cardStyle}">`;
// Power at top
html += `<div style="text-align:center;font-size:1.4rem;font-weight:bold;margin-bottom:0.25rem">${h.p}üí•</div>`;
// Hero image
if(heroImage) html += `<div style="text-align:center"><img src="${heroImage}" alt="${h.n}" style="width:56px;height:56px;border-radius:8px;object-fit:contain;background:#d4c4a8;border:2px solid #60a5fa"></div>`;
// Name
html += `<div style="text-align:center;font-weight:bold;font-size:0.9rem;margin:0.25rem 0">${h.n}</div>`;
// HP
if(h.ls) {
  html += `<div style="text-align:center;font-size:0.85rem;color:#fca5a5">Last Stand (T${h.lst+1})</div>`;
} else {
  html += `<div style="text-align:center;font-size:0.85rem">${h.h}/${h.m}‚ù§</div>`;
}
// Extra info (shield, ghost, stun)
if(extra.length > 0) html += `<div style="text-align:center;font-size:0.75rem;margin-top:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils - combine base sigils + temp sigils
const allSigils = [...(h.s || []), ...(h.ts || [])];
const uniqueSigils = [...new Set(allSigils)];
const totalSigils = uniqueSigils.length;
const compactClass = totalSigils >= 5 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">`;
uniqueSigils.forEach(sig => {
  const level = getLevel(sig, idx);
  const cl = level===0?'l0':level===1?'l1':level===2?'l2':level===3?'l3':level===4?'l4':'l5';
  html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${sig}', this, ${level})" onmouseleave="hideTooltip()">${sigilIconOnly(sig, level)}</span>`;
});
html += '</div>';
html += '</div>';
});

html += '</div>'; // end flex container
html += '<button class="btn secondary" onclick="levelUp()" style="margin-top:1rem">Return</button>';
html += '</div>';
v.innerHTML = html;
}

function nextFloor() {
// QUEST TRACKING: Neutral encounter completed (even floors are neutrals)
if(S.floor % 2 === 0 && S.lastNeutral) {
  // Extract base neutral type from encounter name (e.g., 'shopkeeper1' -> 'shopkeeper')
  const neutralBase = S.lastNeutral.replace(/[12]$/, '');
  trackQuestProgress('neutral', neutralBase);
}
// Tapo's Chosen bonus: +1G per floor cleared
if(S.chosenHeroIdx >= 0 && S.heroes[S.chosenHeroIdx]) {
S.gold += 1;
toast(`${S.heroes[S.chosenHeroIdx].n} earned +1G (Tapo's Chosen)`, 1200);
}
// Clear any pending recruit replacement choice
S.pendingNewRecruit = null;
S.pendingOldRecruitId = null;
saveGame();
// Show header buttons tutorial after first neutral encounter (Floor 2 complete)
if(S.floor === 2 && !S.tutorialFlags.faq_intro) {
S.tutorialFlags.faq_intro = true;
showTutorialPop('faq_intro', "You're (mostly) on your own from here - good luck! Need help? Check the header buttons at the top:<br><br>üåÄ <strong>Sigilarium</strong> - View all sigils and their effects<br>ü™µ <strong>Log</strong> - See combat message history<br>‚ùì <strong>FAQ</strong> - Frequently asked questions about game mechanics<br>‚öôÔ∏è <strong>Settings</strong> - Adjust game options and preferences", () => {
startFloor(S.floor + 1);
});
return;
}
startFloor(S.floor + 1);
}

function showStartingXPScreen() {
const v = document.getElementById('gameView');
const nextCost = getXPCost(S.levelUpCount);
const canAfford = S.xp >= nextCost;
const spendStyle = canAfford
  ? 'background:linear-gradient(135deg,#fbbf24,#f59e0b);color:#000;font-size:1.3rem;font-weight:bold;border:2px solid #fcd34d;box-shadow:0 0 15px rgba(251,191,36,0.5);text-align:center'
  : 'opacity:0.5;text-align:center';
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem;color:#a855f7">Starting XP Bonus!</h2>
<p style="text-align:center;margin-bottom:0.5rem;font-size:1.1rem">You start this run with <strong>${S.startingXP} XP</strong> from Death Boy sacrifices!</p>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;opacity:0.8">Spend it now or bank it for later. Remaining XP: <strong>${S.xp}</strong> | Next Level Cost: <strong>${nextCost}XP</strong></p>
<div class="choice" onclick="startingXPMenu()" style="${spendStyle}">Spend XP${canAfford ? ' ‚ú®' : ''}</div>
<button class="btn safe" onclick="startFloor(1)">Start Run (Bank XP)</button>`;
}

function startingXPMenu() {
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend Starting XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="startingHeroStats()">Upgrade Hero Stats</div>
<div class="choice" onclick="showStartingSigilUpgradeMenu()">Upgrade/Add Sigil</div>
<button class="btn secondary" onclick="showStartingXPScreen()">Back</button>`;
}

function showStartingSigilUpgradeMenu() {
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Upgrade/Add Sigil</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>

<div style="background:rgba(44,99,199,0.1);border:2px solid #2c63c7;border-radius:8px;padding:1rem;margin-bottom:1rem">
<h3 style="color:#2c63c7;margin:0 0 0.5rem 0;font-size:1rem">‚öîÔ∏è Core Sigils</h3>
<p style="font-size:0.85rem;margin:0;line-height:1.4">Basic actions that heroes start with: Attack, Shield, Heal, D20. Every hero can learn these.</p>
</div>

<div style="background:rgba(249,115,22,0.1);border:2px solid #f97316;border-radius:8px;padding:1rem;margin-bottom:1rem">
<h3 style="color:#f97316;margin:0 0 0.5rem 0;font-size:1rem">üî• Advanced Sigils</h3>
<p style="font-size:0.85rem;margin:0;line-height:1.4">Alternative specialist actions for your turn: Ghost, Alpha, Grapple. Heroes don't start with these, but any hero can learn them!</p>
</div>

<div style="background:rgba(147,51,234,0.1);border:2px solid #9333ea;border-radius:8px;padding:1rem;margin-bottom:1rem">
<h3 style="color:#9333ea;margin:0 0 0.5rem 0;font-size:1rem">‚ú® Passive Sigils</h3>
<p style="font-size:0.85rem;margin:0;line-height:1.4">Global enhancements that automatically improve all heroes: Expand, Asterisk, Star. <strong>All heroes benefit immediately from passive upgrades!</strong></p>
</div>

<div style="background:rgba(34,197,94,0.1);border:2px solid #22c55e;border-radius:8px;padding:1rem;margin-bottom:1.5rem">
<p style="font-size:0.9rem;margin:0;line-height:1.5"><strong>üí° Upgrading a sigil makes it stronger everywhere:</strong> in the Sigilarium, on every hero who has it, and for any hero who learns it later!</p>
</div>

<div class="choice" onclick="startingUpgradeSigil()">Upgrade Existing Sigil</div>
<div class="choice" onclick="startingAddSigilToHero()">Add New Sigil to Hero</div>
<button class="btn secondary" onclick="startingXPMenu()">Back</button>`;
}

function startingHeroStats() {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Hero Stats</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
S.heroes.forEach((h, idx) => {
html += `<div class="choice" onclick="startingUpPow(${idx})"><strong>${h.n} POW</strong> (${h.p} ‚Üí ${h.p+1})</div>`;
html += `<div class="choice" onclick="startingUpHP(${idx})"><strong>${h.n} HP</strong> (${h.m} ‚Üí ${h.m+5})</div>`;
});
}
html += `<button class="btn secondary" onclick="startingXPMenu()">Back</button>`;
v.innerHTML = html;
}

function startingUpPow(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].p++;
toast(`${S.heroes[idx].n} POW +1!`);
upd();
startingXPMenu();
}

function startingUpHP(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].m += 5;
S.heroes[idx].h += 5;
toast(`${S.heroes[idx].n} HP +5!`);
upd();
startingXPMenu();
}

function startingUpgradeSigil() {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Sigil</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
const allSigils = [...coreSigils, ...advancedSigils, ...passiveSigils];

const available = allSigils.filter(s => {
const totalLevel = (S.sig[s] || 0) + (S.tempSigUpgrades[s] || 0);
return totalLevel < 4;
});

if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">All sigils maxed!</p>`;
} else {
const actives = [...coreSigils, ...advancedSigils];

const renderSigilChoices = (sigils, categoryName, categoryColor) => {
const availableInCategory = sigils.filter(s => available.includes(s));
if(availableInCategory.length === 0) return '';
let categoryHtml = `<h3 style="color:${categoryColor};margin:1rem 0 0.5rem 0;font-size:1rem">${categoryName}</h3>`;
availableInCategory.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const isActive = actives.includes(sig);
const displayLevel = (isActive && level === 0) ? 1 : level;
const nextDisplayLevel = displayLevel + 1;
const anyHeroHasSigil = S.heroes.some(hero => hero.s.includes(sig) || (hero.ts && hero.ts.includes(sig)));
const newSigilNote = !anyHeroHasSigil ? `<br><span style="color:#dc2626;font-size:0.85rem">*No hero has this yet!</span>` : '';
categoryHtml += `<div class="choice" onclick="startingUpSigil('${sig}')"><strong>${sigilIconWithTooltip(sig, nextDisplayLevel)} L${displayLevel} ‚Üí L${nextDisplayLevel}</strong>${newSigilNote}</div>`;
});
return categoryHtml;
};

html += renderSigilChoices(coreSigils, '‚öîÔ∏è Core Sigils', '#2c63c7');
html += renderSigilChoices(advancedSigils, 'üî• Advanced Sigils', '#f97316');
html += renderSigilChoices(passiveSigils, '‚ú® Passive Sigils', '#9333ea');
}
}
html += `<button class="btn secondary" onclick="showStartingSigilUpgradeMenu()">Back</button>`;
v.innerHTML = html;
}

function startingUpSigil(sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.tempSigUpgrades[sig] = (S.tempSigUpgrades[sig] || 0) + 1;
toast(`${sig} upgraded!`);
upd();
startingUpgradeSigil();
}

function startingAddSigilToHero() {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to Hero</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a hero:</p><div style="max-width:400px;margin:0 auto">`;
S.heroes.forEach((h, idx) => {
const sigilInfo = `<br><span style="font-size:0.75rem;opacity:0.8">Current: ${h.s.join(', ')}</span>`;
html += renderHeroCard(h, idx, `startingSelectHeroForSigil(${idx})`, sigilInfo);
});
html += '</div>';
}
html += `<button class="btn secondary" onclick="showStartingSigilUpgradeMenu()">Back</button>`;
v.innerHTML = html;
}

function startingSelectHeroForSigil(heroIdx) {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
const allSigils = [...coreSigils, ...advancedSigils, ...passiveSigils];
const available = allSigils.filter(sig => !h.s.includes(sig) && !(h.ts && h.ts.includes(sig)));
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to ${h.n}</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">${h.n} already has all sigils!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a sigil to add:</p>`;

const actives = [...coreSigils, ...advancedSigils];

const renderCategorySigils = (sigils, categoryName, categoryColor) => {
const availableInCategory = sigils.filter(s => available.includes(s));
if(availableInCategory.length === 0) return '';
let categoryHtml = `<h3 style="color:${categoryColor};margin:1rem 0 0.5rem 0;font-size:1rem">${categoryName}</h3>`;
availableInCategory.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const isActive = actives.includes(sig);
const displayLevel = (isActive && level === 0) ? 1 : level;
const levelText = (level === 0 && !isActive) ? `L${displayLevel} (Passive only)` : `L${displayLevel}`;
const anyHeroHasSigil = S.heroes.some(hero => hero.s.includes(sig) || (hero.ts && hero.ts.includes(sig)));
const newSigilNote = !anyHeroHasSigil ? `<span style="color:#dc2626;font-size:0.85rem"> *No hero has this yet!</span>` : '';
categoryHtml += `<div class="choice" onclick="startingAddSigilConfirm(${heroIdx}, '${sig}')">
<strong>${sigilIconWithTooltip(sig, displayLevel)}</strong> <span style="opacity:0.7">(${levelText})</span>${newSigilNote}
</div>`;
});
return categoryHtml;
};

html += renderCategorySigils(coreSigils, '‚öîÔ∏è Core Sigils', '#2c63c7');
html += renderCategorySigils(advancedSigils, 'üî• Advanced Sigils', '#f97316');
html += renderCategorySigils(passiveSigils, '‚ú® Passive Sigils', '#9333ea');
}
html += `<button class="btn secondary" onclick="startingAddSigilToHero()">Back</button>`;
v.innerHTML = html;
}

function startingAddSigilConfirm(heroIdx, sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
const h = S.heroes[heroIdx];
if(!h.ts) h.ts = [];
h.ts.push(sig);
toast(`${h.n} learned ${sig}!`);
upd();
startingAddSigilToHero();
}

function levelUpMenu() {
// First-time tutorial: multi-modal popup explaining all options
if(!S.tutorialFlags.levelup_intro) {
S.tutorialFlags.levelup_intro = true;
showLevelUpIntroTutorial();
return;
}
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="addActiveToHero()">Add Active Sigil to Hero</div>
<div class="choice" onclick="upgradeActiveSigil()">Upgrade Active Sigil (All Heroes)</div>
<div class="choice" onclick="upgradePassiveSigil()">Add/Upgrade Passive Sigil (All Heroes)</div>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<button class="btn secondary" onclick="levelUp()">Back</button>`;
}

// Multi-modal tutorial for first-time level-up
function showLevelUpIntroTutorial() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="tutorial-modal-backdrop" onclick="event.stopPropagation()">
<div class="tutorial-modal" style="max-width:550px;text-align:left">
<h2 style="text-align:center;color:#22c55e;margin-bottom:1rem">Level Up!</h2>
<p style="text-align:center;margin-bottom:1.5rem;font-size:1rem">Nice! You earned enough XP for your first upgrade! Here are your options:</p>

<div style="background:rgba(59,130,246,0.1);border:2px solid #3b82f6;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem">
<h4 style="color:#3b82f6;margin:0 0 0.25rem 0;font-size:0.95rem">1. Add Active Sigil to Hero</h4>
<p style="font-size:0.85rem;margin:0;line-height:1.3">Teach a hero a NEW ability they don't have yet.<br><em>Example: Give your Tank the Grapple sigil to stun enemies!</em></p>
</div>

<div style="background:rgba(34,197,94,0.1);border:2px solid #22c55e;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem">
<h4 style="color:#22c55e;margin:0 0 0.25rem 0;font-size:0.95rem">2. Upgrade Active Sigil (All Heroes)</h4>
<p style="font-size:0.85rem;margin:0;line-height:1.3">Make an active sigil stronger for EVERYONE who has it.<br><em>Example: Attack L2 = 2 hits, Shield L2 = 4√óPOW shields!</em></p>
</div>

<div style="background:rgba(147,51,234,0.1);border:2px solid #9333ea;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem">
<h4 style="color:#9333ea;margin:0 0 0.25rem 0;font-size:0.95rem">3. Add/Upgrade Passive Sigil (All Heroes)</h4>
<p style="font-size:0.85rem;margin:0;line-height:1.3">Passives (Expand, Asterisk, Star) work automatically for ALL heroes!<br><em>Example: Expand +1 = all heroes can target one extra enemy/ally!</em></p>
</div>

<div style="background:rgba(249,115,22,0.1);border:2px solid #f97316;border-radius:8px;padding:0.75rem;margin-bottom:1rem">
<h4 style="color:#f97316;margin:0 0 0.25rem 0;font-size:0.95rem">4. Upgrade Hero Stats</h4>
<p style="font-size:0.85rem;margin:0;line-height:1.3">Add +1 POW or +5 HP to a hero of your choice.<br><em>Great for boosting your key damage dealer or keeping tanks alive!</em></p>
</div>

<button class="btn" onclick="showLevelUpMenuAfterTutorial()" style="width:100%;margin-top:0.5rem">Got it! Show me the options</button>
</div>
</div>`;
}

function showLevelUpMenuAfterTutorial() {
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="addActiveToHero()">Add Active Sigil to Hero</div>
<div class="choice" onclick="upgradeActiveSigil()">Upgrade Active Sigil (All Heroes)</div>
<div class="choice" onclick="upgradePassiveSigil()">Add/Upgrade Passive Sigil (All Heroes)</div>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<button class="btn secondary" onclick="levelUp()">Back</button>`;
}

// NEW: Add Active Sigil to Hero (only active sigils)
function addActiveToHero() {
showTutorialPop('levelup_add_active', "Teach a hero a NEW active ability! Heroes only get 1 action per turn, but more choices = more tactics. Pick a hero, then pick the sigil they'll learn!");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Active Sigil to Hero</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a hero to teach a new ability:</p><div style="max-width:400px;margin:0 auto">`;
S.heroes.forEach((h, idx) => {
const sigilInfo = `<br><span style="font-size:0.75rem;opacity:0.8">Current: ${h.s.join(', ')}</span>`;
html += renderHeroCard(h, idx, `selectHeroForActiveSigil(${idx})`, sigilInfo);
});
html += '</div>';
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function selectHeroForActiveSigil(heroIdx) {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];
const activeSigils = ['Attack', 'Shield', 'Heal', 'D20', 'Ghost', 'Alpha', 'Grapple'];
const available = activeSigils.filter(sig => !h.s.includes(sig) && !(h.ts && h.ts.includes(sig)));
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Active Sigil to ${h.n}</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">${h.n} already has all active sigils!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose an active sigil to learn:</p>`;
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];

const renderActiveSigils = (sigils, categoryName, categoryColor) => {
const availableInCategory = sigils.filter(s => available.includes(s));
if(availableInCategory.length === 0) return '';
let categoryHtml = `<h3 style="color:${categoryColor};margin:1rem 0 0.5rem 0;font-size:1rem">${categoryName}</h3>`;
availableInCategory.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const displayLevel = level + 1;  // Internal 0 = display L1, etc.
categoryHtml += `<div class="choice" onclick="confirmAddActiveSigil(${heroIdx}, '${sig}')">
<strong>${sigilIconWithTooltip(sig, displayLevel)}</strong> <span style="opacity:0.7">(L${displayLevel})</span>
</div>`;
});
return categoryHtml;
};

html += renderActiveSigils(coreSigils, '‚öîÔ∏è Core Sigils', '#2c63c7');
// Advanced Sigils - locked if not unlocked
if(S.advancedSigilsUnlocked) {
html += renderActiveSigils(advancedSigils, 'üî• Advanced Sigils', '#f97316');
} else {
html += `
<h3 style="color:#f97316;margin:1rem 0 0.5rem 0;font-size:1rem">üî• Advanced Sigils</h3>
<div style="background:#1a1a2e;padding:1.5rem;border-radius:8px;border:2px solid #f97316;text-align:center;opacity:0.8">
<div style="font-size:1.5rem;margin-bottom:0.5rem">üîí</div>
<p style="color:#f97316;font-weight:bold;margin:0 0 0.25rem 0">Ghost ‚Ä¢ Alpha ‚Ä¢ Grapple</p>
<p style="color:#888;font-size:0.85rem;margin:0;font-style:italic">Continue your Adventure to Unlock</p>
</div>`;
}
}
html += `<button class="btn secondary" onclick="addActiveToHero()">Back</button>`;
v.innerHTML = html;
}

function confirmAddActiveSigil(heroIdx, sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
const h = S.heroes[heroIdx];
if(h.s.includes(sig) || (h.ts && h.ts.includes(sig))) { toast(`${h.n} already has ${sig}!`); return; }
S.xp -= cost;
S.levelUpCount++;
if(!h.ts) h.ts = [];
h.ts.push(sig);
h.ts = sortSigils(h.ts);
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const displayLevel = totalLevel + 1;  // Internal 0 = display L1, etc.
toast(`${h.n} learned ${sig} (L${displayLevel})!`);
upd();
saveGame();
levelUpMenu();
}

// NEW: Upgrade Active Sigil (All Heroes)
function upgradeActiveSigil() {
showTutorialPop('levelup_upgrade_active', "Upgrading an active sigil makes it MORE POWERFUL <em>for every hero who has or gains that sigil!</em> For example, Attack L2 = hit twice, Shield L2 = 4√óPOW shields!");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Active Sigil</h2>
<p style="text-align:center;margin-bottom:0.5rem">Cost: ${cost} XP</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.85rem;opacity:0.8">Upgrades apply to ALL heroes who have this sigil!</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
const activeSigils = ['Attack', 'Shield', 'Heal', 'D20', 'Ghost', 'Alpha', 'Grapple'];
const available = activeSigils.filter(s => {
const totalLevel = (S.sig[s] || 0) + (S.tempSigUpgrades[s] || 0);
return totalLevel < 4;
});

if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">All active sigils maxed!</p>`;
} else {
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];

const renderUpgradeSigils = (sigils, categoryName, categoryColor) => {
const availableInCategory = sigils.filter(s => available.includes(s));
if(availableInCategory.length === 0) return '';
let categoryHtml = `<h3 style="color:${categoryColor};margin:1rem 0 0.5rem 0;font-size:1rem">${categoryName}</h3>`;
availableInCategory.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const displayLevel = level + 1;  // Internal 0 = display L1, internal 1 = display L2, etc.
const nextDisplayLevel = displayLevel + 1;
const anyHeroHasSigil = S.heroes.some(hero => hero.s.includes(sig) || (hero.ts && hero.ts.includes(sig)));
const heroNote = !anyHeroHasSigil ? `<br><span style="color:#dc2626;font-size:0.85rem">*No hero has this yet!</span>` : '';
categoryHtml += `<div class="choice" onclick="confirmUpgradeActive('${sig}')"><strong>${sigilIconWithTooltip(sig, displayLevel)} ${sig} | L${displayLevel} ‚Üí L${nextDisplayLevel}</strong>${heroNote}</div>`;
});
return categoryHtml;
};

html += renderUpgradeSigils(coreSigils, '‚öîÔ∏è Core Sigils', '#2c63c7');
// Advanced Sigils - locked if not unlocked
if(S.advancedSigilsUnlocked) {
html += renderUpgradeSigils(advancedSigils, 'üî• Advanced Sigils', '#f97316');
} else {
html += `
<h3 style="color:#f97316;margin:1rem 0 0.5rem 0;font-size:1rem">üî• Advanced Sigils</h3>
<div style="background:#1a1a2e;padding:1.5rem;border-radius:8px;border:2px solid #f97316;text-align:center;opacity:0.8">
<div style="font-size:1.5rem;margin-bottom:0.5rem">üîí</div>
<p style="color:#f97316;font-weight:bold;margin:0 0 0.25rem 0">Ghost ‚Ä¢ Alpha ‚Ä¢ Grapple</p>
<p style="color:#888;font-size:0.85rem;margin:0;font-style:italic">Continue your Adventure to Unlock</p>
</div>`;
}
}
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function confirmUpgradeActive(sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
if(totalLevel >= 4) { toast(`${sig} is already maxed!`); return; }
S.xp -= cost;
S.levelUpCount++;
S.tempSigUpgrades[sig] = (S.tempSigUpgrades[sig] || 0) + 1;
const newLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const displayLevel = newLevel + 1;  // Internal 0 = display L1, etc.
toast(`${sig} upgraded to L${displayLevel}!`);
upd();
saveGame();
levelUpMenu();
}

// NEW: Add/Upgrade Passive Sigil (All Heroes)
function upgradePassiveSigil() {
showTutorialPop('levelup_upgrade_passive', "Once upgraded, Passive sigils (Expand, Asterisk, Star) work AUTOMATICALLY for ALL heroes! They enhance your abilities without needing to click them.");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add/Upgrade Passive Sigil</h2>
<p style="text-align:center;margin-bottom:0.5rem">Cost: ${cost} XP</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.85rem;opacity:0.8">Passive sigils automatically benefit ALL heroes!</p>`;
// Passive Sigils - locked if not unlocked
if(!S.passiveSigilsUnlocked) {
html += `
<div style="background:#1a1a2e;padding:2rem;border-radius:8px;border:2px solid #9333ea;text-align:center;opacity:0.8">
<div style="font-size:1.5rem;margin-bottom:0.5rem">üîí</div>
<p style="color:#9333ea;font-weight:bold;margin:0 0 0.25rem 0">Expand ‚Ä¢ Asterisk ‚Ä¢ Star</p>
<p style="color:#888;font-size:0.85rem;margin:0;font-style:italic">Continue your Adventure to Unlock</p>
</div>`;
} else if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
const available = passiveSigils.filter(s => {
const totalLevel = (S.sig[s] || 0) + (S.tempSigUpgrades[s] || 0);
return totalLevel < 4;
});

if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">All passive sigils maxed!</p>`;
} else {
html += `<div style="background:rgba(147,51,234,0.1);border:2px solid #9333ea;border-radius:8px;padding:1rem;margin-bottom:1rem">
<h3 style="color:#9333ea;margin:0 0 0.5rem 0;font-size:1rem">‚ú® Passive Sigils</h3>
<p style="font-size:0.85rem;margin:0;line-height:1.4"><strong>Expand:</strong> +1 target for Attack/Shield/Heal<br><strong>Asterisk:</strong> Next action triggers multiple times<br><strong>Star:</strong> Multiply XP earned in combat</p>
</div>`;

available.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const isNew = level === 0;
const displayText = isNew ? `Add ${sig}` : `${sig} | L${level} ‚Üí L${level + 1}`;
const tooltipLevel = isNew ? 1 : level;  // Show L1 tooltip when adding, current level otherwise
html += `<div class="choice" onclick="confirmUpgradePassive('${sig}')"><strong>${sigilIconWithTooltip(sig, tooltipLevel)} ${displayText}</strong></div>`;
});
}
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function confirmUpgradePassive(sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
if(totalLevel >= 4) { toast(`${sig} is already maxed!`); return; }
S.xp -= cost;
S.levelUpCount++;
S.tempSigUpgrades[sig] = (S.tempSigUpgrades[sig] || 0) + 1;
const newLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
// When passive is first acquired (level becomes 1), add it to all heroes' sigil lists
if(newLevel === 1) {
S.heroes.forEach(hero => {
if(!hero.s.includes(sig) && !(hero.ts && hero.ts.includes(sig))) {
hero.s.push(sig);
hero.s = sortSigils(hero.s);
}
});
}
toast(`${sig} ${newLevel === 1 ? 'added' : 'upgraded to L' + newLevel}! All heroes benefit!`);
upd();
saveGame();
levelUpMenu();
}

function heroStats() {
showTutorialPop('levelup_stat_upgrade', "This one is pretty straightforward - add +1 POW or +5 HP to a hero of your choice.");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Hero Stats</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
S.heroes.forEach((h, idx) => {
html += `<div class="choice" onclick="upPow(${idx})"><strong>${h.n} POW</strong> (${h.p} ‚Üí ${h.p+1})</div>`;
html += `<div class="choice" onclick="upHP(${idx})"><strong>${h.n} HP</strong> (${h.m} ‚Üí ${h.m+5})</div>`;
});
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function upPow(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].p++;
toast(`${S.heroes[idx].n} POW +1!`);
upd();
saveGame();
levelUpMenu();
}

function upHP(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].m += 5;
S.heroes[idx].h += 5;
if(S.heroes[idx].ls) {
S.heroes[idx].ls = false;
S.heroes[idx].lst = 0;
S.heroes[idx].h = 5;
toast(`${S.heroes[idx].n} revived with 5 HP!`);
} else toast(`${S.heroes[idx].n} HP +5!`);
upd();
saveGame();
levelUpMenu();
}


// ===== NEUTRAL DECK SYSTEM =====
function initNeutralDeck() {
S.neutralDeck = [
'shopkeeper1', 'wishingwell1', 'treasurechest1',
'wizard1', 'oracle1', 'encampment1',
'gambling1', 'ghost1', 'royal1'
];
S.lastNeutral = null;
}

function getNeutralEncounter() {
// FIRST RUN ONLY: Floor 2 gets Oracle Stage 1 as a safe intro to neutrals
if(S.floor === 2 && S.runsAttempted === 1) {
return 'oracle1';
}

// Level 18: Prioritize Stage 2s
if(S.floor === 18) {
const stage2s = S.neutralDeck.filter(n => n.includes('2'));
if(stage2s.length > 0) {
const pick = stage2s[Math.floor(Math.random() * stage2s.length)];
return pick;
}
}

// Filter out last neutral for back-to-back prevention
let available = S.neutralDeck;
if(S.lastNeutral) {
const base = S.lastNeutral.replace(/[12]$/, '');
available = available.filter(n => !n.startsWith(base));
}

// Floor 10: NEVER allow Enemy Encampment (Floor 11 is always ambush)
if(S.floor === 10) {
available = available.filter(n => !n.startsWith('encampment'));
}

if(available.length === 0) {
available = S.neutralDeck;
}

const pick = available[Math.floor(Math.random() * available.length)];
S.lastNeutral = pick;
return pick;
}

function removeNeutralFromDeck(base) {
S.neutralDeck = S.neutralDeck.filter(n => !n.startsWith(base));
}

function replaceStage1WithStage2(base) {
S.neutralDeck = S.neutralDeck.filter(n => n !== `${base}1`);
S.neutralDeck.push(`${base}2`);
}

// ===== D20 ROLLS FOR NEUTRALS =====
function rollD20Neutral() {
// Include both permanent AND temporary upgrades for neutral D20 rolls
// Active sigils are stored 0-indexed (L1 = 0), so add 1 for actual level
const d20Level = ((S.sig.D20 || 0) + (S.tempSigUpgrades.D20 || 0)) + 1;
// TUTORIAL: Explain D20 level affects neutral rolls
showTutorialPop('neutral_d20_level', "D20 checks out-of-combat use your D20 Sigil Level, too! Leveling it up grants bonus dice every time you roll, and you keep the highest result!");
return rollDice(d20Level, 20);
}

function showD20Result(rolls, best) {
// Visual dice display with highlighted best roll - improved contrast
const diceHTML = rolls.map(r => {
const isBest = r === best;
return `<span style="display:inline-block;width:2.5rem;height:2.5rem;line-height:2.5rem;text-align:center;background:${isBest ? '#166534' : '#1e293b'};border:2px solid ${isBest ? '#15803d' : '#475569'};border-radius:0.5rem;margin:0.2rem;font-weight:bold;color:${isBest ? '#bbf7d0' : '#f1f5f9'};font-size:1.2rem;${isBest ? 'box-shadow:0 0 12px rgba(22,163,74,0.6);' : ''}">${r}</span>`;
}).join(' ');
return `<div style="margin:0.5rem 0"><div style="font-size:0.9rem;margin-bottom:0.5rem;color:#4a4540">Rolling ${rolls.length}d20:</div>${diceHTML}</div>`;
}

function formatD20Compact(rolls, best) {
// Compact dice display for toasts/combat - improved contrast
const diceHTML = rolls.map(r => {
const isBest = r === best;
return `<span style="display:inline-block;width:1.8rem;height:1.8rem;line-height:1.8rem;text-align:center;background:${isBest ? '#166534' : '#1e293b'};border:2px solid ${isBest ? '#15803d' : '#475569'};border-radius:0.4rem;margin:0 0.15rem;font-weight:bold;color:${isBest ? '#bbf7d0' : '#f1f5f9'};font-size:1rem;vertical-align:middle;${isBest ? 'box-shadow:0 0 8px rgba(22,163,74,0.6);' : ''}">${r}</span>`;
}).join('');
return diceHTML;
}

function buildNeutralHTML(options) {
const {
bgImage,
title,
description,
outcomes = [],
diceRoll = '',
buttons = '',
showStats = true
} = options;

let html = `<div class="neutral-container">`;

// Left side - Content
html += '<div class="neutral-left">';

// Header with stats and narrative
html += '<div class="neutral-header">';
if(showStats) {
html += `<div class="neutral-stats">üí∞ ${S.gold}G | üéØ Floor ${S.floor}</div>`;
}
html += '<div class="neutral-narrative">';
if(title) html += `<div class="neutral-title">${title}</div>`;
if(description) html += `<div class="neutral-desc">${description}</div>`;
if(diceRoll) html += `<div class="dice-roll">${diceRoll}</div>`;
outcomes.forEach(outcome => {
if(outcome) html += `<div class="neutral-outcome">${outcome}</div>`;
});
html += '</div></div>'; // close narrative and header

// Footer with buttons
if(buttons) {
html += `<div class="neutral-footer">${buttons}</div>`;
}

html += '</div>'; // close neutral-left

// Right side - Art
html += `<div class="neutral-right" style="background-image: url('${bgImage}')"></div>`;

html += '</div>'; // close container
return html;
}

// ===== MAIN TITLE PAGE =====
function mainTitlePage() {
debugLog('[FROGGLE] mainTitlePage START');
// JUICE: Funky frog beat for title screen
ProceduralMusic.startTitleBeat();
// Hide game header on title screen
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'none';

const v = document.getElementById('gameView');
debugLog('[FROGGLE] gameView element:', v);
// Check for old saves and migrate
migrateOldSave();
// If migration created slot 1 but currentSlot not set, set it
if(!S.currentSlot && localStorage.getItem('froggle8_permanent_slot1')) {
S.currentSlot = 1;
localStorage.setItem('froggle8_current_slot', '1');
debugLog('[SAVE] Set currentSlot to 1 after migration');
}
v.innerHTML = `
<div class="title-screen">
<div class="title-container">
<!-- Background image - landscape for wide screens, portrait for narrow -->
<picture>
<source media="(min-aspect-ratio: 1/1)" srcset="assets/froggle_title_wide.jpeg">
<img src="assets/froggle_title.png" alt="FROGGLE" class="title-bg-image">
</picture>
<!-- Version badge -->
<div class="title-version">v${GAME_VERSION}</div>
<!-- Left side buttons stacked -->
<div class="title-button-container">
<button class="btn title-secondary-btn" onclick="showCredits()">Credits</button>
<button class="btn title-secondary-btn" onclick="showSettingsMenu()">Settings</button>
<button class="btn title-secondary-btn" onclick="quitGame()" style="background:#dc2626;border-color:#b91c1c">Quit</button>
</div>
<!-- Play button on the right -->
<button class="btn title-play-btn" onclick="showSaveSlotSelection()">PLAY</button>
</div>
</div>`;

// Fit title image to fill viewport while maintaining aspect ratio
const titleImg = v.querySelector('.title-bg-image');
function fitTitleImage() {
  if (!titleImg || !titleImg.naturalWidth) return;

  const imgRatio = titleImg.naturalWidth / titleImg.naturalHeight;
  const viewRatio = window.innerWidth / window.innerHeight;

  if (viewRatio > imgRatio) {
    // Viewport is wider than image - fit to height, mat shows on sides
    titleImg.style.height = '100vh';
    titleImg.style.width = 'auto';
  } else {
    // Viewport is taller/equal - fit to width, mat shows on top/bottom
    titleImg.style.width = '100vw';
    titleImg.style.height = 'auto';
  }
}

// Run on load and resize
if (titleImg.complete && titleImg.naturalWidth) {
  fitTitleImage();
} else {
  titleImg.addEventListener('load', fitTitleImage);
}
window.addEventListener('resize', fitTitleImage);

// Auto-select Play button - always show focus highlight on load
setTimeout(() => {
const playBtn = document.querySelector('.title-play-btn');
if (playBtn) {
  // Always add controller-focus class to show the green highlight
  playBtn.classList.add('controller-focus');
  // Also set up GamepadController if available
  if (typeof GamepadController !== 'undefined') {
    GamepadController.updateFocusableElements();
    GamepadController.focusedElement = playBtn;
  }
}
}, 50);
}

// Quit game - works in Electron/PWA standalone, shows message in browser
function quitGame() {
showConfirmModal('Are you sure you want to quit FROGGLE?', () => {
  // Try to close the window (works in Electron, PWA standalone, or script-opened windows)
  window.close();

  // If window.close() didn't work (browser security), show a message
  setTimeout(() => {
    // Still here? Show instructions
    const v = document.getElementById('gameView');
    v.innerHTML = `
    <div style="height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#1a1a1a;padding:2rem">
    <div style="background:#22c55e;border:4px solid #000;border-radius:16px;padding:2rem;max-width:400px;text-align:center">
    <h2 style="margin:0 0 1rem 0">üê∏ Thanks for playing!</h2>
    <p style="margin:0 0 1.5rem 0;opacity:0.9">Close this tab or window to exit completely.</p>
    <button class="btn" onclick="mainTitlePage()" style="background:#6366f1">Return to Title</button>
    </div>
    </div>`;
  }, 100);
});
}

// Show credits screen
function showCredits() {
// JUICE: Funky frog beat for credits
ProceduralMusic.startTitleBeat();
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;background:linear-gradient(180deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%);padding:1rem;overflow-y:auto">
<div style="background:rgba(255,255,255,0.95);border:4px solid #000;border-radius:16px;padding:2rem;max-width:500px;width:100%;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
<h2 style="text-align:center;margin:0 0 1rem 0;font-size:1.8rem;color:#4f46e5">üê∏ FROGGLE üê∏</h2>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.95rem;margin:0 0 0.25rem 0;color:#1e1b4b">A DubsPubs game by</p>
<p style="font-size:1.3rem;font-weight:bold;margin:0;color:#22c55e">Preston Wesley Evans</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.9rem;margin:0;color:#1e1b4b"><strong>Design, Art, & Code:</strong> Preston + Claude</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.85rem;margin:0 0 0.25rem 0;color:#6366f1;font-weight:bold">Playtesting</p>
<p style="font-size:0.85rem;margin:0;color:#4b5563;line-height:1.5">Michael Griffin, Charlie Schmidt, Carolyn Powell, Matt Sutz, Ryan Evertz, Noel McKillip, Ray Willess</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.85rem;margin:0 0 0.25rem 0;color:#6366f1;font-weight:bold">Inspiration</p>
<p style="font-size:0.85rem;margin:0;color:#4b5563">Inscryption, Slay the Spire, Balatro, and too much coffee</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.85rem;margin:0 0 0.25rem 0;color:#6366f1;font-weight:bold">Sanity</p>
<p style="font-size:0.85rem;margin:0;color:#4b5563">Erin Keif, Adal Rfai, JPC, Odell Brewing</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.85rem;margin:0 0 0.25rem 0;color:#6366f1;font-weight:bold">Support</p>
<p style="font-size:0.85rem;margin:0;color:#4b5563">Lisa Evans</p>
</div>

<div style="text-align:center;margin-bottom:1rem;padding:0.5rem;background:#fef3c7;border-radius:8px">
<p style="font-size:0.8rem;margin:0;color:#92400e">Version ${GAME_VERSION}</p>
</div>

<button class="btn" onclick="mainTitlePage()" style="width:100%;background:#6366f1;border:3px solid #4f46e5;font-weight:bold">Back to Title</button>
</div>
</div>`;
}

// Format timestamp as readable date
function formatSaveDate(timestamp) {
if(!timestamp) return '';
const d = new Date(timestamp);
const month = d.toLocaleDateString('en-US', { month: 'short' });
const day = d.getDate();
const hour = d.getHours();
const min = d.getMinutes().toString().padStart(2, '0');
const ampm = hour >= 12 ? 'PM' : 'AM';
const hour12 = hour % 12 || 12;
return `${month} ${day}, ${hour12}:${min} ${ampm}`;
}

// Show save slot selection screen
function showSaveSlotSelection() {
const v = document.getElementById('gameView');
const slot1 = getSlotMetadata(1);
const slot2 = getSlotMetadata(2);
const slot3 = getSlotMetadata(3);

v.innerHTML = `
<div style="height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#1a1a1a;padding:1rem;overflow:hidden;box-sizing:border-box">
<div style="background:#22c55e;border:4px solid #000;border-radius:12px;padding:1rem;max-width:500px;width:100%;box-shadow:0 8px 16px rgba(0,0,0,0.5);max-height:95vh;overflow-y:auto">
<h2 style="text-align:center;margin-bottom:1rem;font-size:1.3rem;color:#000">Select Save Slot</h2>

<!-- Slot 1 -->
<div style="background:white;border:3px solid #000;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem;color:#1a1a1a">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.25rem">
<h3 style="font-size:1.1rem;margin:0;color:#1a1a1a">Slot 1</h3>
${slot1.lastSaved ? `<span style="font-size:0.75rem;color:#6b7280">üìÖ ${formatSaveDate(slot1.lastSaved)}</span>` : ''}
</div>
${slot1.exists ? `
<div style="font-size:0.85rem;color:#374151;margin-bottom:0.5rem">
<div>üìä Runs: <strong>${slot1.runsAttempted}</strong> | üí∞ Rate: <strong>${slot1.goingRate}G</strong></div>
${slot1.hasActiveRun ? `<div style="color:#16a34a;font-weight:bold">üéÆ Active Run${slot1.activeFloor ? ` - Floor ${slot1.activeFloor}` : ''}</div>` : ''}
</div>
<div style="display:flex;gap:0.5rem">
<button class="btn" onclick="continueSlot(1)" style="flex:1;background:#22c55e;border:3px solid #16a34a;font-weight:bold;padding:0.5rem">${slot1.hasActiveRun ? '‚ñ∂Ô∏è Continue' : 'üÜï New Run'}</button>
<button class="btn secondary icon" onclick="confirmDeleteSlot(1)" style="padding:0.5rem">üóëÔ∏è</button>
</div>
` : `
<p style="color:#6b7280;margin-bottom:0.5rem;font-size:0.9rem">Empty Slot</p>
<button class="btn" onclick="createNewSlot(1)" style="width:100%;background:#3b82f6;border:3px solid #f97316;font-weight:bold;padding:0.5rem">üÜï New Game</button>
`}
</div>

<!-- Slot 2 -->
<div style="background:white;border:3px solid #000;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem;color:#1a1a1a">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.25rem">
<h3 style="font-size:1.1rem;margin:0;color:#1a1a1a">Slot 2</h3>
${slot2.lastSaved ? `<span style="font-size:0.75rem;color:#6b7280">üìÖ ${formatSaveDate(slot2.lastSaved)}</span>` : ''}
</div>
${slot2.exists ? `
<div style="font-size:0.85rem;color:#374151;margin-bottom:0.5rem">
<div>üìä Runs: <strong>${slot2.runsAttempted}</strong> | üí∞ Rate: <strong>${slot2.goingRate}G</strong></div>
${slot2.hasActiveRun ? `<div style="color:#16a34a;font-weight:bold">üéÆ Active Run${slot2.activeFloor ? ` - Floor ${slot2.activeFloor}` : ''}</div>` : ''}
</div>
<div style="display:flex;gap:0.5rem">
<button class="btn" onclick="continueSlot(2)" style="flex:1;background:#22c55e;border:3px solid #16a34a;font-weight:bold;padding:0.5rem">${slot2.hasActiveRun ? '‚ñ∂Ô∏è Continue' : 'üÜï New Run'}</button>
<button class="btn secondary icon" onclick="confirmDeleteSlot(2)" style="padding:0.5rem">üóëÔ∏è</button>
</div>
` : `
<p style="color:#6b7280;margin-bottom:0.5rem;font-size:0.9rem">Empty Slot</p>
<button class="btn" onclick="createNewSlot(2)" style="width:100%;background:#3b82f6;border:3px solid #f97316;font-weight:bold;padding:0.5rem">üÜï New Game</button>
`}
</div>

<!-- Slot 3 -->
<div style="background:white;border:3px solid #000;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem;color:#1a1a1a">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.25rem">
<h3 style="font-size:1.1rem;margin:0;color:#1a1a1a">Slot 3</h3>
${slot3.lastSaved ? `<span style="font-size:0.75rem;color:#6b7280">üìÖ ${formatSaveDate(slot3.lastSaved)}</span>` : ''}
</div>
${slot3.exists ? `
<div style="font-size:0.85rem;color:#374151;margin-bottom:0.5rem">
<div>üìä Runs: <strong>${slot3.runsAttempted}</strong> | üí∞ Rate: <strong>${slot3.goingRate}G</strong></div>
${slot3.hasActiveRun ? `<div style="color:#16a34a;font-weight:bold">üéÆ Active Run${slot3.activeFloor ? ` - Floor ${slot3.activeFloor}` : ''}</div>` : ''}
</div>
<div style="display:flex;gap:0.5rem">
<button class="btn" onclick="continueSlot(3)" style="flex:1;background:#22c55e;border:3px solid #16a34a;font-weight:bold;padding:0.5rem">${slot3.hasActiveRun ? '‚ñ∂Ô∏è Continue' : 'üÜï New Run'}</button>
<button class="btn secondary icon" onclick="confirmDeleteSlot(3)" style="padding:0.5rem">üóëÔ∏è</button>
</div>
` : `
<p style="color:#6b7280;margin-bottom:0.5rem;font-size:0.9rem">Empty Slot</p>
<button class="btn" onclick="createNewSlot(3)" style="width:100%;background:#3b82f6;border:3px solid #f97316;font-weight:bold;padding:0.5rem">üÜï New Game</button>
`}
</div>

<button class="btn secondary" onclick="mainTitlePage()" style="width:100%;padding:0.5rem">‚Üê Back</button>
</div>
</div>`;
}

// Continue/start a slot
function continueSlot(slot) {
const meta = getSlotMetadata(slot);
if(meta.hasActiveRun) {
// Load existing run
if(loadSlot(slot)) {
// Success - game already started
} else {
toast('Save data corrupted. Try starting a new game in this slot.');
}
} else {
// Start new run in existing slot
S.runsAttempted = (meta.runsAttempted || 0) + 1;
newGameInSlot(slot);
}
}

// Create new game in empty slot
function createNewSlot(slot) {
S.currentSlot = slot;
localStorage.setItem('froggle8_current_slot', slot.toString());
// Reset ALL permanent state for a fresh slot
S.gold = 0;
S.goingRate = 1;
S.startingXP = 0;
S.sig = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.pedestal = [];
S.hasReachedFloor20 = false;
S.fuUnlocked = false;
S.forcedFUEntry = false;
S.tapoUnlocked = false;
S.pondHistory = [];
S.questsCompleted = {};
S.questsClaimed = {};
S.questProgress = {
  // Combat stats
  enemiesKilled: 0,
  totalDamageDealt: 0,
  maxDamageOneAction: 0,
  maxTargetsOneAction: 0,
  lastStandSurvived: false,
  // Action usage
  d20Used: false,
  shieldApplied: false,
  healUsed: false,
  grappleUsed: false,
  alphaUsed: false,
  ghostBlocked: false,
  // Per-hero tracking
  heroesPlayed: { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 },
  heroWins: { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 },
  // Neutral encounters
  neutralsCompleted: { shopkeeper: false, wishingwell: false, treasurechest: false, wizard: false, oracle: false, encampment: false, gambling: false, ghost: false, royal: false },
  // Enemy types
  enemyTypesDefeated: { Goblin: false, Wolf: false, Orc: false, Giant: false, 'Cave Troll': false, Dragon: false, Flydra: false },
  // Milestones
  highestFloor: 0,
  totalGoldEarned: 0,
  totalRunsCompleted: 0,
  standardWins: 0,
  fuWins: 0,
  maxRecruitsHeld: 0,
  purchasedUpgrade: false,
  // Repeatable quest tiers
  slayerTier: 0,
  goldDiggerTier: 0,
  veteranTier: 0
};
S.tutorialFlags = {};
S.usedDeathQuotes = [];
S.runsAttempted = 1;
S.runNumber = 1;
newGame();
}

// Start new game in existing slot
function newGameInSlot(slot) {
S.currentSlot = slot;
localStorage.setItem('froggle8_current_slot', slot.toString());
S.runNumber = (S.runsAttempted || 1);
if(S.runNumber === 1 && !S.helpTipsDisabled) {
showTutorialStory();
} else {
// Go to Ribbleton hub first, player clicks red portal to start run
showRibbleton();
}
}

// Delete slot with confirmation
function confirmDeleteSlot(slot) {
showConfirmModal(`Delete Save Slot ${slot}? This cannot be undone!`, () => {
try {
localStorage.removeItem(`froggle8_slot${slot}`);
localStorage.removeItem(`froggle8_permanent_slot${slot}`);
toast(`Slot ${slot} deleted`);
showSaveSlotSelection(); // Refresh
} catch(e) {
toast('Delete failed. Browser storage may be locked.');
}
});
}

function newGame() {
// Reset runNumber to 1 for new game (allows tutorial to show)
S.runNumber = 1;
debugLog('[FROGGLE] newGame called - runNumber:', S.runNumber, 'helpTipsDisabled:', S.helpTipsDisabled);
if(S.runNumber === 1 && !S.helpTipsDisabled) {
debugLog('[FROGGLE] Showing tutorial story');
showTutorialStory();
} else {
debugLog('[FROGGLE] Skipping tutorial, going to Ribbleton');
// Go to Ribbleton hub first, player clicks red portal to start run
showRibbleton();
}
}

function loadGameFromTitle() {
const s = localStorage.getItem('froggle8');
if(s) {
loadGame();
} else {
toast('No saved game found!');
}
}

function exitGame() {
showConfirmModal('Thanks for playing FROGGLE! Close the window to exit.', () => {
window.close();
});
}

function exportSave() {
const saveData = localStorage.getItem('froggle8');
const permanentData = localStorage.getItem('froggle8_permanent');
if(!saveData && !permanentData) {
toast('No save data to export!');
return;
}
const exportData = {
save: saveData ? JSON.parse(saveData) : null,
permanent: permanentData ? JSON.parse(permanentData) : null,
exportDate: new Date().toISOString(),
version: GAME_VERSION
};
const dataStr = JSON.stringify(exportData, null, 2);
const blob = new Blob([dataStr], {type: 'application/json'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `froggle-save-${new Date().toISOString().split('T')[0]}.json`;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);
toast('Save exported!');
}

function importSave() {
const input = document.createElement('input');
input.type = 'file';
input.accept = '.json';
input.onchange = (e) => {
const file = e.target.files[0];
if(!file) return;
const reader = new FileReader();
reader.onload = (event) => {
try {
const importData = JSON.parse(event.target.result);
if(importData.save) {
localStorage.setItem('froggle8', JSON.stringify(importData.save));
}
if(importData.permanent) {
localStorage.setItem('froggle8_permanent', JSON.stringify(importData.permanent));
}
toast('Save imported successfully!');
setTimeout(() => {
mainTitlePage();
}, 1000);
} catch(err) {
toast('Invalid file format. Make sure to select a FROGGLE save file (.json)');
console.error('Import error:', err);
}
};
reader.readAsText(file);
};
input.click();
}

// ===== NARRATIVE SLIDE SYSTEM =====
// Slides can have: text, html, bg (background image), buttonText
// If slide has 'bg' property, renders in full-art mode
function showNarrativeSlide(slides, currentIndex = 0) {
debugLog('[FROGGLE] showNarrativeSlide called - currentIndex:', currentIndex, 'total slides:', slides.length);
if(currentIndex >= slides.length) {
// All slides shown, call completion callback
debugLog('[FROGGLE] All slides complete, calling onComplete');
// Remove no-scroll class when narrative is done
const gameArea = document.getElementById('gameView');
if(gameArea) gameArea.classList.remove('no-scroll');
if(slides.onComplete) slides.onComplete();
return;
}

const slide = slides[currentIndex];
debugLog('[FROGGLE] Rendering slide', currentIndex);

// Check if this slide has an action that should trigger immediately (no text to show)
// Actions with real text (like statue_slotting) are triggered in continueNarrative after user reads
const isPlaceholderText = slide.text && typeof slide.text === 'string' && slide.text.startsWith('INTERSTITIAL_');
if(slide.action && isPlaceholderText && window.firstVictorySlideAction) {
const handled = window.firstVictorySlideAction(slide.action, currentIndex, () => {
// Action complete, continue to next slide
showNarrativeSlide(slides, currentIndex + 1);
});
if(handled) return; // Action handler will call callback when done
}

const v = document.getElementById('gameView');
debugLog('[FROGGLE] gameView element:', v);
// Add no-scroll class to prevent scrolling on full-screen slides
v.classList.add('no-scroll');
const skipButton = slides.skippable ? `<button class="btn" onclick="skipTutorialFromSlide()" style="padding:0.75rem 1.5rem;background:rgba(100,100,100,0.8);border:2px solid #666;font-size:1rem">Skip</button>` : '';
// Resolve text - may be a function for dynamic content
const slideText = typeof slide.text === 'function' ? slide.text() : slide.text;
debugLog('[FROGGLE] Setting innerHTML for slide', currentIndex);

// Full-art mode: background image takes up screen, text in bottom bar
if(slide.bg) {
const bgStyle = slide.bgStyle || '';
v.innerHTML = `
<div class="full-screen-content" style="position:relative;width:100%;overflow:hidden;background:#1a5c3a">
<!-- Full-page background image -->
<img src="${slide.bg}" style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:0;${bgStyle}">

<!-- Compact text bar at bottom -->
<div style="position:absolute;bottom:0;left:0;right:0;z-index:10;background:rgba(0,0,0,0.75);padding:0.6rem 1rem 0.5rem 1rem;border-top:2px solid rgba(34,197,94,0.5)">
<div style="max-width:700px;margin:0 auto">
${slide.html || `<div class="narrative-text" style="font-size:1.05rem;line-height:1.5;text-align:center;color:#fff;text-shadow:1px 1px 3px rgba(0,0,0,0.9)">${slideText}</div>`}
<div style="display:flex;gap:0.75rem;justify-content:center;margin-top:0.6rem;flex-wrap:wrap;align-items:center">
<button class="btn" onclick="continueNarrative()" style="padding:0.4rem 1.25rem;font-size:0.95rem;background:#22c55e;border:2px solid #15803d">${slide.buttonText || 'Continue'}</button>
${skipButton}
<span style="font-size:0.75rem;color:rgba(255,255,255,0.5)">‚í∂${slides.skippable ? '/‚í∑ skip' : ''}</span>
</div>
</div>
</div>
</div>`;
} else {
// Standard mode: fullscreen centered content with backdrop for readability
v.innerHTML = `
<div class="full-screen-content" style="width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden;padding:1rem;background:rgba(0,0,0,0.3)">
<div style="max-width:700px;text-align:center;background:rgba(0,0,0,0.8);padding:2rem;border-radius:16px;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
${slide.html || `<div class="narrative-text" style="font-size:1.3rem;line-height:1.75;margin-bottom:1.5rem;color:#f5f5f5">${slideText}</div>`}
<div style="display:flex;gap:1rem;justify-content:center;flex-wrap:wrap;margin-top:1.25rem">
<button class="btn" onclick="continueNarrative()" style="padding:0.85rem 2.5rem;font-size:1.15rem">${slide.buttonText || 'Continue'}</button>
${skipButton}
</div>
<div style="margin-top:1rem;font-size:0.9rem;opacity:0.6;color:#ccc">‚í∂ to continue${slides.skippable ? ' ‚Ä¢ ‚í∑ to skip' : ''}</div>
</div>
</div>`;
}

window.currentNarrativeSlides = slides;
window.currentNarrativeIndex = currentIndex;
window.narrativeSlideShownAt = Date.now(); // Track when slide was shown for minimum display time
debugLog('[FROGGLE] Slide', currentIndex, 'rendered successfully');
}

function continueNarrative() {
// Enforce minimum 500ms display time to prevent accidental skips
if(window.narrativeSlideShownAt && Date.now() - window.narrativeSlideShownAt < 500) {
return; // Too soon, ignore the click
}

const slides = window.currentNarrativeSlides;
const currentSlide = slides[window.currentNarrativeIndex];
const nextIndex = window.currentNarrativeIndex + 1;

// Check if current slide has an action that needs to be handled
if(currentSlide && currentSlide.action && window.firstVictorySlideAction) {
const handled = window.firstVictorySlideAction(currentSlide.action, window.currentNarrativeIndex, () => {
// Action complete, continue to next slide
showNarrativeSlide(slides, nextIndex);
});
if(handled) return; // Action handler will call callback when done
}

showNarrativeSlide(slides, nextIndex);
}

function showSkipTutorialConfirmation(proceedCallback) {
// Show friendly skip confirmation with visual indicators for FAQ/Sigilarium
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:500px">
<h2 style="font-size:1.5rem;margin-bottom:1rem;text-align:center">Alright champ! üí™</h2>
<p style="font-size:1.1rem;line-height:1.6;text-align:center;margin-bottom:1.5rem">
You're on your own - get going and save Tapo!
</p>
<div style="background:rgba(59,130,246,0.1);border:2px solid #3b82f6;border-radius:12px;padding:1rem;margin-bottom:1.5rem">
<p style="font-size:0.95rem;line-height:1.5;text-align:center;margin-bottom:0.75rem">
Need help? Look for these buttons:
</p>
<div style="display:flex;justify-content:center;gap:1.5rem;flex-wrap:wrap">
<div style="text-align:center">
<div style="font-size:1.5rem;margin-bottom:0.25rem">üëá</div>
<div style="background:#f97316;color:white;padding:0.5rem 1rem;border-radius:8px;font-weight:bold;border:2px solid #000">‚ùì Help/FAQ</div>
</div>
<div style="text-align:center">
<div style="font-size:1.5rem;margin-bottom:0.25rem">üëá</div>
<div style="background:#9333ea;color:white;padding:0.5rem 1rem;border-radius:8px;font-weight:bold;border:2px solid #000">üìñ Sigilarium</div>
</div>
</div>
</div>
<p style="font-size:0.8rem;line-height:1.4;text-align:center;margin-bottom:1.5rem;opacity:0.7">
(Help/tips can be disabled in ‚öôÔ∏è Settings)
</p>
<button onclick="confirmSkipTutorial()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer;display:block;margin:0 auto">Let's go!</button>
</div>`;
document.body.appendChild(overlay);
window.skipTutorialProceedCallback = proceedCallback;
}

function confirmSkipTutorial() {
const overlay = document.querySelector('.tutorial-modal-backdrop');
if(overlay) overlay.remove();
if(window.skipTutorialProceedCallback) {
window.skipTutorialProceedCallback();
window.skipTutorialProceedCallback = null;
}
}

function skipTutorialFromSlide() {
// Show confirmation popup before skipping
showSkipTutorialConfirmation(() => {
// Remove no-scroll class when leaving narrative
const gameArea = document.getElementById('gameView');
if(gameArea) gameArea.classList.remove('no-scroll');
toast('Tutorial skipped!', ANIMATION_TIMINGS.TOAST_SHORT);
setTimeout(() => transitionScreen(showTitleCard), ANIMATION_TIMINGS.ACTION_COMPLETE);
});
}

// ===== RIBBLETON TUTORIAL INTRO =====
function showTutorialStory() {
debugLog('[FROGGLE] showTutorialStory START');
const slides = [
{
// Full-art: Ribbleton background with text overlay
bg: 'assets/ribbleton.png',
text: `Welcome to the beautiful, tranquil town of <strong style="color:#22c55e">Ribbleton</strong>.<br><br>Today is a very special day!! Why, you ask?`
},
{
// Tapo with birthday vibes - signature double jump + flip animation
html: `
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#f5f5f5">Today is <strong style="color:#22c55e">Tapo's First Birthday!</strong> üéÇ</h2>
<div style="animation:tapoSignature 3.6s ease-in-out infinite;display:inline-block;margin:1.5rem 0">
<img src="assets/tapo-nobg.png" alt="Tapo the tadpole" style="width:170px;height:auto">
</div>
<p style="font-size:1.15rem;line-height:1.7;margin-top:1rem;color:#f5f5f5">The whole town is celebrating the little tadpole's special day!</p>
<style>
@keyframes tapoSignature {
  /* Quick hop 1 */
  0% { transform: translateY(0) scaleX(1); }
  7% { transform: translateY(-20px) scaleX(1); }
  14% { transform: translateY(0) scaleX(1); }
  /* Quick hop 2 */
  21% { transform: translateY(-28px) scaleX(1); }
  28% { transform: translateY(0) scaleX(1); }
  /* Flip to face LEFT - halved stationary gap */
  29.5% { transform: translateY(-8px) scaleX(0); }
  33.5% { transform: translateY(0) scaleX(-1); }
  /* Pause facing left */
  47% { transform: translateY(0) scaleX(-1); }
  /* Quick hop 1 LEFT */
  50% { transform: translateY(0) scaleX(-1); }
  57% { transform: translateY(-20px) scaleX(-1); }
  64% { transform: translateY(0) scaleX(-1); }
  /* Quick hop 2 LEFT */
  71% { transform: translateY(-28px) scaleX(-1); }
  78% { transform: translateY(0) scaleX(-1); }
  /* Flip back to RIGHT - halved stationary gap */
  79.5% { transform: translateY(-8px) scaleX(0); }
  83.5% { transform: translateY(0) scaleX(1); }
  /* Pause facing right */
  100% { transform: translateY(0) scaleX(1); }
}
</style>
`
},
{
html: `
<h2 style="font-size:1.7rem;margin-bottom:1rem;color:#2c63c7">A Special Gift</h2>
<div style="display:flex;justify-content:center;align-items:center;gap:2rem;margin:1.5rem 0">
<div>
<img src="assets/reactions/mage-happy.jpeg" alt="Mage smiling" style="width:130px;height:auto;border-radius:8px;border:2px solid #22c55e;box-shadow:0 4px 8px rgba(0,0,0,0.2)">
<div style="margin-top:0.5rem;font-weight:bold;font-size:1rem;color:#f5f5f5">Mage</div>
</div>
<div style="font-size:2.5rem;display:flex;flex-direction:column;align-items:center;gap:0.25rem">
<span>ü™∞</span>
<span>üéÅ</span>
</div>
<div style="animation:tapoSignature 3.6s ease-in-out infinite">
<img src="assets/tapo-nobg.png" alt="Tapo" style="width:110px;height:auto">
<div style="margin-top:0.5rem;font-weight:bold;font-size:1rem;color:#f5f5f5">Tapo</div>
</div>
</div>
<p style="font-size:1.15rem;line-height:1.7;margin-top:1rem;color:#f5f5f5">
As a birthday gift, <strong>Mage</strong> promised to teach Tapo how to catch flies.
</p>
`
}
];
slides.skippable = true;
slides.onComplete = () => {
// Start Phase 1: Tapo's Birthday tutorial
startTaposBirthdayTutorial();

setTimeout(() => {
showTaposBirthdayOverlay();
}, 100);
};
debugLog('[FROGGLE] About to call showNarrativeSlide with', slides.length, 'slides');
showNarrativeSlide(slides, 0);
debugLog('[FROGGLE] showNarrativeSlide called');
}

function showTaposBirthdayOverlay() {
// Show Phase 1 narrative overlay - positioned at bottom to not obscure combat
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.style.cssText = 'background:rgba(0,0,0,0.4);align-items:flex-end;padding-bottom:2rem;';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:400px;padding:1rem 1.5rem;background:rgba(31,41,55,0.95);border-width:3px;">
<p style="font-size:1.1rem;line-height:1.5;margin:0.5rem 0;padding:0.5rem 0.75rem;">
ü™∞ Here come three <strong>flies</strong> now - you're up! ü™∞
</p>
<button onclick="dismissTaposBirthdayOverlay()" style="margin-top:0.75rem;padding:0.6rem 1.5rem;font-size:1rem;">Let's catch flies!</button>
</div>`;
document.body.appendChild(overlay);
}

function dismissTaposBirthdayOverlay() {
try {
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
allBackdrops.forEach(backdrop => backdrop.remove());
} catch (error) {
console.error('[TUTORIAL] Error removing Tapo birthday backdrops:', error);
}
// Show first tutorial popup - explain Expand from the start
showTutorialPop('tapo_first_attack', "Mage has <strong>Attack</strong> (an active sigil that costs your turn) and <strong>Expand</strong> (a passive sigil with automatic effects). Use Attack to hit 2 flies at once!", () => {
tutorialState.stage = 'catching_flies';
// Mage is happy to teach Tapo to catch flies!
const mage = S.heroes.find(h => h.n === 'Mage');
if(mage) setHeroReaction(mage.id, 'happy', 2000);
render();
});
}

function startTaposBirthdayTutorial() {
// Phase 1: Mage vs 3 Flies - Mage has Attack + Expand (no D20 - explained later)
S.floor = 0;
S.xp = 0;
S.levelUpCount = 0;
// Initialize sigils to base levels for clean tutorial state
S.sig = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// Reset tutorial-specific flags to ensure popups show for fresh tutorial
S.tutorialFlags.tapo_first_attack = false;
// Force help tips enabled for tutorial (critical popups must show)
S.helpTipsDisabled = false;
S.heroes = [
{id:'h_tutorial_mage', n:'Mage', p:1, h:5, m:5, s:['Attack', 'Expand'], sh:0, g:0, ls:false, lst:0, ts:[], st:0}
];

// Initialize Phase 1 tutorial state
tutorialState = {
stage: 'waiting_for_start',
phase: 1, // Track which phase we're in
fliesKilled: 0,
round: 1
};

// Start combat with 3 Flies
combat(0);
}

// Tapo rescue sequence - called when Mage would die in Phase 1 tutorial
// Shows a narrative interstitial, then animates flies dying one by one
function showTapoRescueSequence() {
// Save reference to remaining flies for the death sequence
const remainingFlies = [...S.enemies];
const flyCount = remainingFlies.length;
const flyText = flyCount === 1 ? 'fly' : 'flies';

// Create narrative overlay explaining what happened
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:600px">
<div style="text-align:center">
<div style="animation:tapoSignatureRescue 3s ease-in-out infinite;display:inline-block;margin-bottom:1rem">
<img src="assets/tapo-nobg.png" alt="Tapo" style="width:120px;height:auto">
</div>
<h2 style="color:#22c55e;margin-bottom:1rem">Tapo to the Rescue!</h2>
<p style="font-size:1.1rem;line-height:1.7;margin-bottom:1.5rem">
Just as the ${flyText} ${flyCount === 1 ? 'is' : 'are'} about to finish off Mage, <strong style="color:#22c55e">Tapo</strong> leaps into action!
<br><br>
His sticky tongue lashes out and <strong>swallows the ${flyText} whole!</strong>
<br><br>
<span style="font-size:0.9rem;opacity:0.8">(In normal combat, your hero would enter "Last Stand" mode - but Tapo's got your back for now!)</span>
</p>
<button onclick="continueTapoRescue()" style="padding:1rem 2.5rem;font-size:1.3rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer">
*ribbit* ü™∞
</button>
</div>
</div>
<style>
@keyframes tapoSignatureRescue {
  /* Quick hop 1 */
  0% { transform: translateY(0) scaleX(1); }
  8% { transform: translateY(-20px) scaleX(1); }
  16% { transform: translateY(0) scaleX(1); }
  /* Quick hop 2 */
  24% { transform: translateY(-28px) scaleX(1); }
  32% { transform: translateY(0) scaleX(1); }
  /* Flip to face LEFT */
  36% { transform: translateY(-8px) scaleX(0); }
  40% { transform: translateY(0) scaleX(-1); }
  /* Quick hop 1 LEFT */
  48% { transform: translateY(-20px) scaleX(-1); }
  56% { transform: translateY(0) scaleX(-1); }
  /* Quick hop 2 LEFT */
  64% { transform: translateY(-28px) scaleX(-1); }
  72% { transform: translateY(0) scaleX(-1); }
  /* Flip back to RIGHT */
  76% { transform: translateY(-8px) scaleX(0); }
  80% { transform: translateY(0) scaleX(1); }
  /* Pause facing right */
  100% { transform: translateY(0) scaleX(1); }
}
</style>`;
document.body.appendChild(overlay);

// Store flies for death animation
window.tapoRescueFlies = remainingFlies;
}

// Continue after Tapo rescue narrative - animate flies dying
function continueTapoRescue() {
// Remove narrative overlay
const backdrops = document.querySelectorAll('.tutorial-modal-backdrop');
backdrops.forEach(b => b.remove());

// Play ribbit sound
SoundFX.play('ribbit');

// Get the saved flies
const flies = window.tapoRescueFlies || [];
window.tapoRescueFlies = null;

// Re-render combat view to show the battlefield
render();

// Kill flies one by one with staggered timing
flies.forEach((fly, index) => {
setTimeout(() => {
// Set fly HP to 0
fly.h = 0;
// Trigger knockout animation
if(typeof triggerKnockout === 'function') {
triggerKnockout(fly.id);
}
// Remove fly after animation
setTimeout(() => {
S.enemies = S.enemies.filter(e => e.id !== fly.id);
render();

// After last fly is removed, wait then proceed
if(index === flies.length - 1) {
setTimeout(() => {
// Show brief "battlefield clear" moment, then proceed
finishTaposBirthdayPhase();
}, 800); // Pause on empty battlefield
}
}, 300); // Death animation duration
}, index * 500); // Stagger each fly death by 500ms
});

// If no flies for some reason, just proceed
if(flies.length === 0) {
setTimeout(() => {
finishTaposBirthdayPhase();
}, 500);
}
}

function finishTaposBirthdayPhase() {
// Phase 1 victory celebration
const v = document.getElementById('gameView');
v.classList.add('no-scroll');
v.innerHTML = `
<style>
@keyframes danceTapo {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  25% { transform: translateY(-10px) rotate(-5deg); }
  50% { transform: translateY(0) rotate(0deg); }
  75% { transform: translateY(-10px) rotate(5deg); }
}
</style>
<div class="full-screen-content" style="width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden;padding:1rem">
<div style="max-width:600px;text-align:center">
<h2 style="font-size:2.5rem;margin-bottom:0.5rem;color:#22c55e">Success!!</h2>
<div style="animation:danceTapo 0.5s ease-in-out infinite;margin:1rem 0">
<img src="assets/tapo-nobg.png" alt="Tapo" style="width:100px;height:auto">
</div>
<p style="font-size:1.2rem;line-height:1.7;margin:1rem 0;color:#fff;background:rgba(0,0,0,0.7);padding:1rem;border-radius:8px">
Tapo squeals with delight as you knock the flies out of the air!<br>
Belly overflowing with delicious fresh flies, Mage and Tapo return to Ribbleton. üéâ
</p>
<button onclick="transitionToPortalInvasion()" style="padding:1rem 2rem;font-size:1.2rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer;margin-top:1.5rem">Continue</button>
</div>
</div>`;
}

function transitionToPortalInvasion() {
// Show portal opening narrative
const slides = [
{
html: `
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#dc2626;animation:shake 0.5s ease-in-out infinite">DANGER!</h2>
<div style="margin:1.5rem 0;position:relative">
<div style="width:160px;height:160px;margin:0 auto;position:relative;border-radius:50%;background:radial-gradient(circle, #dc2626, #7c2d12);animation:narrativePortalPulse 1s ease-in-out infinite;box-shadow:0 0 40px #dc2626"></div>
<div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:3.5rem;animation:spin 2s linear infinite">üåÄ</div>
</div>
<p style="font-size:1.1rem;line-height:1.7;margin:1rem 0;color:#f5f5f5">
As Mage and Tapo enter Ribbleton, something seems off..<br>
Whoa! <strong>A dark portal</strong> is open in the center of square!
</p>
<div style="display:flex;justify-content:center;gap:2rem;margin:1rem 0;font-size:2.5rem">
<div style="animation:enemyAppear 1s ease-out">üë∫</div>
<div style="animation:enemyAppear 1.3s ease-out">üê∫</div>
</div>
<style>
@keyframes shake {
0%, 100% { transform: translateX(0); }
25% { transform: translateX(-5px); }
75% { transform: translateX(5px); }
}
@keyframes narrativePortalPulse {
0%, 100% { transform: scale(1); opacity: 0.8; }
50% { transform: scale(1.1); opacity: 1; }
}
@keyframes spin {
from { transform: translate(-50%, -50%) rotate(0deg); }
to { transform: translate(-50%, -50%) rotate(360deg); }
}
@keyframes enemyAppear {
from { transform: scale(0) rotate(-180deg); opacity: 0; }
to { transform: scale(1) rotate(0deg); opacity: 1; }
}
</style>
`
}
];
slides.onComplete = () => {
// Start Phase 2: Portal Invasion
startRibbletonTutorial();

setTimeout(() => {
showTutorialStoryOverlay();
}, 100);
};
showNarrativeSlide(slides, 0);
}

function showTutorialStoryOverlay() {
// Show narrative on TOP of combat screen with Ribbleton background
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.style.cssText = 'background:none;';
overlay.innerHTML = `
<div style="position:relative;width:100%;height:100%;overflow:hidden">
<!-- Full-page Ribbleton background -->
<img src="assets/ribbleton.png" alt="" style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:0;filter:brightness(0.7)">

<!-- Content overlay -->
<div style="position:relative;z-index:10;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100%;padding:1rem">
<div style="background:rgba(0,0,0,0.85);border-radius:16px;padding:1.5rem;max-width:550px;border:3px solid #dc2626;box-shadow:0 0 30px rgba(220,38,38,0.5)">
<p style="font-size:1.1rem;line-height:1.6;margin-bottom:1.5rem;color:#fff;text-align:center">
Strange, hostile creatures spill out of the <strong style="color:#dc2626">portal</strong>. Take control of Warrior and Healer to fend them off!
</p>
<div style="display:grid;grid-template-columns:1fr auto 1fr;gap:1.5rem;align-items:center;margin:1.5rem 0">
<div style="display:flex;gap:0.5rem;align-items:center;justify-content:center">
<div style="animation:defensiveStance 1.5s ease-in-out infinite">
<img src="assets/characters/tankfull.png" alt="Tank" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem;color:#22c55e">üõ° On Guard!</div>
</div>
<div style="text-align:center">
<div style="animation:tapoSignatureSmall 3s ease-in-out infinite;display:inline-block">
<img src="assets/tapo-nobg.png" alt="Tapo" style="width:60px;height:auto">
</div>
<div style="font-size:0.65rem;color:#22c55e;margin-top:0.25rem">Protected!</div>
</div>
<div style="animation:defensiveStance 1.3s ease-in-out infinite">
<img src="assets/characters/magefull.png" alt="Mage" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem;color:#22c55e">üìñ On Guard!</div>
</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.5rem;align-items:center">
<div style="animation:chargeForward 0.8s ease-out infinite alternate">
<img src="assets/characters/warriorfull.png" alt="Warrior" style="width:80px;height:auto;border-radius:6px;border:2px solid #3b82f6;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem;color:#3b82f6">‚öîÔ∏è Attacking!</div>
</div>
<div style="animation:chargeForward 1s ease-out infinite alternate">
<img src="assets/characters/healerfull.png" alt="Healer" style="width:80px;height:auto;border-radius:6px;border:2px solid #3b82f6;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem;color:#3b82f6">‚úö Attacking!</div>
</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.75rem;align-items:center;font-size:2.5rem">
<div style="animation:enemyThreat 1s ease-in-out infinite">üë∫</div>
<div style="animation:enemyThreat 1.2s ease-in-out infinite">üê∫</div>
</div>
</div>
<div style="margin-top:1.5rem;display:flex;gap:1rem;justify-content:center;flex-wrap:wrap">
<button onclick="dismissStoryOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer">Let's fight!</button>
<button onclick="skipTutorialFromOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#666;color:#fff;border:2px solid #444;border-radius:8px;cursor:pointer">Skip Tutorial</button>
</div>
</div>
</div>
</div>
<style>
@keyframes chargeForward {
0% { transform: translateX(0) scale(1); }
100% { transform: translateX(15px) scale(1.05); }
}
@keyframes defensiveStance {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(-5px); }
}
@keyframes enemyThreat {
0%, 100% { transform: scale(1) rotate(0deg); }
50% { transform: scale(1.2) rotate(10deg); }
}
@keyframes tapoSignatureSmall {
  /* Quick hop 1 */
  0% { transform: translateY(0) scaleX(1); }
  8% { transform: translateY(-12px) scaleX(1); }
  16% { transform: translateY(0) scaleX(1); }
  /* Quick hop 2 */
  24% { transform: translateY(-18px) scaleX(1); }
  32% { transform: translateY(0) scaleX(1); }
  /* Flip to face LEFT */
  36% { transform: translateY(-5px) scaleX(0); }
  40% { transform: translateY(0) scaleX(-1); }
  /* Quick hop 1 LEFT */
  48% { transform: translateY(-12px) scaleX(-1); }
  56% { transform: translateY(0) scaleX(-1); }
  /* Quick hop 2 LEFT */
  64% { transform: translateY(-18px) scaleX(-1); }
  72% { transform: translateY(0) scaleX(-1); }
  /* Flip back to RIGHT */
  76% { transform: translateY(-5px) scaleX(0); }
  80% { transform: translateY(0) scaleX(1); }
  /* Pause facing right */
  100% { transform: translateY(0) scaleX(1); }
}
</style>`;
document.body.appendChild(overlay);
}

function dismissStoryOverlay() {
debugLog('[TUTORIAL] Dismissing story overlay');
// Remove ALL backdrops before showing the tutorial pop
try {
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
debugLog('[TUTORIAL] Found', allBackdrops.length, 'backdrops to remove');
allBackdrops.forEach((backdrop, idx) => {
debugLog('[TUTORIAL] Removing backdrop', idx);
backdrop.remove();
});
} catch (error) {
console.error('[TUTORIAL] Error removing story overlay backdrops:', error);
}

// Double-check they're gone
setTimeout(() => {
try {
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
debugLog('[TUTORIAL] Remaining overlays after dismiss:', remaining.length);
if(remaining.length > 0) {
console.error('[TUTORIAL] ERROR: Still have backdrops!', remaining);
remaining.forEach(r => r.remove());
}

// Wait for DOM to fully update before showing popup
requestAnimationFrame(() => {
// PROMPT 1: Warrior Attack + Targeting (BATCHED)
showTutorialPop('ribbleton_warrior_attack', "In FROGGLE, you'll usually control 2 heroes. Warrior doesn't start with Expand, but he does have 2 POW! Take out that Wolf before it chomps on your Healer!<br><br>(Enemies will usually attack whoever is closest to them, but you can be more strategic) Click the Warrior's Attack sigil.", () => {
debugLog('[TUTORIAL] Prompt 1 dismissed - transitioning to warrior_attack stage');
tutorialState.stage = 'warrior_attack';
S.activeIdx = 0;
debugLog('[TUTORIAL] S.activeIdx is now:', S.activeIdx);
render();
});
});
} catch (error) {
console.error('[TUTORIAL] Error in story overlay cleanup:', error);
}
}, 50);
}

function skipTutorialFromOverlay() {
const overlay = document.querySelector('.tutorial-modal-backdrop');
if(overlay) overlay.remove();
// Show confirmation popup before skipping
showSkipTutorialConfirmation(() => {
toast('Tutorial skipped!', ANIMATION_TIMINGS.TOAST_SHORT);
setTimeout(() => transitionScreen(showTitleCard), ANIMATION_TIMINGS.ACTION_COMPLETE);
});
}

function skipTutorial() {
// This function is for legacy "skip tutorial" - just go to title
toast('Going to hero selection...');
title();
}

// ===== RIBBLETON TUTORIAL (PHASE 2) =====
function startRibbletonTutorial() {
// Phase 2: Portal Invasion - Wolf and Goblin fight with Warrior and Healer
S.floor = 0;
S.xp = 0;
S.levelUpCount = 0;
// Reset Phase 2 tutorial flags to ensure popups show for fresh tutorial
S.tutorialFlags.ribbleton_warrior_attack = false;
S.tutorialFlags.ribbleton_targeting = false;
S.tutorialFlags.ribbleton_healer_d20 = false;
S.tutorialFlags.ribbleton_d20_menu = false;
S.tutorialFlags.ribbleton_enemy_turn = false;
S.tutorialFlags.ribbleton_healer_heal = false;
S.tutorialFlags.enemies_get_sigils = false;
S.heroes = [
{id:'h_tutorial_warrior', n:'Warrior', p:2, h:5, m:5, s:['Attack','D20'], sh:0, g:0, ls:false, lst:0, ts:[], st:0},
{id:'h_tutorial_healer', n:'Healer', p:1, h:5, m:5, s:['Heal','D20','Expand'], sh:0, g:0, ls:false, lst:0, ts:[], st:0}
];

// Add permanently upgraded passives (Expand, Asterisk, Star) to tutorial heroes
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
S.heroes.forEach(hero => {
passiveSigils.forEach(passive => {
const permLevel = S.sig[passive] || 0;
if(permLevel > 0 && !hero.s.includes(passive)) {
hero.s.push(passive);
}
});
});

// Initialize Phase 2 tutorial state
tutorialState = {
stage: 'waiting_for_start',
phase: 2, // Phase 2: Portal Invasion
wolfDamaged: false,
wolfKilled: false,
goblinKilled: false,
round: 1
};

// Start combat using real combat system!
combat(0);
}


function finishRibbletonTutorial() {
// Post-combat narrative with full-art backgrounds
const slides = [
{bg: 'assets/ribbleton.png', text: "Scattered, the remaining enemies scamper back into the portal. The frog heroes unite, wipe their brows, and sheathe their weapons. <strong style='color:#22c55e'>Close call!</strong> At least Tapo is safe..."},
{bg: 'assets/ribbleton-tadpole.png', bgStyle: 'animation: spinTapo 1s linear infinite;', text: "A familiar squeal of delight pierces the air as Tapo crawls toward the portal. <strong style='color:#dc2626'>No, Tapo, don't go in there!!</strong>",
html: `<style>@keyframes spinTapo { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style><div class="narrative-text" style="font-size:1.25rem;line-height:1.7;text-align:center;color:#fff;text-shadow:1px 1px 4px rgba(0,0,0,0.9)">A familiar squeal of delight pierces the air as Tapo crawls toward the portal. <strong style='color:#dc2626'>No, Tapo, don't go in there!!</strong></div>`},
{text: "But it is too late - the portal flares with <strong style='color:#9333ea'>dark energy</strong>. The heroes have no choice but to dive in after, to save their adorable little Tapo!",
html: `<div class="narrative-text" style="font-size:1.8rem;line-height:1.9;text-align:center;color:#fff;text-shadow:2px 2px 8px rgba(0,0,0,0.9);max-width:600px">But it is too late - the portal flares with <strong style='color:#9333ea'>dark energy</strong>. The heroes have no choice but to dive in after, to save their adorable little Tapo!</div>`}
];
slides.onComplete = showTitleCard;
showNarrativeSlide(slides, 0);
}

function showTitleCard() {
const v = document.getElementById('gameView');
if(!v) {
showRibbleton();
return;
}
v.classList.add('no-scroll');
v.innerHTML = `
<div id="titleCardScreen" class="full-screen-content" style="width:100%;background:#000;display:flex;align-items:center;justify-content:center;cursor:pointer">
<div style="text-align:center;color:#fff;pointer-events:none">
<div style="font-size:3.5rem;font-weight:bold;margin-bottom:1rem">FROGGLE</div>
<div style="font-size:1.5rem;font-style:italic">A Froggy Roguelike</div>
<div style="font-size:0.9rem;margin-top:2rem;opacity:0.6">Tap to continue</div>
</div>
</div>`;

let proceeded = false;
const proceed = () => {
if(proceeded) return;
proceeded = true;
tutorialState = null;
v.classList.remove('no-scroll');
showRibbleton();
};

// Multiple ways to trigger - belt and suspenders
const screen = document.getElementById('titleCardScreen');
if(screen) {
screen.onclick = proceed;
screen.ontouchend = (e) => { e.preventDefault(); proceed(); };
}

// Auto-advance
setTimeout(proceed, 2500);
}

// ===== TITLE & HERO SELECT =====
let selectedHeroView = null; // Track which hero card is currently displayed

function title() {
debugLog('[FROGGLE] title() called - Hero selection screen');
// Show header on hero selection
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';
// JUICE: Funky frog beat for title/hero select
ProceduralMusic.startTitleBeat();
upd();
// Reset selection first
sel = [];

const v = document.getElementById('gameView');
// Hero selection is a normal scrollable screen
v.classList.remove('no-scroll');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;

v.innerHTML = `
<h1 style="text-align:center;margin:0.75rem 0;font-size:1.8rem;color:${S.gameMode === 'fu' ? '#dc2626' : '#22c55e'}">${S.gameMode === 'fu' ? 'FROGGED UP üî•' : 'FROGGLE üê∏'}</h1>

<div style="max-width:600px;margin:0 auto;padding:0 0.5rem">
<h2 style="text-align:center;margin-bottom:0.5rem;font-size:1.1rem">Choose ${requiredHeroes} Heroes</h2>
<div id="hero-select-container" style="position:relative;max-width:100%;margin:0 auto;cursor:pointer" onclick="handleHeroImageClick(event, this)">
<img src="assets/hero-select.png" alt="Hero selection" style="width:100%;height:auto;display:block;border-radius:8px;border:3px solid #000;pointer-events:none">
<!-- Controller-friendly hero selection buttons -->
<button type="button" class="hero-select-btn" data-hero="warrior" onclick="event.stopPropagation();toggleHeroSelection('warrior')" aria-label="Select Warrior"></button>
<button type="button" class="hero-select-btn" data-hero="tank" onclick="event.stopPropagation();toggleHeroSelection('tank')" aria-label="Select Tank"></button>
<button type="button" class="hero-select-btn" data-hero="mage" onclick="event.stopPropagation();toggleHeroSelection('mage')" aria-label="Select Mage"></button>
<button type="button" class="hero-select-btn" data-hero="healer" onclick="event.stopPropagation();toggleHeroSelection('healer')" aria-label="Select Healer"></button>
<!-- Hero card overlays -->
<div id="warrior-card" style="position:absolute;bottom:10%;left:1%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="tank-card" style="position:absolute;bottom:10%;left:26%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="mage-card" style="position:absolute;bottom:10%;left:51%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="healer-card" style="position:absolute;bottom:10%;left:76%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
</div>

${S.tapoUnlocked ? `
<div style="margin-top:1rem;text-align:center">
<button class="btn" onclick="toggleHeroSelection('tapo')" style="background:linear-gradient(135deg,#3b82f6 0%,#22c55e 100%);padding:0.75rem 1.5rem;font-size:1rem;font-weight:bold;border:3px solid #000">
üéâ View Tapo (UNLOCKED!) üéâ
</button>
</div>` : ''}

<!-- Selection display with X/Y counter -->
<div style="text-align:center;margin:0.5rem 0;padding:0.5rem;background:rgba(0,0,0,0.05);border-radius:6px">
<strong>Selected:</strong> <span id="selection-display" style="font-size:1rem;color:#2563eb"></span>
<span id="selection-counter" style="font-size:1.1rem;font-weight:bold;margin-left:0.5rem"></span>
</div>

<button class="btn" id="start" onclick="start()" style="width:100%;padding:0.75rem;font-size:1rem">Delve into Floor 1</button>
</div>`;

debugLog('[FROGGLE] title() innerHTML set successfully');

// Update selection display
updateSelectionDisplay();
}

function handleHeroImageClick(event, container) {
// Validate inputs
if (!event || !container) {
console.warn('Invalid event or container, ignoring click');
return;
}

// Calculate which hero was clicked based on X position
const rect = container.getBoundingClientRect();
if (!rect) {
console.warn('Could not get container bounds, ignoring click');
return;
}

const x = event.clientX - rect.left;
const percent = (x / rect.width) * 100;

// Validate coordinates - if invalid, ignore the click
if (Number.isNaN(percent) || percent < 0 || percent > 100) {
console.warn('Invalid click coordinates, ignoring');
return;
}

// Determine hero based on position (4 equal 25% sections)
let heroType;
if (percent < 25) heroType = 'warrior';
else if (percent < 50) heroType = 'tank';
else if (percent < 75) heroType = 'mage';
else heroType = 'healer';

toggleHeroSelection(heroType);
}

function updateHeroCards() {
// Hero data matches H constant in constants.js
const heroData = {
warrior: {name: 'Warrior', pow: 2, hp: 5, maxhp: 5, sigils: ['Attack', 'D20'], bonus: '+1 POW'},
tank: {name: 'Tank', pow: 1, hp: 10, maxhp: 10, sigils: ['Attack', 'Shield', 'D20'], bonus: '+5 HP'},
mage: {name: 'Mage', pow: 1, hp: 5, maxhp: 5, sigils: ['Attack', 'D20', 'Expand'], bonus: '+1 Expand'},
healer: {name: 'Healer', pow: 1, hp: 5, maxhp: 5, sigils: ['Heal', 'D20', 'Expand'], bonus: '+1 Expand'},
tapo: {name: 'Tapo', pow: 1, hp: 1, maxhp: 1, sigils: ['D20'], bonus: 'D20 + upgraded passives'}
};

// Update all card displays
['warrior', 'tank', 'mage', 'healer'].forEach(h => {
const cardEl = document.getElementById(`${h}-card`);
if(!cardEl) return;

if(sel.includes(h)) {
const hData = heroData[h];
const hPixelImage = HERO_IMAGES[h] || '';
const sigilsHTML = hData.sigils.map(s => {
const passiveClass = ['Expand', 'Asterisk', 'Star'].includes(s) ? 'passive' : '';
return `<span class="sigil l1 ${passiveClass}" style="font-size:0.7rem;padding:3px 5px;margin:1px;display:inline-block" onmouseenter="showTooltip('${s}', this, 1)" onmouseleave="hideTooltip()">${sigilIconOnly(s)}</span>`;
}).join('');
cardEl.innerHTML = `
<div style="background:white;border:3px solid #22c55e;border-radius:8px;padding:0.5rem;box-shadow:0 4px 6px rgba(0,0,0,0.3);pointer-events:auto;cursor:pointer;color:#1a1a1a"
onclick="event.stopPropagation();toggleHeroSelection('${h}')">
<div style="text-align:center">
<div style="font-size:0.8rem;font-weight:bold;margin-bottom:0.25rem;color:#1a1a1a">${hData.name}</div>
${hPixelImage ? `<img src="${hPixelImage}" alt="${hData.name}" style="width:100%;height:auto;border-radius:4px;margin-bottom:0.25rem">` : ''}
<div style="font-size:0.7rem;color:#374151">${hData.pow}üí• | ${hData.hp}‚ù§</div>
<div style="font-size:0.7rem;margin-top:0.25rem">${sigilsHTML}</div>
<div style="font-size:0.65rem;color:#16a34a;font-weight:bold;margin-top:0.25rem">${hData.bonus}</div>
<div style="font-size:0.55rem;color:#6b7280;margin-top:0.15rem">‚úì SELECTED</div>
</div>
</div>`;
cardEl.style.display = 'block';
} else {
cardEl.style.display = 'none';
}
});
}

function toggleHeroSelection(heroType) {
// Toggle selection
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
const isSelected = sel.includes(heroType);
if(isSelected) {
sel = sel.filter(h => h !== heroType);
SoundFX.play('click');
} else {
if(sel.length < requiredHeroes) {
sel.push(heroType);
SoundFX.play('hop'); // Froggy hop for hero selection
}
}

// Update card displays and selection display
updateHeroCards();
updateSelectionDisplay();
}


function updateSelectionDisplay() {
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
const display = document.getElementById('selection-display');
const counter = document.getElementById('selection-counter');
if(!display) return;

if(sel.length === 0) {
display.textContent = 'None';
display.style.color = '#6b7280';
} else {
const heroNames = sel.map(h => H[h].n);
display.textContent = heroNames.join(' + ');
display.style.color = '#2563eb';
}

// Update X/Y counter
if(counter) {
const isComplete = sel.length === requiredHeroes;
counter.textContent = `(${sel.length}/${requiredHeroes})`;
counter.style.color = isComplete ? '#22c55e' : '#f59e0b';
}

const btn = document.getElementById('start');
if(btn) {
const isDisabled = sel.length !== requiredHeroes;
btn.disabled = isDisabled;
if(isDisabled) {
btn.classList.add('disabled');
} else {
btn.classList.remove('disabled');
}
btn.style.opacity = sel.length === requiredHeroes ? '1' : '0.4';
}
}

function toggleMode() {
S.gameMode = S.gameMode === 'Standard' ? 'fu' : 'Standard';
document.body.classList.toggle('fu-mode', S.gameMode === 'fu');
savePermanent();
title();
}

function pick(t) {
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
const i = sel.indexOf(t);
if(i>=0) {
sel.splice(i,1);
} else if(sel.length<requiredHeroes) {
sel.push(t);
} else {
toast(`Maximum ${requiredHeroes} heroes!`);
return;
}

// Update selection display
updateSelectionDisplay();
}

function start() {
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
if(sel.length!==requiredHeroes) return;
// Show game header when entering gameplay
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';

S.floor=1; S.xp=0; S.levelUpCount=0;
// Reset temporary XP sigil upgrades (these don't persist between runs)
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// Reset recruits from any previous run
S.recruits = [];
// NOTE: Gold persists between runs! Only reset on victory or spent at Death Screen
S.heroes = sel.map((t,i) => ({
id:`h-${crypto.randomUUID()}`,
n:H[t].n, p:H[t].p, h:H[t].h, m:H[t].m,
s:[...H[t].s], sh:0, g:0, ls:false, lst:0, ts:[], st:0
}));

// Add permanently upgraded passives (Expand, Asterisk, Star) to all heroes
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
S.heroes.forEach(hero => {
passiveSigils.forEach(passive => {
const permLevel = S.sig[passive] || 0;
// If this passive has been upgraded with gold (L1+) and hero doesn't have it, add it
if(permLevel > 0 && !hero.s.includes(passive)) {
hero.s.push(passive);
}
});
});

// Apply pedestal buffs
// Standard mode statues apply to BOTH modes, FU statues only apply to FU mode
S.pedestal.forEach(slot => {
// Standard mode statues apply universally, FU statues only in FU mode
if(slot.mode === 'fu' && S.gameMode !== 'fu') return;
const hero = S.heroes.find(h => h.n === slot.hero);
if(!hero) return;
if(slot.stat === 'POW') {
hero.p += 1;
} else if(slot.stat === 'HP') {
hero.m += 5;
hero.h += 5;
}
});

// Chosen Hero: On run 2+, pick randomly from least-used heroes among selected
S.chosenHeroIdx = -1; // Reset (no chosen hero by default)
if(S.runNumber >= 2 && S.pondHistory && S.pondHistory.length > 0) {
// Count usage of each hero from pond history
const usageCounts = {};
S.pondHistory.forEach(run => {
(run.heroes || []).forEach(heroName => {
usageCounts[heroName] = (usageCounts[heroName] || 0) + 1;
});
});
// Find usage counts for heroes in current party
const heroUsages = S.heroes.map((h, idx) => ({
idx,
name: h.n,
usage: usageCounts[h.n] || 0
}));
// Find the minimum usage count
const minUsage = Math.min(...heroUsages.map(h => h.usage));
// Get all heroes with minimum usage
const leastUsed = heroUsages.filter(h => h.usage === minUsage);
// Randomly pick one from least-used
const chosen = leastUsed[Math.floor(Math.random() * leastUsed.length)];
S.chosenHeroIdx = chosen.idx;
}

initNeutralDeck();
upd();

// QUEST TRACKING: Track heroes played this run
S.heroes.forEach(hero => {
  trackQuestProgress('heroPlayed', hero.n);
});

// Show chosen hero tutorial on first occurrence (run 2)
if(S.chosenHeroIdx >= 0 && !S.tutorialFlags.chosen_hero_intro) {
const chosenHero = S.heroes[S.chosenHeroIdx];
showTutorialPop('chosen_hero_intro', `Somehow, somewhere, Tapo smiles upon <strong>${chosenHero.n}</strong>. They'll gain an extra 1G for each floor cleared this run!`, () => {
if(S.startingXP > 0) {
S.xp = S.startingXP;
showStartingXPScreen();
} else {
startFloor(1);
}
});
return;
}

// Check if player has starting XP from Death Boy sacrifices
if(S.startingXP > 0) {
S.xp = S.startingXP;
showStartingXPScreen();
} else {
startFloor(1);
}
}


// ===== NEUTRAL ENCOUNTERS =====
// Neutral encounter display names for floor interstitials
const NEUTRAL_NAMES = {
shopkeeper1: 'Potions for Sale',
shopkeeper2: "Death's Bargain",
wishingwell1: 'The Old Wishing Well',
wishingwell2: 'Crystal Waters',
treasurechest1: 'A Mysterious Chest',
treasurechest2: 'The Silver Key',
wizard1: 'Trials of Arcane Power',
wizard2: 'The Hieroglyphs',
oracle1: 'Consult the Oracle',
oracle2: "The Oracle's Promise",
encampment1: 'Enemy Encampment',
encampment2: 'Abandoned Encampment',
gambling1: 'Between the 20s',
gambling2: 'Between the 20s Extreme',
ghost1: 'The Haunted Playroom',
ghost2: 'Passing On',
royal1: 'The Flummoxed Royal',
royal2: 'Royal Wedding'
};

function showNeutralInterstitial(f, encName, callback) {
const displayName = NEUTRAL_NAMES[encName] || encName;
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="position:fixed;top:0;left:0;width:100%;height:100vh;background:#000;display:flex;align-items:center;justify-content:center;z-index:30000">
<div style="text-align:center;color:#fff;animation:fadeIn 0.5s ease">
<div style="font-size:2.5rem;font-weight:bold;margin-bottom:1rem;font-family:'Fredoka One',cursive">Floor ${f}</div>
<div style="font-size:1.8rem;font-style:italic;font-family:'Fredoka One',cursive">${displayName}</div>
</div>
</div>
<style>
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
</style>`;
setTimeout(callback, T(ANIMATION_TIMINGS.FLOOR_INTERSTITIAL));
}

function neutral(f) {
// Show header during neutral encounters
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';
// JUICE: Ambient music for neutral/exploration
ProceduralMusic.startAmbient();
upd();
// TUTORIAL: Show neutral intro on Floor 2
if(f === 2) {
showTutorialPop('neutral_intro', "Neutral floors offer choices and opportunities! You can walk straight through, or take a risk for potential rewards.");
}

const enc = getNeutralEncounter();

if(S.ghostBoysConverted && enc.startsWith('ghost')) {
showEmptyPlayroom();
return;
}

// Show interstitial then launch encounter
const launchEncounter = () => {
if(enc === 'shopkeeper1') showShopkeeper1();
else if(enc === 'shopkeeper2') showShopkeeper2();
else if(enc === 'wishingwell1') showWishingWell1();
else if(enc === 'wishingwell2') showWishingWell2();
else if(enc === 'treasurechest1') showTreasureChest1();
else if(enc === 'treasurechest2') showTreasureChest2();
else if(enc === 'wizard1') showWizard1();
else if(enc === 'wizard2') showWizard2();
else if(enc === 'oracle1') showOracle1();
else if(enc === 'oracle2') showOracle2();
else if(enc === 'encampment1') showEncampment1();
else if(enc === 'encampment2') showEncampment2();
else if(enc === 'gambling1') showGambling1();
else if(enc === 'gambling2') showGambling2();
else if(enc === 'ghost1') showGhost1();
else if(enc === 'ghost2') showGhost2();
else if(enc === 'royal1') showRoyal1();
else if(enc === 'royal2') showRoyal2();
else {
const v = document.getElementById('gameView');
v.innerHTML = `
<h2 style="text-align:center;margin:2rem 0">Floor ${f}</h2>
<p style="text-align:center;margin-bottom:2rem">${enc}</p>
<button class="btn" onclick="nextFloor()">Continue</button>`;
}
};

showNeutralInterstitial(f, enc, launchEncounter);
}

// ===== 1. SHOPKEEPER =====
let shopSmallBought = false;
let shopLargeBought = false;

function showShopkeeper1() {
// Reset shopkeeper state at start of each encounter
shopSmallBought = false;
shopLargeBought = false;
renderShopkeeper();
}

function renderShopkeeper() {
// Build buttons based on what's already been bought (limit 1 of each per visit)
let buttons = '';
if(!shopSmallBought) {
buttons += `<button class="neutral-btn safe" onclick="buySmallPotion()">Small Potion (3G) - Restore 3 HP</button>`;
} else {
buttons += `<button class="neutral-btn" disabled>Small Potion - SOLD</button>`;
}
if(!shopLargeBought) {
buttons += `<button class="neutral-btn safe" onclick="buyLargePotion()">Large Potion (5G) - Restore 8 HP</button>`;
} else {
buttons += `<button class="neutral-btn" disabled>Large Potion - SOLD</button>`;
}
buttons += `<button class="neutral-btn secondary" onclick="declineShopkeeper()">Leave Shop</button>`;

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Potions for Sale',
description: 'A cheerful gnome stands behind a small cart laden with vials and bottles. Their voice is excited and earnest: "Healing Potions for sale!"',
buttons: buttons
});
}

function buySmallPotion() {
if(S.gold < 3) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn" onclick="applySmallPotion(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Choose Hero',
description: 'Select a hero to restore 3 HP.',
buttons: heroButtons + `<button class="neutral-btn secondary" onclick="renderShopkeeper()">Back</button>`
});
}

function applySmallPotion(idx) {
S.gold -= 3;
const h = S.heroes[idx];
h.h = Math.min(h.h + 3, h.m);
upd();
toast(`${h.n} restored 3 HP!`);
shopSmallBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 1800);
}
renderShopkeeper();
}

function buyLargePotion() {
if(S.gold < 5) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn" onclick="applyLargePotion(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Choose Hero',
description: 'Select a hero to restore 8 HP.',
buttons: heroButtons + `<button class="neutral-btn secondary" onclick="renderShopkeeper()">Back</button>`
});
}

function applyLargePotion(idx) {
S.gold -= 5;
const h = S.heroes[idx];
h.h = Math.min(h.h + 8, h.m);
upd();
toast(`${h.n} restored 8 HP!`);
shopLargeBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 1800);
}
renderShopkeeper();
}

function declineShopkeeper() {
shopSmallBought = false;
shopLargeBought = false;
nextFloor();
}

function showShopkeeper2() {
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const available = allSigils.filter(s => (S.sig[s] || 0) < 4);
const cost = S.goingRate;
let description = `The cheerful gnome shopkeeper has been replaced by an ominous figure: your old friend, Death. "I sent the kid home. Thanks for supporting my side hustle. I can keep this one off the books."<br><br><p style="text-align:center;font-weight:bold;margin:1rem 0">Cost: ${cost} Gold</p>`;
let buttons = '';
let outcomes = [];

if(available.length === 0) {
outcomes.push('All your sigils are already at maximum power. Death nods approvingly and fades away.');
buttons = `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else if(S.gold < cost) {
outcomes.push('<span style="color:#dc2626">"Darn. Not enough gold. Maybe next time, I guess?"</span>');
buttons = `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else {
description += `<div style="font-size:0.9rem;margin-bottom:1rem">Choose one sigil to upgrade permanently (costs ${cost}G, Going Rate does NOT increase):</div>`;
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
available.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives.includes(sig);
// Actives display +1 (storage L0 = display L1)
const displayLevel = isActive ? permLevel + 1 : permLevel;
const nextDisplayLevel = displayLevel + 1;
buttons += `<div class="choice" onclick="acceptDeathsBargain('${sig}', ${cost})">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">L${displayLevel} ‚Üí L${nextDisplayLevel}</span>
</div>`;
});
buttons += `<button class="btn risky" onclick="finishDeathsBargain()">Decline</button>`;
}

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper2.png',
title: 'Death\'s Bargain',
description,
outcomes,
buttons
});
}

function acceptDeathsBargain(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }
S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
// NOTE: Going Rate does NOT increase for Death's Bargain!
upd();
savePermanent();
toast(`${sig} permanently upgraded to L${S.sig[sig]}! (GR unchanged)`, 3000);
removeNeutralFromDeck('shopkeeper');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Good choice. See you soon."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}, 1000);
}

function finishDeathsBargain() {
removeNeutralFromDeck('shopkeeper');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Shame. You don't get a chance like this every day. Oh well, it's your funeral."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 2. WISHING WELL =====
function showWishingWell1() {
const v = document.getElementById('gameView');
const buttons = `
<button class="btn risky" onclick="climbWell()">Climb down and get coins</button>
<button class="btn" onclick="tossWish()">Toss in a coin and make a wish</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'The Old Wishing Well',
description: 'An ancient stone well sits in the center of the chamber. You hear the faint sound of trickling water far below. A glint of gold catches your eye at the bottom.',
buttons
});
}

function climbWell() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
let goldGain = 0;
let hpLoss = 0;

if(best === 1) {
outcome = 'You lose your grip on the slick stone and plummet, smacking your head HARD! The landing is brutal, and by the time you scramble out, you realize that some coins must have gotten knocked out of your pouch.';
hpLoss = 3;
goldGain = -5;
} else if(best >= 2 && best <= 10) {
outcome = 'You climb carefully and manage to grab a single coin, but get a booboo climbing out of the well.';
hpLoss = 1;
goldGain = 1;
} else if(best >= 11 && best <= 19) {
outcome = 'Your climbing skills are impressive! You retrieve a small cache of coins from the bottom. (+3 Gold)';
goldGain = 3;
} else if(best === 20) {
outcome = 'Hardcore Parkour! You effortlessly dip into the well, snatch the cache of coins, and leap out. As you leave the room, the well somehow seems to begin to fill... (+10 Gold)';
goldGain = 10;
replaceStage1WithStage2('wishingwell');
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'Climbing the Well',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="applyWellClimb(${hpLoss}, ${goldGain})">Continue</button>`
});
}

function applyWellClimb(hpLoss, goldGain) {
if(hpLoss > 0) {
// Show hero selection screen
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="applyWellDamage(${idx}, ${hpLoss}, ${goldGain})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'Choose Who Takes Damage',
description: `Choose which hero takes ${hpLoss} damage from climbing the well:`,
buttons: heroButtons
});
} else {
// No damage, just apply gold
S.gold += goldGain;
if(S.gold < 0) S.gold = 0;
upd();
if(goldGain > 0) toast(`Gained ${goldGain} Gold!`);
else if(goldGain < 0) toast(`Lost ${Math.abs(goldGain)} Gold!`);
nextFloor();
}
}

function applyWellDamage(heroIdx, hpLoss, goldGain) {
const hero = S.heroes[heroIdx];
hero.h -= hpLoss;
if(hero.h <= 0 && !hero.ls) {
if(hero.g > 0) {
hero.g--;
hero.h += hpLoss;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
hero.h = 0;
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`, 3000);
}
}
toast(`${hero.n} took ${hpLoss} damage!`);

S.gold += goldGain;
if(S.gold < 0) S.gold = 0;
upd();
if(goldGain > 0) toast(`Gained ${goldGain} Gold!`);
else if(goldGain < 0) toast(`Lost ${Math.abs(goldGain)} Gold!`);
nextFloor();
}

function tossWish() {
const cost = S.heroes.length;
if(S.gold < cost) {
toast(`Need ${cost} Gold to make a wish!`);
return;
}
S.gold -= cost;
upd();
replaceStage1WithStage2('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'A Wish Made',
outcomes: [`You toss ${cost} gold coin${cost>1?'s':''} into the well and make a silent wish. The water begins to glow softly, then surges upward, overflowing the well's edge!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showWishingWell2() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell2.png',
title: 'Overflowing Crystal Waters',
description: 'The well now overflows with sparkling, crystal-clear water that pools around its base. The water pulses with pure, restorative energy.',
buttons: `<button class="btn safe" onclick="drinkCrystalWater()">Drink from the well</button>`
});
}

function drinkCrystalWater() {
S.heroes.forEach(h => {
if(h.ls) {
h.ls = false;
h.lst = 0;
h.h = h.m;
toast(`${h.n} revived to full HP!`);
} else {
h.h = h.m;
}
});
toast('All heroes fully healed!', 1800);
removeNeutralFromDeck('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell2.png',
title: 'Fully Restored',
outcomes: [
'The crisp water tastes impossibly pure and refreshing. A pleasant coolness spreads through your body as your wounds close and your exhaustion fades. You feel completely restored.',
'The well\'s glow fades as the water recedes to its normal level. Its magic has been spent, for now.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 3. TREASURE CHEST =====
function showTreasureChest1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'A Mysterious Chest',
description: 'An unadorned wooden chest sits against the far wall, worn brass fittings gleaming in the torchlight. No lock is visible, but there are drops of blood around the chest.',
buttons: `
<button class="btn risky" onclick="openChest()">Open the chest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`
});
}

function openChest() {
const {rolls: trapRolls, best: trapBest} = rollD20Neutral();
const trapText = showD20Result(trapRolls, trapBest);

let trapOutcome = '';
let trapDmg = 0;
let secretFound = false;

if(trapBest === 1) {
trapOutcome = 'It\'s a trap! Thick, noxious smoke fills the chamber.';
trapDmg = 3;
} else if(trapBest >= 2 && trapBest <= 9) {
trapOutcome = 'It\'s a trap! A hidden dart flies from the wall and strikes you in the neck! Ouch.';
trapDmg = 1;
} else if(trapBest >= 10 && trapBest <= 18) {
trapOutcome = 'You carefully open the chest without triggering any traps.';
} else {
trapOutcome = 'You open the chest without issue. Your keen eyes spot a hidden compartment in the chest\'s lid!';
secretFound = true;
}

// Show trap result with Continue button
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Opening the Chest',
diceRoll: trapText,
outcomes: [trapOutcome],
buttons: `<button class="btn" onclick="openChestPart2(${trapDmg}, ${secretFound})">Continue</button>`
});
}

function openChestPart2(trapDmg, secretFound) {
setTimeout(() => {
const {rolls: contentRolls, best: contentBest} = rollD20Neutral();
const contentText = showD20Result(contentRolls, contentBest);

let contentOutcome = '';
let goldGain = 0;

if(contentBest >= 1 && contentBest <= 9) {
contentOutcome = 'The chest is empty. Someone got here first.';
} else if(contentBest >= 10 && contentBest <= 19) {
goldGain = Math.ceil(Math.random() * 10);
contentOutcome = `The chest contains a small stack of ${goldGain} gold coins!`;
} else {
goldGain = Math.ceil(Math.random() * 10) * S.heroes.length;
contentOutcome = `The chest is filled to the brim with ${goldGain} gold coins!`;
}

if(secretFound && contentBest >= 10) {
S.silverKeyHeld = true;
replaceStage1WithStage2('treasurechest');
contentOutcome += ' Inside the secret compartment, you find a small silver key!';
}

const v = document.getElementById('gameView');
if(trapDmg > 0) {
// Show hero selection for trap damage
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="finishChestOpen(${idx}, ${trapDmg}, ${goldGain})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Chest Contents',
description: `Choose which hero takes ${trapDmg} damage:`,
diceRoll: contentText,
outcomes: [contentOutcome],
buttons: heroButtons
});
} else {
// No trap damage, just show results and continue
S.gold += goldGain;
upd();
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Chest Contents',
diceRoll: contentText,
outcomes: [contentOutcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}, 0);
}

function finishChestOpen(heroIdx, trapDmg, goldGain) {
const hero = S.heroes[heroIdx];
hero.h -= trapDmg;
if(hero.h <= 0 && !hero.ls) {
if(hero.g > 0) {
hero.g--;
hero.h += trapDmg;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
hero.h = 0;
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`, 3000);
}
}
toast(`${hero.n} took ${trapDmg} damage!`);

S.gold += goldGain;
upd();
nextFloor();
}

function showTreasureChest2() {
if(!S.silverKeyHeld) {
nextFloor();
return;
}
const goldGain = 10 * S.heroes.length;
S.gold += goldGain;
S.silverKeyHeld = false;
upd();
removeNeutralFromDeck('treasurechest');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest2.png',
title: 'Small Silver Chest',
description: 'A small, beautifully-adorned silver chest sits on a stone pedestal. The silver keyhole is perfectly sized for the key you found earlier.',
outcomes: [`What a windfall! Gold coins overflow from the open chest. You gather and pocket ${goldGain} before moving on.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 4. MUMBLING WIZARD =====
function showWizard1() {
const v = document.getElementById('gameView');
let description = 'An elderly wizard stands with arms outstretched toward a wall covered in glowing hieroglyphs. He mutters to himself, but stops when you walk in. "Do you see it? CAN you see it? Look closely!" He pulls you toward the wall.<br><br>Choose which hero will approach the wizard:';
let buttons = '';
S.heroes.forEach((h, idx) => {
const heroSigils = [...h.s];
if(h.ts) heroSigils.push(...h.ts);
const sigilList = heroSigils.map(s => sigilIconOnly(s)).join(' ');
buttons += `<button class="neutral-btn safe" onclick="heroApproachesWizard(${idx})">${h.n} <span style="font-size:0.8rem;opacity:0.8">${sigilList}</span></button>`;
});
buttons += `<button class="btn secondary" onclick="nextFloor()">Do Not Engage</button>`;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'Hieroglyphs on the Wall',
description,
buttons
});
}

function heroApproachesWizard(heroIdx) {
const h = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= 1 && best <= 10) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText,
outcomes: [`${h.n} stares at the glowing symbols but can't make sense of them. The wizard sighs heavily: "You... you don't see it? Hmmm." The wizard turns back to the wall and continues mumbling to himself. He seems to have forgotten about you.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Non-starter sigil pool
const nonStarterPool = ['Alpha', 'Asterisk', 'Star', 'Grapple', 'Ghost'];

// Get sigils hero has from non-starter pool
const heroNonStarters = nonStarterPool.filter(sig => h.s.includes(sig) || (h.ts && h.ts.includes(sig)));

let chosenSigil;
if(heroNonStarters.length > 0) {
// Prioritize passives (Star, Asterisk, Ghost) if hero has any
const heroPassives = heroNonStarters.filter(sig => ['Star', 'Asterisk', 'Ghost'].includes(sig));
if(heroPassives.length > 0) {
// On natural 20, prioritize lower level sigils
if(best === 20) {
heroPassives.sort((a, b) => getLevel(a, heroIdx) - getLevel(b, heroIdx));
chosenSigil = heroPassives[0];
} else {
chosenSigil = heroPassives[Math.floor(Math.random() * heroPassives.length)];
}
} else {
// No passives, pick from actives hero has
if(best === 20) {
heroNonStarters.sort((a, b) => getLevel(a, heroIdx) - getLevel(b, heroIdx));
chosenSigil = heroNonStarters[0];
} else {
chosenSigil = heroNonStarters[Math.floor(Math.random() * heroNonStarters.length)];
}
}
} else {
// Hero has no non-starters, pick random from pool
chosenSigil = nonStarterPool[Math.floor(Math.random() * nonStarterPool.length)];
}

const currentLevel = getLevel(chosenSigil, heroIdx);
const bonusLevels = best === 20 ? 2 : 1;

// Check if hero has the sigil
const heroHasSigil = h.s.includes(chosenSigil) || (h.ts && h.ts.includes(chosenSigil));

if(!heroHasSigil) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText,
outcomes: [
`The hieroglyphs shift around, finally revealing the symbol for ${chosenSigil}! The wizard beams with pride.`,
`But ${h.n} doesn't possess this sigil. The wizard's face falls: "Ah, shame. Not the outcome I expected. Return when you have become more powerful."`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Hero has it! Grant temp upgrade
if(!h.ts) h.ts = [];
if(!h.ts.includes(chosenSigil)) h.ts.push(chosenSigil);

// Use tempSigUpgrades for temporary upgrades (not S.sig which is permanent!)
const oldTotalLevel = (S.sig[chosenSigil] || 0) + (S.tempSigUpgrades[chosenSigil] || 0);
S.tempSigUpgrades[chosenSigil] = (S.tempSigUpgrades[chosenSigil] || 0) + bonusLevels;
const newTotalLevel = oldTotalLevel + bonusLevels;

S.wizardHero = heroIdx;
S.wizardSigil = chosenSigil;

const critText = best === 20 ? ` <span style="color:#3b82f6;font-weight:bold">(CRITICAL!)</span>` : '';
toast(`${chosenSigil} temporarily upgraded to L${newTotalLevel} for ${h.n}!`, 1800);

replaceStage1WithStage2('wizard');
setTimeout(() => {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText + critText,
outcomes: [
`The hieroglyph reveals itself as the symbol for ${chosenSigil}! "Yes! YES! You see! You understand!" The wizard touches the sigil, then reaches towards ${h.n}.`,
`${h.n} feels power surge through them. ${chosenSigil} temporarily upgraded from L${currentLevel} to L${currentLevel + bonusLevels}!`,
'"Your journey has just begun... Seek me again this night." He disappears.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}, 500);
}

function showWizard2() {
if(S.wizardHero === undefined || !S.wizardSigil) {
nextFloor();
return;
}

// Initialize wizard challenge state
if(!S.wizardChallenges) {
S.wizardChallenges = [5, 10, 15, 20];
S.wizardChallengeIndex = 0;
S.wizardUpgradedSigils = [];
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: 'Trials of Arcane Power',
description: 'The wizard\'s eyes gleam with arcane power: "You have returned! Just as I knew you would. You are ready now to face my trials. Each success earns you greater strength!"<br><br><div style="font-size:0.85rem;margin-top:1rem;color:#4a4540">Four trials: DC 5, DC 10, DC 15, DC 20<br>Each success: Choose a sigil to upgrade temporarily<br>On failure: Keep all upgrades earned so far</div>',
buttons: `<button class="btn risky" onclick="startWizardChallenges()">Accept the Trials</button>
<button class="btn secondary" onclick="declineWizardChallenges()">Decline</button>`
});
}

function startWizardChallenges() {
attemptWizardChallenge();
}

function attemptWizardChallenge() {
const heroIdx = S.wizardHero;
const h = S.heroes[heroIdx];
const challengeIndex = S.wizardChallengeIndex;
const dc = S.wizardChallenges[challengeIndex];

const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best < dc) {
// Failed! Keep what you got
const upgradeCount = S.wizardUpgradedSigils.length;
let outcomeText = upgradeCount > 0
? `${h.n} earned ${upgradeCount} temporary upgrade${upgradeCount > 1 ? 's' : ''} before failing!`
: `${h.n} failed the first trial. No upgrades earned.`;

removeNeutralFromDeck('wizard');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: `Trial ${challengeIndex + 1} - DC ${dc}`,
diceRoll: rollText + ` - <span style="color:#dc2626">FAILED</span>`,
outcomes: [
`${h.n} could not quite meet the challenge.`,
outcomeText,
'"A good effort, but you have reached your limit. Take what you have earned and go."'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Success! Choose a sigil to upgrade
const heroSigils = [...h.s];
if(h.ts) heroSigils.push(...h.ts);
const availableSigils = heroSigils.filter(sig => !S.wizardUpgradedSigils.includes(sig));

if(availableSigils.length === 0) {
// No more sigils to upgrade
removeNeutralFromDeck('wizard');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: `Trial ${challengeIndex + 1} - DC ${dc}`,
diceRoll: rollText + ` - <span style="color:#22c55e">SUCCESS</span>`,
outcomes: [
`${h.n} passed the trial!`,
`But ${h.n} has no more sigils available to upgrade!`,
`Total upgrades earned: ${S.wizardUpgradedSigils.length}`,
'"You have taken all I can offer. Go now."'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Show sigil selection
let description = `${h.n} passed the trial! Choose a sigil to upgrade temporarily (cannot pick the same sigil twice):`;
let buttons = '';
availableSigils.forEach(sig => {
const currentLevel = getLevel(sig, heroIdx);
const nextLevel = currentLevel + 1;
buttons += `<button class="neutral-btn safe" onclick="selectWizardUpgrade('${sig}')">${sigilIconWithTooltip(sig, nextLevel)} ${sig} - L${currentLevel} ‚Üí L${nextLevel}</button>`;
});

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: `Trial ${challengeIndex + 1} - DC ${dc}`,
diceRoll: rollText + ` - <span style="color:#22c55e">SUCCESS</span>`,
description,
buttons
});
}

function selectWizardUpgrade(sig) {
const heroIdx = S.wizardHero;
const h = S.heroes[heroIdx];

// Apply temp upgrade (use tempSigUpgrades, not S.sig which is permanent!)
if(!h.ts) h.ts = [];
if(!h.ts.includes(sig)) h.ts.push(sig);

const oldTotalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
S.tempSigUpgrades[sig] = (S.tempSigUpgrades[sig] || 0) + 1;
const newTotalLevel = oldTotalLevel + 1;

S.wizardUpgradedSigils.push(sig);
toast(`${sig} temporarily upgraded to L${newTotalLevel} for ${h.n}!`, 1800);

S.wizardChallengeIndex++;

// Check if more challenges remain
if(S.wizardChallengeIndex >= S.wizardChallenges.length) {
// All trials complete!
removeNeutralFromDeck('wizard');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
outcomes: [
`${h.n} has completed all trials!`,
`Total upgrades: ${S.wizardUpgradedSigils.length}`,
'"Merlin\'s Toad! You have proven yourself worthy. Now go forth with your newfound power, my disciple!"'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}, ANIMATION_TIMINGS.ACTION_COMPLETE);
} else {
// Continue to next challenge
setTimeout(() => attemptWizardChallenge(), ANIMATION_TIMINGS.TUTORIAL_DELAY);
}
}

function declineWizardChallenges() {
removeNeutralFromDeck('wizard');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
outcomes: ['The wizard\'s glow fades. "You would refuse my arcane boons? Very well." He grabs his books and disappears.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 5. ORACLE =====
function showOracle1() {
// Mark tutorial as seen so future runs have random neutrals
S.tutorialFlags.neutral_intro = true;
const v = document.getElementById('gameView');
let description = 'A figure shrouded in mist sits cross-legged before a glowing crystal sphere. Their voice echoes: "Step forward, adventurer, and I shall ponder your future within this here orb. Crave you Power or Life?" Choose a hero and their desired fortune:';
let buttons = '';
S.heroes.forEach((h, idx) => {
buttons += `<button class="neutral-btn risky" onclick="oracleChoose(${idx}, 'POW')">${h.n} - Power (${h.p}üí• ‚Üí ${h.p+1}üí•)</button>`;
buttons += `<button class="neutral-btn safe" onclick="oracleChoose(${idx}, 'HP')">${h.n} - Life (${h.m}‚ù§ max ‚Üí ${h.m+5}‚ù§ max)</button>`;
});
buttons += `<button class="neutral-btn secondary" onclick="nextFloor()">Do Not Engage</button>`;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle1.png',
title: 'Consult the Oracle',
description,
buttons
});
}

function oracleChoose(heroIdx, stat) {
S.oracleHero = heroIdx;
S.oracleStat = stat;

const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);
S.oracleRoll = best;

const h = S.heroes[heroIdx];
let fortune = '';
let stage2Effect = '';

if(best === 1) {
fortune = '"No...This cannot be! You are cursed! CURSED! Begone from me at once, and cross not my path again!"';
stage2Effect = 'CURSE';
replaceStage1WithStage2('oracle');
} else if(best >= 2 && best <= 9) {
fortune = '"Alas... The orb is cruel. Your desires shall not come to pass this night."';
stage2Effect = 'NO UNLOCK';
} else if(best >= 10 && best <= 15) {
fortune = 'The Oracle gives a knowing smile. "Great things in your future, but perhaps not what you want."';
stage2Effect = 'OPPOSITE';
replaceStage1WithStage2('oracle');
} else if(best >= 16 && best <= 19) {
fortune = 'The Oracle gives a kind wink. "Your desired future just may come to pass, if you are patient."';
stage2Effect = 'DESIRED';
replaceStage1WithStage2('oracle');
} else {
// Nat 20 - IMMEDIATE effect! Grant reward now, no stage 2 needed
if(stat === 'HP') {
h.m += 10;
h.h += 10;
} else {
h.p += 2;
}
fortune = `"Incredible.. Could it be... Now? Before my very eyes?!" A strange light emanates from the orb, infusing the room. ${h.n} feels ${stat === 'POW' ? 'stronger' : 'healthier'} already! ${stat === 'POW' ? 'POW +2!' : 'Maximum HP +10!'}`;
stage2Effect = 'IMMEDIATE DOUBLE';
removeNeutralFromDeck('oracle'); // Remove oracle entirely - effect already granted
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle1.png',
title: 'The Oracle\'s Fortune',
diceRoll: rollText,
outcomes: [
`${h.n} steps forward seeking ${stat === 'POW' ? 'Power' : 'Life'}.`,
`The Oracle gazes into the crystal sphere, then speaks: ${fortune}`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showOracle2() {
if(S.oracleHero === null || S.oracleRoll === null) {
nextFloor();
return;
}

const heroIdx = S.oracleHero;
const stat = S.oracleStat;
const roll = S.oracleRoll;
const h = S.heroes[heroIdx];

let outcome = '';

if(roll === 1) {
// CURSE
if(stat === 'HP') {
h.m = Math.max(1, h.m - 5);
if(h.h > h.m) h.h = h.m;
outcome = `"Cursed! Cursed!" Dark light surges from the orb, and ${h.n} feels weaker. Maximum HP reduced by 5!`;
} else {
h.p = Math.max(0, h.p - 1);
outcome = `"Cursed! Cursed!" Dark light surges from the orb, and ${h.n} feels their strength fade. POW reduced by 1!`;
}
} else if(roll >= 10 && roll <= 15) {
// OPPOSITE
if(stat === 'HP') {
h.p++;
outcome = `"Alas, we cannot always choose our destiny", the Oracle intones. The light coalesces around ${h.n}. ${h.n} gains unexpected Power! POW +1!`;
} else {
h.m += 5;
h.h += 5;
outcome = `"Alas, we cannot always choose our destiny", the Oracle intones. The light coalesces around ${h.n}. ${h.n} gains unexpected Life! Maximum HP +5!`;
}
} else if(roll >= 16 && roll <= 19) {
// DESIRED
if(stat === 'HP') {
h.m += 5;
h.h += 5;
outcome = `"I knew you were destined to grow healthier." The light coalesces around ${h.n}. ${h.n}'s Maximum HP +5! "Alas, the orb grows cloudy. What does the future hold for you, I wonder..."`;
} else {
h.p++;
outcome = `"I knew you were destined to grow stronger." The light coalesces around ${h.n}. ${h.n}'s POW +1! "Alas, the orb grows cloudy. What does the future hold for you, I wonder..."`;
}
} else if(roll === 20) {
// IMMEDIATE DOUBLE
if(stat === 'HP') {
h.m += 10;
h.h += 10;
outcome = `Your blessings overflow! The Oracle's orb sends glittering light dancing around the room as ${h.n} surges with life force! Maximum HP +10!`;
} else {
h.p += 2;
outcome = `Your blessings overflow! The Oracle's orb sends glittering light dancing around the room as ${h.n} surges with power! POW +2!`;
}
} else {
// Rolls 2-9 shouldn't reach Stage 2, but handle defensively
outcome = 'The Oracle\'s fortune was unclear. The crystal sphere dims.';
}

removeNeutralFromDeck('oracle');

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle2.png',
title: 'The Oracle\'s Promise',
outcomes: [
`The Oracle has been expecting ${h.n}. Strange chanting fills the room. As you enter her chamber, the crystal sphere flares brightly!`,
outcome
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 6. ENEMY ENCAMPMENT =====
function showEncampment1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Enemy Encampment',
description: 'From the last chamber\'s exit, you spy some enemies in their encampment, preparing for their next battle. They haven\'t noticed you yet. You might be able to sneak by, or this could be a good chance to get the jump on them.',
buttons: `
<button class="btn risky" onclick="chooseEncampmentAction('sneak')">Sneak by?</button>
<button class="btn risky" onclick="chooseEncampmentAction('engage')">Engage early</button>
`
});
}

function chooseEncampmentAction(action) {
const v = document.getElementById('gameView');
let buttons = '';
S.heroes.forEach((h, i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
buttons += `<button class="neutral-btn ${action === 'sneak' ? '' : 'risky'}" onclick="${action === 'sneak' ? 'sneakByEncampment' : 'engageEarlyEncampment'}(${i})">${h.n} - ${h.p}üí• | ${hp}</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: action === 'sneak' ? 'Choose Scout' : 'Choose Leader',
description: `Which hero will ${action === 'sneak' ? 'sneak past the encampment' : 'lead the charge'}?`,
buttons
});
}

function sneakByEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
if(best >= 1 && best <= 10) {
outcome = `Well, that's why the enemies set up a trip wire. It worked. It's an ambush!`;
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 1800);

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Sneaking Past',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else if(best >= 11 && best <= 19) {
outcome = `You slip past quietly. The enemies remain unaware.`;

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Sneaking Past',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else {
// Roll 20 - recruit a straggler! Ask which hero should recruit them
const comp = getEnemyComp(S.floor + 1);
const stragglerType = comp[Math.floor(Math.random() * comp.length)];
const base = E[stragglerType];

// Store straggler data for selection
window.pendingStragglerData = { base, stragglerType };

outcome = `As you sneak by, you spy an enemy straggler who appears to be hiding from the group... It looks like they want to join your party!`;

// Show hero selection for who should recruit
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
heroButtons += `<button class="neutral-btn safe" onclick="assignRecruitToHero(${i})">${h.n} - ${h.p}üí• | ${hp}</button>`;
});

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Sneaking Past - NAT 20!',
diceRoll: rollText,
description: `${outcome}<br><br><strong>Who should recruit the ${base.n}?</strong>`,
buttons: heroButtons
});
}
}

function assignRecruitToHero(heroIdx) {
const { base, stragglerType } = window.pendingStragglerData;
const hero = S.heroes[heroIdx];
const fuMultiplier = S.gameMode === 'fu' ? 3 : 1;
const straggler = {
id: `recruit-${crypto.randomUUID()}`,
n: base.n,
p: base.p * fuMultiplier,
h: base.h * fuMultiplier,
m: base.m * fuMultiplier,
g: base.g,
x: base.x,
s: [],
pool: base.pool,
maxLevel: base.maxLevel || 1,
sigilLevels: base.sigilLevels || {},
gainRate: base.gainRate || 3,
turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st: 0,
li: heroIdx,
sh: 0,
alphaActed: false,
recruitedBy: heroIdx,
isRecruit: true
};
// Add permanent sigils
if(base.permSigils) base.permSigils.forEach(ps => straggler.s.push({sig:ps.s, level:ps.l, perm:true}));
// Add start sigils
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
base.startSigils.forEach(ss => straggler.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(straggler, base);
}
}
}
// Handle startRandom: draw additional random L1 sigils
if(base.startRandom) {
for(let j = 0; j < base.startRandom; j++) {
drawEnemyStartSigil(straggler, base, true);
}
}
if(!S.recruits) S.recruits = [];

// Check if hero already has a recruit
const existingRecruit = S.recruits.find(r => r.recruitedBy === heroIdx);
if(existingRecruit) {
// Store both for replacement choice
S.pendingNewRecruit = straggler;
S.pendingOldRecruitId = existingRecruit.id;
const v = document.getElementById('gameView');
const oldName = existingRecruit.n;
const newName = straggler.n;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Replace Recruit?',
outcomes: [`${hero.n} already has ${oldName}... Replace them with the new ${newName}?`],
buttons: `<button class="btn" onclick="keepCurrentRecruit()">Keep ${oldName}</button><button class="btn safe" style="margin-left:0.5rem" onclick="replaceWithNewRecruit()">Replace with ${newName}</button>`
});
} else {
S.recruits.push(straggler);
const outcome = `The Recruited ${base.n} looks glad to join ${hero.n}'s side and will fight loyally!`;
toast(`${base.n} recruited! Will fight in ${hero.n}'s lane!`, 1800);
window.pendingStragglerData = null;

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Recruit Joined!',
outcomes: [outcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function keepCurrentRecruit() {
S.pendingNewRecruit = null;
S.pendingOldRecruitId = null;
window.pendingStragglerData = null;
toast('Kept current recruit.', 1200);
nextFloor();
}

function replaceWithNewRecruit() {
if(!S.pendingNewRecruit || !S.pendingOldRecruitId) { nextFloor(); return; }
const oldRecruit = S.recruits.find(r => r.id === S.pendingOldRecruitId);
S.recruits = S.recruits.filter(r => r.id !== S.pendingOldRecruitId);
S.recruits.push(S.pendingNewRecruit);
toast(`${S.pendingNewRecruit.n} replaces ${oldRecruit?.n || 'old recruit'}!`, 1500);
S.pendingNewRecruit = null;
S.pendingOldRecruitId = null;
window.pendingStragglerData = null;
nextFloor();
}

function engageEarlyEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= 1 && best <= 15) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`As the heroes sneak up to the camp, a scout's horn sounds. You've been spotted, and you're surrounded! It's an ambush!`],
buttons: `<button class="btn" onclick="finishEncampmentFail()">Continue</button>`
});
} else if(best >= 16 && best <= 19) {
S.encampmentEarlyKills = 1;
replaceStage1WithStage2('encampment');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`Your frogs work together to lure one enemy away and take him out! He screams as he dies, though, and by the time you turn, the rest are scrambling to form ranks.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else {
S.encampmentEarlyKills = 2;
replaceStage1WithStage2('encampment');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`With an excellent ploy, you succeed at picking off 2 enemies! The next combat should be a walk in the pond!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function finishEncampmentFail() {
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 1800);
nextFloor();
}

// ===== 6b. ENCAMPMENT STAGE 2 =====
function showEncampment2() {
const healAmt = Math.floor(S.heroes[0].m * 0.5);
const goldGain = 2 * S.heroes.length;

S.heroes.forEach(h => {
if(!h.ls) {
h.h = Math.min(h.h + healAmt, h.m);
}
});

S.gold += goldGain;
upd();
toast(`All heroes healed ${healAmt} HP!`, 1200);
toast(`Gained ${goldGain} Gold!`, 1200);

removeNeutralFromDeck('encampment');

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment2.png',
title: 'Abandoned Encampment',
description: 'You spy another enemy encampment from a distance, but this one appears abandoned. The bedrolls stink and the tack is stale, but you are able to enter and rest safely.',
outcomes: [
`All heroes restored ${healAmt} HP!`,
`Found ${goldGain} Gold in supplies!`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 7. BETWEEN THE 20s =====
function showGambling1() {
const v = document.getElementById('gameView');
// Entry requirement: minimum 2 gold
if(S.gold < 2) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
description: 'A mysterious gambling den with glowing dice floating in the air. A sign reads: "Minimum 2 Gold to play."',
outcomes: ['<span style="color:#ef4444">You don\'t have enough gold to play.</span>'],
buttons: `<button class="btn safe" onclick="nextFloor()">Leave</button>`
});
return;
}

// Calculate wager: max 10, or highest even number player has
const maxWager = 10;
let wager = Math.min(maxWager, Math.floor(S.gold / 2) * 2);
if(wager < 2) wager = 2;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
description: `A mysterious gambling den beckons. Roll dice to set your range, then try to land between them. Wager: ${wager}G for a ${wager * 2}G payout.`,
outcomes: [],
buttons: `
<button class="btn safe" onclick="nextFloor()">Walk away</button>
<button class="btn risky" onclick="playBetween20s(1, ${wager})">Play (${wager}G)</button>
`
});
}

function playBetween20s(stage, wager) {
const v = document.getElementById('gameView');
// Include both permanent AND temporary upgrades (active sigils stored 0-indexed)
const d20Level = ((S.sig.D20 || 0) + (S.tempSigUpgrades.D20 || 0)) + 1;

// PHASE 1: Establish Range
const boundsCount = stage === 1 ? (d20Level + 1) : 2; // Stage 1: level+1, Stage 2: always 2
const boundsRolls = [];
for(let i = 0; i < boundsCount; i++) {
boundsRolls.push(Math.floor(Math.random() * 20) + 1);
}
const minBound = Math.min(...boundsRolls);
const maxBound = Math.max(...boundsRolls);

// Format dice display
const diceDisplay = formatDiceRolls(boundsRolls);

// Check instant loss (bounds are equal)
if(minBound === maxBound) {
S.gold -= wager;
upd();
v.innerHTML = buildNeutralHTML({
bgImage: stage === 1 ? 'assets/neutrals/gambling1.png' : 'assets/neutrals/gambling2.jpeg',
title: stage === 1 ? 'Between the 20s' : 'Between the 20s Extreme',
description: `Rolling ${boundsCount} dice to set bounds...`,
outcomes: [
`${diceDisplay}`,
`<span style="color:#ef4444">INSTANT LOSS! Both bounds are ${minBound}!</span>`,
`Lost ${wager}G.`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Store game state for phase 2/3
window.between20sState = { stage, wager, minBound, maxBound, boundsRolls };

// PHASE 2: Decision Point (Stage 1 only)
if(stage === 1) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
description: `Rolling ${boundsCount} dice to set bounds...`,
outcomes: [
`${diceDisplay}`,
`Range set: <span style="color:#22c55e">${minBound}</span> to <span style="color:#22c55e">${maxBound}</span>`,
'You can back out for half your wager, or continue for a chance at double.'
],
buttons: `
<button class="btn risky" onclick="backOutBetween20s()">Back out (get ${Math.floor(wager / 2)}G back)</button>
<button class="btn danger" onclick="targetRollBetween20s()">Continue to target roll</button>
`
});
} else {
// Stage 2: No backing out, go straight to target roll
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling2.jpeg',
title: 'Between the 20s Extreme',
description: `Rolling ${boundsCount} dice to set bounds...`,
outcomes: [
`${diceDisplay}`,
`Range set: <span style="color:#22c55e">${minBound}</span> to <span style="color:#22c55e">${maxBound}</span>`,
'<span style="color:#3b82f6">NO BACKING OUT! Rolling for target...</span>'
],
buttons: `<button class="btn danger" onclick="targetRollBetween20s()">Roll target dice</button>`
});
}
}

function formatDiceRolls(rolls) {
return rolls.map(r => `<span style="display:inline-block;width:2.5rem;height:2.5rem;line-height:2.5rem;text-align:center;background:#1e293b;border:2px solid #475569;border-radius:0.5rem;margin:0.2rem;font-weight:bold;color:#f1f5f9;font-size:1.2rem;">${r}</span>`).join(' ');
}

function backOutBetween20s() {
const state = window.between20sState;
const refund = Math.floor(state.wager / 2);
S.gold -= state.wager;
S.gold += refund;
upd();

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
outcomes: [
'You decide to play it safe and back out.',
`Net loss: ${state.wager - refund}G`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function targetRollBetween20s() {
const state = window.between20sState;
const v = document.getElementById('gameView');
// Include both permanent AND temporary upgrades (active sigils stored 0-indexed)
const d20Level = ((S.sig.D20 || 0) + (S.tempSigUpgrades.D20 || 0)) + 1;

// PHASE 3: Target Roll
const targetRolls = [];
for(let i = 0; i < d20Level; i++) {
targetRolls.push(Math.floor(Math.random() * 20) + 1);
}

// Check if ANY die lands between bounds (inclusive)
const winners = targetRolls.filter(r => r >= state.minBound && r <= state.maxBound);
const won = winners.length > 0;

const targetDisplay = formatDiceRolls(targetRolls);

if(won) {
// Calculate payout
let payout = state.wager * (state.stage === 1 ? 2 : 4);
if(state.stage === 2) {
payout = Math.min(payout, 40); // Cap at 40G for Stage 2
}
const netGain = payout - state.wager;
S.gold -= state.wager; // Deduct wager before adding payout
S.gold += payout;
upd();

// Unlock Stage 2 after Stage 1 win
if(state.stage === 1) {
replaceStage1WithStage2('gambling');
toast('Between the 20s Extreme unlocked!', 1800);
}

v.innerHTML = buildNeutralHTML({
bgImage: state.stage === 1 ? 'assets/neutrals/gambling1.png' : 'assets/neutrals/gambling2.jpeg',
title: state.stage === 1 ? 'Between the 20s - WIN!' : 'Between the 20s Extreme - WIN!',
description: `Rolling ${d20Level} target ${d20Level === 1 ? 'die' : 'dice'}...`,
outcomes: [
`${targetDisplay}`,
`<span style="color:#22c55e">SUCCESS! ${winners.map(w => `[${w}]`).join(' ')} landed in range [${state.minBound}-${state.maxBound}]!</span>`,
`Won ${payout}G! (Net: +${netGain}G)`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else {
S.gold -= state.wager;
upd();

v.innerHTML = buildNeutralHTML({
bgImage: state.stage === 1 ? 'assets/neutrals/gambling1.png' : 'assets/neutrals/gambling2.jpeg',
title: state.stage === 1 ? 'Between the 20s - Loss' : 'Between the 20s Extreme - Loss',
description: `Rolling ${d20Level} target ${d20Level === 1 ? 'die' : 'dice'}...`,
outcomes: [
`${targetDisplay}`,
`<span style="color:#ef4444">MISS! No dice landed in range [${state.minBound}-${state.maxBound}].</span>`,
`Lost ${state.wager}G.`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function showGambling2() {
const v = document.getElementById('gameView');
// Entry requirement: minimum 2 gold
if(S.gold < 2) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling2.jpeg',
title: 'Between the 20s Extreme',
description: 'The high-stakes gambling den glows with intense energy. A sign reads: "Minimum 2 Gold to play - 4x payout, capped at 40G."',
outcomes: ['<span style="color:#ef4444">You don\'t have enough gold to play.</span>'],
buttons: `<button class="btn safe" onclick="nextFloor()">Leave</button>`
});
return;
}

// Calculate wager: max 10, or highest even number player has
const maxWager = 10;
let wager = Math.min(maxWager, Math.floor(S.gold / 2) * 2);
if(wager < 2) wager = 2;

// Calculate potential payout (capped at 40)
const potentialPayout = Math.min(wager * 4, 40);

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling2.jpeg',
title: 'Between the 20s Extreme',
description: `The EXTREME version! Only 2 dice for bounds, NO backing out, but ${potentialPayout}G payout! High risk, high reward.`,
outcomes: ['<span style="color:#3b82f6">WARNING: No safety net here. You\'re all in once you start.</span>'],
buttons: `
<button class="btn safe" onclick="nextFloor()">Walk away</button>
<button class="btn danger" onclick="playBetween20s(2, ${wager})">Play EXTREME (${wager}G for ${potentialPayout}G)</button>
`
});
}

// ===== 8. GHOST =====
function showGhost1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'The Haunted Playroom',
description: 'Various toys and games litter a dusty playroom. Two translucent boys appear before you, giggling. "Play with us! Play with us!" They reach out with spectral hands.',
buttons: `
<button class="btn danger" onclick="playWithGhostBoys()">Play with the ghost boys</button>
<button class="btn risky" onclick="nextFloor()">Avoid?</button>
`
});
}

let ghostEscapeDC = 18;
let ghostEscapeAttempts = 0;

function playWithGhostBoys() {
ghostEscapeDC = 18;
ghostEscapeAttempts = 0;
attemptGhostEscape();
}

function attemptGhostEscape() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= ghostEscapeDC) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Escaping the Ghost Boys',
diceRoll: rollText,
outcomes: ['You clear your head and break free from the strange trance. The boys look sad to stop playing, but let you go. "Come back and play sometime... We\'re so lonely..."'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Failed - show hero selection
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="applyGhostDamage(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Trapped with the Ghost Boys',
diceRoll: rollText,
description: 'Choose which hero takes 1 damage:',
outcomes: ['You don\'t notice time passing, but pangs of hunger and fatigue make it clear you\'ve been here longer than it feels like. The boys are having a great time playing.'],
buttons: heroButtons
});
}

function applyGhostDamage(heroIdx) {
const hero = S.heroes[heroIdx];
const hadGhostCharge = hero.g > 0;

hero.h -= 1;
if(hero.h <= 0) {
hero.h = 0;
if(hero.g > 0) {
hero.g--;
hero.h = hero.m;
// EASTER EGG: Ghost charge consumed during Ghost encounter triggers conversion
if(hadGhostCharge) {
replaceStage1WithStage2('ghost');
toast(`${hero.n}'s Ghost keeps them from entering Last Stand! The boys stare in awe...`, 1800);
upd();
// Trigger the full Ghost Boys conversion (showGhost2)
showGhost2();
return;
}
} else {
hero.ls = true;
hero.lst = 0;
upd();
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Escaping the Ghost Boys',
outcomes: [
`Unable to withstand the hunger, ${hero.n} takes 1 damage and enters Last Stand! The shock breaks the ghost boys' hold!`,
'"Oops! We didn\'t realize..." they say in unison, staring at each other in horror. They begin to sob, and quickly disappear.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}
}

toast(`${hero.n} took 1 damage!`);
ghostEscapeAttempts++;
ghostEscapeDC -= 2;
upd();

const v = document.getElementById('gameView');

if(ghostEscapeAttempts >= 9) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Finally Free',
outcomes: ['After many attempts, the ghost boys grow bored and fade away.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Try Again',
description: `<div style="font-size:0.9rem;margin:1rem 0">Attempts: ${ghostEscapeAttempts}/9 | Next DC: ${ghostEscapeDC}</div>`,
outcomes: [`${hero.n} took 1 damage!`],
buttons: `<button class="btn danger" onclick="attemptGhostEscape()">Try to Escape (DC ${ghostEscapeDC})</button>`
});
}

function showGhost2() {
S.ghostBoysConverted = true;
toast('Ghost Boys permanently converted to Empty Playroom!', 1800);
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost2.png',
title: 'Passing On',
description: 'The ghost boys stare at each other, then at their translucent hands. "We\'re... we\'re dead. We\'re ghosts."',
outcomes: [
'Tears form in their spectral eyes. "We didn\'t know. We want to go home."',
'They hold hands and embrace you in a ghostly hug. "We would never have figured it out without you. Thank you." They vanish peacefully.',
'<span style="color:#22c55e">This room is now an Empty Playroom - you can pass safely in future runs.</span>'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showEmptyPlayroom() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost2.png',
title: 'Empty Playroom',
description: 'An empty chamber, dust motes drifting in pale light. It might have been a playroom once, but whatever haunted it is long gone. The air feels peaceful.',
outcomes: ['Nothing stops you here. You pass through quietly.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue to Floor ${S.floor + 1}</button>`
});
}

// ===== 9. FLUMMOXED ROYAL =====
// Helper to get random royal title
function getRandomRoyalTitle() {
return Math.random() < 0.5 ? 'Prince' : 'Princess';
}

function showRoyal1() {
// Generate random titles for each royal (the one asking for help and their beloved)
const askerTitle = getRandomRoyalTitle();
const belovedTitle = getRandomRoyalTitle();
// Store for use in acceptRoyalQuest callback
S.royalAskerTitle = askerTitle;
S.royalBelovedTitle = belovedTitle;

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal1.png',
title: 'The Flummoxed Royal',
description: `A flummoxed ${askerTitle} paces anxiously: "Please, you must help! A creature in the next chamber ate my beloved's engagement ring! But I have cooked up a stratagem to retrieve it! If you can but stun a foe on the first turn of battle, I can search for the ring!"`,
buttons: `
<button class="btn" onclick="acceptRoyalQuest()">Accept the quest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`
});
}

function acceptRoyalQuest() {
toast('Stun any enemy Turn 1 of next combat!', 1800);
S.royalQuestActive = true;
S.royalQuestCompleted = false;
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal1.png',
outcomes: [`The ${S.royalAskerTitle} looks hopeful: "Thank you! I'll follow you and grab it when you stun the creature!"`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showRoyal2() {
const v = document.getElementById('gameView');
// Use stored titles from showRoyal1, or generate new ones if not present
const askerTitle = S.royalAskerTitle || getRandomRoyalTitle();
const belovedTitle = S.royalBelovedTitle || getRandomRoyalTitle();

// Check if quest was completed
if(!S.royalQuestCompleted) {
// Quest failed
S.royalQuestActive = false;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal1.png',
title: 'Quest Failed',
description: `The ${askerTitle} returns, dejected: "The creature fled before I could retrieve the ring. I'll have to find another way..."`,
outcomes: [`The ${askerTitle} departs sadly. No reward.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Quest succeeded - show wedding
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const eligible = allSigils.filter(s => (S.sig[s] || 0) < 4);

eligible.sort((a, b) => {
const costA = S.sig[a] || 0;
const costB = S.sig[b] || 0;
return costA - costB;
});

const sigil1 = eligible[0] || 'Attack';
const sigil2 = eligible[1] || 'Shield';

removeNeutralFromDeck('royal');
S.royalQuestActive = false;

let buttons = '';
buttons += `<div class="choice" onclick="chooseRoyalSigil('${sigil1}')">
<strong>${sigilIcon(sigil1)}</strong> <span style="opacity:0.7">L${S.sig[sigil1] || 0} ‚Üí L${(S.sig[sigil1] || 0) + 1}</span>
</div>`;
buttons += `<div class="choice" onclick="chooseRoyalSigil('${sigil2}')">
<strong>${sigilIcon(sigil2)}</strong> <span style="opacity:0.7">L${S.sig[sigil2] || 0} ‚Üí L${(S.sig[sigil2] || 0) + 1}</span>
</div>`;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal2.png',
title: 'Royal Wedding',
description: `The ${askerTitle} welcomes you with a grand sweep of their open arms. "Ah, here are the very heroes who saved our wedding day, my love! Shall we give them the blessing we discussed?" The ${belovedTitle} beside them nods warmly.`,
outcomes: ['Each wears a garment displaying a sigil of power. As thanks for your help, you may choose one:'],
buttons
});
}

function chooseRoyalSigil(sig) {
S.sig[sig] = (S.sig[sig] || 0) + 1;
toast(`${sig} permanently upgraded to L${S.sig[sig]}!`, 1800);
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal2.png',
outcomes: [`The royal couple thanks you profusely. The ${sig} sigil glows and merges with your power!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== OLD TAPO ENCOUNTER (FLOOR 20) =====
function showOldTapo() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/old-tapo.png" alt="Old Tapo, Master of Space and Time" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #8b5cf6;box-shadow:0 0 20px rgba(139,92,246,0.5)">
<div class="neutral-title" style="color:#8b5cf6;font-size:1.8rem">The Master of Space and Time</div>
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;background:rgba(139,92,246,0.1);border-radius:8px;margin:1rem 0">
"Tapo, you say? Yes... I was called Tapo once, wasn't I? That was 'Before'... Before I mastered the speculae of space, the tesseracts of time... before I became one with the universe. You would save me? Why, I need no saving... In a universe of infinite and terrifying possibility, there need be no fear, no hate, no pain."
</div>
<button class="btn" onclick="oldTapoSlide2()" style="background:linear-gradient(135deg, #8b5cf6, #6366f1);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Continue</button>
</div>`;
}

function oldTapoSlide2() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/old-tapo.png" alt="Old Tapo" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #8b5cf6;box-shadow:0 0 20px rgba(139,92,246,0.5)">
<div class="neutral-title" style="color:#8b5cf6;font-size:1.8rem">The Master of Space and Time</div>
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;background:rgba(139,92,246,0.1);border-radius:8px;margin:1rem 0">
"Noble frogs of my youth, do you understand? Of course not... For you are the true tadpoles, on this fleeting cosmic scale. But you cannot understand, not as I have understood... There is only love, and joy, and progress... And flies. I have transcended the need for food, but that Flydra sure looked yummy..."
</div>
<button class="btn" onclick="oldTapoTransform()" style="background:linear-gradient(135deg, #8b5cf6, #6366f1);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Continue</button>
</div>`;
}

function oldTapoTransform() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;background:rgba(139,92,246,0.1);border-radius:8px;margin:1rem 0;text-align:center">
"Ah! I know!" <em>*Poof*</em>
</div>
<div style="text-align:center;margin:2rem 0">
<img src="assets/tapo-nobg.png" alt="Baby Tapo" style="max-width:100%;height:auto;max-width:300px;margin:0 auto 1rem auto;display:block;animation:bounce 1s ease-in-out 3">
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;margin:1rem 0">
<em>Squeals.</em> The heroes know this sound well - Baby Tapo is hungry for flies!
</div>
<div style="font-size:2.5rem;font-weight:bold;color:#3b82f6;text-shadow:0 0 10px rgba(251,191,36,0.5);margin:2rem 0;animation:glow 1s ease-in-out infinite">
‚ú® Tapo Unlocked! ‚ú®
</div>
<div class="neutral-outcome" style="font-size:1.1rem;margin:1.5rem 0">
Baby Tapo has been added to your hero roster!<br>
<span style="color:#22c55e">Stats: 1 HP / 1 POW</span><br>
<span style="color:#8b5cf6">Starts with D20 + any upgraded passives!</span>
</div>
</div>
<button class="btn" onclick="completeTapoUnlock()" style="background:linear-gradient(135deg, #3b82f6, #f97316);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Victory!</button>
</div>
<style>
@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-20px); }
}
@keyframes glow {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}
</style>`;
}

function completeTapoUnlock() {
S.tapoUnlocked = true;
savePermanent();
win();
}

// ===== DEATH DIALOGUE SEQUENCE =====
function showDeathIntroDialogue() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="background:#2c2416;padding:2rem;border-radius:8px;max-width:800px;margin:2rem auto;color:#e8dcc4">
<img src="assets/neutrals/shopkeeper2.png" alt="The mysterious shopkeeper" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #dc2626;box-shadow:0 0 20px rgba(220,38,38,0.5)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:2rem;text-align:center">
"Oh hey, it's you! I'm the one who's been giving you tips along the way."
</p>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:2rem;text-align:center">
"I'm supposed to take you to the next life‚Ä¶ but you're not from this realm, are you?"
</p>
<div class="choice" onclick="showDeathResponseDialogue(true)" style="cursor:pointer">
<strong>Yes, I'm from a place called Ribbleton!</strong>
</div>
<div class="choice" onclick="showDeathResponseDialogue(false)" style="cursor:pointer">
<strong>No, I sure am from this realm!</strong>
</div>
</div>`;
}

function showDeathResponseDialogue(fromRibbleton) {
const v = document.getElementById('gameView');
const responseText = fromRibbleton
? "Ribbleton! I thought so. Not many travelers make it here from other realms."
: "Is that so? Well, regardless of where you're from...";

v.innerHTML = `
<div style="background:#2c2416;padding:2rem;border-radius:8px;max-width:800px;margin:2rem auto;color:#e8dcc4">
<img src="assets/neutrals/shopkeeper2.png" alt="The mysterious shopkeeper" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #dc2626;box-shadow:0 0 20px rgba(220,38,38,0.5)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:1.5rem;text-align:center">
"${responseText}"
</p>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:2rem;text-align:center">
"Well, it might be more profitable for <em>both</em> of us if I don't, you know‚Ä¶ kill you. I have another arrangement in mind."
</p>
<button class="btn danger" onclick="completeDeathIntro()" style="font-size:1.2rem;padding:1rem 2rem;margin:0 auto;display:block">Continue...</button>
</div>`;
}

function completeDeathIntro() {
// Mark the intro as seen
S.tutorialFlags.death_intro = true;
savePermanent();
// Show the actual death screen with upgrades
showDeathScreen();
}



// ===== THE POND - RUN HISTORY =====
// Records a run's outcome to the permanent history
function recordPondHistory(outcome, killedBy = null) {
const heroNames = S.heroes.map(h => h.n);
const entry = {
runNumber: S.runNumber,
heroes: heroNames,
floorReached: S.floor,
gameMode: S.gameMode,
outcome: outcome, // 'defeat' or 'victory'
killedBy: killedBy,
timestamp: Date.now(),
xpEarned: S.xp - S.startingXP,
goldEarned: S.gold
};
// Add to history (limit to last 50 runs to save localStorage space)
S.pondHistory.unshift(entry);
if(S.pondHistory.length > 50) {
S.pondHistory = S.pondHistory.slice(0, 50);
}
savePermanent();
}

// Show The Pond - a reflective place for remembering past adventures
function showPond() {
const v = document.getElementById('gameView');
const history = S.pondHistory || [];

// Generate lily pad for each run
function renderLilyPad(run, idx) {
const isVictory = run.outcome === 'victory';
const isFUVictory = isVictory && run.gameMode === 'fu';
const isStandardVictory = isVictory && run.gameMode !== 'fu';

// Size based on floor reached (40px base + up to 60px more for floor 20)
const baseSize = 45;
const maxBonus = 55;
const floorReached = Math.max(1, run.floorReached || 1); // Guard against undefined/NaN
const floorProgress = Math.min(floorReached, 20) / 20;
const size = Math.round(baseSize + (maxBonus * floorProgress));

// Colors: green (defeat), gold (standard win), prismatic (FU win)
let background, border, glow, animation;
if (isFUVictory) {
  // Prismatic rainbow gradient
  background = 'linear-gradient(135deg, #ff6b6b 0%, #feca57 17%, #48dbfb 34%, #ff9ff3 51%, #54a0ff 68%, #5f27cd 85%, #ff6b6b 100%)';
  border = '3px solid #fff';
  glow = '0 0 15px rgba(255,255,255,0.8), 0 0 30px rgba(138,43,226,0.5)';
  animation = 'animation: prismatic-shimmer 3s linear infinite;';
} else if (isStandardVictory) {
  // Golden
  background = 'linear-gradient(135deg, #fbbf24 0%, #f59e0b 50%, #d97706 100%)';
  border = '3px solid #fcd34d';
  glow = '0 0 12px rgba(251,191,36,0.6)';
  animation = '';
} else {
  // Green lily pad (defeat) - brighter green for higher floors
  const greenIntensity = 0.5 + (floorProgress * 0.4);
  background = `linear-gradient(135deg, rgba(34,197,94,${greenIntensity}) 0%, rgba(22,163,74,${greenIntensity + 0.15}) 100%)`;
  border = '2px solid rgba(34,197,94,0.7)';
  glow = '0 2px 8px rgba(0,0,0,0.3)';
  animation = '';
}

return `
<div class="lily-pad" onclick="showLilyPadDetail(${idx})" style="
  width:${size}px;
  height:${size}px;
  border-radius:50% 50% 50% 20%;
  background:${background};
  border:${border};
  box-shadow:${glow};
  cursor:pointer;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  transition:transform 0.2s, box-shadow 0.2s;
  position:relative;
  ${animation}
" onmouseover="this.style.transform='scale(1.15)'"
   onmouseout="this.style.transform='scale(1)'"
   title="Run #${run.runNumber} - Floor ${run.floorReached}${isVictory ? ' üèÜ' : ''}">
  <span style="font-size:${Math.max(11, size/4)}px;font-weight:bold;color:${isVictory ? '#000' : '#fff'};text-shadow:${isVictory ? 'none' : '1px 1px 2px rgba(0,0,0,0.6)'}">${run.floorReached}</span>
  ${isVictory ? `<span style="font-size:${Math.max(10, size/5)}px">üèÜ</span>` : ''}
</div>`;
}

let html = `
<style>
@keyframes prismatic-shimmer {
  0% { filter: hue-rotate(0deg); }
  100% { filter: hue-rotate(360deg); }
}
@keyframes pond-ripple {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}
.pond-water {
  background: linear-gradient(135deg,
    rgba(30,58,138,0.4) 0%,
    rgba(59,130,246,0.25) 25%,
    rgba(30,64,175,0.35) 50%,
    rgba(59,130,246,0.25) 75%,
    rgba(30,58,138,0.4) 100%);
  background-size: 200% 200%;
  animation: pond-ripple 8s ease-in-out infinite;
}
.lily-pad-container {
  display:flex;
  flex-wrap:wrap;
  gap:15px;
  justify-content:center;
  align-items:center;
  padding:2rem 1.5rem;
  min-height:180px;
}
</style>
<div style="max-width:900px;margin:0 auto;padding:1rem">
<h1 style="text-align:center;margin-bottom:0.5rem;font-size:2rem;color:#60a5fa;text-shadow:2px 2px 4px rgba(0,0,0,0.3)">
üåø The Pond üåø
</h1>
<p style="text-align:center;color:#94a3b8;margin-bottom:1rem;font-size:0.95rem">
A quiet place to reflect on adventures past...
</p>

<!-- Legend -->
<div style="display:flex;justify-content:center;gap:1.5rem;margin-bottom:1rem;flex-wrap:wrap;font-size:0.85rem">
<span style="color:#22c55e">üü¢ Good Try</span>
<span style="color:#fbbf24">üü° Good Job</span>
${S.fuUnlocked ? `<span style="background:linear-gradient(90deg,#ff6b6b,#feca57,#48dbfb,#ff9ff3);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-weight:bold">üåà ${(S.pondHistory || []).some(r => r.gameMode === 'fu') ? 'Frogged Up Win' : 'What the Frog?'}</span>` : ''}
<span style="color:#64748b;font-size:0.8rem">(bigger = higher floor)</span>
</div>

${history.length === 0 ? `
<div class="pond-water" style="text-align:center;padding:4rem 2rem;border-radius:24px;max-width:500px;margin:0 auto;border:3px solid rgba(59,130,246,0.3)">
<p style="font-size:2rem;margin-bottom:1rem">ü™∑</p>
<p style="color:#94a3b8;font-size:1.1rem">The water is still...</p>
<p style="color:#64748b;margin-top:0.5rem">Lily pads will appear here after your first adventure and grow the further you progress.</p>
</div>
` : `
<div class="pond-water" style="border-radius:20px;border:3px solid rgba(59,130,246,0.3)">
<div class="lily-pad-container">
${history.map((run, idx) => renderLilyPad(run, idx)).join('')}
</div>
</div>

<!-- Stats summary -->
<div style="margin-top:1.5rem;display:grid;grid-template-columns:repeat(auto-fit, minmax(100px, 1fr));gap:0.75rem;text-align:center">
<div style="background:rgba(30,41,59,0.8);padding:0.75rem;border-radius:8px;border:2px solid #334155">
<div style="font-size:1.4rem;font-weight:bold;color:#f1f5f9">${history.length}</div>
<div style="color:#94a3b8;font-size:0.85rem">Journeys</div>
</div>
<div style="background:rgba(30,41,59,0.8);padding:0.75rem;border-radius:8px;border:2px solid #334155">
<div style="font-size:1.4rem;font-weight:bold;color:#fbbf24">${history.filter(r => r.outcome === 'victory').length}</div>
<div style="color:#94a3b8;font-size:0.85rem">Victories</div>
</div>
<div style="background:rgba(30,41,59,0.8);padding:0.75rem;border-radius:8px;border:2px solid #334155">
<div style="font-size:1.4rem;font-weight:bold;color:#60a5fa">${Math.max(...history.map(r => r.floorReached), 0)}</div>
<div style="color:#94a3b8;font-size:0.85rem">Best Floor</div>
</div>
<div style="background:rgba(30,41,59,0.8);padding:0.75rem;border-radius:8px;border:2px solid #334155">
<div style="font-size:1.4rem;font-weight:bold;color:#f59e0b">${getMostUsedHero(history)}</div>
<div style="color:#94a3b8;font-size:0.85rem">Favorite</div>
</div>
</div>
`}

${S.hasReachedFloor20 ? `
<div style="text-align:center;margin-top:1.5rem;padding:1rem;background:linear-gradient(135deg,rgba(59,130,246,0.2),rgba(251,191,36,0.1));border:2px solid #3b82f6;border-radius:12px">
<h3 style="margin:0 0 0.75rem 0;color:#60a5fa;text-shadow:1px 1px 2px rgba(0,0,0,0.5)">üèÜ The Flydra's Conquerors üèÜ</h3>
<p style="color:#94a3b8;font-size:0.9rem;margin-bottom:0.75rem">You've proven yourself worthy. Visit the Champions Hall to manage figurines and explore other realms.</p>
<button class="btn" onclick="showChampionsMenu()" style="background:linear-gradient(135deg,#3b82f6,#1e40af);border:2px solid #60a5fa;padding:0.75rem 1.5rem;font-size:1rem">
üê∏ Enter Champions Hall
</button>
</div>
` : ''}

<div style="text-align:center;margin-top:1.5rem">
<button class="btn" onclick="showRibbleton()" style="padding:1rem 2rem;font-size:1.1rem">üê∏ Return to Ribbleton</button>
</div>
</div>`;

v.innerHTML = html;
}

// Show detail popup when clicking a lily pad
function showLilyPadDetail(idx) {
const run = S.pondHistory[idx];
if (!run) return;

const date = new Date(run.timestamp);
const dateStr = date.toLocaleDateString(undefined, {weekday: 'short', month: 'short', day: 'numeric'});
const isVictory = run.outcome === 'victory';
const isFUVictory = isVictory && run.gameMode === 'fu';
const modeText = run.gameMode === 'fu' ? 'Frogged Up' : 'Standard';

let headerBg, headerColor;
if (isFUVictory) {
headerBg = 'linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff)';
headerColor = '#000';
} else if (isVictory) {
headerBg = 'linear-gradient(135deg, #fbbf24, #f59e0b)';
headerColor = '#000';
} else {
headerBg = 'linear-gradient(135deg, #22c55e, #16a34a)';
headerColor = '#fff';
}

const v = document.getElementById('gameView');
const html = `
<div class="modal-container" style="max-width:350px">
<div style="background:${headerBg};padding:1rem;border-radius:8px 8px 0 0;text-align:center">
<h2 style="margin:0;color:${headerColor};font-size:1.3rem">${isVictory ? 'üèÜ Victory!' : 'ü™∑ Journey'} #${run.runNumber}</h2>
</div>
<div style="padding:1rem">
<div style="display:grid;gap:0.5rem;font-size:0.95rem">
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Date:</span>
<span style="color:#f1f5f9">${dateStr}</span>
</div>
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Mode:</span>
<span style="color:#f1f5f9">${run.gameMode === 'fu' ? 'üî• ' : '‚öîÔ∏è '}${modeText}</span>
</div>
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Floor Reached:</span>
<span style="color:#f1f5f9;font-weight:bold">${run.floorReached}</span>
</div>
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Heroes:</span>
<span style="color:#f1f5f9">${run.heroes.join(' + ')}</span>
</div>
${run.xpEarned !== undefined ? `
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">XP Earned:</span>
<span style="color:#a78bfa;font-weight:bold">${run.xpEarned}</span>
</div>
` : ''}
${run.goldEarned !== undefined ? `
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Gold Balance:</span>
<span style="color:#fbbf24;font-weight:bold">${run.goldEarned}G</span>
</div>
` : ''}
${!isVictory && run.killedBy ? `
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Fell to:</span>
<span style="color:#f87171">${run.killedBy}</span>
</div>
` : ''}
${isVictory ? `
<div style="text-align:center;margin-top:0.5rem;padding:0.5rem;background:rgba(34,197,94,0.2);border-radius:4px">
<span style="color:#22c55e;font-weight:bold">üéâ Tapo Rescued!</span>
</div>
` : ''}
</div>
<button class="btn" onclick="this.closest('.modal-container').remove();document.querySelector('.modal-overlay')?.remove()" style="margin-top:1rem;width:100%">Close</button>
</div>
</div>
<div class="modal-overlay" onclick="document.querySelector('.modal-container')?.remove();this.remove()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
SoundFX.play('hop');
}

function getMostUsedHero(history) {
if(history.length === 0) return '-';
const counts = {};
history.forEach(run => {
run.heroes.forEach(hero => {
  counts[hero] = (counts[hero] || 0) + 1;
});
});
const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
return sorted.length > 0 ? sorted[0][0] : '-';
}

// ===== DEATH SCREEN =====
function showDeathScreen() {
savePermanent(); // Save gold, goingRate, sig upgrades
// Recruits persist until killed - don't clear here

// QUEST TRACKING: Run completed (death)
trackQuestProgress('runComplete');

// Check if this is the first time meeting Death
if(!S.tutorialFlags.death_intro) {
showDeathIntroDialogue();
return;
}

const v = document.getElementById('gameView');
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
const allSigils = [...coreSigils, ...advancedSigils, ...passiveSigils];

// Select a random Death quote that hasn't been used yet
let deathQuote = "";
if(S.usedDeathQuotes.length >= DEATH_QUOTES.length) {
// All quotes used - reset the pool
S.usedDeathQuotes = [];
}
const availableQuotes = DEATH_QUOTES.filter((_, idx) => !S.usedDeathQuotes.includes(idx));
if(availableQuotes.length > 0) {
const randomIdx = Math.floor(Math.random() * availableQuotes.length);
deathQuote = availableQuotes[randomIdx];
// Mark this quote as used
const quoteIndex = DEATH_QUOTES.indexOf(deathQuote);
S.usedDeathQuotes.push(quoteIndex);
savePermanent(); // Save the updated usedDeathQuotes
}

// Calculate next upgrade's rate increase (tiered: first 5 +5, next 5 +10, etc.)
const currentTotalUpgrades = ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha']
  .reduce((sum, sig) => sum + (S.sigUpgradeCounts[sig] || 0), 0);
const nextTier = Math.floor(currentTotalUpgrades / 5);
const nextRateIncrease = 5 * (nextTier + 1);

let html = `
<style>
@keyframes marquee-flash {
  0%, 100% { border-color: #dc2626; box-shadow: 0 0 10px rgba(220,38,38,0.8), 0 0 20px rgba(220,38,38,0.5); }
  50% { border-color: #3b82f6; box-shadow: 0 0 15px rgba(251,191,36,0.9), 0 0 30px rgba(251,191,36,0.6); }
}
.going-rate-marquee {
  animation: marquee-flash 1.5s ease-in-out infinite;
  border: 4px solid #dc2626;
  padding: 1.5rem;
  border-radius: 12px;
  background: linear-gradient(135deg, rgba(220,38,38,0.1), rgba(251,191,36,0.1));
  margin: 1.5rem 0;
}
</style>
<div class="death-screen-container" style="background:#f5f4ed;padding:2rem;border-radius:8px;max-width:900px;margin:0 auto;color:#2c2416;box-shadow:0 4px 12px rgba(0,0,0,0.15)">
<img src="assets/neutrals/shopkeeper2.png" alt="The mysterious shopkeeper" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #dc2626;box-shadow:0 0 20px rgba(220,38,38,0.5)">
<h1 style="text-align:center;margin-bottom:1rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
${deathQuote ? `<p style="text-align:center;margin-bottom:1rem;font-size:1rem;color:#4a4540;font-style:italic">"${deathQuote}"</p>` : ''}
<div class="going-rate-marquee">
<p style="text-align:center;font-size:1.3rem;margin:0">Gold: <strong style="color:#b45309">${S.gold}</strong></p>
<p style="text-align:center;font-size:1.5rem;margin:0.5rem 0 0 0;font-weight:bold;color:#dc2626">‚ö° Going Rate: ${S.goingRate}G ‚ö°</p>
<p style="text-align:center;font-size:0.85rem;margin:0.25rem 0 0 0;color:#5a5550;font-style:italic">(+${nextRateIncrease}G per upgrade)</p>
</div>`;

if(S.gold === 0) {
html += `<p style="text-align:center;margin:2rem 0;font-size:1.2rem;color:#dc2626;font-style:italic">"Nothing? Really? Come back when you have something to offer."</p>`;
} else {
html += `<h3 style="margin-bottom:1rem;text-align:center;font-size:1.3rem;color:#2c2416">Upgrade Sigilarium:</h3>`;

// Sanity check: if goingRate is very low but sigUpgradeCounts is high, something is wrong
// This can happen if save data gets corrupted or from old migration issues
const allSigils = ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha'];
const totalUpgradeCounts = allSigils.reduce((sum, sig) => sum + (S.sigUpgradeCounts[sig] || 0), 0);
// Calculate expected going rate with tiered formula: first 5 upgrades +5 each, next 5 +10 each, etc.
const calculateExpectedGoingRate = (n) => {
  if(n <= 0) return 1;
  const fullTiers = Math.floor(n / 5);
  const partial = n % 5;
  // Sum of full tiers: each tier i (0-indexed) adds 5*(i+1)*5 = 25*(i+1)
  // Sum = 25 * (1+2+...+fullTiers) = 25 * fullTiers * (fullTiers+1) / 2
  const fullTierSum = 25 * fullTiers * (fullTiers + 1) / 2;
  // Partial tier adds: partial * 5 * (fullTiers+1)
  const partialSum = partial * 5 * (fullTiers + 1);
  return 1 + fullTierSum + partialSum;
};
const expectedMinGoingRate = calculateExpectedGoingRate(totalUpgradeCounts);
if (S.goingRate < expectedMinGoingRate && totalUpgradeCounts > 0) {
  console.warn('[DEATH SCREEN] sigUpgradeCounts out of sync with goingRate. Resetting sigUpgradeCounts.');
  console.warn('  goingRate:', S.goingRate, 'totalUpgradeCounts:', totalUpgradeCounts, 'expectedMin:', expectedMinGoingRate);
  // Reset sigUpgradeCounts to match what goingRate implies
  allSigils.forEach(sig => S.sigUpgradeCounts[sig] = 0);
  savePermanent();
  toast('Fixed corrupted upgrade data', 1500);
}

// Helper function to render sigil upgrade cards
const renderSigilCards = (sigils) => {
let cards = '';
sigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
// Actives show their effective level (perm + 1 for display)
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const nextLevel = currentLevel + 1;
const maxLevel = isActive ? 4 : 5; // Actives max at perm 4 (display 5), passives at perm 5

// Show SOLD OUT card for maxed sigils instead of hiding
if(currentLevel >= 5) {
const colors = ['#666', '#000', '#0d9488', '#9333ea', '#d97706', '#ff00ff'];
const maxColor = colors[5];
cards += `
<div class="death-screen-sigil-card" style="background:#1a1a2e;padding:1rem;border-radius:8px;border:2px solid ${maxColor};box-shadow:0 0 12px rgba(255,0,255,0.3)">
<div style="font-weight:bold;margin-bottom:0.75rem;font-size:1.1rem">${sigilIconWithTooltip(sig, currentLevel, 750)}</div>
<div style="font-size:1.2rem;margin-bottom:0.75rem;font-weight:bold">
<span style="color:${maxColor}">L${currentLevel}</span>
</div>
<div style="font-size:1rem;color:${maxColor};font-weight:bold;text-transform:uppercase;letter-spacing:1px">SOLD OUT</div>
</div>`;
return;
}

const upgradeCount = S.sigUpgradeCounts[sig] || 0;
const baseCost = S.goingRate;
const escalationTable = [0, 25, 50, 100, 150];
// Cap upgradeCount to valid table index to prevent undefined escalation
const cappedCount = Math.min(upgradeCount, escalationTable.length - 1);
const escalation = escalationTable[cappedCount];
const cost = baseCost + escalation;

const canAfford = S.gold >= cost;
const colors = ['#666', '#000', '#0d9488', '#9333ea', '#d97706', '#ff00ff'];
const colorClass = colors[currentLevel] || '#666';
const nextColorClass = colors[nextLevel] || '#ff00ff';
// Show cost breakdown if there's escalation
const costDisplay = escalation > 0
  ? `<span title="Base: ${baseCost}G + Escalation: ${escalation}G">${cost}G</span>`
  : `${cost}G`;

// Use color-coded borders based on next level
const borderColor = nextColorClass;
cards += `
<div class="death-screen-sigil-card" style="background:#ffffff;padding:1rem;border-radius:8px;border:2px solid ${borderColor};box-shadow:0 2px 4px rgba(0,0,0,0.1)">
<div style="font-weight:bold;margin-bottom:0.75rem;font-size:1.1rem">${sigilIconWithTooltip(sig, currentLevel, 750)}</div>
<div style="font-size:1rem;margin-bottom:0.75rem;font-weight:bold">
<span style="color:${colorClass}">L${currentLevel}</span> ‚Üí <span style="color:${nextColorClass}">L${nextLevel}</span>
</div>
<div style="font-size:0.9rem;margin-bottom:0.75rem;color:#4a4540;font-weight:600">Cost: ${cost}G</div>
<button class="btn" ${!canAfford ? 'disabled' : ''} onclick="purchaseSigilUpgrade('${sig}', ${cost})" style="padding:0.5rem 1rem;font-size:0.9rem;width:100%;${canAfford ? `border-color:${nextColorClass}` : ''}">
${canAfford ? 'Purchase' : 'Too Expensive'}
</button>
</div>`;
});
return cards;
};

// Core Sigils
html += `<h4 style="color:#2c63c7;margin:1rem 0 0.5rem 0;text-align:center;font-size:1.1rem">‚öîÔ∏è Core Sigils</h4>`;
html += `<div class="death-screen-sigil-grid" style="display:grid;grid-template-columns:repeat(4,1fr);gap:1rem;margin-bottom:1.5rem;max-width:850px;margin-left:auto;margin-right:auto">`;
html += renderSigilCards(coreSigils);
html += `</div>`;

// Advanced Sigils
html += `<h4 style="color:#f97316;margin:1rem 0 0.5rem 0;text-align:center;font-size:1.1rem">üî• Advanced Sigils</h4>`;
if(S.advancedSigilsUnlocked) {
html += `<div class="death-screen-sigil-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-bottom:1.5rem;max-width:850px;margin-left:auto;margin-right:auto">`;
html += renderSigilCards(advancedSigils);
html += `</div>`;
} else {
const canAffordAdvanced = S.gold >= 20;
html += `
<div style="background:#1a1a2e;padding:2rem;border-radius:12px;margin-bottom:1.5rem;max-width:850px;margin-left:auto;margin-right:auto;border:3px solid #f97316;box-shadow:0 0 20px rgba(249,115,22,0.3);text-align:center">
<div style="font-size:2rem;margin-bottom:1rem">üîí</div>
<p style="color:#f97316;font-weight:bold;font-size:1.1rem;margin-bottom:0.5rem">Ghost ‚Ä¢ Alpha ‚Ä¢ Grapple</p>
<p style="color:#888;font-size:0.9rem;margin-bottom:1rem;font-style:italic">Unlock advanced combat techniques</p>
<button class="btn" ${!canAffordAdvanced ? 'disabled' : ''} onclick="unlockSigilCategory('advanced')" style="padding:0.75rem 1.5rem;font-size:1rem;${canAffordAdvanced ? 'background:linear-gradient(135deg,#f97316,#ea580c);border-color:#f97316;color:#fff' : ''}">
${canAffordAdvanced ? 'UNLOCK - 20G' : 'Need 20G to Unlock'}
</button>
</div>`;
}

// Passive Sigils
html += `<h4 style="color:#9333ea;margin:1rem 0 0.5rem 0;text-align:center;font-size:1.1rem">‚ú® Passive Sigils</h4>`;
if(S.passiveSigilsUnlocked) {
html += `<div class="death-screen-sigil-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-bottom:1.5rem;max-width:850px;margin-left:auto;margin-right:auto">`;
html += renderSigilCards(passiveSigils);
html += `</div>`;
} else {
const canAffordPassive = S.gold >= 50;
html += `
<div style="background:#1a1a2e;padding:2rem;border-radius:12px;margin-bottom:1.5rem;max-width:850px;margin-left:auto;margin-right:auto;border:3px solid #9333ea;box-shadow:0 0 20px rgba(147,51,234,0.3);text-align:center">
<div style="font-size:2rem;margin-bottom:1rem">üîí</div>
<p style="color:#9333ea;font-weight:bold;font-size:1.1rem;margin-bottom:0.5rem">Expand ‚Ä¢ Asterisk ‚Ä¢ Star</p>
<p style="color:#888;font-size:0.9rem;margin-bottom:1rem;font-style:italic">Unlock passive enhancements</p>
<button class="btn" ${!canAffordPassive ? 'disabled' : ''} onclick="unlockSigilCategory('passive')" style="padding:0.75rem 1.5rem;font-size:1rem;${canAffordPassive ? 'background:linear-gradient(135deg,#9333ea,#7c3aed);border-color:#9333ea;color:#fff' : ''}">
${canAffordPassive ? 'UNLOCK - 50G' : 'Need 50G to Unlock'}
</button>
</div>`;
}
}

// Death Boys (only if Ghost Boys converted)
if(S.ghostBoysConverted) {
html += `
<div style="border-top:2px solid rgba(255,255,255,0.2);padding-top:2rem;margin-top:2rem">
<h2 style="text-align:center;margin-bottom:0.5rem;font-size:1.5rem;color:#a855f7">The Death Boys</h2>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;font-style:italic;opacity:0.8">"We work for Death now! It's WAY cooler than being ghosts!"</p>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-bottom:1.5rem">
<!-- Boy 1: Sell Back -->
<div style="background:rgba(34,197,94,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(34,197,94,0.3)">
<h3 style="color:#22c55e;margin-bottom:0.5rem">Death Boy 1: "Sell Back"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Remove one upgrade level from any sigil and get Gold equal to the current Going Rate (no rate increase)</p>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G</div>`;

// List all sigils that can be sold back
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const canSellBack = permLevel > 0;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIconWithTooltip(sig, currentLevel, 750)} L${currentLevel}</span>
<button class="btn" ${!canSellBack ? 'disabled' : ''} onclick="deathBoySellBack('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSellBack ? `Sell for ${S.goingRate}G` : 'Cannot Sell'}
</button>
</div>`;
});

html += `</div>

<!-- Boy 2: Sacrifice for XP -->
<div style="background:rgba(168,85,247,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(168,85,247,0.3)">
<h3 style="color:#a855f7;margin-bottom:0.5rem">Death Boy 2: "Sacrifice"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Sacrifice one upgrade level to gain ${S.goingRate} Starting XP permanently. Going Rate decreases by 5G.</p>
<div style="font-size:0.8rem;margin-bottom:0.5rem;opacity:0.7">Current Starting XP: ${S.startingXP}</div>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G ‚Üí ${Math.max(1, S.goingRate - 5)}G</div>`;

// List all sigils that can be sacrificed
const actives2 = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives2.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const canSacrifice = permLevel > 0 && S.goingRate > 1;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIconWithTooltip(sig, currentLevel, 750)} L${currentLevel}</span>
<button class="btn" ${!canSacrifice ? 'disabled' : ''} onclick="deathBoySacrifice('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSacrifice ? `+${S.goingRate}XP` : 'Cannot'}
</button>
</div>`;
});

html += `</div>
</div>
</div>`;
}

html += `
<div style="text-align:center;margin-top:2rem">
<button class="btn danger" onclick="restartAfterDeath()" style="font-size:1.2rem;padding:1rem 2rem">Return to Ribbleton</button>
</div>
</div>`;

v.innerHTML = html;
}

function purchaseSigilUpgrade(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }

// Check max level: actives max at perm L4 (displays as L5), passives max at perm L5
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const permLevel = S.sig[sig] || 0;
const maxLevel = isActive ? 4 : 5;

if(permLevel >= maxLevel) {
toast('Already at maximum level!', 1800);
return;
}

S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
S.sigUpgradeCounts[sig] = (S.sigUpgradeCounts[sig] || 0) + 1;
// Going Rate increase formula: first 5 upgrades +5 each, next 5 +10 each, next 5 +15 each, etc.
const totalUpgradesBefore = Object.values(S.sigUpgradeCounts).reduce((a, b) => a + b, 0) - 1; // -1 because we just incremented
const tier = Math.floor(totalUpgradesBefore / 5);
const rateIncrease = 5 * (tier + 1);
S.goingRate += rateIncrease;
// QUEST TRACKING: Upgrade purchased
trackQuestProgress('upgrade');
// JUICE: Power up sound for sigil upgrade
SoundFX.play('powerUp');
const displayLevel = actives.includes(sig) ? S.sig[sig] + 1 : S.sig[sig];
toast(`${sig} upgraded to L${displayLevel}!`, 1200);
savePermanent();
showDeathScreen(); // Refresh
}

function unlockSigilCategory(category) {
const costs = { advanced: 20, passive: 50 };
const cost = costs[category];
if(!cost) { toast('Invalid category!'); return; }
if(S.gold < cost) { toast('Not enough Gold!'); return; }

S.gold -= cost;
if(category === 'advanced') {
S.advancedSigilsUnlocked = true;
SoundFX.play('powerUp');
toast('Advanced Sigils Unlocked!', 1500);
} else if(category === 'passive') {
S.passiveSigilsUnlocked = true;
SoundFX.play('powerUp');
toast('Passive Sigils Unlocked!', 1500);
}
// Category unlocks do NOT increase Going Rate
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySellBack(sig) {
const permLevel = S.sig[sig] || 0;
if(permLevel <= 0) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
// Sell back: get gold, lower sigil level, no going rate change
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const oldLevel = isActive ? permLevel + 1 : permLevel;
S.gold += S.goingRate;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
const newPermLevel = S.sig[sig];
const newLevel = isActive ? newPermLevel + 1 : newPermLevel;
toast(`Sold ${sig} L${oldLevel}‚ÜíL${newLevel} for ${S.goingRate}G!`, 1800);
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySacrifice(sig) {
const permLevel = S.sig[sig] || 0;
if(permLevel <= 0) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
if(S.goingRate <= 1) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
// Sacrifice: get starting XP, lower sigil level, decrease going rate
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const oldLevel = isActive ? permLevel + 1 : permLevel;
const xpGained = S.goingRate;
S.startingXP += xpGained;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
S.goingRate = Math.max(1, S.goingRate - 5);
const newPermLevel = S.sig[sig];
const newLevel = isActive ? newPermLevel + 1 : newPermLevel;
toast(`Sacrificed ${sig} L${oldLevel}‚ÜíL${newLevel} for +${xpGained}XP permanently!`, 1800);
savePermanent();
showDeathScreen(); // Refresh
}

function restartAfterDeath() {
// Check if player has unspent gold
if(S.gold >= S.goingRate && !S.tutorialFlags.death_exit_warning) {
showTutorialPop('death_exit_warning', "Are you sure? This is some <span style='font-size:0.7em'>great value</span> and you'll end up giving it to me sooner or later...", () => {
// After tutorial, ask for confirmation
showConfirmModal('Leave Death Screen with unspent gold?', () => {
actuallyRestartAfterDeath();
}, () => {
showDeathScreen();
});
});
return;
}
actuallyRestartAfterDeath();
}

function actuallyRestartAfterDeath() {
// Increment run number
S.runNumber++;

// Check if this was the forced FU entry (after first Standard win)
if(S.forcedFUEntry) {
S.forcedFUEntry = false;
S.gameMode = 'Standard'; // Reset to Standard mode
savePermanent();
showFUIntroPopup();
return;
}

savePermanent();
// Clear run-specific save (slot-specific)
if(S.currentSlot) {
localStorage.removeItem(`froggle8_slot${S.currentSlot}`);
}
// Also clear old save format for backwards compatibility
localStorage.removeItem('froggle8');
// Return to Ribbleton hub
toast('Returning to Ribbleton...', 1200);
setTimeout(() => transitionScreen(showRibbleton), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}

// Popup explaining Standard vs FU paths after first FU taste
function showFUIntroPopup() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="max-width:600px;margin:2rem auto;padding:2rem;background:linear-gradient(135deg,#1e1b4b 0%,#312e81 100%);border-radius:12px;border:3px solid #22c55e;color:#fff;text-align:center">
<h2 style="margin-bottom:1.5rem;font-size:1.8rem;color:#22c55e">üê∏ Welcome to the Endgame! üê∏</h2>

<p style="margin-bottom:1.5rem;font-size:1.1rem;line-height:1.6">
You've conquered the Flydra and saved Tapo once... but there's always more to do!
</p>

<div style="display:flex;gap:1rem;justify-content:center;flex-wrap:wrap;margin:2rem 0">
<div style="flex:1;min-width:200px;background:rgba(59,130,246,0.2);border:2px solid #3b82f6;border-radius:8px;padding:1rem">
<h3 style="color:#3b82f6;margin-bottom:0.5rem">üîµ Standard Runs</h3>
<p style="font-size:0.9rem;color:#94a3b8">Earn <strong style="color:#fbbf24">Figurines</strong> for surviving heroes. Permanently boost your stats!</p>
</div>

<div style="flex:1;min-width:200px;background:rgba(34,197,94,0.2);border:2px solid #22c55e;border-radius:8px;padding:1rem">
<h3 style="color:#22c55e;margin-bottom:0.5rem">üü¢ Frogged Up Runs</h3>
<p style="font-size:0.9rem;color:#94a3b8">Earn <strong style="color:#d97706">bonus Gold</strong> for upgrades. Higher risk, higher rewards!</p>
</div>
</div>

<p style="margin-bottom:1.5rem;font-size:0.95rem;color:#94a3b8">
Visit the <strong style="color:#3b82f6">Statue Room</strong> via the blue portal in Ribbleton to switch between modes!
</p>

<button class="btn" onclick="continueFUIntro()" style="padding:1rem 2rem;font-size:1.1rem">Got it! Back to Ribbleton</button>
</div>`;
}

function continueFUIntro() {
// Clear run-specific save
if(S.currentSlot) {
localStorage.removeItem(`froggle8_slot${S.currentSlot}`);
}
localStorage.removeItem('froggle8');
toast('Returning to Ribbleton...', 1200);
setTimeout(() => transitionScreen(showRibbleton), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}

// ===== CHAMPIONS MENU =====
function showChampionsMenu() {
const v = document.getElementById('gameView');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;

let html = `
<style>
@keyframes champions-portal-pulse {
  0%, 100% { transform: scale(1); opacity: 0.9; }
  50% { transform: scale(1.08); opacity: 1; }
}
@keyframes champions-portal-spin {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}
</style>
<div style="position:relative;max-width:800px;margin:0 auto">
<h1 style="text-align:center;margin:1rem 0;font-size:2rem;background:linear-gradient(135deg,#3b82f6,#f97316);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text">
üèÜ The Flydra's Conquerors üèÜ
</h1>

<div style="position:relative;width:100%;margin:0 auto">
<img src="assets/champions-hall.png" alt="The Champions Hall" style="width:100%;display:block;border-radius:8px;border:3px solid #000">

<!-- Clickable pedestal hotspot (center) -->
<div onclick="showPedestal()" style="position:absolute;left:35%;top:30%;width:30%;height:50%;cursor:pointer" title="View Pedestal"></div>

<!-- Clickable left portal (blue portal - leads to Ribbleton/Standard mode) -->
<div onclick="goToRibbleton()" style="position:absolute;left:5%;top:20%;width:20%;height:60%;cursor:pointer;display:flex;align-items:center;justify-content:center"
     onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'"
     title="Return to Ribbleton">
  <div style="width:90px;height:90px;position:relative;border-radius:50%;background:radial-gradient(circle, #3b82f6, #1e3a8a);animation:champions-portal-pulse 1.2s ease-in-out infinite;box-shadow:0 0 30px #3b82f6">
    <div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:3rem">üê∏</div>
  </div>
</div>

<!-- Clickable right portal (green-black portal - leads to FU mode) - no emoji, just ominous -->
<div onclick="enterPortal('fu')" style="position:absolute;right:5%;top:20%;width:20%;height:60%;cursor:pointer;transition:transform 0.2s;display:flex;align-items:center;justify-content:center"
     onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"
     title="${S.gameMode === 'fu' ? 'Current Mode' : 'Enter Frogged Up Realm'}">
  <div style="width:100px;height:100px;position:relative;border-radius:50%;background:radial-gradient(circle, #22c55e 0%, #0a0a0a 60%, #000 100%);animation:champions-portal-pulse 1s ease-in-out infinite;box-shadow:0 0 40px rgba(34,197,94,0.5), inset 0 0 30px rgba(0,0,0,0.8)">
  </div>
</div>
</div>

<div style="text-align:center;margin-top:1.5rem;padding:1rem;background:rgba(251,191,36,0.1);border:2px solid #3b82f6;border-radius:8px">
<p style="margin:0.5rem 0;font-size:1rem"><strong>Current Mode:</strong> <span style="color:${S.gameMode === 'fu' ? '#22c55e' : '#3b82f6'}">${S.gameMode === 'Standard' ? 'Standard' : 'FROGGED UP üî•'}</span></p>
<p style="margin:0.5rem 0;font-size:0.9rem;opacity:0.8">Click the <strong>pedestal</strong> to manage figurines (${pedestalCount}/${maxSlots})</p>
<p style="margin:0.5rem 0;font-size:0.9rem"><strong>üîµ Blue Portal:</strong> Standard Mode | <strong>üü¢ Green Portal:</strong> Frogged Up Mode</p>
</div>

<div style="text-align:center;margin-top:1rem">
<button class="btn secondary" onclick="title()">Back to Title</button>
</div>
</div>`;

v.innerHTML = html;
}

function enterPortal(targetMode) {
if(S.gameMode === targetMode) {
toast('You are already in this realm!');
return;
}
S.gameMode = targetMode;
savePermanent();
toast(`Entered ${targetMode === 'Standard' ? 'Standard' : 'Frogged Up üî•'} Realm!`);
// Go to hero select for the new mode
title();
}

function goToRibbleton() {
S.gameMode = 'Standard';
savePermanent();
SoundFX.play('portal');
toast('Returning to Ribbleton...', 1200);
setTimeout(() => transitionScreen(showRibbleton), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}

// NOTE: Waiting on Champions Hall toggle button image asset from Preston
// This function will be used for a visual toggle button in the Champions menu
function toggleModeFromChampions() {
S.gameMode = S.gameMode === 'Standard' ? 'fu' : 'Standard';
document.body.classList.toggle('fu-mode', S.gameMode === 'fu');
showChampionsMenu();
}

// ===== PEDESTAL UI =====
function showPedestal() {
const v = document.getElementById('gameView');
const heroes = ['Warrior', 'Tank', 'Mage', 'Healer'];
const stats = ['POW', 'HP'];

// Build 8 slots in 4x2 grid over the pedestal image
// Slots are positioned to overlay the cubbies in the pedestal art
let slotsHTML = '';
heroes.forEach((hero, colIdx) => {
stats.forEach((stat, rowIdx) => {
const slotted = S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
const isSlotted = !!slotted;

// Position 4 columns x 2 rows of slots centered on the pedestal cubbies
// Top row: POW slots, Bottom row: HP slots
const left = 12 + (colIdx * 19.5); // 4 columns across the pedestal width
const top = 32 + (rowIdx * 22); // 2 rows on the pedestal

slotsHTML += `
<div style="position:absolute;left:${left}%;top:${top}%;width:17%;height:18%;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:transform 0.15s"
     onclick="${isSlotted ? `removeFigurine('${hero}','${stat}')` : `slotFigurine('${hero}','${stat}')`}"
     onmouseenter="this.style.transform='scale(1.1)'" onmouseleave="this.style.transform='scale(1)'">`;

if(isSlotted) {
// Show frog emoji when slot is filled
slotsHTML += `<div style="font-size:2.5rem;filter:drop-shadow(0 2px 6px rgba(0,0,0,0.8));animation:frogBounce 1.5s ease-in-out infinite">üê∏</div>`;
} else {
// Empty slot - subtle indicator
slotsHTML += `<div style="width:80%;height:80%;background:rgba(0,0,0,0.2);border:2px dashed rgba(255,255,255,0.3);border-radius:6px;display:flex;align-items:center;justify-content:center">
<span style="font-size:1.2rem;color:rgba(255,255,255,0.4)">+</span>
</div>`;
}

slotsHTML += `</div>`;
});
});

// Labels for heroes across the top
let heroLabelsHTML = '<div style="position:absolute;top:18%;left:10%;right:10%;display:flex;justify-content:space-around">';
heroes.forEach(hero => {
heroLabelsHTML += `<div style="text-align:center;color:#fff;text-shadow:0 2px 4px rgba(0,0,0,0.9);font-size:0.8rem;font-weight:bold">${hero}</div>`;
});
heroLabelsHTML += '</div>';

// Stat labels on the left side
let statLabelsHTML = `
<div style="position:absolute;left:3%;top:38%;color:#fbbf24;font-weight:bold;text-shadow:0 2px 4px rgba(0,0,0,0.9);font-size:0.9rem">POW</div>
<div style="position:absolute;left:3%;top:60%;color:#ef4444;font-weight:bold;text-shadow:0 2px 4px rgba(0,0,0,0.9);font-size:0.9rem">HP</div>`;

// Count placed figurines
const placedCount = S.pedestal.filter(p => p.mode === S.gameMode).length;

let html = `
<div style="width:100%;height:100vh;position:relative;background:#1a1a1a;overflow:hidden">
<!-- Pedestal image as background, centered -->
<div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:95%;height:90%;background-image:url('assets/neutrals/statue2.png');background-size:contain;background-position:center;background-repeat:no-repeat">
${heroLabelsHTML}
${statLabelsHTML}
${slotsHTML}
</div>

<!-- Header overlay -->
<div style="position:absolute;top:1rem;left:50%;transform:translateX(-50%);text-align:center;z-index:10">
<h2 style="margin:0;color:#fbbf24;text-shadow:0 2px 8px rgba(0,0,0,0.9);font-size:1.3rem">‚ö±Ô∏è Pedestal of Champions</h2>
<p style="margin:0.25rem 0;font-size:0.85rem;color:#fff;text-shadow:0 2px 4px rgba(0,0,0,0.8)">${S.gameMode} Mode - ${placedCount}/8 figurines placed</p>
</div>

<!-- Back button -->
<div style="position:absolute;bottom:2rem;left:50%;transform:translateX(-50%);z-index:10">
<button class="btn secondary" onclick="showChampionsMenu()" style="padding:0.75rem 2rem">Back to Victory Room</button>
</div>
<style>
@keyframes frogBounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}
</style>
</div>`;

v.innerHTML = html;
}

function slotFigurine(hero, stat) {
// Check if slot is available
if(S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode)) {
toast('Slot already filled!');
return;
}

// Check if we have 8 slots filled
const slotsUsed = S.pedestal.filter(p => p.mode === S.gameMode).length;
if(slotsUsed >= 8) {
toast('All 8 slots filled! Remove a figurine first.');
return;
}

// Check if this hero can have a figurine (max 2 per hero per mode)
const existingCount = S.pedestal.filter(p => p.hero === hero && p.mode === S.gameMode).length;
if(existingCount >= 2) {
toast(`${hero} already has 2 figurines in ${S.gameMode} mode!`, 1800);
return;
}

// Check if hero already slotted their figurine THIS victory session (1 per hero per victory)
if(window.heroesSlottedThisVictory && window.heroesSlottedThisVictory.includes(hero)) {
toast(`${hero} already placed their figurine this victory!`, 1800);
return;
}

// Check if hero earned a figurine this victory (only survivors who aren't maxed)
if(window.earnedFigurines && !window.earnedFigurines.includes(hero)) {
toast(`${hero} didn't earn a figurine this victory!`, 1800);
return;
}

// Place the hero figurine
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'hero'});
// Track that this hero slotted their figurine this victory
if(!window.heroesSlottedThisVictory) window.heroesSlottedThisVictory = [];
window.heroesSlottedThisVictory.push(hero);
savePermanent();
toast(`${hero} ${stat} figurine placed!`, 1800);
showPedestal();
}

function removeFigurine(hero, stat) {
const idx = S.pedestal.findIndex(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
if(idx >= 0) {
S.pedestal.splice(idx, 1);
savePermanent();
toast(`${hero} ${stat} figurine removed!`);
showPedestal();
}
}

// ===== WIN =====
function win() {
// JUICE: Victory music and treasure sound!
ProceduralMusic.playVictory();
SoundFX.play('treasure');

// Record victory to The Pond!
recordPondHistory('victory');

// QUEST TRACKING: Run completed, victory, hero wins
trackQuestProgress('runComplete');
if(S.gameMode === 'fu') {
  trackQuestProgress('fuWin');
} else {
  trackQuestProgress('standardWin');
}
S.heroes.forEach(hero => {
  trackQuestProgress('heroWin', hero.n);
});

// Reset run state on victory (gold persists between runs)
S.xp = 0; // Clear XP earned this run
S.levelUpCount = 0; // Reset level up count
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0}; // Clear temp upgrades
S.recruits = []; // Clear recruits
savePermanent();

// Award figurines for heroes who survived (HP > 0, not Last Stand)
const survivedHeroes = S.heroes.filter(h => h.h > 0 && !h.ls);
const earnedFigurines = [];
const maxedHeroes = [];
survivedHeroes.forEach(h => {
// Check if this hero already has 2 figurines for this mode
const existingCount = S.pedestal.filter(slot => slot.hero === h.n && slot.mode === S.gameMode).length;
if(existingCount < 2) {
earnedFigurines.push(h.n);
} else {
maxedHeroes.push(h.n);
}
});

// Award 25 gold per maxed hero
if(maxedHeroes.length > 0) {
const goldReward = maxedHeroes.length * 25;
S.gold += goldReward;
window.maxedHeroesGold = { heroes: maxedHeroes, gold: goldReward };
} else {
window.maxedHeroesGold = null;
}

// Unlock Frogged Up mode if Standard victory
const firstStandardVictory = S.gameMode === 'Standard' && !S.tutorialFlags.first_victory_sequence;
if(S.gameMode === 'Standard') {
S.fuUnlocked = true;
if(firstStandardVictory) {
S.tutorialFlags.first_victory_sequence = true;
}
}

const firstFU = S.gameMode === 'fu' && !S.tutorialFlags.first_fu_victory;
if(firstFU) {
S.tutorialFlags.first_fu_victory = true;
// Note: Tapo is now unlocked at Floor 20 via Old Tapo encounter
}

savePermanent();

// Store earned figurines for later display
window.earnedFigurines = earnedFigurines;
// Reset per-victory slotting tracker (each hero can only slot 1 figurine per victory)
window.heroesSlottedThisVictory = [];

// FIRST STANDARD VICTORY: Show cutscene
if(firstStandardVictory) {
showFirstVictoryCutscene();
return;
}

// FIRST FU VICTORY: Show credits
if(firstFU) {
showFUVictoryCredits();
return;
}

// TAPO IN PARTY: Show heartfelt thank you (only if Tapo is alive)
const tapoInParty = S.heroes.some(h => h.n === 'Tapo' && h.h > 0 && !h.ls);
if(tapoInParty && !S.tutorialFlags.tapo_victory_message) {
S.tutorialFlags.tapo_victory_message = true;
savePermanent();
showTapoVictoryMessage();
return;
}

// SUBSEQUENT VICTORIES: Go directly to Pedestal if figurines earned
if(earnedFigurines.length > 0) {
showStatueRoom();
return;
}

// No figurines earned: show simple victory screen
showSimpleVictoryScreen();
}

function showFirstVictoryCutscene() {
// Build dynamic stats text based on what was slotted
const getSlottedStatsText = () => {
const slotted = S.pedestal.filter(p => p.mode === S.gameMode);
if(slotted.length === 0) return "The statues remain unslotted... for now.";
const statTexts = slotted.map(p => `${p.hero} ${p.stat === 'POW' ? '+1 POW' : '+5 HP'}`);
return statTexts.join('! ') + '!';
};

const slides = [
{bg: 'assets/victory-room.png', text: "After traversing 19 precarious floors, you finally come upon the still form of <strong style='color:#22c55e'>Tapo the Tadpole</strong>..."},
{bg: 'assets/victory-room.png', text: "Perhaps he succumbed to the FLYDRA's terrible bite? The heroes gather around Tapo..."},
{bg: 'assets/victory-room.png', text: "With a start, the little tadpole suddenly awakens from his well-earned nap! Clutched in his budding appendages, he holds carvings of the heroes who saved him!"},
{bg: 'assets/victory-room.png', text: "The heroes notice that the statues are juuust the right size to slot into the nearby pedestal!", action: 'statue_slotting'},
{bg: 'assets/victory-room.png', text: () => `As the statues click into place, a warm ripple of power surges through the heroes. <strong style='color:#fbbf24'>${getSlottedStatsText()}</strong>`, dynamic: true},
{bg: 'assets/victory-room.png', text: "Exhausted but tingling with power, the heroes hoist Tapo onto their shoulders and begin the long journey back to Ribbleton. Wait... What's this portal?"},
{bg: 'assets/ribbleton.png', text: "WHOOSH! One portal trip later, and the crew is back safe and sound in Ribbleton. Off to the Lilypad Pond for a well-earned night of sleep!"},
{bg: 'assets/ribbleton.png', text: "INTERSTITIAL_HERO_CARDS", action: 'hero_cards_interstitial'},
{bg: 'assets/ribbleton.png', text: "As the sun rises, the town of Ribbleton awakens, delighted to see their heroes home safe. There is only one problem... Where is Tapo? Our heroes gear up and take the portal back to the statue room where they found him last time."},
{bg: 'assets/victory-room.png', bgStyle: 'transform:scaleX(-1)', text: "...and there he is! Staring at YET ANOTHER portal, this one crackling with black and green energy. But before anyone can stop him, the little bugger squirms his way in. <span style='font-size:1.2em;font-weight:bold;color:#22c55e'>Here we go again!</span>"}
];

// Custom slide handler for statue slotting and hero cards
window.firstVictorySlideAction = (action, slideIndex, callback) => {
if(action === 'statue_slotting') {
showFirstVictoryPedestal(() => {
callback();
});
return true;
}
if(action === 'hero_cards_interstitial') {
showVictoryHeroCardsInterstitial(() => {
callback();
});
return true;
}
return false;
};

slides.onComplete = () => {
window.firstVictorySlideAction = null;
// Force player into FU mode for their first taste!
S.gameMode = 'fu';
S.forcedFUEntry = true; // Track that this is the forced entry
savePermanent();
toast('Tapo has entered the Frogged Up realm! You must follow!', 2500);
setTimeout(() => title(), T(1500));
};

showNarrativeSlide(slides, 0);
}

// Hero cards interstitial showing final stats
function showVictoryHeroCardsInterstitial(onComplete) {
const v = document.getElementById('gameView');

// Get pedestal bonuses for display
// Standard mode statues apply in both modes, FU statues only in FU mode
const getPedestalBonus = (heroName) => {
const bonuses = S.pedestal.filter(p => {
if(p.hero !== heroName) return false;
// Standard mode bonuses always apply, FU bonuses only in FU mode
if(p.mode === 'fu' && S.gameMode !== 'fu') return false;
return true;
});
if(bonuses.length === 0) return '';
return bonuses.map(b => b.stat === 'POW' ? '+1üí•' : '+5‚ù§').join(' ');
};

// Build hero cards
let heroCardsHTML = '<div style="display:flex;flex-wrap:wrap;justify-content:center;gap:1rem;margin:1.5rem 0">';
S.heroes.forEach(hero => {
const pedestalBonus = getPedestalBonus(hero.n);
const sigilsHTML = hero.s.map(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const displayLevel = ['Expand', 'Asterisk', 'Star'].includes(sig) ? level : level + 1;
return `<span style="background:#1e293b;padding:2px 6px;border-radius:4px;font-size:0.75rem;margin:2px">${sigilIconOnly(sig)}L${displayLevel}</span>`;
}).join(' ');
heroCardsHTML += `
<div style="background:linear-gradient(135deg,#1e3a5f,#0f172a);border:3px solid #22c55e;border-radius:12px;padding:1rem;min-width:140px;text-align:center">
<div style="font-size:1.2rem;font-weight:bold;color:#22c55e;margin-bottom:0.5rem">${hero.n}</div>
<div style="font-size:0.9rem;margin-bottom:0.5rem">${hero.p}üí• | ${hero.m}‚ù§</div>
${pedestalBonus ? `<div style="font-size:0.8rem;color:#fbbf24;margin-bottom:0.5rem">üóø ${pedestalBonus}</div>` : ''}
<div style="font-size:0.7rem">${sigilsHTML}</div>
</div>`;
});
heroCardsHTML += '</div>';

v.innerHTML = `
<div style="max-width:700px;margin:0 auto;padding:2rem;background:linear-gradient(135deg,#0f172a 0%,#1e3a5f 100%);border-radius:12px;border:3px solid #22c55e;color:#fff;text-align:center">
<h2 style="margin-bottom:0.5rem;color:#22c55e;font-size:1.8rem">üèÜ Congratulations! üèÜ</h2>
<p style="margin-bottom:1.5rem;font-size:1.1rem">You've cleared Standard Mode!</p>
${heroCardsHTML}
<p style="margin-top:1.5rem;font-size:0.9rem;color:#94a3b8">Your heroes rest peacefully in Ribbleton...</p>
<div style="margin-top:2rem">
<button class="btn" onclick="window.heroCardsInterstitialComplete()" style="padding:1rem 2rem;font-size:1.1rem">Continue</button>
</div>
</div>`;

window.heroCardsInterstitialComplete = onComplete;
}

function showFirstVictoryPedestal(onComplete) {
// Show a simplified pedestal UI during the first victory cutscene
const v = document.getElementById('gameView');
const heroIcons = {'Warrior': '‚öî', 'Tank': 'üõ°', 'Mage': 'üìñ', 'Healer': '‚úö'};
const stats = ['POW', 'HP'];

// Get earned figurines - only heroes who earned one this run
const earnedFigurines = window.earnedFigurines || [];
const totalToSlot = earnedFigurines.length;

// Track which heroes have slotted THIS session (to enforce 1 figurine per hero per victory)
if(!window.heroesSlottedThisVictory) window.heroesSlottedThisVictory = [];
const slotsThisSession = window.heroesSlottedThisVictory.length;

// Only show heroes who earned figurines
const heroesToShow = earnedFigurines.length > 0 ? earnedFigurines : ['Warrior', 'Tank', 'Mage', 'Healer'];

// Build slot grid - only for heroes who earned figurines
let slotsHTML = `<div style="display:grid;grid-template-columns:repeat(${Math.min(heroesToShow.length, 4)},1fr);gap:1rem;margin:1rem 0">`;
stats.forEach((stat) => {
heroesToShow.forEach((hero) => {
const slotted = S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
const isSlotted = !!slotted;
// Can only slot if: hero earned a figurine AND this slot not filled AND hero hasn't slotted THIS victory session
const heroAlreadySlottedThisVictory = window.heroesSlottedThisVictory.includes(hero);
const canSlot = earnedFigurines.includes(hero) && !isSlotted && !heroAlreadySlottedThisVictory;

slotsHTML += `
<div style="background:${isSlotted ? 'rgba(251,191,36,0.3)' : 'rgba(255,255,255,0.1)'};border:2px solid ${isSlotted ? '#fbbf24' : 'rgba(255,255,255,0.3)'};border-radius:8px;padding:1rem;text-align:center;${canSlot ? 'cursor:pointer' : 'opacity:0.5'}" onclick="${canSlot ? `slotFirstVicFigurine('${hero}','${stat}')` : ''}">
<div style="font-size:1.5rem">${heroIcons[hero] || 'üê∏'}</div>
<div style="font-size:0.8rem;font-weight:bold">${hero}</div>
<div style="font-size:0.7rem;color:#94a3b8">${stat === 'POW' ? '+1 POW' : '+5 HP'}</div>
${isSlotted ? '<div style="color:#fbbf24;font-size:0.8rem;margin-top:0.5rem">‚úì Slotted</div>' : (canSlot ? '<div style="color:#64748b;font-size:0.8rem;margin-top:0.5rem">Click to slot</div>' : '')}
</div>`;
});
});
slotsHTML += '</div>';

// Check if all earned figurines have been slotted
const allSlotted = slotsThisSession >= totalToSlot;
const buttonDisabled = !allSlotted && totalToSlot > 0;

v.innerHTML = `
<div style="max-width:800px;margin:0 auto;padding:2rem;background:linear-gradient(135deg,#1e1b4b 0%,#312e81 100%);border-radius:12px;border:3px solid #fbbf24;color:#fff">
<h2 style="text-align:center;margin-bottom:1rem;color:#fbbf24">‚ö±Ô∏è Slot Your Figurines!</h2>
<p style="text-align:center;margin-bottom:1rem;font-size:0.95rem">Each surviving hero earns a figurine! Place them to permanently boost that hero's stats.</p>
<p style="text-align:center;margin-bottom:1rem;font-size:1.1rem;color:${allSlotted ? '#22c55e' : '#fbbf24'}">
<strong>Figurines placed: ${slotsThisSession}/${totalToSlot}</strong>
</p>
${slotsHTML}
<div style="text-align:center;margin-top:1.5rem">
<button class="btn" onclick="window.firstVicPedestalComplete()" style="padding:1rem 2rem;font-size:1.1rem" ${buttonDisabled ? 'disabled' : ''}>
${buttonDisabled ? `Slot all ${totalToSlot} figurines to continue` : 'Continue Story'}
</button>
</div>
</div>`;

window.firstVicPedestalComplete = onComplete;
}

function slotFirstVicFigurine(hero, stat) {
if(S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode)) {
toast('Slot already filled!');
return;
}
// Check if this hero already slotted their figurine THIS victory session
if(window.heroesSlottedThisVictory && window.heroesSlottedThisVictory.includes(hero)) {
toast(`${hero} already placed their figurine!`);
return;
}
const slotsUsed = S.pedestal.filter(p => p.mode === S.gameMode).length;
if(slotsUsed >= 8) {
toast('All 8 slots filled! Remove a figurine first.');
return;
}
const existingCount = S.pedestal.filter(p => p.hero === hero && p.mode === S.gameMode).length;
if(existingCount >= 2) {
toast(`${hero} already has 2 figurines in ${S.gameMode} mode!`, 1800);
return;
}
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'hero'});
// Track that this hero has slotted their figurine this victory session
if(!window.heroesSlottedThisVictory) window.heroesSlottedThisVictory = [];
window.heroesSlottedThisVictory.push(hero);
savePermanent();
toast(`${hero} ${stat} figurine placed!`, 1200);
showFirstVictoryPedestal(window.firstVicPedestalComplete);
}

function removeFirstVicFigurine(hero, stat) {
const idx = S.pedestal.findIndex(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
if(idx >= 0) {
S.pedestal.splice(idx, 1);
savePermanent();
toast(`${hero} ${stat} figurine removed!`);
showFirstVictoryPedestal(window.firstVicPedestalComplete);
}
}

function showFUVictoryCredits() {
const v = document.getElementById('gameView');

// Check if this is a Tapo victory (gated behind beating FU with Tapo)
const tapoInParty = S.heroes.some(h => h.n === 'Tapo');

v.innerHTML = `
<div style="max-width:600px;margin:2rem auto;padding:2rem;background:linear-gradient(135deg,#1e1b4b 0%,#7c2d12 100%);border-radius:12px;border:3px solid #22c55e;color:#fff">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem">üî• FROGGED UP MODE CONQUERED! üî•</h1>

<div style="text-align:center;margin-bottom:2rem;font-size:1.2rem;line-height:1.8">
<p>Holy frog. You defeated the ${tapoInParty ? '(second) ' : ''}hardest challenge in FROGGLE.</p>
<p style="margin-top:1rem">Thank you for playing. No other thank yous really matter - <strong>YOU</strong>, the Player, deserve all the thanks in the world.</p>
${!tapoInParty ? `<p style="margin-top:1.5rem;font-style:italic;color:#fbbf24">Now, think you can beat the FROGGED UP Flydra with Tapo in your party?</p>` : ''}
<p style="font-size:2rem;margin:2rem 0">‚ù§Ô∏è</p>
</div>

<div style="background:rgba(0,0,0,0.3);padding:1.5rem;border-radius:8px;margin:2rem 0">
<h3 style="text-align:center;margin-bottom:1rem;color:#22c55e">FROGGLE</h3>
<div style="text-align:center;font-size:0.9rem;line-height:2;opacity:0.9">
<p><strong>A DubsPubs game by Preston Wesley Evans</strong></p>
<p>Design, Art, & Code: Preston + Claude</p>
<p>Playtesting: Michael Griffin, Charlie Schmidt, Carolyn Powell, Matt Sutz, Ryan Evertz</p>
<p>Inspiration: Inscryption, Slay the Spire, Balatro, and too much coffee</p>
<p>Sanity: Erin Keif, Adal Rfai, JPC, Odell Brewing</p>
<p>Support: Lisa Evans</p>
</div>
</div>

<div style="background:rgba(251,191,36,0.2);padding:1.5rem;border-radius:8px;margin:2rem 0;border:2px solid #22c55e">
<h3 style="text-align:center;margin-bottom:1rem">üéâ TAPO UNLOCKED! üéâ</h3>
<img src="assets/tapo.png" alt="Tapo the Tadpole" style="max-width:200px;height:auto;display:block;margin:1rem auto;border-radius:8px">
<p style="text-align:center;margin-top:1rem">Tapo the Tadpole is now available as a playable hero!</p>
<p style="text-align:center;font-size:0.9rem;opacity:0.8;margin-top:0.5rem">Stats: 1 POW, 1 HP ‚Ä¢ Starts with D20 + any upgraded passives</p>
<p style="text-align:center;font-size:0.85rem;opacity:0.6;margin-top:0.5rem;font-style:italic">(Glass cannon mode activated)</p>
</div>

<div style="text-align:center">
<button class="btn safe" onclick="showStatueRoom()" style="padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem">Place Figurines</button>
<button class="btn" onclick="title()" style="padding:1rem 2rem;font-size:1.1rem">Play Again</button>
</div>
</div>`;
}

function showTapoVictoryMessage() {
const v = document.getElementById('gameView');
v.innerHTML = `
<style>
@keyframes tapoSignatureVictory {
  /* Double jump RIGHT */
  0% { transform: translateY(0) scaleX(1); }
  10% { transform: translateY(-30px) scaleX(1); }
  20% { transform: translateY(0) scaleX(1); }
  30% { transform: translateY(-40px) scaleX(1); }
  40% { transform: translateY(0) scaleX(1); }
  /* Flip to LEFT */
  45% { transform: translateY(-15px) scaleX(0); }
  50% { transform: translateY(0) scaleX(-1); }
  /* Double jump LEFT */
  60% { transform: translateY(-30px) scaleX(-1); }
  70% { transform: translateY(0) scaleX(-1); }
  80% { transform: translateY(-40px) scaleX(-1); }
  90% { transform: translateY(0) scaleX(-1); }
  /* Flip back to RIGHT */
  95% { transform: translateY(-15px) scaleX(0); }
  100% { transform: translateY(0) scaleX(1); }
}
</style>
<div style="max-width:700px;margin:2rem auto;padding:3rem;background:linear-gradient(135deg,#22c55e 0%,#10b981 50%,#059669 100%);border-radius:16px;border:4px solid #3b82f6;color:#fff;box-shadow:0 8px 32px rgba(0,0,0,0.3)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:3rem;text-shadow:2px 2px 4px rgba(0,0,0,0.3)">üèÜ VICTORY! üèÜ</h1>

<div style="text-align:center;margin:2rem 0">
<div style="display:inline-block;animation:tapoSignatureVictory 4.8s ease-in-out infinite">
<img src="assets/tapo-nobg.png" alt="Tapo celebrating" style="max-width:250px;height:auto;display:block;margin:0 auto 2rem auto">
</div>
</div>

<div style="background:rgba(0,0,0,0.2);padding:2rem;border-radius:12px;margin:2rem 0;border:2px solid rgba(251,191,36,0.5)">
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
Holy frog. I can't believe you put this much time into my silly little game.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
From the bottom of my heart, thank you for playing.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;font-weight:500">
I hope you had fun!
</p>
<p style="text-align:center;font-size:1.1rem;margin-top:2rem;font-style:italic;opacity:0.9">
-Preston
</p>
</div>

<div style="text-align:center;font-size:2.5rem;margin:2rem 0">
‚ù§Ô∏èüê∏‚ù§Ô∏è
</div>

<div style="text-align:center;margin-top:2rem">
${window.earnedFigurines && window.earnedFigurines.length > 0 ?
  '<button class="btn" onclick="showStatueRoom()" style="background:#3b82f6;color:#000;padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem;font-weight:bold">Place Figurines</button><br>' :
  ''}
<button class="btn" onclick="title()" style="background:#fff;color:#22c55e;padding:1rem 2rem;font-size:1.1rem;font-weight:bold">Play Again</button>
</div>
</div>`;
}

function showStatueRoom() {
// This redirects to the existing Pedestal UI
showTutorialPop('pedestal_first_placement', "Welcome to the Pedestal! Figurines are rewards for heroes who survive to victory. Place them here to permanently boost that hero's stats. Each hero can earn up to 2 figurines per difficulty mode.", () => {
showPedestal();
});
}

function showSimpleVictoryScreen() {
// JUICE: Funky frog beat for victory celebration (after fanfare)
setTimeout(() => ProceduralMusic.startTitleBeat(), 2000);
const v = document.getElementById('gameView');
let html = `
<h1 style="text-align:center;margin:2rem 0;font-size:2.5rem">üèÜ VICTORY! üèÜ</h1>`;

if(S.gameMode === 'fu') {
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1.2rem">You conquered the Frogged Up realm once again!<br>Impressive.</p>`;
} else {
html += `<img src="assets/tapo.png" alt="Tapo saved!" style="max-width:100%;height:auto;max-width:400px;margin:1rem auto;display:block;border-radius:8px;border:3px solid #000">`;
html += `<p style="text-align:center;margin-bottom:1rem;font-size:1.2rem;font-weight:bold">You saved Tapo the Tadpole!</p>`;

// Check if they've explored FU mode and show conditional text
const hasExploredFU = (S.pondHistory || []).some(r => r.gameMode === 'fu');
if(hasExploredFU) {
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1rem;color:#22c55e">Ready to try FROGGED UP mode again?</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1rem;color:#64748b">Have you explored the green portal in the statue room yet?</p>`;
}
}

if(window.earnedFigurines && window.earnedFigurines.length > 0) {
html += `<div style="background:rgba(251,191,36,0.1);padding:1rem;border-radius:8px;margin:1rem auto;max-width:500px">
<h3 style="text-align:center;margin-bottom:0.5rem">üèÜ Hero Figurines Earned! üèÜ</h3>
<p style="text-align:center">The following heroes can place figurines (Max 2 per frog):</p>
<ul style="list-style:none;padding:0;text-align:center">`;
window.earnedFigurines.forEach(name => {
html += `<li style="margin:0.5rem 0;font-weight:bold">${name}</li>`;
});
html += `</ul></div>`;
}

// Show gold reward for maxed heroes
if(window.maxedHeroesGold && window.maxedHeroesGold.heroes.length > 0) {
html += `<div style="background:rgba(234,179,8,0.15);padding:1rem;border-radius:8px;margin:1rem auto;max-width:500px;border:2px solid #fbbf24">
<p style="text-align:center;margin:0;color:#fbbf24;font-weight:bold">Each hero can earn only 2 statues - take <span style="color:#22c55e">${window.maxedHeroesGold.gold} gold</span> instead for ${window.maxedHeroesGold.heroes.length === 1 ? window.maxedHeroesGold.heroes[0] + ' who is' : window.maxedHeroesGold.heroes.join(' & ') + ' who are'} already maxed!</p>
</div>`;
}

html += `<div style="text-align:center;margin-top:2rem">
<button class="btn" onclick="showStatueRoom()" style="padding:1rem 2rem;font-size:1.1rem;margin-right:1rem">Place Figurines</button>
<button class="btn secondary" onclick="showRibbleton()" style="padding:1rem 2rem;font-size:1.1rem">Return to Ribbleton</button>
</div>`;

v.innerHTML = html;
}

// ===== QUEST BOARD SYSTEM =====
// Quest definitions - all quests are passive (no acceptance required)
const QUESTS = {
  // === TUTORIAL QUEST (Only visible if player did the tutorial) ===
  fly_muncher: {
    name: 'Fly Muncher',
    desc: 'Munch on a fly during the tutorial',
    reward: 1,
    category: 'learning',
    unlock: () => S.tutorialFlags.tutorial_fly_munched,  // Only shows if they did the tutorial and killed a fly
    check: () => S.tutorialFlags.tutorial_fly_munched
  },

  // === LEARNING QUESTS (Always visible) ===
  first_blood: {
    name: 'First Blood',
    desc: 'Defeat your first enemy',
    reward: 5,
    category: 'learning',
    check: () => S.questProgress.enemiesKilled >= 1
  },
  tactical_roller: {
    name: 'Tactical Roller',
    desc: 'Use the D20 sigil',
    reward: 5,
    category: 'learning',
    check: () => S.questProgress.d20Used
  },
  shield_bearer: {
    name: 'Shield Bearer',
    desc: 'Apply a shield to any hero',
    reward: 5,
    category: 'learning',
    check: () => S.questProgress.shieldApplied
  },
  healers_touch: {
    name: "Healer's Touch",
    desc: 'Heal any hero',
    reward: 5,
    category: 'learning',
    check: () => S.questProgress.healUsed
  },
  survivor: {
    name: 'Survivor',
    desc: 'Reach Floor 3',
    reward: 5,
    category: 'learning',
    check: () => S.questProgress.highestFloor >= 3
  },
  battle_hardened: {
    name: 'Battle Hardened',
    desc: 'Reach Floor 5',
    reward: 10,
    category: 'learning',
    check: () => S.questProgress.highestFloor >= 5
  },

  // === HERO EXPLORATION (Unlock after 1 run) ===
  warrior_path: {
    name: "Warrior's Path",
    desc: 'Play a run with Warrior',
    reward: 5,
    category: 'heroes',
    unlock: () => S.questProgress.totalRunsCompleted >= 1 || S.runsAttempted >= 2,
    check: () => S.questProgress.heroesPlayed.Warrior >= 1
  },
  tank_path: {
    name: "Tank's Path",
    desc: 'Play a run with Tank',
    reward: 5,
    category: 'heroes',
    unlock: () => S.questProgress.totalRunsCompleted >= 1 || S.runsAttempted >= 2,
    check: () => S.questProgress.heroesPlayed.Tank >= 1
  },
  mage_path: {
    name: "Mage's Path",
    desc: 'Play a run with Mage',
    reward: 5,
    category: 'heroes',
    unlock: () => S.questProgress.totalRunsCompleted >= 1 || S.runsAttempted >= 2,
    check: () => S.questProgress.heroesPlayed.Mage >= 1
  },
  healer_path: {
    name: "Healer's Path",
    desc: 'Play a run with Healer',
    reward: 5,
    category: 'heroes',
    unlock: () => S.questProgress.totalRunsCompleted >= 1 || S.runsAttempted >= 2,
    check: () => S.questProgress.heroesPlayed.Healer >= 1
  },
  diverse_squad: {
    name: 'Diverse Squad',
    desc: 'Play with all 4 base heroes',
    reward: 10,
    category: 'heroes',
    unlock: () => S.questProgress.totalRunsCompleted >= 1 || S.runsAttempted >= 2,
    check: () => S.questProgress.heroesPlayed.Warrior >= 1 && S.questProgress.heroesPlayed.Tank >= 1 && S.questProgress.heroesPlayed.Mage >= 1 && S.questProgress.heroesPlayed.Healer >= 1
  },
  champion_warrior: {
    name: 'Champion: Warrior',
    desc: 'Win a run with Warrior',
    reward: 20,
    category: 'heroes',
    unlock: () => S.questProgress.totalRunsCompleted >= 1,
    check: () => S.questProgress.heroWins.Warrior >= 1
  },
  champion_tank: {
    name: 'Champion: Tank',
    desc: 'Win a run with Tank',
    reward: 20,
    category: 'heroes',
    unlock: () => S.questProgress.totalRunsCompleted >= 1,
    check: () => S.questProgress.heroWins.Tank >= 1
  },
  champion_mage: {
    name: 'Champion: Mage',
    desc: 'Win a run with Mage',
    reward: 20,
    category: 'heroes',
    unlock: () => S.questProgress.totalRunsCompleted >= 1,
    check: () => S.questProgress.heroWins.Mage >= 1
  },
  champion_healer: {
    name: 'Champion: Healer',
    desc: 'Win a run with Healer',
    reward: 20,
    category: 'heroes',
    unlock: () => S.questProgress.totalRunsCompleted >= 1,
    check: () => S.questProgress.heroWins.Healer >= 1
  },
  army_of_frogs: {
    name: 'Army of Frogs',
    desc: 'Win with all 4 base heroes',
    reward: 20,
    category: 'heroes',
    unlock: () => S.questProgress.standardWins >= 1,
    check: () => S.questProgress.heroWins.Warrior >= 1 && S.questProgress.heroWins.Tank >= 1 && S.questProgress.heroWins.Mage >= 1 && S.questProgress.heroWins.Healer >= 1
  },

  // === NEUTRAL EXPLORATION (Unlock after Floor 2) ===
  neutral_shop: {
    name: 'The Shop',
    desc: 'Complete Shopkeeper encounter',
    reward: 5,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 2,
    check: () => S.questProgress.neutralsCompleted.shopkeeper
  },
  neutral_well: {
    name: 'Make a Wish',
    desc: 'Complete Wishing Well encounter',
    reward: 5,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 2,
    check: () => S.questProgress.neutralsCompleted.wishingwell
  },
  neutral_chest: {
    name: 'Treasure Hunter',
    desc: 'Complete Treasure Chest encounter',
    reward: 5,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 2,
    check: () => S.questProgress.neutralsCompleted.treasurechest
  },
  neutral_wizard: {
    name: "Wizard's Test",
    desc: 'Complete Wizard encounter',
    reward: 5,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 2,
    check: () => S.questProgress.neutralsCompleted.wizard
  },
  neutral_oracle: {
    name: "Oracle's Wisdom",
    desc: 'Complete Oracle encounter',
    reward: 5,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 2,
    check: () => S.questProgress.neutralsCompleted.oracle
  },
  neutral_camp: {
    name: 'Camp Visitor',
    desc: 'Complete Encampment encounter',
    reward: 5,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 2,
    check: () => S.questProgress.neutralsCompleted.encampment
  },
  neutral_gambling: {
    name: 'High Roller',
    desc: 'Complete Gambling Den encounter',
    reward: 5,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 2,
    check: () => S.questProgress.neutralsCompleted.gambling
  },
  neutral_ghost: {
    name: 'Ghost Whisperer',
    desc: 'Complete Ghost Boys encounter',
    reward: 5,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 2,
    check: () => S.questProgress.neutralsCompleted.ghost
  },
  neutral_royal: {
    name: 'Royal Audience',
    desc: 'Complete Royal Court encounter',
    reward: 5,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 2,
    check: () => S.questProgress.neutralsCompleted.royal
  },
  neutral_explorer: {
    name: 'Neutral Explorer',
    desc: 'Complete all Stage 1 neutrals',
    reward: 20,
    category: 'neutrals',
    unlock: () => S.questProgress.highestFloor >= 4,
    check: () => Object.values(S.questProgress.neutralsCompleted).every(v => v)
  },

  // === PROGRESSION MILESTONES ===
  dragon_slayer: {
    name: 'Dragon Slayer',
    desc: 'Defeat a Dragon',
    reward: 10,
    category: 'milestones',
    unlock: () => S.questProgress.highestFloor >= 10,
    check: () => S.questProgress.enemyTypesDefeated.Dragon
  },
  flydra_hunter: {
    name: 'Flydra Hunter',
    desc: 'Defeat a Flydra head',
    reward: 10,
    category: 'milestones',
    unlock: () => S.questProgress.highestFloor >= 15,
    check: () => S.questProgress.enemyTypesDefeated.Flydra
  },
  first_victory: {
    name: 'First Victory',
    desc: 'Complete Floor 20 (Standard)',
    reward: 20,
    category: 'milestones',
    check: () => S.questProgress.standardWins >= 1
  },
  eternal_power: {
    name: 'Eternal Power',
    desc: 'Purchase a permanent upgrade',
    reward: 10,
    category: 'milestones',
    unlock: () => S.runsAttempted >= 2,
    check: () => S.questProgress.purchasedUpgrade
  },
  spreading_wealth: {
    name: 'Spreading the Wealth',
    desc: 'Upgrade all sigils to L1',
    reward: 20,
    category: 'milestones',
    unlock: () => S.questProgress.purchasedUpgrade,
    check: () => Object.values(S.sig).every(v => v >= 1)
  },

  // === COMBAT MASTERY (Unlock after Floor 10) ===
  combo_striker: {
    name: 'Combo Striker',
    desc: 'Deal 10+ damage in one action',
    reward: 10,
    category: 'combat',
    unlock: () => S.questProgress.highestFloor >= 10,
    check: () => S.questProgress.maxDamageOneAction >= 10
  },
  multi_target: {
    name: 'Multi-Target',
    desc: 'Hit 3+ targets with one action',
    reward: 10,
    category: 'combat',
    unlock: () => S.questProgress.highestFloor >= 10,
    check: () => S.questProgress.maxTargetsOneAction >= 3
  },
  ghost_walk: {
    name: 'Ghost Walk',
    desc: 'Block damage with Ghost charges',
    reward: 10,
    category: 'combat',
    unlock: () => S.questProgress.highestFloor >= 10,
    check: () => S.questProgress.ghostBlocked
  },
  grappler: {
    name: 'Grappler',
    desc: 'Stun an enemy with Grapple',
    reward: 10,
    category: 'combat',
    unlock: () => S.questProgress.highestFloor >= 10,
    check: () => S.questProgress.grappleUsed
  },
  alpha_strike: {
    name: 'Alpha Strike',
    desc: 'Grant bonus actions with Alpha',
    reward: 10,
    category: 'combat',
    unlock: () => S.questProgress.highestFloor >= 10,
    check: () => S.questProgress.alphaUsed
  },
  last_stand_hero: {
    name: 'Last Stand Hero',
    desc: 'Survive a round in Last Stand',
    reward: 10,
    category: 'combat',
    unlock: () => S.questProgress.highestFloor >= 10,
    check: () => S.questProgress.lastStandSurvived
  },

  // === REPEATABLE/SCALING QUESTS ===
  slayer_1: {
    name: 'Slayer I',
    desc: 'Defeat 25 enemies',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.highestFloor >= 5,
    check: () => S.questProgress.enemiesKilled >= 25 && S.questProgress.slayerTier === 0
  },
  slayer_2: {
    name: 'Slayer II',
    desc: 'Defeat 100 enemies',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.slayerTier >= 1,
    check: () => S.questProgress.enemiesKilled >= 100 && S.questProgress.slayerTier === 1
  },
  slayer_3: {
    name: 'Slayer III',
    desc: 'Defeat 250 enemies',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.slayerTier >= 2,
    check: () => S.questProgress.enemiesKilled >= 250 && S.questProgress.slayerTier === 2
  },
  slayer_4: {
    name: 'Slayer IV',
    desc: 'Defeat 500 enemies',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.slayerTier >= 3,
    check: () => S.questProgress.enemiesKilled >= 500 && S.questProgress.slayerTier === 3
  },
  slayer_5: {
    name: 'Slayer V',
    desc: 'Defeat 1000 enemies',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.slayerTier >= 4,
    check: () => S.questProgress.enemiesKilled >= 1000 && S.questProgress.slayerTier === 4
  },
  gold_digger_1: {
    name: 'Gold Digger I',
    desc: 'Earn 250G total',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.highestFloor >= 5,
    check: () => S.questProgress.totalGoldEarned >= 250 && S.questProgress.goldDiggerTier === 0
  },
  gold_digger_2: {
    name: 'Gold Digger II',
    desc: 'Earn 1000G total',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.goldDiggerTier >= 1,
    check: () => S.questProgress.totalGoldEarned >= 1000 && S.questProgress.goldDiggerTier === 1
  },
  gold_digger_3: {
    name: 'Gold Digger III',
    desc: 'Earn 2500G total',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.goldDiggerTier >= 2,
    check: () => S.questProgress.totalGoldEarned >= 2500 && S.questProgress.goldDiggerTier === 2
  },
  veteran_1: {
    name: 'Veteran I',
    desc: 'Complete 5 runs',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.totalRunsCompleted >= 1,
    check: () => S.questProgress.totalRunsCompleted >= 5 && S.questProgress.veteranTier === 0
  },
  veteran_2: {
    name: 'Veteran II',
    desc: 'Complete 15 runs',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.veteranTier >= 1,
    check: () => S.questProgress.totalRunsCompleted >= 15 && S.questProgress.veteranTier === 1
  },
  veteran_3: {
    name: 'Veteran III',
    desc: 'Complete 30 runs',
    reward: 20,
    category: 'repeatable',
    unlock: () => S.questProgress.veteranTier >= 2,
    check: () => S.questProgress.totalRunsCompleted >= 30 && S.questProgress.veteranTier === 2
  },

  // === FU MODE QUESTS (Unlock after FU unlock) ===
  fu_taste: {
    name: 'This is Frogged Up',
    desc: 'Complete Floor 1 in FU mode',
    reward: 20,
    category: 'fu',
    unlock: () => S.fuUnlocked,
    check: () => (S.questProgress.highestFUFloor || 0) >= 1
  },
  recruiter: {
    name: 'Recruiter',
    desc: 'Recruit an enemy',
    reward: 10,
    category: 'fu',
    unlock: () => S.fuUnlocked,
    check: () => S.questProgress.maxRecruitsHeld >= 1
  },
  squad_goals: {
    name: 'Squad Goals',
    desc: 'Have 3 recruits at once',
    reward: 20,
    category: 'fu',
    unlock: () => S.questProgress.maxRecruitsHeld >= 1,
    check: () => S.questProgress.maxRecruitsHeld >= 3
  },
  fu_champion: {
    name: 'FU Champion',
    desc: 'Complete FU mode',
    reward: 20,
    category: 'fu',
    unlock: () => S.fuUnlocked,
    check: () => S.questProgress.fuWins >= 1
  },

  // === SECRET/HIDDEN QUESTS ===
  tapos_hero: {
    name: "Tapo's Hero",
    desc: 'Unlock Tapo',
    reward: 20,
    category: 'secret',
    unlock: () => S.fuUnlocked,
    check: () => S.tapoUnlocked
  },
  bruce_willis: {
    name: 'Bruce & Willis',
    desc: 'Help the Ghost Boys realize something',
    reward: 10,
    category: 'secret',
    unlock: () => S.questProgress.neutralsCompleted.ghost,
    check: () => S.ghostBoysConverted
  },
  true_champion: {
    name: 'True Champion',
    desc: 'Win FU mode with Tapo',
    reward: 20,
    category: 'secret',
    unlock: () => S.tapoUnlocked,
    check: () => S.questProgress.heroWins.Tapo >= 1 && S.questProgress.fuWins >= 1
  }
};

// Category display names and order
const QUEST_CATEGORIES = {
  learning: { name: 'Getting Started', icon: 'üìö', order: 1 },
  heroes: { name: 'Hero Exploration', icon: 'ü¶∏', order: 2 },
  neutrals: { name: 'Neutral Encounters', icon: 'üèïÔ∏è', order: 3 },
  milestones: { name: 'Milestones', icon: 'üèÜ', order: 4 },
  combat: { name: 'Combat Mastery', icon: '‚öîÔ∏è', order: 5 },
  repeatable: { name: 'Ongoing Challenges', icon: 'üîÑ', order: 6 },
  fu: { name: 'Frogged Up', icon: 'üî•', order: 7 },
  secret: { name: 'Secrets', icon: 'üîÆ', order: 8 }
};

// Check if a quest is unlocked (visible)
function isQuestUnlocked(questId) {
  const quest = QUESTS[questId];
  if(!quest) return false;
  // Learning quests always visible
  if(quest.category === 'learning') return true;
  // Check unlock condition if exists
  if(quest.unlock && !quest.unlock()) return false;
  return true;
}

// Check if a quest is complete (can be claimed)
function isQuestComplete(questId) {
  const quest = QUESTS[questId];
  if(!quest) return false;
  if(S.questsClaimed[questId]) return false; // Already claimed
  return quest.check();
}

// Get count of claimable quests
function getClaimableQuestCount() {
  let count = 0;
  for(const questId in QUESTS) {
    if(isQuestUnlocked(questId) && isQuestComplete(questId) && !S.questsClaimed[questId]) {
      count++;
    }
  }
  return count;
}

// Claim a quest reward
function claimQuest(questId) {
  const quest = QUESTS[questId];
  if(!quest || S.questsClaimed[questId]) return;
  if(!isQuestComplete(questId)) return;

  // Award gold
  S.gold += quest.reward;
  S.questsClaimed[questId] = true;
  S.questsCompleted[questId] = true;

  // Handle tier progression for repeatable quests
  if(questId.startsWith('slayer_')) {
    S.questProgress.slayerTier = parseInt(questId.split('_')[1]);
  } else if(questId.startsWith('gold_digger_')) {
    S.questProgress.goldDiggerTier = parseInt(questId.split('_')[1]);
  } else if(questId.startsWith('veteran_')) {
    S.questProgress.veteranTier = parseInt(questId.split('_')[1]);
  }

  savePermanent();
  SoundFX.play('coin');
  toast(`+${quest.reward}G from "${quest.name}"!`);

  // Refresh quest board
  showQuestBoard();
}

// Show Quest Board UI
function showQuestBoard() {
  const v = document.getElementById('gameView');

  // Group quests by category
  const questsByCategory = {};
  for(const questId in QUESTS) {
    const quest = QUESTS[questId];
    if(!questsByCategory[quest.category]) {
      questsByCategory[quest.category] = [];
    }
    questsByCategory[quest.category].push({ id: questId, ...quest });
  }

  // Sort categories by order
  const sortedCategories = Object.keys(questsByCategory).sort((a, b) =>
    (QUEST_CATEGORIES[a]?.order || 99) - (QUEST_CATEGORIES[b]?.order || 99)
  );

  // Calculate pending gold from unclaimed completed quests
  let pendingGold = 0;
  for(const questId in QUESTS) {
    if(isQuestComplete(questId) && !S.questsClaimed[questId]) {
      pendingGold += QUESTS[questId].reward;
    }
  }

  let html = `
<style>
.quest-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 0.75rem;
  margin: 0.25rem 0;
  background: rgba(255,255,255,0.1);
  border-radius: 6px;
  border: 2px solid transparent;
  transition: all 0.2s;
}
.quest-item.complete {
  border-color: #22c55e;
  background: rgba(34,197,94,0.15);
}
.quest-item.claimed {
  opacity: 0.5;
  border-color: #666;
}
.quest-item.locked {
  opacity: 0.4;
  filter: grayscale(0.5);
}
.quest-reward {
  font-weight: bold;
  color: #fbbf24;
  min-width: 50px;
  text-align: right;
}
.quest-claim-btn {
  background: linear-gradient(135deg, #22c55e, #16a34a);
  border: 2px solid #000;
  border-radius: 4px;
  padding: 0.25rem 0.75rem;
  font-weight: bold;
  cursor: pointer;
  color: #fff;
  font-size: 0.85rem;
  animation: pulse-glow 1.5s ease-in-out infinite;
}
@keyframes pulse-glow {
  0%, 100% { box-shadow: 0 0 5px #22c55e; }
  50% { box-shadow: 0 0 15px #22c55e; }
}
.quest-category {
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  padding: 0.75rem;
}
.quest-category-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: bold;
  font-size: 1.1rem;
  margin-bottom: 0.5rem;
  color: #fff;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  padding-bottom: 0.5rem;
}
</style>

<div style="max-width:600px;margin:0 auto;padding:1rem">
<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:1rem">
  <h1 style="margin:0;font-size:1.8rem;color:#fbbf24">üìã Quest Board</h1>
  <div style="font-size:1rem;color:#22c55e">üí∞ ${S.gold}G${pendingGold > 0 ? ` <span style="opacity:0.8">(+${pendingGold}G)</span>` : ''}</div>
</div>

<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem;opacity:0.8">Complete quests to earn gold rewards!</p>
`;

  for(const category of sortedCategories) {
    const quests = questsByCategory[category];
    const catInfo = QUEST_CATEGORIES[category] || { name: category, icon: 'üìã' };

    // Count unlocked quests in this category
    const unlockedQuests = quests.filter(q => isQuestUnlocked(q.id));
    if(unlockedQuests.length === 0) continue; // Skip empty categories

    // Count completed/claimed
    const claimable = unlockedQuests.filter(q => isQuestComplete(q.id) && !S.questsClaimed[q.id]).length;

    html += `
<div class="quest-category">
  <div class="quest-category-header">
    <span>${catInfo.icon}</span>
    <span>${catInfo.name}</span>
    ${claimable > 0 ? `<span style="background:#22c55e;color:#000;padding:0 0.5rem;border-radius:10px;font-size:0.8rem;margin-left:auto">${claimable} ready</span>` : ''}
  </div>`;

    for(const quest of quests) {
      const unlocked = isQuestUnlocked(quest.id);
      const complete = isQuestComplete(quest.id);
      const claimed = S.questsClaimed[quest.id];

      if(!unlocked) continue; // Don't show locked quests

      let statusClass = '';
      let statusText = '';
      if(claimed) {
        statusClass = 'claimed';
        statusText = '‚úì Claimed';
      } else if(complete) {
        statusClass = 'complete';
      }

      html += `
<div class="quest-item ${statusClass}">
  <div>
    <div style="font-weight:bold;font-size:0.95rem">${quest.name}</div>
    <div style="font-size:0.8rem;opacity:0.8">${quest.desc}</div>
  </div>
  <div style="display:flex;align-items:center;gap:0.5rem">
    ${claimed ? `<span style="color:#5a5550;font-size:0.85rem">${statusText}</span>` :
      complete ? `<button class="quest-claim-btn" onclick="claimQuest('${quest.id}')">Claim ${quest.reward}G</button>` :
      `<span class="quest-reward">${quest.reward}G</span>`}
  </div>
</div>`;
    }

    html += `</div>`;
  }

  html += `
<div style="text-align:center;margin-top:1.5rem">
  <button class="btn" onclick="showRibbleton()" style="padding:0.75rem 2rem">Back to Ribbleton</button>
</div>
</div>`;

  v.innerHTML = html;
}

// ===== RIBBLETON HUB =====
function showRibbleton() {
// Show game header in Ribbleton with location label
S.inRibbleton = true;
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';
// JUICE: Froggy beat for Ribbleton hub
ProceduralMusic.startFroggyBeat();
upd(); // Update header to show "Ribbleton"

const v = document.getElementById('gameView');

// Show tutorial for first-time visitors to Ribbleton hub (delayed to ensure screen is rendered first)
const isFirstVisit = !S.tutorialFlags.ribbleton_hub_intro;
if(isFirstVisit && !S.helpTipsDisabled) {
  setTimeout(() => {
    showTutorialPop('ribbleton_hub_intro', "Welcome home to Ribbleton! This is your safe haven between adventures. Click the glowing red portal on the right to begin your next rescue mission and save Tapo!");
  }, 500);
}

let html = `
<style>
@keyframes ribbleton-portal-pulse {
  0%, 100% { transform: scale(1); opacity: 0.9; box-shadow: 0 0 30px #dc2626; }
  50% { transform: scale(1.08); opacity: 1; box-shadow: 0 0 50px #dc2626; }
}
@keyframes ribbleton-portal-spin {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}
</style>
<div class="full-screen-content" style="position:relative;width:100%;overflow:hidden">
<!-- Full-page background image -->
<img src="assets/ribbleton.png" alt="" style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:0">

<!-- Title overlay at top -->
<div style="position:absolute;top:0;left:0;right:0;z-index:10;padding:1rem;background:linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.3) 70%, transparent 100%)">
<h1 style="text-align:center;margin:0;font-size:2rem;color:#22c55e;text-shadow:2px 2px 6px rgba(0,0,0,0.9), 0 0 20px rgba(34,197,94,0.5)">
üê∏ Welcome Home to Ribbleton! üê∏
</h1>
</div>


<!-- Lilypad Pond (bottom-left) - Blue circle portal, same size as red portal -->
${S.pondHistory && S.pondHistory.length > 0 ? `
<div style="position:absolute;bottom:1rem;left:1rem;z-index:10">
<div onclick="showPond()" style="cursor:pointer;transition:transform 0.2s;text-align:center"
     onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"
     title="Reflect on your adventures at the Lilypad Pond">
  <div style="width:120px;height:120px;position:relative;border-radius:50%;background:radial-gradient(circle, #3b82f6, #1e3a8a);animation:ribbleton-portal-pulse 1.2s ease-in-out infinite;box-shadow:0 0 40px #3b82f6">
    <div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:4rem">ü™∑</div>
  </div>
  <p style="margin-top:0.5rem;font-size:1rem;font-weight:bold;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.9);background:rgba(59,130,246,0.8);padding:0.25rem 0.75rem;border-radius:6px;border:2px solid #3b82f6">üåø The Pond</p>
</div>
</div>
` : ''}

<!-- Red Portal (bottom-right) - Always Available -->
<div style="position:absolute;bottom:1rem;right:1rem;z-index:10">
<div onclick="enterRedPortal()" style="cursor:pointer;transition:transform 0.2s;text-align:center"
     onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"
     title="Click to begin your adventure and save Tapo!">
  <div style="width:120px;height:120px;position:relative;border-radius:50%;background:radial-gradient(circle, #dc2626, #7c2d12);animation:ribbleton-portal-pulse 1s ease-in-out infinite;box-shadow:0 0 40px #dc2626">
    <div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:4rem">üë∫</div>
  </div>
  <p style="margin-top:0.5rem;font-size:1rem;font-weight:bold;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.9);background:rgba(220,38,38,0.8);padding:0.25rem 0.75rem;border-radius:6px;border:2px solid #dc2626">üê∏ Save Tapo!</p>
</div>
</div>

<!-- Quest Board in bottom-center -->
<div style="position:absolute;bottom:1rem;left:50%;transform:translateX(-50%);z-index:10">
  <div onclick="showQuestBoard()" style="cursor:pointer;transition:transform 0.2s;text-align:center"
       onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"
       title="View available quests and claim rewards">
    <div style="width:80px;height:80px;position:relative;background:linear-gradient(135deg, #92400e, #78350f);border-radius:8px;border:4px solid #451a03;box-shadow:0 4px 16px rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center">
      <span style="font-size:3rem">ü™ß</span>
      ${getClaimableQuestCount() > 0 ? `<span style="position:absolute;top:-8px;right:-8px;background:#22c55e;color:#000;font-weight:bold;font-size:0.9rem;padding:0.15rem 0.5rem;border-radius:10px;border:2px solid #000;animation:pulse-glow 1.5s ease-in-out infinite">${getClaimableQuestCount()}</span>` : ''}
    </div>
    <p style="margin-top:0.4rem;font-size:0.9rem;font-weight:bold;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.9);background:rgba(146,64,14,0.9);padding:0.2rem 0.6rem;border-radius:4px;border:2px solid #78350f">üìã Quests</p>
  </div>
</div>
</div>`;

v.innerHTML = html;
}

function enterRedPortal() {
S.inRibbleton = false;
SoundFX.play('portal');
toast('Preparing to enter the dungeon...', 1200);
setTimeout(() => transitionScreen(title), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}


// ===== DEBUG MODE =====
function toggleDebugMode(enabled) {
S.debugMode = enabled;
toast(enabled ? 'Debug Mode ON' : 'Debug Mode OFF', 1200);
// Update debug button visibility in header
const debugBtn = document.getElementById('debugBtn');
if(debugBtn) debugBtn.style.display = enabled ? 'block' : 'none';
// Refresh settings menu if open to show/hide debug tools button
const settingsMenu = document.querySelector('[style*="z-index:30000"]');
if(settingsMenu) {
closeSettingsMenu();
showSettingsMenu();
}
}

function toggleOopsAll20s(enabled) {
S.oopsAll20s = enabled;
toast(enabled ? 'üé≤ Oops All 20s: ON (All D20 rolls = 20!)' : 'üé≤ Oops All 20s: OFF', 1500);
// Refresh debug menu to update checkbox
const debugMenu = document.querySelector('[style*="z-index:30000"]');
if(debugMenu && debugMenu.textContent.includes('DEBUG MENU')) {
closeDebugMenu();
showDebugMenu();
}
}

function showDebugMenu() {
const inCombat = S.enemies && S.enemies.length > 0;
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha'];
const heroNames = S.heroes.map((h, i) => ({name: h.n, idx: i}));

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">üõ†Ô∏è DEBUG MENU üõ†Ô∏è</h2>

<h3 class="modal-section-title green">Resources</h3>
<button class="btn" onclick="debugAddGold()" style="margin-bottom:0.5rem;background:#22c55e">+100 Gold</button>
<button class="btn" onclick="debugAddXP()" style="margin-bottom:0.5rem;background:#22c55e">+100 XP</button>

<h3 class="modal-section-title green">Navigation</h3>
<div style="margin:0.5rem 0">
<label style="color:white;font-size:0.9rem">Jump to Floor:</label>
<input type="number" id="debugFloorInput" min="1" max="19" value="${S.floor}" style="width:60px;padding:0.25rem;margin:0 0.5rem;font-size:1rem">
<button class="btn" onclick="debugJumpFloor()" style="display:inline-block;width:auto;padding:0.5rem 1rem;margin:0;font-size:0.9rem;min-height:auto">Go</button>
</div>

<h3 class="modal-section-title green">Sigil Levels</h3>
<div style="margin:0.5rem 0">
<select id="debugSigilSelect" style="padding:0.25rem;margin-right:0.5rem;font-size:0.9rem">
${allSigils.map(sig => `<option value="${sig}">${sig} (L${S.sig[sig] || 0})</option>`).join('')}
</select>
<input type="number" id="debugSigilLevel" min="0" max="5" value="1" style="width:50px;padding:0.25rem;margin:0 0.5rem;font-size:1rem">
<button class="btn" onclick="debugSetSigilLevel()" style="display:inline-block;width:auto;padding:0.5rem 1rem;margin:0;font-size:0.9rem;min-height:auto">Set</button>
</div>

${heroNames.length > 0 ? `
<h3 class="modal-section-title green">Hero Stats</h3>
<div style="margin:0.5rem 0">
<select id="debugHeroSelect" style="padding:0.25rem;margin-bottom:0.5rem;font-size:0.9rem;width:100%">
${heroNames.map(h => `<option value="${h.idx}">${h.name} (POW:${S.heroes[h.idx].p}, HP:${S.heroes[h.idx].h}/${S.heroes[h.idx].m})</option>`).join('')}
</select>
<div style="display:flex;gap:0.5rem;margin-bottom:0.5rem">
<div style="flex:1">
<label style="color:white;font-size:0.85rem;display:block">POW:</label>
<input type="number" id="debugHeroPOW" min="1" max="20" value="1" style="width:100%;padding:0.25rem;font-size:1rem">
</div>
<div style="flex:1">
<label style="color:white;font-size:0.85rem;display:block">Max HP:</label>
<input type="number" id="debugHeroMaxHP" min="1" max="50" value="5" style="width:100%;padding:0.25rem;font-size:1rem">
</div>
</div>
<button class="btn" onclick="debugSetHeroStats()" style="background:#3b82f6;margin-bottom:0.5rem">Update Hero Stats</button>
${S.heroes.some(h => h.ls) ? `<button class="btn" onclick="debugReviveFromLastStand()" style="background:#dc2626;margin-bottom:0.5rem">üíÄ Revive from Last Stand</button>` : ''}
</div>
` : ''}

${inCombat ? `
<h3 class="modal-section-title green">Combat</h3>
<button class="btn danger" onclick="debugDealDamage()">Deal 50 DMG to Enemy</button>
` : ''}

<h3 class="modal-section-title blue">Cheats</h3>
<label class="modal-checkbox-label" style="background:rgba(251,191,36,0.2)">
<input type="checkbox" ${S.oopsAll20s ? 'checked' : ''} onchange="toggleOopsAll20s(this.checked)">
<span>üé≤ Oops All 20s (Auto-succeed D20 rolls)</span>
</label>

<button class="btn" onclick="closeDebugMenu()" style="margin-top:1rem;background:#888">Close</button>
</div>
<div class="modal-overlay" onclick="closeDebugMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeDebugMenu() {
// Remove debug menu elements - only target settings/debug modals
const menus = document.querySelectorAll('.settings-modal-container, .settings-modal-overlay, .modal-container.dark, .modal-overlay');
menus.forEach(m => m.remove());
}

// ===== SETTINGS MENU =====
function showSettingsMenu() {
const v = document.getElementById('gameView');
const inGame = S.heroes && S.heroes.length > 0 && S.floor > 0;
const inTutorial = S.heroes && S.heroes.length > 0 && S.floor === 0;
const inRibbleton = S.inRibbleton;

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">‚öôÔ∏è SETTINGS ‚öôÔ∏è</h2>

${inGame ? `
<button class="btn" onclick="manualSave()" style="margin-bottom:0.5rem;background:#22c55e">üíæ Save Game</button>
<button class="btn" onclick="restartLevel()" style="margin-bottom:0.5rem;background:#f97316">üîÑ Restart Level</button>
` : ''}

<div style="margin-top:0.5rem;display:flex;flex-direction:column;gap:0.5rem">
<button class="btn" onclick="showAudioSettings()" style="background:#22c55e">üîä Audio</button>
<button class="btn" onclick="showGameplaySettings()" style="background:#6366f1">üéÆ Gameplay</button>
<button class="btn" onclick="showDisplaySettings()" style="background:#8b5cf6">üñ•Ô∏è Display</button>
<button class="btn" onclick="showControllerSettings()" style="background:#0ea5e9">üïπÔ∏è Controller</button>
</div>

${inGame ? `
<button class="btn danger" onclick="confirmQuitToRibbleton()" style="margin-top:1rem;background:#dc2626">üö™ Quit to Ribbleton</button>
` : inTutorial ? `
<button class="btn danger" onclick="confirmQuitTutorial()" style="margin-top:1rem;background:#dc2626">üö™ Exit Tutorial</button>
` : inRibbleton ? `
<button class="btn" onclick="confirmExitGame()" style="margin-top:1rem;background:#dc2626">üö™ Quit Game</button>
` : ''}

<button class="settings-back-btn" onclick="closeSettingsMenu()">Return</button>
<div style="margin-top:0.5rem;font-size:0.8rem;opacity:0.5;text-align:center">Press ‚í∑ to close menu</div>
</div>
<div class="modal-overlay" onclick="closeSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

// ===== AUDIO SETTINGS SUBMENU =====
function showAudioSettings() {
closeSettingsMenu();
const v = document.getElementById('gameView');

// Convert 0-1 to percentage for display
const masterPct = Math.round((S.masterVolume || 1) * 100);
const sfxPct = Math.round((S.sfxVolume || 1) * 100);
const musicPct = Math.round((S.musicVolume || 1) * 100);

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">üîä AUDIO</h2>

<div style="display:flex;flex-direction:column;gap:1.25rem">

<div>
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem">
<label style="font-weight:bold;color:#fbbf24">üîà Master Volume</label>
<span id="master-vol-display" style="font-size:0.9rem;color:#fbbf24">${masterPct}%</span>
</div>
<input type="range" min="0" max="100" value="${masterPct}"
  oninput="updateVolumeDisplay('master', this.value); setMasterVolume(this.value / 100)"
  style="width:100%;height:8px;cursor:pointer;accent-color:#fbbf24">
</div>

<div>
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem">
<label style="font-weight:bold;color:#22c55e">üí• Sound Effects</label>
<span id="sfx-vol-display" style="font-size:0.9rem;color:#22c55e">${sfxPct}%</span>
</div>
<input type="range" min="0" max="100" value="${sfxPct}"
  oninput="updateVolumeDisplay('sfx', this.value); setSfxVolume(this.value / 100)"
  style="width:100%;height:8px;cursor:pointer;accent-color:#22c55e">
</div>

<div>
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem">
<label style="font-weight:bold;color:#8b5cf6">üéµ Music</label>
<span id="music-vol-display" style="font-size:0.9rem;color:#8b5cf6">${musicPct}%</span>
</div>
<input type="range" min="0" max="100" value="${musicPct}"
  oninput="updateVolumeDisplay('music', this.value); setMusicVolume(this.value / 100)"
  style="width:100%;height:8px;cursor:pointer;accent-color:#8b5cf6">
</div>

</div>

<button class="btn" onclick="testAudioLevels()" style="margin-top:1rem;background:#374151">üîä Test Sound</button>

<button class="settings-back-btn" onclick="closeSettingsMenu();showSettingsMenu()">Back <span style="opacity:0.6;font-size:0.85em">(B)</span></button>
</div>
<div class="modal-overlay" onclick="closeSettingsMenu();showSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

// Update volume display as slider moves
function updateVolumeDisplay(type, value) {
const display = document.getElementById(`${type}-vol-display`);
if (display) display.textContent = `${value}%`;
}

// Test audio levels with a sample sound
function testAudioLevels() {
SoundFX.play('ribbit');
}

// ===== GAMEPLAY SETTINGS SUBMENU =====
function showGameplaySettings() {
closeSettingsMenu();
const v = document.getElementById('gameView');

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">üéÆ GAMEPLAY</h2>

<h3 class="modal-section-title green">Animation Speed</h3>
<div style="display:flex;gap:0.5rem;flex-wrap:wrap;margin-bottom:0.5rem">
<button class="btn ${S.animationSpeed === 1 ? 'selected' : ''}" onclick="setAnimationSpeed(1, true)" style="flex:1;min-width:60px;padding:0.5rem;font-size:0.9rem;${S.animationSpeed === 1 ? 'background:#22c55e;border-color:#16a34a' : 'background:#374151'}">üê∏ Normal</button>
<button class="btn ${S.animationSpeed === 2 ? 'selected' : ''}" onclick="setAnimationSpeed(2, true)" style="flex:1;min-width:60px;padding:0.5rem;font-size:0.9rem;${S.animationSpeed === 2 ? 'background:#22c55e;border-color:#16a34a' : 'background:#374151'}">üê∏üí® 2x</button>
<button class="btn ${S.animationSpeed === 4 ? 'selected' : ''}" onclick="setAnimationSpeed(4, true)" style="flex:1;min-width:60px;padding:0.5rem;font-size:0.9rem;${S.animationSpeed === 4 ? 'background:#22c55e;border-color:#16a34a' : 'background:#374151'}">üê∏üí®üí® 4x</button>
<button class="btn ${S.animationSpeed === 0 ? 'selected' : ''}" onclick="setAnimationSpeed(0, true)" style="flex:1;min-width:60px;padding:0.5rem;font-size:0.9rem;${S.animationSpeed === 0 ? 'background:#f97316;border-color:#ea580c' : 'background:#374151'}">‚ö° Instant</button>
</div>

<h3 class="modal-section-title blue">Debug</h3>
<label class="modal-checkbox-label">
<input type="checkbox" ${S.debugMode ? 'checked' : ''} onchange="toggleDebugMode(this.checked)">
<span>üõ†Ô∏è Enable Debug Mode</span>
</label>
${S.debugMode ? `<button class="btn" onclick="closeSettingsMenu();showDebugMenu()" style="margin-bottom:0.5rem;background:#3b82f6">üõ†Ô∏è Open Debug Tools</button>` : ''}

<button class="settings-back-btn" onclick="closeSettingsMenu();showSettingsMenu()">Back <span style="opacity:0.6;font-size:0.85em">(B)</span></button>
</div>
<div class="modal-overlay" onclick="closeSettingsMenu();showSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

// ===== DISPLAY SETTINGS SUBMENU =====
function showDisplaySettings() {
closeSettingsMenu();
const v = document.getElementById('gameView');

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">üñ•Ô∏è DISPLAY</h2>

<label class="modal-checkbox-label">
<input type="checkbox" ${S.toastLogVisible ? 'checked' : ''} onchange="toggleToastLogVisibility(this.checked)">
<span>üìú Show Toast Log</span>
</label>
<label class="modal-checkbox-label">
<input type="checkbox" ${!S.helpTipsDisabled ? 'checked' : ''} onchange="toggleHelpTips(this.checked)">
<span>üí° Show Help/Tips</span>
</label>
<p style="font-size:0.75rem;opacity:0.6;margin:-0.25rem 0 0.5rem 0.5rem;padding-left:0.5rem">Turning this on resets all tutorial popups</p>
<label class="modal-checkbox-label">
<input type="checkbox" ${!S.tooltipsDisabled ? 'checked' : ''} onchange="toggleTooltips(this.checked)">
<span>üîç Show Sigil Tooltips</span>
</label>

<h3 class="modal-section-title green" style="margin-top:1rem">Accessibility</h3>
<label class="modal-checkbox-label">
<input type="checkbox" ${S.highContrastMode ? 'checked' : ''} onchange="toggleHighContrastMode(this.checked)">
<span>üëÅÔ∏è High Contrast Mode</span>
</label>
<p style="font-size:0.75rem;opacity:0.6;margin:-0.25rem 0 0.5rem 0.5rem;padding-left:0.5rem">Enhanced visibility for low vision users</p>

<button class="settings-back-btn" onclick="closeSettingsMenu();showSettingsMenu()">Back <span style="opacity:0.6;font-size:0.85em">(B)</span></button>
</div>
<div class="modal-overlay" onclick="closeSettingsMenu();showSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

// Toggle toast log visibility in header
function toggleToastLogVisibility(enabled) {
S.toastLogVisible = enabled;
savePermanent();
render();
toast(enabled ? 'üìú Toast Log: Visible' : 'üìú Toast Log: Hidden', 1500);
}

// Toggle high contrast mode
function toggleHighContrastMode(enabled) {
S.highContrastMode = enabled;
if (enabled) {
document.body.classList.add('high-contrast');
} else {
document.body.classList.remove('high-contrast');
}
savePermanent();
toast(enabled ? 'üëÅÔ∏è High Contrast Mode: ON' : 'üëÅÔ∏è High Contrast Mode: OFF', 1500);
}

// ===== CONTROLLER SETTINGS SUBMENU =====
function showControllerSettings() {
closeSettingsMenu();
const v = document.getElementById('gameView');

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">üïπÔ∏è CONTROLLER</h2>

<label class="modal-checkbox-label">
<input type="checkbox" ${!S.controllerDisabled ? 'checked' : ''} onchange="toggleControllerSupport(this.checked)">
<span>üéÆ Controller Support</span>
</label>
<button class="btn" onclick="showControlsGuide()" style="margin-bottom:0.5rem;background:#6366f1">üéÆ Controls Guide</button>
<button class="btn" onclick="forceReinitController()" style="margin-bottom:0.5rem;background:#22c55e;font-size:0.9rem">üîÑ Re-Init Controller</button>
<button class="btn" onclick="toggleControllerDebug()" style="margin-bottom:0.5rem;background:#f59e0b;font-size:0.9rem">üîç Input Overlay</button>

<button class="settings-back-btn" onclick="closeSettingsMenu();showSettingsMenu()">Back <span style="opacity:0.6;font-size:0.85em">(B)</span></button>
</div>
<div class="modal-overlay" onclick="closeSettingsMenu();showSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeSettingsMenu() {
// Only remove settings-specific modals to avoid interfering with game screens
const menus = document.querySelectorAll('.settings-modal-container, .settings-modal-overlay, .modal-container.dark, .modal-overlay');
menus.forEach(m => m.remove());
}

function manualSave() {
saveGame();
toast('Game Saved!', 1200);
closeSettingsMenu();
}

function restartLevel() {
showConfirmModal('Restart this floor? All progress on this floor will be lost.', () => {
closeSettingsMenu();
toast('Restarting floor...', 1200);
setTimeout(() => {
if(S.floor % 2 === 1) {
// Odd floor = combat
combat(S.floor);
} else {
// Even floor = neutral
startFloor(S.floor);
}
}, 500);
});
}

function confirmQuitToRibbleton() {
showConfirmModal('Quit to Ribbleton? Your progress is saved at the start of each floor. Any progress on the current floor will be lost.', () => {
closeSettingsMenu();
toast('Returning to Ribbleton...', 1200);
// Reset game state but preserve permanent progression
S.heroes = [];
S.floor = 0;
S.round = 0;
S.enemies = [];
S.recruits = [];
S.combatXP = 0;
S.combatGold = 0;
S.inRibbleton = true;
setTimeout(() => {
showRibbleton();
}, 500);
});
}

function confirmQuitTutorial() {
showConfirmModal('Exit tutorial? You can restart it anytime from Ribbleton.', () => {
closeSettingsMenu();
toast('Exiting tutorial...', 1200);
// Clear tutorial state
if(typeof tutorialState !== 'undefined') tutorialState = null;
// Reset game state
S.heroes = [];
S.floor = 0;
S.round = 0;
S.enemies = [];
S.recruits = [];
S.combatXP = 0;
S.combatGold = 0;
S.inRibbleton = true;
S.inTutorial = false;
setTimeout(() => {
showRibbleton();
}, 500);
});
}

function confirmExitGame() {
showConfirmModal('Exit to title screen? Your permanent progress (gold, sigil upgrades, etc.) is always saved.', () => {
closeSettingsMenu();
toast('Returning to title...', 1200);
// Reset ALL game state
S.heroes = [];
S.floor = 0;
S.round = 0;
S.enemies = [];
S.recruits = [];
S.combatXP = 0;
S.combatGold = 0;
S.inRibbleton = false;
S.inTutorial = false;
// Save permanent progress
savePermanent();
setTimeout(() => {
mainTitlePage();
}, 500);
});
}


function toggleHelpTips(enabled) {
S.helpTipsDisabled = !enabled;
// If turning ON, reset all tutorial flags so they show again
if(enabled) {
// Preserve narrative/progression flags while resetting tip popups
const narrativeFlags = ['death_intro', 'first_victory_sequence', 'first_fu_victory',
  'tapo_victory_message', 'death_exit_warning', 'tutorial_fly_munched'];
const preserved = {};
narrativeFlags.forEach(flag => { if(S.tutorialFlags[flag]) preserved[flag] = S.tutorialFlags[flag]; });
S.tutorialFlags = preserved;
toast('Help/Tips enabled! All tips reset and will show again.', 2000);
// Re-trigger current screen to show relevant popups immediately
if(typeof render === 'function') {
try { render(); } catch(e) { /* render() not applicable in current state */ }
}
// If in Ribbleton hub, re-show to trigger ribbleton_hub_intro popup
if(document.querySelector('h1')?.textContent?.includes('Welcome Home to Ribbleton')) {
setTimeout(() => showRibbleton(), 100);
}
} else {
toast('Help/Tips disabled. No more popups!', 1200);
}
savePermanent();
}

function toggleTooltips(enabled) {
S.tooltipsDisabled = !enabled;
if(enabled) {
toast('Sigil tooltips enabled!', 1200);
} else {
toast('Sigil tooltips disabled!', 1200);
}
savePermanent();
}

function toggleSoundFX(enabled) {
SoundFX.enabled = enabled;
if(enabled) {
SoundFX.init();
SoundFX.play('select');
toast('Sound effects enabled!', 1200);
} else {
toast('Sound effects disabled!', 1200);
}
}

function setAnimationSpeed(speed, fromSubmenu = false) {
S.animationSpeed = speed;
const labels = {0: '‚ö° Instant', 1: 'üê∏ Normal', 2: 'üê∏üí® 2x', 4: 'üê∏üí®üí® 4x'};
toast(`Animation speed: ${labels[speed]}`, 1200);
SoundFX.play('hop');
savePermanent();
// Refresh gameplay settings submenu to update button states
closeSettingsMenu();
if (fromSubmenu) {
showGameplaySettings();
} else {
showSettingsMenu();
}
}

// toggleControllerSupport and forceReinitController are defined in controller.js

// Live controller debug overlay - shows input in real-time on screen
function toggleControllerDebug() {
const existing = document.getElementById('controller-debug-overlay');
if (existing) {
existing.remove();
toast('Controller debug disabled', 1200);
closeSettingsMenu();
return;
}

const overlay = document.createElement('div');
overlay.id = 'controller-debug-overlay';
overlay.style.cssText = 'position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.9);color:#0f0;font-family:monospace;font-size:12px;padding:10px;border-radius:8px;z-index:99999;max-width:300px;border:2px solid #0f0';
overlay.innerHTML = `
<div style="font-weight:bold;margin-bottom:5px;color:#fff">üéÆ CONTROLLER DEBUG</div>
<div id="debug-gamepad-status">Checking...</div>
<div id="debug-buttons" style="margin-top:5px"></div>
<div id="debug-axes" style="margin-top:5px"></div>
<div id="debug-keyboard" style="margin-top:5px;color:#ff0">Last key: none</div>
<div id="debug-key-count" style="font-size:10px;color:#888">Keys pressed: 0</div>
<div style="margin-top:8px">
<button id="debug-detect-btn" style="background:#22c55e;color:#000;border:none;padding:4px 8px;border-radius:4px;font-size:11px;cursor:pointer">üîç Force Detect</button>
</div>
<div style="margin-top:5px;font-size:10px;color:#888">Tap overlay to close</div>
`;
overlay.onclick = (e) => {
  if (e.target === overlay) overlay.remove();
};
document.body.appendChild(overlay);

// Force detect button
document.getElementById('debug-detect-btn').onclick = (e) => {
  e.stopPropagation();
  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  let msg = 'Gamepad API result:\\n';
  for (let i = 0; i < 4; i++) {
    msg += `[${i}]: ${gamepads[i] ? gamepads[i].id : 'null'}\\n`;
  }
  msg += '\\nIf all null, Steam Input may be intercepting.\\n';
  msg += 'Try: Steam > FROGGLE > Properties > Controller\\n';
  msg += '> Use "Gamepad with Joystick Trackpad"';
  alert(msg);
  // Also try to reinit controller
  if (typeof GamepadController !== 'undefined') {
    GamepadController.initGamepad();
    toast('Retrying gamepad detection...', 1500);
  }
};

// Track keyboard input - use capture to catch ALL key events
let keyCount = 0;
const keyHandler = (e) => {
keyCount++;
const keyEl = document.getElementById('debug-keyboard');
const countEl = document.getElementById('debug-key-count');
if (keyEl) keyEl.innerHTML = `Last key: <span style="color:#0f0;font-weight:bold">${e.key}</span> (${e.code})`;
if (countEl) countEl.innerHTML = `Keys pressed: <span style="color:#0f0">${keyCount}</span>`;
};
document.addEventListener('keydown', keyHandler, true); // capture phase

// Update loop
const updateDebug = () => {
if (!document.getElementById('controller-debug-overlay')) {
document.removeEventListener('keydown', keyHandler);
return;
}

const statusEl = document.getElementById('debug-gamepad-status');
const buttonsEl = document.getElementById('debug-buttons');
const axesEl = document.getElementById('debug-axes');

const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
let found = false;

for (let i = 0; i < gamepads.length; i++) {
const gp = gamepads[i];
if (gp) {
found = true;
statusEl.innerHTML = `<span style="color:#0f0">‚úì FOUND:</span> ${gp.id.substring(0,30)}...`;

// Button names for standard gamepad layout
const btnNames = ['A','B','X','Y','LB','RB','LT','RT','Select','Start','L3','R3','Up','Down','Left','Right'];

// Show pressed buttons with names
const pressed = [];
for (let b = 0; b < gp.buttons.length; b++) {
if (gp.buttons[b].pressed || gp.buttons[b].value > 0.5) {
const name = btnNames[b] || `#${b}`;
pressed.push(`<span style="color:#0f0">${name}</span><span style="color:#888">(${b})</span>`);
}
}
buttonsEl.innerHTML = pressed.length > 0
? `Buttons: ${pressed.join(' ')}`
: 'Buttons: <span style="color:#888">none</span>';

// Show axes with friendly names
const axisNames = ['LX', 'LY', 'RX', 'RY', 'LT', 'RT'];
const axes = gp.axes.map((a, i) => {
  if (Math.abs(a) > 0.15) {
    const name = axisNames[i] || `#${i}`;
    return `<span style="color:#0f0">${name}</span>:${a.toFixed(1)}`;
  }
  return null;
}).filter(Boolean);
axesEl.innerHTML = axes.length > 0
? `Axes: ${axes.join(' ')}`
: 'Axes: <span style="color:#888">centered</span>';
break;
}
}

if (!found) {
// Show more diagnostic info
const gpArray = navigator.getGamepads ? navigator.getGamepads() : null;
const gpLen = gpArray ? gpArray.length : 'N/A';
const hasAPI = typeof navigator.getGamepads === 'function' ? 'Yes' : 'No';
const gcLib = typeof gameControl !== 'undefined' ? 'Loaded' : 'Missing';
const gcGps = typeof gameControl !== 'undefined' ? Object.keys(gameControl.getGamepads()).length : 0;
statusEl.innerHTML = `<span style="color:#f00">‚úó NO GAMEPAD</span><br>
<span style="font-size:10px;color:#888">
API: ${hasAPI} | Array len: ${gpLen}<br>
gameControl: ${gcLib} (${gcGps} gps)<br>
GamepadController: ${typeof GamepadController !== 'undefined' ? (GamepadController.currentGamepad ? 'Connected' : 'No GP') : 'Missing'}
</span>`;
buttonsEl.innerHTML = '<span style="color:#ff0">Press controller buttons...</span>';
axesEl.innerHTML = '<span style="font-size:10px;color:#888">If using Steam Deck, check Steam Input config</span>';
}

requestAnimationFrame(updateDebug);
};
updateDebug();

toast('Controller debug enabled - overlay shown', 1500);
closeSettingsMenu();
}

// Alias for controller.js R3 handler
const showControllerDebug = toggleControllerDebug;

function showControlsGuide() {
closeSettingsMenu();
const v = document.getElementById('gameView');

const controls = [
{ section: 'üïπÔ∏è Sticks (Combat)', items: [
  { btn: 'Right Stick', desc: 'Cycle between characters (heroes ‚Üî enemies)', highlight: true },
  { btn: 'Left Stick', desc: 'Cycle sigils on current character', highlight: true }
]},
{ section: 'üéÆ Bumpers & Triggers (Combat)', items: [
  { btn: 'LB / RB', desc: 'Previous / Next character (same as right stick)' },
  { btn: 'LT / RT', desc: 'Previous / Next sigil with tooltip (same as left stick)' }
]},
{ section: '‚úö D-Pad', items: [
  { btn: 'In Menus', desc: 'Navigate between buttons and options' },
  { btn: 'Up / Down', desc: 'In combat: cycle characters' },
  { btn: 'Left / Right', desc: 'In combat: cycle sigils' }
]},
{ section: 'üîò Face Buttons', items: [
  { btn: 'A', desc: 'Confirm / Select / Click focused element' },
  { btn: 'B', desc: 'Back / Cancel action' },
  { btn: 'X', desc: 'Switch sides (jump to enemy across from you)' },
  { btn: 'Y', desc: 'Toggle sigil tooltip' }
]},
{ section: '‚öôÔ∏è Menu Buttons', items: [
  { btn: 'START (‚ò∞)', desc: 'Open Settings menu (works anywhere)' },
  { btn: 'SELECT (‚ä°)', desc: 'Auto-target: smart targeting for current action' },
  { btn: 'L3 (left click)', desc: 'Show Controls Guide' },
  { btn: 'R3 (right click)', desc: 'Toggle Controller Debug overlay' }
]},
{ section: '‚å®Ô∏è Keyboard Fallback', items: [
  { btn: 'Arrow Keys / WASD', desc: 'Navigate (D-pad equivalent)' },
  { btn: 'Q / E', desc: 'Previous / Next character (LB / RB)' },
  { btn: 'Z / C', desc: 'Previous / Next sigil (LT / RT)' },
  { btn: 'Enter / Space', desc: 'Confirm (A button)' },
  { btn: 'Escape', desc: 'Back / Cancel (B button)' },
  { btn: 'X / T', desc: 'Switch sides / Toggle tooltip' },
  { btn: 'R', desc: 'Auto-target (SELECT)' }
]}
];

let html = `
<div class="modal-container dark" style="max-height:85vh;overflow-y:auto">
<h2 class="modal-title blue" style="margin-bottom:1rem">üéÆ CONTROLS GUIDE üéÆ</h2>

<div style="margin-bottom:1rem;padding:0.75rem;background:rgba(34,197,94,0.15);border:2px solid #22c55e;border-radius:8px">
<p style="margin:0;color:#86efac;font-size:0.9rem;text-align:center">
<strong>Quick Reference:</strong> Right Stick = Characters ‚Ä¢ Left Stick = Sigils ‚Ä¢ Bumpers & Triggers work the same way!
</p>
</div>
`;

controls.forEach(section => {
html += `<h3 class="modal-section-title green" style="margin-top:1rem;font-size:0.95rem">${section.section}</h3>`;
html += `<div style="display:flex;flex-direction:column;gap:0.3rem">`;
section.items.forEach(item => {
const bgColor = item.highlight ? 'rgba(34,197,94,0.1)' : 'rgba(255,255,255,0.05)';
const borderStyle = item.highlight ? 'border:1px solid rgba(34,197,94,0.3);' : '';
html += `
<div style="display:flex;align-items:center;gap:0.75rem;padding:0.4rem 0.5rem;background:${bgColor};${borderStyle}border-radius:6px">
<span style="min-width:120px;font-weight:bold;color:#60a5fa;font-size:0.85rem">${item.btn}</span>
<span style="color:#e5e7eb;font-size:0.8rem">${item.desc}</span>
</div>`;
});
html += `</div>`;
});

html += `
<div style="margin-top:1.5rem;padding:1rem;background:rgba(99,102,241,0.15);border:2px solid #6366f1;border-radius:8px">
<h4 style="color:#a5b4fc;margin:0 0 0.5rem 0;font-size:0.95rem">üí° Pro Tips</h4>
<ul style="margin:0;padding-left:1.25rem;color:#c7d2fe;font-size:0.85rem;line-height:1.5">
<li><strong>Auto-Target (SELECT)</strong> picks smart targets: lowest HP enemies for attacks, most damaged heroes for heals</li>
<li><strong>Switch Sides (X)</strong> quickly jumps between your hero and the enemy across from them</li>
<li><strong>Sigil cycling (LT/RT/Left Stick)</strong> automatically shows tooltips as you browse</li>
<li><strong>Bumpers (LB/RB)</strong> also scroll through long lists in menus</li>
</ul>
</div>

<button class="btn" onclick="showSteamInputGuide()" style="margin-top:1rem;background:#1b2838">
<span style="margin-right:0.5rem">üéÆ</span> Steam Input Setup Guide
</button>
<button class="btn" onclick="closeControlsGuide()" style="margin-top:0.5rem;background:#888">Close</button>
</div>
<div class="modal-overlay" onclick="closeControlsGuide()"></div>
`;

v.insertAdjacentHTML('beforeend', html);
}

function closeControlsGuide() {
const menus = document.querySelectorAll('.modal-container.dark, .modal-overlay');
menus.forEach(m => m.remove());
}

function showSteamInputGuide() {
// Remove existing modal first
const menus = document.querySelectorAll('.modal-container.dark, .modal-overlay');
menus.forEach(m => m.remove());

const v = document.getElementById('gameView');

let html = `
<div class="modal-container dark" style="max-height:85vh;overflow-y:auto">
<h2 class="modal-title" style="margin-bottom:1rem;color:#1b2838">
<span style="background:linear-gradient(135deg,#1b2838,#2a475e);padding:0.3rem 0.6rem;border-radius:4px">üéÆ Steam Input Setup</span>
</h2>

<div style="margin-bottom:1rem;padding:0.75rem;background:rgba(27,40,56,0.3);border:2px solid #2a475e;border-radius:8px">
<p style="margin:0;color:#c7d5e0;font-size:0.9rem;text-align:center">
FROGGLE uses <strong>Gamepad with Joystick Trackpad</strong> template as a base. Here's how to set it up in Steam.
</p>
</div>

<h3 class="modal-section-title" style="margin-top:1rem;color:#66c0f4">üìã Quick Setup (Recommended)</h3>
<div style="padding:0.75rem;background:rgba(255,255,255,0.05);border-radius:6px;margin-bottom:1rem">
<ol style="margin:0;padding-left:1.25rem;color:#e5e7eb;font-size:0.85rem;line-height:1.8">
<li>Open Steam and navigate to your game in the Library</li>
<li>Click the <strong>controller icon</strong> or go to <strong>Properties ‚Üí Controller</strong></li>
<li>Select <strong>"Gamepad with Joystick Trackpad"</strong> as the template</li>
<li>The default mappings should work perfectly!</li>
</ol>
</div>

<h3 class="modal-section-title" style="margin-top:1rem;color:#66c0f4">üîß Custom Configuration</h3>
<div style="padding:0.75rem;background:rgba(255,255,255,0.05);border-radius:6px;margin-bottom:1rem">
<p style="margin:0 0 0.75rem 0;color:#c7d5e0;font-size:0.85rem">
If you want to customize, here's the expected mapping:
</p>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:0.5rem;font-size:0.8rem">
<div style="padding:0.4rem;background:rgba(102,192,244,0.1);border-radius:4px">
<strong style="color:#66c0f4">Left Stick</strong><br/>
<span style="color:#e5e7eb">Joystick Move (axes 0,1)</span>
</div>
<div style="padding:0.4rem;background:rgba(102,192,244,0.1);border-radius:4px">
<strong style="color:#66c0f4">Right Stick</strong><br/>
<span style="color:#e5e7eb">Joystick Move (axes 2,3)</span>
</div>
<div style="padding:0.4rem;background:rgba(102,192,244,0.1);border-radius:4px">
<strong style="color:#66c0f4">D-Pad</strong><br/>
<span style="color:#e5e7eb">D-Pad buttons (12-15)</span>
</div>
<div style="padding:0.4rem;background:rgba(102,192,244,0.1);border-radius:4px">
<strong style="color:#66c0f4">Face Buttons</strong><br/>
<span style="color:#e5e7eb">A(0) B(1) X(2) Y(3)</span>
</div>
<div style="padding:0.4rem;background:rgba(102,192,244,0.1);border-radius:4px">
<strong style="color:#66c0f4">Bumpers</strong><br/>
<span style="color:#e5e7eb">LB(4) RB(5)</span>
</div>
<div style="padding:0.4rem;background:rgba(102,192,244,0.1);border-radius:4px">
<strong style="color:#66c0f4">Triggers</strong><br/>
<span style="color:#e5e7eb">LT(6) RT(7)</span>
</div>
<div style="padding:0.4rem;background:rgba(102,192,244,0.1);border-radius:4px">
<strong style="color:#66c0f4">Select/Back</strong><br/>
<span style="color:#e5e7eb">Button 8</span>
</div>
<div style="padding:0.4rem;background:rgba(102,192,244,0.1);border-radius:4px">
<strong style="color:#66c0f4">Start/Menu</strong><br/>
<span style="color:#e5e7eb">Button 9</span>
</div>
</div>
</div>

<h3 class="modal-section-title" style="margin-top:1rem;color:#66c0f4">üéÆ Steam Deck Gaming Mode</h3>
<div style="padding:0.75rem;background:rgba(255,255,255,0.05);border-radius:6px;margin-bottom:1rem">
<p style="margin:0;color:#e5e7eb;font-size:0.85rem;line-height:1.6">
On Steam Deck, the built-in controls should work automatically. If not:
</p>
<ol style="margin:0.5rem 0 0 0;padding-left:1.25rem;color:#c7d5e0;font-size:0.85rem;line-height:1.8">
<li>Press the <strong>Steam button</strong> while in-game</li>
<li>Select <strong>Controller Settings</strong></li>
<li>Choose <strong>Gamepad with Joystick Trackpad</strong></li>
<li>Optionally map L4/R4 paddles to X for quick auto-targeting!</li>
</ol>
</div>

<h3 class="modal-section-title" style="margin-top:1rem;color:#66c0f4">üñ•Ô∏è Electron / Desktop App</h3>
<div style="padding:0.75rem;background:rgba(255,255,255,0.05);border-radius:6px;margin-bottom:1rem">
<p style="margin:0;color:#e5e7eb;font-size:0.85rem;line-height:1.6">
When packaging with Electron for Steam:
</p>
<ol style="margin:0.5rem 0 0 0;padding-left:1.25rem;color:#c7d5e0;font-size:0.85rem;line-height:1.8">
<li>Add the game to Steam as a <strong>Non-Steam Game</strong></li>
<li>Enable <strong>Steam Input</strong> in the controller settings</li>
<li>Select <strong>Gamepad with Joystick Trackpad</strong> template</li>
<li>For Steamworks integration, use the <a href="https://partner.steamgames.com/doc/features/steam_controller" style="color:#66c0f4" target="_blank">Steam Input API</a></li>
</ol>
</div>

<div style="margin-top:1rem;padding:0.75rem;background:rgba(245,158,11,0.15);border:2px solid #f59e0b;border-radius:8px">
<p style="margin:0;color:#fcd34d;font-size:0.85rem">
The game also supports keyboard fallback. If controller input isn't detected, you can use Arrow Keys, WASD, Q/E/Z/C, and Enter/Escape to play!<br><br><em style="font-size:0.85em;opacity:0.9">(üí° Tip: This works great for Steam Deck users who prefer touch controls!)</em>
</p>
</div>

<button class="btn" onclick="showControlsGuide()" style="margin-top:1rem;background:#6366f1">‚Üê Back to Controls</button>
<button class="btn" onclick="closeControlsGuide()" style="margin-top:0.5rem;background:#888">Close</button>
</div>
<div class="modal-overlay" onclick="closeControlsGuide()"></div>
`;

v.insertAdjacentHTML('beforeend', html);
}

function showFAQ() {
const v = document.getElementById('gameView');

const faqItems = [
{
q: "What are sigils?",
a: `Sigils are your heroes' special abilities! Each hero has sigils they can use in combat to attack enemies, defend the team, or perform special actions.<br><br>
<strong>Basic Sigils:</strong><br>
‚Ä¢ <strong>Attack</strong> - Deal damage to enemies<br>
‚Ä¢ <strong>Shield</strong> - Protect heroes from damage<br>
‚Ä¢ <strong>Heal</strong> - Restore HP to heroes<br>
‚Ä¢ <strong>D20</strong> - Roll the dice for powerful gambit actions (not guaranteed to succeed)<br><br>
You can see your sigils at the bottom of your hero card during combat. Hover / long-press any sigil icon to see what it does!`
},
{
q: "How do I level up sigils?",
a: `There are two ways to upgrade sigils:<br><br>
<strong>1. Level-Up Menu (Odd Floors - 1, 3, 5...)</strong><br>
‚Ä¢ Spend XP earned from battles<br>
‚Ä¢ Choose to upgrade a sigil, boost stats, or add new sigils<br>
‚Ä¢ These upgrades reset when you die<br><br>
<strong>2. Shop (Even Floors - 2, 4, 6...)</strong><br>
‚Ä¢ Spend Gold<br>
‚Ä¢ Permanently upgrade sigils that persist across all runs<br>
‚Ä¢ This is your long-term progression!<br><br>
Your total sigil level = Permanent (Gold) + Temporary (XP) upgrades.`
},
{
q: "Why does Attack show as L1 when I haven't upgraded it?",
a: `Active sigils (Attack, Shield, Heal, Grapple, Ghost, D20, Alpha) always display with a minimum level of 1 when equipped, even if their permanent storage level is 0. This is because they work at "Level 1" effectiveness when you first get them.<br><br>
<strong>Example:</strong> Attack storage level 0 = displays as L1 (1 attack per action)<br>
Attack storage level 1 = displays as L2 (2 attacks per action)<br><br>
The upgrade cost is based on <em>storage level</em>, not display level. So upgrading from display L1 to L2 costs the price for storage level 0‚Üí1.`
},
{
q: "What happens if I run out of enemies before using all my Expand targets?",
a: `If you have Expand and select targets for multi-instance actions (Attack, Shield, Heal), you might run out of valid targets mid-instance. When this happens, you'll see a "wasted targets" message.<br><br>
<strong>Example:</strong> You have Attack L2 with Expand L1 (3 total targets). There are only 2 enemies left. You can attack both enemies, but the 3rd target slot is wasted - you still get both attacks, but you can't use the extra Expand slot.<br><br>
This is intentional! Plan your actions carefully.`
},
{
q: "How does Last Stand work and how long does it last?",
a: `When a hero reaches 0 HP (and has no Ghost charges), they enter <strong>Last Stand</strong> instead of dying immediately. In Last Stand:<br><br>
‚Ä¢ They can ONLY use D20 gambits (no other actions)<br>
‚Ä¢ Each turn in Last Stand increases D20 difficulty by +2 DC<br>
‚Ä¢ CONFUSE caps at DC 20; other gambits keep climbing<br>
‚Ä¢ If healed, they revive with the healed HP amount<br><br>
<strong>Last Stand Turn counter (CONFUSE example):</strong><br>
Turn 1: DC +0 (CONFUSE is DC 10)<br>
Turn 2: DC +2 (CONFUSE is DC 12)<br>
Turn 3: DC +4 (CONFUSE is DC 14)<br>
Turn 4: DC +6 (CONFUSE is DC 16)<br>
Turn 5: DC +8 (CONFUSE is DC 18)<br>
Turn 6: DC +10 (CONFUSE is DC 20 - nat 20 required!)<br><br>
You have a few turns to heal your Last Stand heroes before DCs become impossible!`
},
{
q: "How many recruits can I have? What happens to them?",
a: `Recruits are enemies you've converted to your side via D20 RECRUIT (DC 20):<br><br>
‚Ä¢ Each hero can have <strong>1 recruit</strong> (recruiting another replaces the first)<br>
‚Ä¢ Recruits persist between battles until killed<br>
‚Ä¢ Recruits fight in their hero's lane and attack enemies<br>
‚Ä¢ Recruits can gain sigils and act during enemy turns<br><br>
<strong>How they work:</strong> Recruits stand behind their hero and attack enemies during the "Recruit Phase" of the enemy turn. They're powerful allies but can die permanently!`
},
{
q: "Do shields carry over between battles?",
a: `<strong>Yes!</strong> Shields persist between battles and cap at max HP.<br><br>
This means you can "shield farm" by using Shield sigils on the last enemy of a floor to enter the next floor with full shields. Combined with Asterisk or Alpha, this can make you nearly invincible!<br><br>
<br><em style="font-size:0.9em;opacity:0.9">(Strategy tip: Before finishing a floor, use any remaining actions to shield up your team!)</em>`
},
{
q: "What's the difference between XP upgrades and Gold upgrades?",
a: `There are TWO types of sigil upgrades:<br><br>
<strong>1. Permanent (Gold) Upgrades</strong><br>
‚Ä¢ Purchased at the Death Screen after dying<br>
‚Ä¢ Persist through death and across all runs<br>
‚Ä¢ These are your long-term progression!<br><br>
<strong>2. Temporary (XP) Upgrades</strong><br>
‚Ä¢ Purchased during Level Ups (after combat)<br>
‚Ä¢ Reset when you die or start a new run<br>
‚Ä¢ These boost you during a single run only<br><br>
<strong>Your displayed sigil level = Permanent + Temporary upgrades combined</strong>`
},
{
q: "What are Star and Asterisk sigils?",
a: `<strong>Star:</strong> Passive XP multiplier. Each hero with Star adds +0.5√ó XP bonus per Star level.<br>
‚Ä¢ 2 heroes with Star L1 = +1.0√ó bonus = 2√ó total XP<br>
‚Ä¢ Star is extremely powerful for long-term scaling!<br><br>
<strong>Asterisk:</strong> PASSIVE - Next action triggers +X times! Resets after each battle.<br>
‚Ä¢ Asterisk L1: First action triggers √ó2<br>
‚Ä¢ Asterisk L4: First action triggers √ó5<br>
‚Ä¢ Works with ANY action: Attack, Shield, Heal, D20 gambits, etc.<br>
‚Ä¢ No activation needed - happens automatically on your first action<br>
‚Ä¢ Can be combined with Alpha for devastating combos!`
}
];

let html = `
<div class="modal-container faq">
<h2 class="modal-title orange">‚ùì Frequently Asked Questions ‚ùì</h2>

<div style="background:rgba(147,51,234,0.1);border:2px solid #9333ea;border-radius:12px;padding:1.5rem;margin-bottom:1.5rem">
<h3 style="text-align:center;font-size:1.2rem;margin:0 0 0.5rem 0;color:#9333ea">üê∏ FROGGLE</h3>
<p style="text-align:center;font-size:0.95rem;line-height:1.5;margin-bottom:1rem">Use XP to gain and upgrade powerful sigils. Advance through the dungeon and save Tapo the tadpole! On death, you'll have a chance to spend the gold you've earned to make your heroes permanently stronger!</p>

<div style="background:white;border-radius:8px;padding:1rem;margin-top:1rem;color:#1a1a1a">
<h4 style="color:#2c63c7;margin:0 0 0.75rem 0;font-size:1rem">‚öîÔ∏è HOW LEVEL-UPS WORK</h4>
<p style="font-size:0.9rem;margin:0 0 0.5rem 0">After combat, you can spend XP in 3 ways:</p>

<div style="margin-left:1rem;font-size:0.9rem;line-height:1.6">
<p style="margin:0.5rem 0"><strong>1Ô∏è‚É£ UPGRADE A SIGIL</strong> (makes it stronger everywhere!)</p>
<div style="margin-left:1rem;margin-bottom:0.75rem">
<p style="margin:0.25rem 0"><strong style="color:#9333ea">Passive Sigils</strong> (Expand, Asterisk, Star):</p>
<ul style="margin:0.25rem 0;padding-left:1.5rem">
<li>Start at Level 0 (inactive)</li>
<li>Spend XP to upgrade to Level 1 to activate for ALL heroes automatically</li>
<li>Work automatically in battle - no action needed</li>
</ul>
<p style="margin:0.5rem 0 0.25rem 0"><strong style="color:#2c63c7">Active Sigils</strong> (Attack, Shield, Heal, D20, etc.):</p>
<ul style="margin:0.25rem 0;padding-left:1.5rem">
<li>Start at Level 1 effectiveness</li>
<li>Upgrading makes them stronger on every hero who has them</li>
<li>Example: Attack L1‚ÜíL2 means attack twice instead of once!</li>
</ul>
</div>

<p style="margin:0.5rem 0"><strong>2Ô∏è‚É£ ADD A SIGIL TO A HERO</strong></p>
<ul style="margin:0.25rem 0 0.75rem 1.5rem;padding-left:1.5rem">
<li>All heroes can learn any sigil by spending XP!</li>
<li>Active sigils use your hero's 1 action per turn</li>
<li>Choose abilities that complement your strategy</li>
</ul>

<p style="margin:0.5rem 0"><strong>3Ô∏è‚É£ UPGRADE HERO STATS</strong></p>
<ul style="margin:0.25rem 0;padding-left:1.5rem">
<li>Spend XP for +1 POW (increases damage/healing/shields)</li>
<li>Spend XP for +5 Max HP (and heal if in Last Stand)</li>
</ul>
</div>
</div>

<div style="background:rgba(34,197,94,0.1);border:2px solid #22c55e;border-radius:8px;padding:1rem;margin-top:1rem">
<h4 style="color:#15803d;margin:0 0 0.5rem 0;font-size:0.95rem">üí° PRO TIPS</h4>
<ul style="margin:0;padding-left:1.5rem;font-size:0.85rem;line-height:1.5">
<li><strong>Mage & Healer Start Stronger:</strong> They get +1 Expand built-in, so their actions hit 1 extra target from the start!</li>
<li><strong>Shields Persist:</strong> Before winning a battle, use remaining actions to shield your team - they carry over to the next fight!</li>
<li><strong>D20 Gambits:</strong> Higher D20 sigil levels = better success rates. Hover over D20 in battle to see all 5 effects and their difficulty.</li>
</ul>
</div>
</div>

<p style="text-align:center;font-size:0.85rem;opacity:0.7;margin-bottom:1.5rem">Tap a question below to expand/collapse the answer</p>
<div style="display:flex;flex-direction:column;gap:0.75rem;margin-bottom:1.5rem">
`;

faqItems.forEach((item, index) => {
html += `
<div style="background:white;border:3px solid #000;border-radius:12px;overflow:hidden;box-shadow:0 2px 6px rgba(0,0,0,0.15)">
<div onclick="toggleFAQItem(${index})" style="padding:1rem;cursor:pointer;user-select:none;display:flex;justify-content:space-between;align-items:center;background:linear-gradient(135deg, #f0f9ff, #e0f2fe);transition:background 0.2s">
<strong style="font-size:0.95rem;color:#1e40af">${item.q}</strong>
<span id="faq-arrow-${index}" style="font-size:1.2rem;transition:transform 0.3s;color:#1e40af">‚ñº</span>
</div>
<div id="faq-answer-${index}" style="display:none;padding:1rem;font-size:0.9rem;line-height:1.6;border-top:2px solid #ddd;background:rgba(0,0,0,0.02);color:#1a1a1a">
${item.a}
</div>
</div>
`;
});

html += `
</div>
<button class="btn secondary" onclick="closeFAQ()" style="margin-top:0.5rem">Close</button>
</div>
<div class="modal-overlay" onclick="closeFAQ()"></div>
`;

v.insertAdjacentHTML('beforeend', html);
}

function toggleFAQItem(index) {
const answer = document.getElementById(`faq-answer-${index}`);
const arrow = document.getElementById(`faq-arrow-${index}`);

if (answer.style.display === 'none') {
answer.style.display = 'block';
arrow.style.transform = 'rotate(180deg)';
arrow.textContent = '‚ñ≤';
} else {
answer.style.display = 'none';
arrow.style.transform = 'rotate(0deg)';
arrow.textContent = '‚ñº';
}
}

function closeFAQ() {
const overlays = document.querySelectorAll('.modal-container.faq, .modal-overlay');
overlays.forEach(el => el.remove());
}

function showSigilarium() {
closeSettingsMenu();
const v = document.getElementById('gameView');
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];
const passiveSigils = ['Expand', 'Asterisk', 'Star'];

const getLevelColor = (level) => {
if(level === 0) return '#666';
if(level === 1) return '#000';
if(level === 2) return '#0d9488';
if(level === 3) return '#9333ea';
if(level === 4) return '#d97706';
return '#ff0080'; // L5 gradient
};

let html = `
<div class="modal-container light">
<h2 class="modal-title purple">üìñ SIGILARIUM üìñ</h2>
<p style="text-align:center;font-size:0.9rem;opacity:0.8;margin-bottom:1.5rem">All Sigils and Their Permanent Upgrade Levels</p>

<!-- Core Sigils -->
<h3 style="color:#2c63c7;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #2c63c7;padding-bottom:0.25rem">‚öîÔ∏è Core Sigils</h3>
<div style="display:grid;gap:0.75rem;margin-bottom:1.5rem">
`;

coreSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const displayLevel = permLevel + 1; // Actives display +1 higher (perm 0 = L1)
const cl = permLevel===0?'l1':permLevel===1?'l2':permLevel===2?'l3':permLevel===3?'l4':permLevel===4?'l5':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(displayLevel);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl}" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Level: <span style="color:${levelColor};font-weight:bold">L${displayLevel}</span></div>
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>

<!-- Advanced Sigils -->
<h3 style="color:#f97316;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #f97316;padding-bottom:0.25rem">üî• Advanced Sigils</h3>
<div style="display:grid;gap:0.75rem;margin-bottom:1.5rem">
`;

advancedSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const displayLevel = permLevel + 1; // Actives display +1 higher (perm 0 = L1)
const cl = permLevel===0?'l1':permLevel===1?'l2':permLevel===2?'l3':permLevel===3?'l4':permLevel===4?'l5':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(displayLevel);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl}" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Level: <span style="color:${levelColor};font-weight:bold">L${displayLevel}</span></div>
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>

<!-- Passive Sigils -->
<h3 style="color:#9333ea;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #9333ea;padding-bottom:0.25rem">‚ú® Passive Sigils</h3>
<div style="display:grid;gap:0.75rem">
`;

passiveSigils.forEach(sig => {
const level = S.sig[sig] || 0;
const cl = level===0?'l0':level===1?'l1':level===2?'l2':level===3?'l3':level===4?'l4':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(level);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl} passive" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Permanent Level: <span style="color:${levelColor};font-weight:bold">L${level}</span></div>
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>
<button class="btn" onclick="closeSigilarium()" style="margin-top:1.5rem;background:#9333ea;width:100%">Close</button>
</div>
<div class="modal-overlay" onclick="closeSigilarium()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeSigilarium() {
// Fix: Sigilarium uses .light class, not .dark - remove both to be safe
const menus = document.querySelectorAll('.modal-container.dark, .modal-container.light, .modal-overlay');
menus.forEach(m => m.remove());
}

function debugAddGold() {
S.gold += 100;
upd();
toast('Added 100 Gold!', 1200);
closeDebugMenu();
}

function debugAddXP() {
S.xp += 100;
upd();
toast('Added 100 XP!', 1200);
closeDebugMenu();
}

function debugJumpFloor() {
const input = document.getElementById('debugFloorInput');
const targetFloor = parseInt(input.value);
if(targetFloor < 1 || targetFloor > 19 || isNaN(targetFloor)) {
toast('Invalid floor! Must be 1-19', 1200);
return;
}
closeDebugMenu();
S.floor = targetFloor;
upd();
startFloor(targetFloor);
toast(`Jumped to Floor ${targetFloor}!`, 1200);
}

function debugDealDamage() {
if(!S.enemies || S.enemies.length === 0) {
toast('No enemies in combat!', 1200);
return;
}
// Deal 50 damage to first enemy
const enemy = S.enemies[0];
enemy.h -= 50;
if(enemy.h < 0) enemy.h = 0;
upd();
toast(`Dealt 50 damage to ${getEnemyDisplayName(enemy)}!`, 1200);
closeDebugMenu();
// Check if combat is over
setTimeout(() => checkCombatEnd(), 100);
}

function debugSetSigilLevel() {
const sigilSelect = document.getElementById('debugSigilSelect');
const levelInput = document.getElementById('debugSigilLevel');
const sigil = sigilSelect.value;
const newLevel = parseInt(levelInput.value);

if(isNaN(newLevel) || newLevel < 0 || newLevel > 5) {
toast('Invalid level! Must be 0-5', 1200);
return;
}

S.sig[sigil] = newLevel;
savePermanent();
upd();
toast(`Set ${sigil} to Level ${newLevel}!`, 1200);
closeDebugMenu();
}

function debugSetHeroStats() {
const heroSelect = document.getElementById('debugHeroSelect');
const powInput = document.getElementById('debugHeroPOW');
const maxHPInput = document.getElementById('debugHeroMaxHP');
const heroIdx = parseInt(heroSelect.value);
const newPOW = parseInt(powInput.value);
const newMaxHP = parseInt(maxHPInput.value);

if(isNaN(newPOW) || newPOW < 1 || newPOW > 20) {
toast('Invalid POW! Must be 1-20', 1200);
return;
}
if(isNaN(newMaxHP) || newMaxHP < 1 || newMaxHP > 50) {
toast('Invalid Max HP! Must be 1-50', 1200);
return;
}

const hero = S.heroes[heroIdx];
hero.p = newPOW;
hero.m = newMaxHP;
// Also set current HP to max HP for convenience
hero.h = newMaxHP;
// Clear Last Stand if setting HP > 0
if(hero.ls && hero.h > 0) { hero.ls = false; hero.lst = 0; }
saveGame();
upd();
toast(`Updated ${hero.n}: POW=${newPOW}, HP=${newMaxHP}!`, 1200);
closeDebugMenu();
render();
}

function debugReviveFromLastStand() {
// Find heroes in Last Stand and revive them
const lastStandHeroes = S.heroes.filter(h => h.ls);
if(lastStandHeroes.length === 0) {
toast('No heroes in Last Stand!', 1200);
closeDebugMenu();
return;
}
lastStandHeroes.forEach(h => {
h.ls = false;
h.lst = 0;
h.h = Math.max(1, Math.floor(h.m / 2)); // Restore to 50% HP
});
saveGame();
upd();
toast(`Revived ${lastStandHeroes.length} hero(es) from Last Stand!`, 1500);
closeDebugMenu();
render();
}



// ===== FROGGLE CONTROLLER =====
// Supports both Gamepad API (desktop/native) and keyboard events (Steam Deck browser)
// Steam Deck in browser mode converts controller to keyboard - we handle both

const GamepadController = {
  // State
  active: false,
  focusedElement: null,
  focusableElements: [],
  lastFocusedId: null,

  // Gamepad state
  pollInterval: null,
  lastButtons: {},
  lastAxes: { lx: 0, ly: 0 },
  connected: false,

  // Steam Deck input interception detection
  connectTime: 0,
  firstInputTime: 0,
  inputDetectionShown: false,

  // Debounce tracking - prevents double-fire from keyboard events
  lastActionTime: {},
  DEBOUNCE_MS: 150,

  // Initialize controller system
  init() {
    debugLog('[CONTROLLER] Initializing...');

    if (typeof S !== 'undefined' && S.controllerDisabled) {
      debugLog('[CONTROLLER] Controller support disabled in settings');
      return;
    }

    // Keyboard always works (primary for Steam Deck browser mode)
    this.initKeyboard();
    this.initTouchDetection();

    // Gamepad API (works on desktop, native apps, some Steam configs)
    this.initGamepad();

    debugLog('[CONTROLLER] Initialization complete');
  },

  // Check debounce - returns true if action should be allowed
  shouldAllowAction(action) {
    const now = Date.now();
    const lastTime = this.lastActionTime[action] || 0;
    if (now - lastTime < this.DEBOUNCE_MS) {
      return false;
    }
    this.lastActionTime[action] = now;
    return true;
  },

  // Initialize Web Gamepad API
  initGamepad() {
    // Store bound handlers for cleanup in destroy()
    this._onGamepadConnected = (e) => {
      debugLog('[CONTROLLER] Gamepad connected:', e.gamepad.id);
      this.connected = true;
      this.connectTime = Date.now();
      this.firstInputTime = 0;
      this.inputDetectionShown = false;
      this.activate();
      toast('üéÆ Controller connected!', 2000);
      this.startPolling();
      this.startInputDetection();
    };

    this._onGamepadDisconnected = (e) => {
      debugLog('[CONTROLLER] Gamepad disconnected:', e.gamepad.id);
      this.connected = false;
      const gamepads = navigator.getGamepads();
      const anyConnected = Array.from(gamepads).some(gp => gp !== null);
      if (!anyConnected) {
        this.stopPolling();
      }
    };

    window.addEventListener('gamepadconnected', this._onGamepadConnected);
    window.addEventListener('gamepaddisconnected', this._onGamepadDisconnected);

    // Check if gamepad already connected
    const gamepads = navigator.getGamepads();
    for (const gp of gamepads) {
      if (gp) {
        debugLog('[CONTROLLER] Gamepad already connected:', gp.id);
        this.connected = true;
        this.startPolling();
        break;
      }
    }
  },

  startPolling() {
    if (this.pollInterval) return;
    debugLog('[CONTROLLER] Starting gamepad polling');
    this.pollInterval = setInterval(() => this.poll(), 16);
  },

  stopPolling() {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
      debugLog('[CONTROLLER] Stopped gamepad polling');
    }
  },

  poll() {
    const gamepads = navigator.getGamepads();
    const gp = gamepads[0] || gamepads[1] || gamepads[2] || gamepads[3];

    if (!gp) return;

    const prev = this.lastButtons;

    // Face buttons (debounced to match keyboard behavior)
    if (this.pressed(gp, 0) && !prev[0]) { this.markInputReceived(); if (this.shouldAllowAction('A')) this.handleA(); }
    if (this.pressed(gp, 1) && !prev[1]) { this.markInputReceived(); if (this.shouldAllowAction('B')) this.handleB(); }
    if (this.pressed(gp, 2) && !prev[2]) { this.markInputReceived(); if (this.shouldAllowAction('X')) this.handleX(); }
    if (this.pressed(gp, 3) && !prev[3]) { this.markInputReceived(); if (this.shouldAllowAction('Y')) this.handleY(); }

    // Shoulders
    if (this.pressed(gp, 4) && !prev[4]) { this.markInputReceived(); this.handleLB(); }
    if (this.pressed(gp, 5) && !prev[5]) { this.markInputReceived(); this.handleRB(); }

    // Triggers
    if (this.pressed(gp, 6) && !prev[6]) { this.markInputReceived(); this.handleLT(); }
    if (this.pressed(gp, 7) && !prev[7]) { this.markInputReceived(); this.handleRT(); }

    // Select/Start (debounced - these open menus)
    if (this.pressed(gp, 8) && !prev[8]) { this.markInputReceived(); if (this.shouldAllowAction('Select')) this.handleSelect(); }
    if (this.pressed(gp, 9) && !prev[9]) { this.markInputReceived(); if (this.shouldAllowAction('Start')) this.handleStart(); }

    // Stick clicks
    if (this.pressed(gp, 10) && !prev[10]) { this.markInputReceived(); this.handleL3(); }
    if (this.pressed(gp, 11) && !prev[11]) { this.markInputReceived(); this.handleR3(); }

    // D-pad
    if (this.pressed(gp, 12) && !prev[12]) { this.markInputReceived(); this.handleDirection('up'); }
    if (this.pressed(gp, 13) && !prev[13]) { this.markInputReceived(); this.handleDirection('down'); }
    if (this.pressed(gp, 14) && !prev[14]) { this.markInputReceived(); this.handleDirection('left'); }
    if (this.pressed(gp, 15) && !prev[15]) { this.markInputReceived(); this.handleDirection('right'); }

    // Analog sticks
    const deadzone = 0.3;
    const lx = gp.axes[0] || 0;
    const ly = gp.axes[1] || 0;
    const prevLx = this.lastAxes.lx;
    const prevLy = this.lastAxes.ly;

    if (lx < -deadzone && prevLx >= -deadzone) { this.markInputReceived(); this.handleDirection('left'); }
    if (lx > deadzone && prevLx <= deadzone) { this.markInputReceived(); this.handleDirection('right'); }
    if (ly < -deadzone && prevLy >= -deadzone) { this.markInputReceived(); this.handleDirection('up'); }
    if (ly > deadzone && prevLy <= deadzone) { this.markInputReceived(); this.handleDirection('down'); }

    // Right stick: smooth scrolling (more useful than duplicating left stick nav)
    const rx = gp.axes[2] || 0;
    const ry = gp.axes[3] || 0;

    if (Math.abs(ry) > deadzone) {
      this.markInputReceived();
      this.scrollSmooth(ry);
    }

    // Save state
    this.lastButtons = {};
    for (let i = 0; i < gp.buttons.length; i++) {
      this.lastButtons[i] = this.pressed(gp, i);
    }
    this.lastAxes = { lx, ly };
  },

  pressed(gp, index) {
    const btn = gp.buttons[index];
    if (!btn) return false;
    return typeof btn === 'object' ? btn.pressed : btn > 0.5;
  },

  markInputReceived() {
    if (!this.firstInputTime && this.connectTime) {
      this.firstInputTime = Date.now();
      debugLog('[CONTROLLER] First input received after', this.firstInputTime - this.connectTime, 'ms');
    }
  },

  startInputDetection() {
    setTimeout(() => {
      if (this.connected && !this.firstInputTime && !this.inputDetectionShown) {
        this.inputDetectionShown = true;
        this.showSteamDeckWarning();
      }
    }, 5000);
  },

  showSteamDeckWarning() {
    debugLog('[CONTROLLER] No input detected - possible Steam interception');
    const isSteamDeck = navigator.userAgent.includes('Linux') ||
                        (typeof window.electronInfo !== 'undefined');

    if (isSteamDeck) {
      toast('‚ö†Ô∏è Controller not responding? Try keyboard mode or check Steam settings', 4000);
      setTimeout(() => {
        if (!this.firstInputTime && typeof showSteamDeckHelp === 'function') {
          showSteamDeckHelp();
        }
      }, 2000);
    }
  },

  initTouchDetection() {
    this._onTouchStart = () => {
      if (this.active) {
        debugLog('[CONTROLLER] Touch detected, deactivating controller mode');
        this.deactivate();
      }
    };
    document.addEventListener('touchstart', this._onTouchStart, { passive: true });
  },

  // Keyboard handler - primary input for Steam Deck browser mode
  initKeyboard() {
    this._onKeyDown = e => {
      if (typeof S !== 'undefined' && S.controllerDisabled) return;
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

      // Ignore key repeat (holding button down causes spam)
      if (e.repeat) return;

      let handled = false;

      switch (e.key) {
        // D-pad / Arrow keys
        case 'ArrowUp':
          this.handleDirection('up');
          handled = true;
          break;
        case 'ArrowDown':
          this.handleDirection('down');
          handled = true;
          break;
        case 'ArrowLeft':
          this.handleDirection('left');
          handled = true;
          break;
        case 'ArrowRight':
          this.handleDirection('right');
          handled = true;
          break;

        // A button - Enter (with debounce to prevent double-fire)
        case 'Enter':
          if (this.shouldAllowAction('A')) {
            this.handleA();
          }
          handled = true;
          break;

        // Space also triggers A (debounced together with Enter)
        case ' ':
          if (this.shouldAllowAction('A')) {
            this.handleA();
          }
          handled = true;
          break;

        // B button - Escape OR Backspace (Steam browser template uses Backspace)
        case 'Escape':
        case 'Backspace':
          if (this.shouldAllowAction('B')) {
            this.handleB();
          }
          handled = true;
          break;

        // Tab for navigation
        case 'Tab':
          this.handleDirection(e.shiftKey ? 'left' : 'right');
          handled = true;
          break;

        // Bumpers often map to PageUp/PageDown in browser templates
        case 'PageUp':
          this.handleLB();
          handled = true;
          break;
        case 'PageDown':
          this.handleRB();
          handled = true;
          break;

        // Some Steam configs send letter keys for face buttons
        case 'x':
        case 'X':
          if (this.shouldAllowAction('X')) {
            this.handleX();
          }
          handled = true;
          break;
        case 'y':
        case 'Y':
          if (this.shouldAllowAction('Y')) {
            this.handleY();
          }
          handled = true;
          break;
      }

      if (handled) {
        e.preventDefault();
        if (!this.active) this.activate();
      }
    };
    document.addEventListener('keydown', this._onKeyDown);
  },

  // Activate controller mode (show focus ring)
  activate() {
    if (this.active) return;
    this.active = true;
    document.body.classList.add('controller-active');
    this.updateFocusableElements();
    if (this.focusableElements.length > 0) {
      const best = this.findBestDefaultFocus();
      this.setFocus(best || this.focusableElements[0]);
    }
    debugLog('[CONTROLLER] Activated');
  },

  deactivate() {
    if (!this.active) return;
    this.active = false;
    document.body.classList.remove('controller-active');
    this.clearFocus();
    debugLog('[CONTROLLER] Deactivated');
  },

  // ===== CONTEXT DETECTION =====

  getContext() {
    const tutorialModal = document.querySelector('.tutorial-modal-backdrop');
    if (tutorialModal && getComputedStyle(tutorialModal).display !== 'none') return 'tutorial';

    const confirmModal = document.querySelector('.confirm-modal');
    if (confirmModal && getComputedStyle(confirmModal).display !== 'none') return 'confirm';

    if (typeof S !== 'undefined' && S.suspended) return 'suspend';

    const modal = document.querySelector('.modal-container');
    if (modal && getComputedStyle(modal).display !== 'none') return 'modal';

    if (typeof S !== 'undefined' && S.heroes?.length > 0 && S.enemies?.length > 0 && S.turn === 'player') {
      return S.pending ? 'targeting' : 'combat';
    }

    return 'menu';
  },

  // ===== BUTTON HANDLERS =====

  handleA() {
    if (!this.active) this.activate();
    this.playClick();

    const ctx = this.getContext();

    if (ctx === 'tutorial') {
      const btn = document.querySelector('.tutorial-modal button, .tutorial-modal .btn');
      if (btn) btn.click();
      return;
    }

    if (ctx === 'confirm') {
      const btn = document.querySelector('.confirm-btn-yes');
      if (btn) btn.click();
      return;
    }

    if (ctx === 'suspend') {
      if (typeof resumeGame === 'function') resumeGame();
      return;
    }

    // Cooldown after tutorial dismiss to prevent click-through
    if (window.tutorialDismissTime && Date.now() - window.tutorialDismissTime < 300) return;

    // Try focused element first
    if (this.focusedElement && document.body.contains(this.focusedElement)) {
      if (this.focusedElement.hasAttribute('onclick')) {
        this.focusedElement.click();
        return;
      }
      const clickable = this.focusedElement.querySelector('[onclick], button, .btn');
      if (clickable) {
        clickable.click();
        return;
      }
      this.focusedElement.click();
      return;
    }

    // No focused element - find the most prominent clickable thing
    this.updateFocusableElements();
    if (this.focusableElements.length > 0) {
      const best = this.findBestDefaultFocus();
      if (best) {
        this.setFocus(best);
        best.click();
        return;
      }
    }

    // Last resort
    const anyBtn = document.querySelector('.btn:not([disabled]), button:not([disabled])');
    if (anyBtn) {
      anyBtn.click();
    }
  },

  handleB() {
    if (!this.active) this.activate();
    this.playClick();

    const ctx = this.getContext();

    if (ctx === 'confirm') {
      const btn = document.querySelector('.confirm-btn-no');
      if (btn) btn.click();
      return;
    }

    if (ctx === 'modal') {
      const backBtn = document.querySelector('.settings-back-btn, .modal-close, [onclick*="close"]');
      if (backBtn) {
        backBtn.click();
        return;
      }
      if (typeof closeSettingsMenu === 'function') {
        closeSettingsMenu();
        return;
      }
    }

    if (ctx === 'targeting' && typeof S !== 'undefined') {
      S.pending = null;
      S.targets = [];
      S.currentInstanceTargets = [];
      S.instancesRemaining = 0;
      if (typeof render === 'function') render();
      return;
    }

    // Try to find a back/cancel button
    const backBtn = document.querySelector(
      '.back-btn, [onclick*="back"], [onclick*="Back"], ' +
      '[onclick*="close"], [onclick*="Close"], ' +
      '[onclick*="cancel"], [onclick*="Cancel"], ' +
      '.modal-close, .settings-back-btn'
    );
    if (backBtn) {
      backBtn.click();
      return;
    }

    // Close any overlay
    const overlay = document.querySelector('.modal-overlay, .tutorial-modal-backdrop');
    if (overlay) {
      overlay.click();
    }
  },

  handleX() {
    if (!this.active) this.activate();
    this.playClick();

    const ctx = this.getContext();

    // In combat: use sigil and auto-target
    if (ctx === 'combat' || ctx === 'targeting') {
      if (this.focusedElement && document.body.contains(this.focusedElement)) {
        const sigil = this.focusedElement.classList?.contains('sigil')
          ? this.focusedElement
          : this.focusedElement.querySelector('.sigil.clickable');

        if (sigil && sigil.hasAttribute('onclick')) {
          sigil.click();
          setTimeout(() => this.autoTarget(), 50);
          return;
        }
      }
      this.autoTarget();
      return;
    }

    // Outside combat: X acts like A
    this.handleA();
  },

  handleY() {
    if (!this.active) this.activate();
    this.playClick();

    // Show sigil tooltip if focused
    if (this.focusedElement && document.body.contains(this.focusedElement)) {
      const sigil = this.focusedElement.classList?.contains('sigil')
        ? this.focusedElement
        : this.focusedElement.querySelector('.sigil');

      if (sigil && typeof showTooltip === 'function') {
        const name = sigil.dataset?.sigil || sigil.textContent?.trim();
        const level = parseInt(sigil.dataset?.level) || 0;
        showTooltip(name, sigil, level);
        return;
      }
    }

    // No sigil: show controls guide
    if (typeof showControlsGuide === 'function') {
      showControlsGuide();
    }
  },

  handleLB() {
    if (!this.active) this.activate();
    this.playClick();
    const ctx = this.getContext();
    if (ctx === 'combat' || ctx === 'targeting') {
      this.cycleUnit('prev');
    } else {
      this.scrollPage('up');
    }
  },

  handleRB() {
    if (!this.active) this.activate();
    this.playClick();
    const ctx = this.getContext();
    if (ctx === 'combat' || ctx === 'targeting') {
      this.cycleUnit('next');
    } else {
      this.scrollPage('down');
    }
  },

  handleLT() {
    if (!this.active) this.activate();
    this.playClick();
    const ctx = this.getContext();
    if (ctx === 'combat' || ctx === 'targeting') {
      this.cycleSigil('prev');
    } else {
      this.handleDirection('left');
    }
  },

  handleRT() {
    if (!this.active) this.activate();
    this.playClick();
    const ctx = this.getContext();
    if (ctx === 'combat' || ctx === 'targeting') {
      this.cycleSigil('next');
    } else {
      this.handleDirection('right');
    }
  },

  handleSelect() {
    if (!this.active) this.activate();
    this.playClick();
    const ctx = this.getContext();

    if (ctx === 'targeting') {
      const enemies = document.querySelectorAll('.card.enemy:not(.dead)');
      const heroes = document.querySelectorAll('.card.hero:not(.dead)');

      if (this.focusedElement?.classList.contains('enemy') && heroes.length) {
        this.setFocus(heroes[0]);
      } else if (enemies.length) {
        this.setFocus(enemies[0]);
      }
    } else if (ctx === 'combat') {
      const activeHero = document.querySelector('.card.hero.active');
      if (activeHero) {
        const sigil = activeHero.querySelector('.sigil.clickable');
        if (sigil) {
          this.setFocus(sigil);
        }
      }
    } else {
      const primary = document.querySelector('.title-play-btn, .btn-primary, .btn:first-of-type');
      if (primary) {
        this.setFocus(primary);
      }
    }
  },

  handleStart() {
    if (!this.active) this.activate();
    this.playClick();
    if (typeof showSettingsMenu === 'function') {
      showSettingsMenu();
    }
  },

  handleL3() {
    if (!this.active) this.activate();
    this.playClick();
    if (typeof showControlsGuide === 'function') {
      showControlsGuide();
    }
  },

  handleR3() {
    if (!this.active) this.activate();
    this.playClick();
    if (typeof showControllerDebug === 'function') {
      const existing = document.getElementById('controller-debug-overlay');
      if (existing) {
        existing.remove();
      } else {
        showControllerDebug();
      }
    }
  },

  handleDirection(dir) {
    if (!this.active) {
      this.activate();
    }

    const ctx = this.getContext();

    if (ctx === 'tutorial' || ctx === 'suspend') return;

    if (ctx === 'confirm') {
      const yes = document.querySelector('.confirm-btn-yes');
      const no = document.querySelector('.confirm-btn-no');
      if (this.focusedElement === yes) {
        this.setFocus(no);
      } else {
        this.setFocus(yes);
      }
      this.playClick();
      return;
    }

    this.playClick();
    this.navigate(dir);
  },

  // ===== NAVIGATION =====

  navigate(dir) {
    this.updateFocusableElements();
    if (this.focusableElements.length === 0) return;

    if (!this.focusedElement || !document.body.contains(this.focusedElement)) {
      this.setFocus(this.focusableElements[0]);
      return;
    }

    const current = this.focusedElement.getBoundingClientRect();
    const cx = current.left + current.width / 2;
    const cy = current.top + current.height / 2;

    let best = null;
    let bestScore = Infinity;

    for (const el of this.focusableElements) {
      if (el === this.focusedElement) continue;

      const rect = el.getBoundingClientRect();
      const ex = rect.left + rect.width / 2;
      const ey = rect.top + rect.height / 2;

      const dx = ex - cx;
      const dy = ey - cy;

      let inDirection = false;
      switch (dir) {
        case 'up': inDirection = dy < -10; break;
        case 'down': inDirection = dy > 10; break;
        case 'left': inDirection = dx < -10; break;
        case 'right': inDirection = dx > 10; break;
      }

      if (!inDirection) continue;

      const dist = Math.sqrt(dx * dx + dy * dy);
      const perpDist = (dir === 'up' || dir === 'down') ? Math.abs(dx) : Math.abs(dy);
      const score = dist + perpDist * 2;

      if (score < bestScore) {
        bestScore = score;
        best = el;
      }
    }

    if (best) {
      this.setFocus(best);
    } else {
      // Wrap around: if no element found in direction, pick the furthest element
      // in the opposite direction (wraps focus to the other side of the screen)
      let wrapBest = null;
      let wrapScore = -Infinity;
      for (const el of this.focusableElements) {
        if (el === this.focusedElement) continue;
        const rect = el.getBoundingClientRect();
        const ex = rect.left + rect.width / 2;
        const ey = rect.top + rect.height / 2;
        let score;
        switch (dir) {
          case 'up': score = ey; break;     // Furthest down
          case 'down': score = -ey; break;  // Furthest up
          case 'left': score = ex; break;   // Furthest right
          case 'right': score = -ex; break; // Furthest left
        }
        if (score > wrapScore) {
          wrapScore = score;
          wrapBest = el;
        }
      }
      if (wrapBest) this.setFocus(wrapBest);
    }
  },

  // ===== FOCUS MANAGEMENT =====

  // Save focus state before DOM updates (called from render())
  saveFocusState() {
    this._savedFocusId = this.focusedElement?.id || null;
    this._savedFocusClasses = this.focusedElement ?
      Array.from(this.focusedElement.classList).filter(c => c !== 'controller-focus').join('.') : null;
    this._savedFocusTag = this.focusedElement?.tagName || null;
    this._savedFocusText = this.focusedElement?.textContent?.trim()?.substring(0, 30) || null;
  },

  // Restore focus state after DOM updates (called from render())
  restoreFocusState() {
    if (!this.active) return;

    // Try to find element by ID first (most reliable)
    if (this._savedFocusId) {
      const el = document.getElementById(this._savedFocusId);
      if (el) {
        this.updateFocusableElements();
        this.setFocus(el);
        return;
      }
    }

    // Try to find by class combination (for cards, sigils, etc.)
    if (this._savedFocusClasses && this._savedFocusTag) {
      const selector = this._savedFocusTag.toLowerCase() + '.' + this._savedFocusClasses.split('.').join('.');
      try {
        const candidates = document.querySelectorAll(selector);
        if (candidates.length === 1) {
          this.updateFocusableElements();
          this.setFocus(candidates[0]);
          return;
        }
        // Multiple matches - try to match by text content
        if (candidates.length > 1 && this._savedFocusText) {
          for (const c of candidates) {
            if (c.textContent?.trim()?.substring(0, 30) === this._savedFocusText) {
              this.updateFocusableElements();
              this.setFocus(c);
              return;
            }
          }
        }
      } catch(e) { /* invalid selector, fall through */ }
    }

    // Fallback: focus best default element
    this.updateFocusableElements();
    if (this.focusableElements.length > 0) {
      const best = this.findBestDefaultFocus();
      this.setFocus(best || this.focusableElements[0]);
    }
  },

  updateFocusableElements() {
    const selectors = [
      '.btn:not([disabled])',
      '.card.targetable',
      '.card.hero:not(.dead)',
      '.card.enemy:not(.dead)',
      '.sigil.clickable',
      'button:not([disabled])',
      '[onclick]',
      '.hero-select-card',
      '.encounter-choice',
      '.shop-item',
      '.upgrade-option'
    ];

    // Scope to active modal if one exists, preventing focus from jumping behind it
    let root = document;
    const ctx = this.getContext();
    if (ctx === 'tutorial') {
      root = document.querySelector('.tutorial-modal-backdrop') || document;
    } else if (ctx === 'confirm') {
      root = document.querySelector('.confirm-modal') || document;
    } else if (ctx === 'modal') {
      root = document.querySelector('.modal-container') || document;
    }

    this.focusableElements = Array.from(
      root.querySelectorAll(selectors.join(','))
    ).filter(el => {
      const style = getComputedStyle(el);
      if (style.display === 'none' || style.visibility === 'hidden') return false;
      const rect = el.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) return false;
      if (rect.bottom < 0 || rect.top > window.innerHeight + 100) return false;
      return true;
    });
  },

  setFocus(el) {
    if (!el) return;

    if (this.focusedElement) {
      this.focusedElement.classList.remove('controller-focus');
    }

    this.focusedElement = el;
    el.classList.add('controller-focus');

    if (el.id) {
      this.lastFocusedId = el.id;
    }

    el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  },

  clearFocus() {
    if (this.focusedElement) {
      this.focusedElement.classList.remove('controller-focus');
      this.focusedElement = null;
    }
  },

  findBestDefaultFocus() {
    if (this.lastFocusedId) {
      const el = document.getElementById(this.lastFocusedId);
      if (el && this.focusableElements.includes(el)) {
        return el;
      }
    }

    const ctx = this.getContext();

    // Title screen: prioritize Play button
    const playBtn = document.querySelector('.title-play-btn');
    if (playBtn && this.focusableElements.includes(playBtn)) {
      return playBtn;
    }

    // Combat: prioritize active hero or targetable
    if (ctx === 'combat' || ctx === 'targeting') {
      const activeHero = document.querySelector('.card.hero.active');
      if (activeHero) return activeHero;

      const targetable = document.querySelector('.card.targetable');
      if (targetable) return targetable;
    }

    // Default: prioritize primary buttons
    const primaryBtn = document.querySelector('.btn-primary, .btn:not(.title-secondary-btn)');
    if (primaryBtn && this.focusableElements.includes(primaryBtn)) {
      return primaryBtn;
    }

    return this.focusableElements[0];
  },

  // ===== COMBAT HELPERS =====

  cycleUnit(dir) {
    const ctx = this.getContext();
    let cards;

    if (ctx === 'targeting') {
      if (typeof S !== 'undefined') {
        if (['Attack', 'Grapple', 'D20_TARGET'].includes(S.pending)) {
          cards = Array.from(document.querySelectorAll('.card.enemy:not(.dead)'));
        } else {
          cards = Array.from(document.querySelectorAll('.card.hero:not(.dead)'));
        }
      }
    } else {
      cards = Array.from(document.querySelectorAll('.card.hero:not(.dead)'));
    }

    if (!cards || cards.length === 0) return;

    let idx = cards.findIndex(c => c === this.focusedElement || c.contains(this.focusedElement));
    if (idx === -1) idx = 0;
    else idx = dir === 'next' ? (idx + 1) % cards.length : (idx - 1 + cards.length) % cards.length;

    this.setFocus(cards[idx]);
  },

  cycleSigil(dir) {
    let hero = this.focusedElement?.closest('.card.hero');
    if (!hero) {
      hero = document.querySelector('.card.hero.active');
    }
    if (!hero) return;

    const sigils = Array.from(hero.querySelectorAll('.sigil.clickable'));
    if (sigils.length === 0) return;

    let idx = sigils.findIndex(s => s === this.focusedElement);
    if (idx === -1) idx = 0;
    else idx = dir === 'next' ? (idx + 1) % sigils.length : (idx - 1 + sigils.length) % sigils.length;

    this.setFocus(sigils[idx]);
  },

  autoTarget() {
    const ctx = this.getContext();
    if (ctx !== 'targeting' || typeof S === 'undefined' || !S.pending) return;

    let targets;
    if (['Attack', 'Grapple', 'D20_TARGET'].includes(S.pending)) {
      targets = Array.from(document.querySelectorAll('.card.enemy:not(.dead)'));
    } else {
      targets = Array.from(document.querySelectorAll('.card.hero:not(.dead)'));
    }

    if (targets.length === 0) return;

    const target = targets[0];
    if (target.hasAttribute('onclick')) {
      target.click();
    }
  },

  scrollPage(dir) {
    const gameView = document.getElementById('gameView');
    if (gameView) {
      const amount = window.innerHeight * 0.5;
      gameView.scrollBy({ top: dir === 'up' ? -amount : amount, behavior: 'smooth' });
    }
  },

  // Smooth per-frame scrolling for right stick (called each poll at 60fps)
  scrollSmooth(axisValue) {
    const gameView = document.getElementById('gameView');
    if (gameView) {
      // Scale by axis deflection for proportional speed
      const amount = axisValue * 12;
      gameView.scrollBy({ top: amount, behavior: 'instant' });
    }
  },

  // ===== UI =====

  playClick() {
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }
  },

  // ===== CLEANUP =====

  destroy() {
    this.stopPolling();
    this.deactivate();
    // Remove event listeners to prevent accumulation on reinit
    if (this._onGamepadConnected) {
      window.removeEventListener('gamepadconnected', this._onGamepadConnected);
    }
    if (this._onGamepadDisconnected) {
      window.removeEventListener('gamepaddisconnected', this._onGamepadDisconnected);
    }
    if (this._onTouchStart) {
      document.removeEventListener('touchstart', this._onTouchStart);
    }
    if (this._onKeyDown) {
      document.removeEventListener('keydown', this._onKeyDown);
    }
  }
};

// Global helpers
function toggleControllerSupport(enabled) {
  if (typeof S === 'undefined') return;
  S.controllerDisabled = !enabled;
  if (enabled) {
    toast('üéÆ Controller support enabled!', 2000);
    GamepadController.init();
  } else {
    toast('Controller support disabled.', 1200);
    GamepadController.destroy();
  }
  if (typeof savePermanent === 'function') savePermanent();
}

function forceReinitController() {
  if (typeof S !== 'undefined') S.controllerDisabled = false;
  GamepadController.destroy();
  GamepadController.init();
  toast('üéÆ Controller re-initialized!', 2500);
  if (typeof savePermanent === 'function') savePermanent();
  if (typeof closeSettingsMenu === 'function') closeSettingsMenu();
}

function showSteamDeckHelp() {
  // Remove existing if already open
  closeSteamDeckHelp();
  // Append to body (not gameView) so it survives screen transitions
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay steam-deck-help-overlay';
  overlay.onclick = closeSteamDeckHelp;
  const modal = document.createElement('div');
  modal.className = 'modal-container dark steam-deck-help-modal';
  modal.style.maxWidth = '400px';
  modal.innerHTML = `
  <h2 class="modal-title" style="margin-bottom:1rem">üéÆ Steam Deck Controls</h2>
  <div style="text-align:left;font-size:0.85rem;line-height:1.5">
    <p style="margin-bottom:0.8rem">In browser mode, Steam converts controller to keyboard. The game handles both.</p>
    <p style="margin-bottom:0.5rem"><strong>Working controls:</strong></p>
    <ul style="margin-left:1.2rem;margin-bottom:1rem">
      <li><strong>D-pad</strong> - Navigate (arrow keys)</li>
      <li><strong>A</strong> - Select (Enter)</li>
      <li><strong>B</strong> - Back (Backspace)</li>
      <li><strong>Bumpers</strong> - Scroll (PageUp/Down)</li>
    </ul>
    <p style="font-size:0.8rem;opacity:0.8">If Gamepad mode works better for you, try Steam ‚Üí Controller Settings ‚Üí "Gamepad" template.</p>
  </div>
  <button class="btn" onclick="closeSteamDeckHelp()" style="margin-top:1rem">Got it</button>`;
  document.body.appendChild(overlay);
  document.body.appendChild(modal);
}

function closeSteamDeckHelp() {
  const overlay = document.querySelector('.steam-deck-help-overlay');
  if (overlay) overlay.remove();
  const modal = document.querySelector('.steam-deck-help-modal');
  if (modal) modal.remove();
}

// ===== SERVICE WORKER REGISTRATION =====
if ('serviceWorker' in navigator) {
navigator.serviceWorker.register('./sw.js')
.then(reg => {
debugLog('[SW] Service worker registered:', reg.scope);

// Check for updates immediately and periodically
reg.update().catch(() => {});

// Check for updates every 60 seconds while app is open
setInterval(() => {
reg.update().catch(() => {});
}, 60000);

// Handle waiting service worker (update available)
if (reg.waiting) {
debugLog('[SW] Update waiting, activating...');
reg.waiting.postMessage({ type: 'SKIP_WAITING' });
}

// Listen for new service worker installing
reg.addEventListener('updatefound', () => {
const newWorker = reg.installing;
debugLog('[SW] Update found, installing...');

newWorker.addEventListener('statechange', () => {
if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
debugLog('[SW] New version installed, activating...');
newWorker.postMessage({ type: 'SKIP_WAITING' });
}
});
});
})
.catch(err => console.warn('[SW] Registration failed:', err));

// Reload page when new service worker takes control
navigator.serviceWorker.addEventListener('controllerchange', () => {
debugLog('[SW] Controller changed, reloading for update...');
window.location.reload();
});
}

// ===== INIT =====
window.onload = () => {
debugLog('[FROGGLE] window.onload fired');
// Check for last used slot
const lastSlot = localStorage.getItem('froggle8_current_slot');
if(lastSlot) {
const slot = parseInt(lastSlot);
debugLog('[FROGGLE] Found last used slot:', slot);
// Try to load slot-specific permanent data
const permData = localStorage.getItem(`froggle8_permanent_slot${slot}`);
if(permData) {
try {
const j = JSON.parse(permData);
S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// One-time fix: Detect and repair old saves with starter actives at L1 (should be L0)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
let needsFix = false;
starterActives.forEach(sig => {
if(S.sig[sig] === 1 && S.sigUpgradeCounts[sig] === 0) {
S.sig[sig] = 0;
needsFix = true;
}
});
if(needsFix) {
debugLog('[SAVE] Fixed old save format: starter actives L1‚ÜíL0');
}
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.pedestal = j.pedestal || [];
S.hasReachedFloor20 = j.hasReachedFloor20 || false;
S.fuUnlocked = j.fuUnlocked || false;
S.forcedFUEntry = j.forcedFUEntry || false;
S.tapoUnlocked = j.tapoUnlocked || false;
S.advancedSigilsUnlocked = j.advancedSigilsUnlocked || false;
S.passiveSigilsUnlocked = j.passiveSigilsUnlocked || false;
S.runNumber = j.runNumber || 1;
S.runsAttempted = j.runsAttempted || 0;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.tooltipsDisabled = j.tooltipsDisabled || false;
S.highContrastMode = j.highContrastMode || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
S.controllerDisabled = j.controllerDisabled || false;
S.animationSpeed = j.animationSpeed !== undefined ? j.animationSpeed : 1;
S.masterVolume = j.masterVolume !== undefined ? j.masterVolume : 1.0;
S.sfxVolume = j.sfxVolume !== undefined ? j.sfxVolume : 1.0;
S.musicVolume = j.musicVolume !== undefined ? j.musicVolume : 1.0;
S.pondHistory = j.pondHistory || [];
// Apply high contrast mode if enabled
if(S.highContrastMode) document.body.classList.add('high-contrast');
// Load quest data with defaults
S.questsCompleted = j.questsCompleted || {};
S.questsClaimed = j.questsClaimed || {};
if(j.questProgress) {
  Object.assign(S.questProgress, j.questProgress);
  if(!S.questProgress.heroesPlayed) S.questProgress.heroesPlayed = { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 };
  if(!S.questProgress.heroWins) S.questProgress.heroWins = { Warrior: 0, Tank: 0, Mage: 0, Healer: 0, Tapo: 0 };
  if(!S.questProgress.neutralsCompleted) S.questProgress.neutralsCompleted = { shopkeeper: false, wishingwell: false, treasurechest: false, wizard: false, oracle: false, encampment: false, gambling: false, ghost: false, royal: false };
  if(!S.questProgress.enemyTypesDefeated) S.questProgress.enemyTypesDefeated = { Goblin: false, Wolf: false, Orc: false, Giant: false, 'Cave Troll': false, Dragon: false, Flydra: false };
}
if(j.tutorialFlags) Object.assign(S.tutorialFlags, j.tutorialFlags);
S.currentSlot = slot;
debugLog('[FROGGLE] Loaded slot-specific permanent data');
} catch(e) {
console.warn('[FROGGLE] Failed to parse slot permanent data:', e);
loadPermanent(); // Fallback to old format
}
} else {
loadPermanent(); // No slot data, use old format
}
} else {
loadPermanent(); // No last slot, use old format
}
debugLog('[FROGGLE] loadPermanent complete, S.runNumber:', S.runNumber, 'S.helpTipsDisabled:', S.helpTipsDisabled);
applyVolumeSettings(); // Apply audio volume settings
initToastLog(); // Initialize toast log UI
initSuspendSystem(); // Initialize autosave and suspend/resume system
Steam.init(); // Initialize Steam achievements/stats (if running in Electron)
GamepadController.init(); // Initialize Steam Deck / controller support
mainTitlePage();
debugLog('[FROGGLE] mainTitlePage called');
};

// VISIBLE error overlay for debugging (especially Steam Deck where console isn't accessible)
function showErrorOverlay(title, details) {
  let overlay = document.getElementById('errorOverlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'errorOverlay';
    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.95);color:#ff6b6b;padding:2rem;z-index:999999;overflow:auto;font-family:monospace;font-size:14px;';
    document.body.appendChild(overlay);
  }
  const errorHtml = `
    <div style="max-width:800px;margin:0 auto;">
      <h1 style="color:#ff6b6b;margin-bottom:1rem;">‚ö†Ô∏è ${title}</h1>
      <pre style="background:#1a1a1a;padding:1rem;border-radius:8px;overflow-x:auto;white-space:pre-wrap;word-break:break-all;">${details}</pre>
      <p style="margin-top:1rem;color:#888;">Build: ${typeof GAME_VERSION !== 'undefined' ? GAME_VERSION : 'unknown'}</p>
      <button onclick="this.parentElement.parentElement.remove()" style="margin-top:1rem;padding:0.5rem 1rem;background:#333;color:#fff;border:none;border-radius:4px;cursor:pointer;">Dismiss</button>
    </div>
  `;
  overlay.innerHTML = errorHtml;
}

// Global error handler for image loading failures
window.addEventListener('error', (e) => {
if(e.target && e.target.tagName === 'IMG') {
console.error('[FROGGLE] IMAGE LOAD FAILED:', e.target.src);
console.error('[FROGGLE] Current location:', window.location.href);
console.error('[FROGGLE] Image path:', e.target.getAttribute('src'));
} else if(e.message) {
console.error('[FROGGLE] JAVASCRIPT ERROR:', e.message);
console.error('[FROGGLE] File:', e.filename, 'Line:', e.lineno, 'Col:', e.colno);
console.error('[FROGGLE] Stack:', e.error ? e.error.stack : 'No stack trace');
// Show visible error overlay
showErrorOverlay('JavaScript Error', `${e.message}\n\nFile: ${e.filename}\nLine: ${e.lineno}, Col: ${e.colno}\n\nStack:\n${e.error ? e.error.stack : 'No stack trace'}`);
}
}, true);

// Catch unhandled promise rejections
window.addEventListener('unhandledrejection', (e) => {
console.error('[FROGGLE] UNHANDLED PROMISE REJECTION:', e.reason);
showErrorOverlay('Unhandled Promise Rejection', String(e.reason));
});

// ===== MOBILE DOUBLE-TAP FOR AUTO-TARGET =====
// Only on touch devices: double-tap a sigil = select + auto-target
(function() {
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  if (!isTouchDevice) return;

  let lastTapTime = 0;
  let lastTapTarget = null;

  document.addEventListener('touchend', (e) => {
    // Find if we tapped on a clickable sigil
    const sigil = e.target.closest('.sigil.clickable');
    if (!sigil) {
      lastTapTarget = null;
      return;
    }

    const now = Date.now();
    const timeSinceLastTap = now - lastTapTime;

    // Check for double-tap (same sigil, within 300ms)
    if (lastTapTarget === sigil && timeSinceLastTap < 300) {
      // Double-tap detected! Prevent default and call actAndAutoTarget
      e.preventDefault();
      e.stopPropagation();

      // Extract sigil name and hero index from onclick attribute
      const onclick = sigil.getAttribute('onclick');
      if (onclick && onclick.startsWith("act('")) {
        // Parse: act('Attack', 0) -> sig='Attack', heroIdx=0
        const match = onclick.match(/act\('(\w+)',\s*(\d+)\)/);
        if (match && typeof actAndAutoTarget === 'function') {
          const sig = match[1];
          const heroIdx = parseInt(match[2]);
          debugLog('[TOUCH] Double-tap detected on sigil:', sig, 'hero:', heroIdx);
          actAndAutoTarget(sig, heroIdx);
        }
      }

      // Reset to prevent triple-tap continuing
      lastTapTarget = null;
      lastTapTime = 0;
    } else {
      // First tap or new target
      lastTapTarget = sigil;
      lastTapTime = now;
    }
  }, { passive: false });
})();


</script>
</body>
</html>
