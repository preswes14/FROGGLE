<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="apple-mobile-web-app-title" content="FROGGLE"/>
<meta name="theme-color" content="#22c55e"/>
<link rel="manifest" href="manifest.json"/>
<link rel="apple-touch-icon" href="assets/tapo-icon-180.png"/>
<link rel="icon" type="image/png" href="assets/tapo-icon.png"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<title>FROGGLE</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body { font-family: -apple-system, sans-serif; background: #d9cab1; color: #1c1b19; position: fixed; width: 100%; height: 100%; overflow: hidden; }
h1, h2, h3, .modal-title, .neutral-title { font-family: 'Fredoka One', cursive; }

/* Landscape orientation enforcement for mobile */
@media (max-width: 768px) and (orientation: portrait) {
  #rotatePrompt {
    display: flex !important;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
    z-index: 999999;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    padding: 2rem;
  }
  #gameView {
    display: none !important;
  }
  .header {
    display: none !important;
  }
}

@media (min-width: 769px), (orientation: landscape) {
  #rotatePrompt {
    display: none !important;
  }
}

.rotate-icon {
  font-size: 4rem;
  margin-bottom: 1.5rem;
  animation: rotatePhone 2s ease-in-out infinite;
}

@keyframes rotatePhone {
  0%, 100% { transform: rotate(0deg); }
  25% { transform: rotate(-15deg); }
  75% { transform: rotate(15deg); }
}

@keyframes portalPulse {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 0 20px rgba(220, 38, 38, 0.8);
  }
  50% {
    transform: scale(1.08);
    box-shadow: 0 0 40px rgba(220, 38, 38, 1), 0 0 60px rgba(220, 38, 38, 0.6);
  }
}

@keyframes portalGlow {
  0%, 100% {
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8)) drop-shadow(0 0 15px rgba(220, 38, 38, 0.8));
  }
  50% {
    filter: drop-shadow(0 2px 8px rgba(0,0,0,0.9)) drop-shadow(0 0 30px rgba(220, 38, 38, 1));
  }
}

.rotate-message {
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.rotate-submessage {
  font-size: 1rem;
  opacity: 0.9;
  text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

/* Z-INDEX LAYERING REFERENCE:
 * 999999 - Rotate device prompt
 * 30000 - Settings/Debug menus
 * 29999 - Settings/Debug backdrops
 * 25000 - Tooltips
 * 20000 - Tutorial modal backdrops
 * 20 - Hero selection click regions
 * 10 - Hero selection cards
 * Base (0-1) - Normal game elements
 */

/* Modal system - consistent styling for Settings, Debug, Sigilarium, FAQ */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  z-index: 29999;
}
.modal-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  border-radius: 12px;
  padding: 2rem;
  z-index: 30000;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}
.modal-container.dark {
  background: rgba(0,0,0,0.95);
  border: 3px solid #3b82f6;
  color: white;
}
.modal-container.light {
  background: linear-gradient(#fff, #f7f1e3);
  border: 3px solid #9333ea;
}
.modal-container.faq {
  background: linear-gradient(#fff, #f7f1e3);
  border: 3px solid #f97316;
}
.modal-title {
  text-align: center;
  margin-bottom: 1rem;
  font-size: 1.3rem;
}
.modal-title.blue { color: #3b82f6; }
.modal-title.purple { color: #9333ea; }
.modal-title.orange { color: #f97316; }
.modal-section-title {
  margin: 1rem 0 0.5rem 0;
}
.modal-section-title.green { color: #22c55e; }
.modal-section-title.blue { color: #3b82f6; }
.modal-checkbox-label {
  display: flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
  background: rgba(255,255,255,0.1);
  padding: 0.75rem;
  border-radius: 6px;
  margin-bottom: 0.5rem;
}
.modal-checkbox-label input {
  margin-right: 0.5rem;
  transform: scale(1.2);
}
.settings-back-btn {
  display: block;
  margin-top: 1.5rem;
  padding: 0.6rem 1.2rem;
  background: rgba(100, 100, 100, 0.8);
  color: white;
  border: 2px solid #666;
  border-radius: 8px;
  font-size: 0.9rem;
  cursor: pointer;
  text-align: center;
  width: auto;
  margin-left: auto;
  margin-right: auto;
}
.settings-back-btn:hover {
  background: rgba(120, 120, 120, 0.9);
}

/* Sigil description scaling indicator - shows level-dependent values */
.sig-scale { color: #f97316; text-decoration: underline; font-weight: bold; }

.header { padding: 0.5rem; background: linear-gradient(#fff, #f7f1e3); border-bottom: 2px solid #bda; display: flex; justify-content: space-between; font-size: 0.8rem; }
.game-area { height: calc(100vh - 44px); overflow-y: auto; padding: 0.5rem; -webkit-overflow-scrolling: touch; }
.game-area.no-scroll { overflow: hidden; padding: 0; }
.game-area.fade-out { animation: fadeOut 0.2s ease forwards; }
.game-area.fade-in { animation: fadeIn 0.2s ease forwards; }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
.btn { padding: 1rem; border: 3px solid #000; border-radius: 16px; background: #2c63c7; color: white; font-weight: bold; font-size: 1.1rem; min-height: 56px; width: 100%; margin-bottom: 0.75rem; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 12px rgba(0,0,0,0.15); transition: all 0.15s ease; overflow: hidden; text-overflow: ellipsis; word-wrap: break-word; line-height: 1.3; }
.btn:hover { transform: translateY(-2px); box-shadow: 0 6px 0 rgba(0,0,0,0.3), 0 8px 16px rgba(0,0,0,0.2); }
.btn:focus-visible { outline: 3px solid #3b82f6; outline-offset: 2px; }
.btn:active { transform: translateY(4px) scale(0.98); opacity: 0.9; box-shadow: 0 0 0 rgba(0,0,0,0.3), 0 2px 6px rgba(0,0,0,0.15); }
.btn.primary { background: #2c63c7; } /* Default blue */
.btn.safe { background: #22c55e; }
.btn.risky { background: #f97316; }
.btn.danger { background: #dc2626; }
.btn.secondary { background: #6b7280; }
.btn.disabled {
  opacity: 0.4;
  cursor: not-allowed;
  pointer-events: none;
}

/* Size variants */
.btn.small {
  padding: 0.5rem 0.75rem;
  font-size: 0.9rem;
  min-height: 40px;
}

.btn.large {
  padding: 1.5rem;
  font-size: 1.3rem;
  min-height: 70px;
}
.btn.icon {
  flex: 0 0 auto;
  width: auto;
  min-width: 48px;
  padding: 0.5rem;
  font-size: 1.3rem;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.choice { border: 3px solid #000; padding: 1rem; margin-bottom: 0.75rem; border-radius: 16px; background: white; min-height: 60px; width: 100%; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.2), 0 6px 12px rgba(0,0,0,0.1); transition: all 0.15s ease; overflow: hidden; word-wrap: break-word; line-height: 1.3; }
.choice:hover { transform: translateY(-2px); background: #f9f9f9; box-shadow: 0 6px 0 rgba(0,0,0,0.2), 0 8px 16px rgba(0,0,0,0.15); }
.choice:focus-visible { outline: 3px solid #3b82f6; outline-offset: 2px; }
.choice:active { transform: translateY(4px) scale(0.98); background: #f0f0f0; box-shadow: 0 0 0 rgba(0,0,0,0.2), 0 2px 6px rgba(0,0,0,0.1); }
.neutral-btn { padding: 0.5rem 0.75rem; margin-bottom: 0.5rem; border: 2px solid #000; border-radius: 14px; background: white; font-weight: bold; cursor: pointer; font-size: 0.9rem; box-shadow: 0 3px 0 rgba(0,0,0,0.3), 0 4px 8px rgba(0,0,0,0.15); transition: all 0.15s ease; overflow: hidden; text-overflow: ellipsis; word-wrap: break-word; line-height: 1.3; }
.neutral-btn:hover { transform: translateY(-1px); opacity: 0.95; box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 10px rgba(0,0,0,0.2); }
.neutral-btn:focus-visible { outline: 3px solid #3b82f6; outline-offset: 2px; }
.neutral-btn:active { transform: translateY(3px) scale(0.98); opacity: 0.9; box-shadow: 0 0 0 rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.15); }
.neutral-btn.safe { background: #22c55e; color: white; }
.neutral-btn.risky { background: #f97316; color: white; }
.neutral-btn.danger { background: #dc2626; color: white; }
.neutral-btn.secondary { background: #6b7280; color: white; }
.neutral-container {
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: row;
  background: #1a1a1a;
}
.neutral-left {
  flex: 1 1 55%;
  min-width: 45%;
  display: flex;
  flex-direction: column;
  padding: 1rem;
  overflow-y: auto;
  background: #1a1a1a;
}
.neutral-right {
  flex: 1 1 45%;
  min-width: 35%;
  height: auto;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-color: #2a2a2a;
}
@media (min-width: 768px) {
  .neutral-left {
    padding: 1.5rem;
  }
}
@media (min-width: 1400px) {
  .neutral-left {
    padding: 2rem;
  }
}
.neutral-header {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 1rem;
}
.neutral-stats {
  background: rgba(255,255,255,0.1);
  color: white;
  border-radius: 6px;
  padding: 0.4rem 0.75rem;
  font-size: 0.85rem;
  font-weight: bold;
  width: fit-content;
}
.neutral-narrative {
  background: rgba(255,255,255,0.05);
  color: white;
  border-radius: 8px;
  padding: 0.75rem;
  border: 1px solid rgba(255,255,255,0.1);
}
.neutral-title { font-size: 1.2rem; font-weight: bold; margin-bottom: 0.5rem; color: #60a5fa; }
.neutral-desc { font-size: 0.9rem; line-height: 1.4; margin-bottom: 0.5rem; max-width: 600px; }
.neutral-outcome { font-size: 0.85rem; padding: 0.5rem; background: rgba(255,255,255,0.15); border-radius: 4px; margin-bottom: 0.5rem; }
.neutral-content {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}
.neutral-footer {
  margin-top: auto;
  padding-top: 1rem;
}
.dice-roll { font-size: 1.2rem; font-weight: bold; text-align: center; padding: 1rem; background: #2c63c7; color: white; border-radius: 6px; margin: 1rem 0; }
/* Combat layout */
.combat-grid { display: flex; gap: 0.75rem; margin-bottom: 1rem; justify-content: center; }
.column { display: flex; flex-direction: column; gap: 0.5rem; align-items: center; }
.column.heroes { flex: 0 0 auto; }
.column.enemies { flex: 0 0 auto; }
.combat-lane {
  background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
  border: 4px solid #000;
  border-radius: 10px;
  padding: 1rem;
  margin: 0 auto 2rem auto;
  max-width: 800px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255,255,255,0.2);
  position: relative;
}
.combat-lane:not(:last-child)::after {
  content: '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ';
  position: absolute;
  bottom: -2rem;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(0,0,0,0.4);
  font-size: 1.2rem;
  letter-spacing: -2px;
  text-align: center;
  width: 100%;
  text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}
.card { width: auto; max-width: 160px; border: 3px solid #000; border-radius: 8px; padding: 0.5rem; min-height: 70px; font-size: 0.85rem; position: relative; overflow: hidden; word-wrap: break-word; }
.card-stats { font-size: 0.8rem; text-align: center; line-height: 1.2; overflow: hidden; text-overflow: ellipsis; }
.card.hero { background: #2c63c7; color: white; width: 160px; border-radius: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
.card.enemy { background: #b64141; color: white; width: 160px; }
.card.active { box-shadow: 0 0 0 4px #22c55e; animation: pulse-glow 1s infinite; }
.card.hero.chosen-one { position: relative; overflow: visible; }
.card.hero.chosen-one::before {
  content: 'üåº';
  position: absolute;
  top: -14px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 1.3rem;
  filter: drop-shadow(0 0 4px #fbbf24) drop-shadow(0 0 8px #fbbf24);
  z-index: 1;
  animation: chosen-glow 2s ease-in-out infinite;
}
@keyframes chosen-glow {
  0%, 100% { filter: drop-shadow(0 0 4px #fbbf24) drop-shadow(0 0 8px #fbbf24); }
  50% { filter: drop-shadow(0 0 6px #fcd34d) drop-shadow(0 0 12px #fbbf24); }
}
.card.selectable { cursor: pointer; box-shadow: 0 0 0 3px #22c55e; }
.card.selectable:active { transform: scale(0.98); }
.card.targetable { cursor: pointer; }
.card.targetable:active { transform: scale(0.98); }
.card.targeted { box-shadow: 0 0 0 4px lime; }
.card.acted { opacity: 0.6; }
.card.stunned { opacity: 0.7; border-color: #ef4444 !important; }
.card.last-stand {
  border-color: #dc2626;
  box-shadow: 0 0 0 3px #dc2626;
  animation: pulse-last-stand 1.5s ease-in-out infinite;
}
.card.hero.targetable { box-shadow: 0 0 0 3px #3b82f6; }
.card.enemy.targetable { box-shadow: 0 0 0 3px #dc2626; }
.card.hero.targeted { box-shadow: 0 0 0 4px #60a5fa; }
.card.enemy.targeted { box-shadow: 0 0 0 4px #ef4444; }
.card.hero-selectable { transition: transform 0.15s ease, box-shadow 0.15s ease; }
.card.hero-selectable:hover { transform: scale(1.02); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
.card.hit-flash { animation: damage-stagger 0.4s ease !important; }
.card.attack-slide { animation: attack-slide 0.48s ease !important; }
.card.heal-flash { animation: heal-flash 0.48s ease !important; }
.card.shield-flash { animation: shield-flash 0.48s ease !important; }
@keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 0 4px #22c55e; } 50% { box-shadow: 0 0 0 8px #22c55e; } }
@keyframes pulse-last-stand {
  0%, 100% { box-shadow: 0 0 0 3px #dc2626, 0 0 15px rgba(220, 38, 38, 0.6); border-color: #dc2626; }
  50% { box-shadow: 0 0 0 6px #dc2626, 0 0 25px rgba(220, 38, 38, 0.9); border-color: #ef4444; }
}
@keyframes pulse-text {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.85; transform: scale(1.05); }
}
@keyframes damage-stagger {
  0% { transform: translateX(0) scale(1); filter: brightness(1); }
  15% { transform: translateX(-15px) scale(0.95); filter: brightness(2) saturate(2); background-color: rgba(220, 38, 38, 0.5); }
  30% { transform: translateX(8px) scale(0.97); filter: brightness(1.8) saturate(2); background-color: rgba(220, 38, 38, 0.4); }
  50% { transform: translateX(-5px) scale(0.98); filter: brightness(1.5) saturate(1.5); background-color: rgba(220, 38, 38, 0.2); }
  70% { transform: translateX(2px) scale(0.99); filter: brightness(1.2); background-color: rgba(220, 38, 38, 0.1); }
  100% { transform: translateX(0) scale(1); filter: brightness(1); background-color: transparent; }
}
@keyframes attack-slide {
  0% { transform: translateX(0) scale(1); }
  15% { transform: translateX(5px) scale(1.08); }
  40% { transform: translateX(25px) scale(1.1); }
  60% { transform: translateX(25px) scale(1.1); }
  80% { transform: translateX(5px) scale(1.02); }
  100% { transform: translateX(0) scale(1); }
}
@keyframes enemy-attack-slide {
  0% { transform: translateX(0) scale(1); }
  15% { transform: translateX(-5px) scale(1.08); }
  40% { transform: translateX(-25px) scale(1.1); }
  60% { transform: translateX(-25px) scale(1.1); }
  80% { transform: translateX(-5px) scale(1.02); }
  100% { transform: translateX(0) scale(1); }
}
.card.enemy-attack-slide { animation: enemy-attack-slide 0.48s ease !important; }
@keyframes heal-flash {
  0% { filter: brightness(1); transform: scale(1); }
  15% { filter: brightness(1.5) saturate(1.5); transform: scale(1.03); background-color: rgba(34, 197, 94, 0.3); }
  30% { filter: brightness(2) saturate(2) hue-rotate(20deg); transform: scale(1.05); background-color: rgba(34, 197, 94, 0.4); box-shadow: 0 0 25px rgba(34, 197, 94, 0.9); }
  50% { filter: brightness(1.8) saturate(2) hue-rotate(15deg); transform: scale(1.05); background-color: rgba(34, 197, 94, 0.3); box-shadow: 0 0 20px rgba(34, 197, 94, 0.8); }
  70% { filter: brightness(1.4) saturate(1.3); transform: scale(1.02); background-color: rgba(34, 197, 94, 0.2); }
  100% { filter: brightness(1); transform: scale(1); background-color: transparent; box-shadow: none; }
}
@keyframes shield-flash {
  0% { filter: brightness(1); transform: scale(1); }
  15% { filter: brightness(1.3) grayscale(0.2); transform: scale(1.02); background-color: rgba(156, 163, 175, 0.3); }
  30% { filter: brightness(1.6) grayscale(0.4); transform: scale(1.04); background-color: rgba(156, 163, 175, 0.45); box-shadow: 0 0 25px rgba(156, 163, 175, 0.9); }
  50% { filter: brightness(1.5) grayscale(0.3); transform: scale(1.04); background-color: rgba(156, 163, 175, 0.4); box-shadow: 0 0 20px rgba(156, 163, 175, 0.8); }
  70% { filter: brightness(1.2) grayscale(0.1); transform: scale(1.01); background-color: rgba(156, 163, 175, 0.2); }
  100% { filter: brightness(1); transform: scale(1); background-color: transparent; box-shadow: none; }
}
@keyframes heal-cross-fade {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
  50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
}
/* Bonus turn stack visuals for Asterisk/Alpha */
.bonus-turn-stack {
  position: absolute;
  top: 0;
  right: -5px;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: -1;
}
.bonus-turn-card {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  background: #3b82f6;
  border: 3px solid #f97316;
  border-radius: 8px;
  opacity: 0.7;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.bonus-turn-card.sliding-out {
  animation: stack-slide-out 0.3s ease forwards;
}
@keyframes stack-slide-out {
  0% { transform: translate(0, 0); opacity: 0.7; }
  100% { transform: translate(50px, -20px); opacity: 0; }
}
.sigil-row { display: flex !important; flex-direction: row !important; flex-wrap: wrap; gap: 6px; justify-content: center; align-items: center; margin-top: 4px; max-width: 100%; }
.sigil-row.compact { gap: 3px; }
.sigil-row.compact .sigil { padding: 6px; font-size: 0.75rem; min-width: 40px; min-height: 40px; }
.sigil-divider { width: 100%; height: 1px; background: rgba(255,255,255,0.3); margin: 4px 0; }
.sigil { border: none; border-radius: 6px; padding: 10px; font-size: 1.1rem; display: inline-flex; align-items: center; justify-content: center; margin: 2px; min-width: 44px; min-height: 44px; max-width: 56px; width: auto; font-weight: 900; background: transparent; text-shadow: none; flex-shrink: 0; }
.sigil img { width: auto; height: 1.6em; object-fit: contain; }
.sigil sup { font-size: 0.55em; font-weight: bold; margin-left: 1px; vertical-align: super; }
.sigil.clickable { cursor: pointer; }
.sigil.clickable:active { transform: scale(0.95); }
.sigil.active-action { box-shadow: 0 0 12px #22c55e; animation: pulse-action 0.8s infinite; }

/* Active sigils: transparent background, colored icon */
.sigil.l0 { color: #666; opacity: 0.5; }
.sigil.l0 img { filter: brightness(0) saturate(100%) opacity(0.35); }
.sigil.l1 { color: #1a1a1a; }
.sigil.l1 img { filter: brightness(0) saturate(100%); }
.sigil.l2 { color: #06b6d4; }
.sigil.l2 img { filter: invert(56%) sepia(81%) saturate(1239%) hue-rotate(166deg) brightness(95%) contrast(94%); }
.sigil.l3 { color: #9333ea; }
.sigil.l3 img { filter: invert(28%) sepia(97%) saturate(6144%) hue-rotate(262deg) brightness(82%) contrast(100%); }
.sigil.l4 { color: #d97706; }
.sigil.l4 img { filter: invert(44%) sepia(97%) saturate(950%) hue-rotate(22deg) brightness(97%) contrast(92%) drop-shadow(0 0 6px rgba(217,119,6,0.5)); }
.sigil.l5 {
  background: transparent;
  color: #ff0080;
}
.sigil.l5 img { filter: invert(24%) sepia(99%) saturate(6143%) hue-rotate(316deg) brightness(101%) contrast(102%) drop-shadow(0 0 6px rgba(255,0,128,0.8)); animation: rainbow-pulse 2s ease-in-out infinite; }

/* Passive sigils: colored background, white icon, rounder corners */
.sigil.passive { border: 2px solid rgba(0,0,0,0.5); border-radius: 12px; }
.sigil.passive img { filter: brightness(0) invert(1) !important; } /* White icon */
.sigil.passive.l0 { background: #6b7280; opacity: 0.7; } /* Darker Gray */
.sigil.passive.l1 { background: #1f2937; } /* Darker charcoal */
.sigil.passive.l2 { background: #0891b2; } /* Darker Cyan */
.sigil.passive.l3 { background: #7c3aed; } /* Darker Purple */
.sigil.passive.l4 { background: #b45309; box-shadow: 0 0 6px rgba(180,83,9,0.6); } /* Darker Orange with glow */
.sigil.passive.l5 { background: linear-gradient(135deg, #db2777, #6d28d9, #0891b2); animation: rainbow-bg 2s ease-in-out infinite; } /* Darker Rainbow gradient */
@keyframes rainbow-bg {
  0%, 100% { background: linear-gradient(135deg, #ff0080, #7c3aed, #06b6d4); }
  50% { background: linear-gradient(135deg, #06b6d4, #ff0080, #7c3aed); }
}
@keyframes rainbow-pulse {
  0%, 100% { filter: invert(24%) sepia(99%) saturate(6143%) hue-rotate(316deg) brightness(101%) contrast(102%) drop-shadow(0 0 6px rgba(255,0,128,0.8)); }
  50% { filter: invert(69%) sepia(88%) saturate(1053%) hue-rotate(166deg) brightness(90%) contrast(88%) drop-shadow(0 0 8px rgba(64,224,208,0.8)); }
}
.sigil.asterisk-primed { box-shadow: 0 0 8px #a855f7; animation: pulse-asterisk 1s infinite; }
@keyframes pulse-asterisk { 0%, 100% { box-shadow: 0 0 8px #a855f7; } 50% { box-shadow: 0 0 16px #a855f7; } }
@keyframes pulse-action { 0%, 100% { box-shadow: 0 0 12px #3b82f6; } 50% { box-shadow: 0 0 20px #3b82f6; } }

/* FU Mode: Compact 3-hero layout */
.fu-mode .combat-lane {
  padding: 0.5rem;
  margin: 0 auto 0.6rem auto;
}
.fu-mode .combat-lane:not(:last-child)::after {
  display: none;
}
.fu-mode .card {
  padding: 0.35rem;
  min-height: 60px;
}
.fu-mode .card.hero,
.fu-mode .card.enemy {
  width: 120px;
}
.fu-mode .card img {
  width: 36px !important;
  height: 36px !important;
}
.fu-mode .sigil {
  padding: 6px;
  min-width: 32px;
  min-height: 32px;
  max-width: 40px;
  font-size: 0.9rem;
}
.fu-mode .sigil-row {
  gap: 3px;
  margin-top: 2px;
}
.fu-mode .sigil-divider {
  margin: 2px 0;
}
.fu-mode .combat-header {
  padding: 0.5rem;
  margin-bottom: 0.5rem;
}
.fu-mode .lane-content {
  gap: 1rem !important;
}
.fu-mode .card > div {
  font-size: 0.9em;
}
.fu-mode .card > div:first-child {
  font-size: 0.7rem;
}

.toast { position: fixed; bottom: 20px; right: 20px; background: linear-gradient(#fff, #f7f1e3); border: 2px solid #bda; border-radius: 6px; padding: 1rem 1.5rem; font-weight: bold; box-shadow: 0 4px 12px rgba(0,0,0,0.2); opacity: 0; transform: translateY(20px); transition: all 0.3s; z-index: 10000; max-width: 80%; }
.toast.show { opacity: 1; transform: translateY(0); }
.toast-log { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: linear-gradient(#fff, #f7f1e3); border: 3px solid #22c55e; border-radius: 8px; padding: 0.75rem; max-width: 400px; width: 90%; box-shadow: 0 8px 24px rgba(0,0,0,0.3); z-index: 9999; display: none; }
.toast-log.show { display: block; }
.toast-log-header { font-weight: bold; font-size: 0.85rem; margin-bottom: 0.25rem; padding: 0.25rem 0.5rem; display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
.toast-log-toggle { font-size: 1rem; }
.toast-log-entries { max-height: 200px; overflow-y: auto; font-size: 0.8rem; }
.toast-log-entry { padding: 0.4rem 0.5rem; border-top: 1px solid rgba(0,0,0,0.1); }
.toast-log-entry:first-child { border-top: none; }
.toast-log-entry.recent { font-weight: bold; }
.turn-locked { pointer-events: none; opacity: 0.7; }
.tutorial-modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 20000; display: flex; align-items: center; justify-content: center; }
.tutorial-modal { background: linear-gradient(#fff, #e8f5e9); border: 4px solid #22c55e; border-radius: 12px; padding: 2rem; max-width: 600px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); text-align: center; }
.tutorial-modal h2 { margin-top: 0; color: #6b4423; }
.tutorial-modal p { margin: 1rem 0; font-size: 1.1rem; line-height: 1.6; }
.tutorial-modal button { margin-top: 1.5rem; padding: 0.75rem 2rem; font-size: 1.1rem; font-weight: bold; background: #22c55e; color: #fff; border: 2px solid #15803d; border-radius: 8px; cursor: pointer; }
.tutorial-modal button:hover { background: #15803d; }
.tutorial-modal button:active { transform: scale(0.98); }
.choice.disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }
.tooltip { position: fixed; z-index: 25000; background: rgba(0,0,0,0.95); color: #fff; padding: 1rem; border-radius: 8px; border: 2px solid #3b82f6; max-width: 320px; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
.tooltip.show { opacity: 1; }
.tooltip-green { background: rgba(34,197,94,0.85) !important; border-color: #22c55e !important; }
.tooltip-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem; color: #60a5fa; }
.tooltip-desc { font-size: 0.9rem; line-height: 1.4; }

/* Tablet improvements (768px-1023px) */
@media (min-width: 768px) {
  /* Base scaling for tablet */
  .header {
    font-size: 0.95rem;
    padding: 0.75rem 1rem;
  }

  .game-area {
    padding: 1rem;
    height: calc(100vh - 52px);
  }

  /* Cards medium scaling */
  .card {
    width: 180px !important;
    max-width: 180px;
    padding: 0.75rem;
    min-height: 85px;
    font-size: 0.95rem;
  }
  .card.hero { width: 180px; }
  .card.enemy { width: 180px; }

  /* Combat grid spacing */
  .combat-grid {
    gap: 1rem;
  }
  .column {
    gap: 0.75rem;
  }

  /* Combat lane */
  .combat-lane {
    padding: 1.25rem;
    max-width: 900px;
  }

  /* Sigils medium */
  .sigil {
    font-size: 0.95rem;
    padding: 8px;
    min-width: 36px;
    min-height: 36px;
  }
  .sigil-row {
    gap: 6px;
  }

  /* Buttons */
  .btn {
    font-size: 1.2rem;
    padding: 1.1rem;
    min-height: 60px;
  }

  .choice {
    font-size: 1.1rem;
    padding: 1.1rem;
    min-height: 65px;
  }

  .neutral-btn {
    font-size: 1rem;
    padding: 0.6rem 0.9rem;
  }

  /* Toast notifications */
  .toast {
    font-size: 1rem;
    padding: 1.25rem 1.75rem;
    max-width: 500px;
  }

  .toast-log {
    max-width: 480px;
    font-size: 0.9rem;
  }

  /* Tooltips */
  .tooltip {
    max-width: 380px;
    padding: 1.25rem;
  }
  .tooltip-title {
    font-size: 1.2rem;
  }
  .tooltip-desc {
    font-size: 1rem;
  }
}

/* Desktop improvements (1024px+) - Premium experience */
@media (min-width: 1024px) {
  /* Header scaling */
  .header {
    font-size: 1.1rem;
    padding: 1rem 1.5rem;
    height: 56px;
  }

  .header button {
    font-size: 0.85rem !important;
    padding: 0.4rem 0.75rem !important;
  }

  .game-area {
    padding: 1.5rem;
    height: calc(100vh - 56px);
  }

  /* Hero and Enemy Cards - Much larger on desktop */
  .card {
    width: 220px !important;
    max-width: 220px;
    padding: 1rem;
    min-height: 110px;
    font-size: 1.1rem;
    border-width: 4px;
  }
  .card.hero { width: 220px; }
  .card.enemy { width: 220px; }

  /* Hero/enemy images larger */
  .card img {
    width: 64px !important;
    height: 64px !important;
  }

  /* Card text scaling */
  .card > div {
    font-size: 1rem !important;
  }
  .card > div:first-child {
    font-size: 1.2rem !important;
    margin-bottom: 0.5rem !important;
  }

  /* Combat grid - More spacious */
  .combat-grid {
    gap: 1.5rem;
    padding: 1rem 0;
  }

  .column {
    gap: 1rem;
  }

  /* Combat lane - Use more screen */
  .combat-lane {
    padding: 1.5rem 2rem;
    max-width: 1200px;
    margin-bottom: 3rem;
  }

  .combat-lane:not(:last-child)::after {
    font-size: 1.5rem;
    bottom: -2.5rem;
  }

  /* Sigils - Properly sized for desktop */
  .sigil {
    font-size: 1.1rem;
    padding: 10px;
    min-width: 42px;
    min-height: 42px;
    margin: 3px;
  }

  .sigil img {
    width: auto;
    height: 1.4em !important;
    object-fit: contain;
  }

  .sigil-row {
    gap: 8px;
    margin-top: 8px;
  }

  .sigil-row.compact {
    gap: 4px;
  }
  .sigil-row.compact .sigil {
    font-size: 0.85rem;
    padding: 6px;
    min-width: 32px;
    min-height: 32px;
  }

  .sigil-divider {
    margin: 6px 0;
  }

  /* Buttons - Desktop appropriate */
  .btn {
    padding: 1.25rem 2rem;
    font-size: 1.4rem;
    min-height: 70px;
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 1rem;
    display: block;
    border-width: 4px;
  }

  .choice {
    padding: 1.25rem 2rem;
    font-size: 1.3rem;
    min-height: 75px;
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 1rem;
    display: block;
    border-width: 4px;
  }

  .neutral-btn {
    padding: 0.75rem 1.25rem;
    font-size: 1.15rem;
    border-width: 3px;
    margin-bottom: 0.75rem;
  }

  /* Neutral screens - Desktop scaling */
  .neutral-stats {
    font-size: 1.05rem;
    padding: 0.6rem 1rem;
  }

  .neutral-title {
    font-size: 1.5rem;
    margin-bottom: 0.75rem;
  }

  .neutral-desc {
    font-size: 1.1rem;
    line-height: 1.5;
  }

  .neutral-outcome {
    font-size: 1rem;
    padding: 0.75rem;
  }

  /* Dice roll */
  .dice-roll {
    font-size: 1.5rem;
    padding: 1.25rem;
  }

  /* Toast notifications */
  .toast {
    font-size: 1.15rem;
    padding: 1.5rem 2rem;
    max-width: 600px;
    bottom: 40px;
    right: 40px;
    border-width: 3px;
  }

  .toast-log {
    max-width: 600px;
    padding: 1rem;
  }

  .toast-log-header {
    font-size: 1rem;
    padding: 0.4rem 0.75rem;
  }

  .toast-log-toggle {
    font-size: 1.2rem;
  }

  .toast-log-entries {
    font-size: 0.95rem;
    max-height: 320px;
  }

  .toast-log-entry {
    padding: 0.5rem 0.75rem;
  }

  /* Tutorial modal */
  .tutorial-modal {
    padding: 2.5rem;
    max-width: 750px;
    border-width: 5px;
  }

  .tutorial-modal h2 {
    font-size: 1.8rem;
  }

  .tutorial-modal p {
    font-size: 1.25rem;
    line-height: 1.7;
  }

  .tutorial-modal button {
    padding: 1rem 2.5rem;
    font-size: 1.25rem;
    border-width: 3px;
  }

  /* Tooltips */
  .tooltip {
    max-width: 450px;
    padding: 1.5rem;
    border-width: 3px;
  }

  .tooltip-title {
    font-size: 1.3rem;
    margin-bottom: 0.75rem;
  }

  .tooltip-desc {
    font-size: 1.1rem;
    line-height: 1.5;
  }
}

/* Large Desktop improvements (1440px+) - Even more premium */
@media (min-width: 1440px) {
  /* Use even more screen real estate */
  .combat-lane {
    max-width: 1400px;
    padding: 2rem 2.5rem;
  }

  /* Cards can be even larger */
  .card {
    width: 240px !important;
    max-width: 240px;
    padding: 1.25rem;
    min-height: 120px;
    font-size: 1.15rem;
  }
  .card.hero { width: 240px; }
  .card.enemy { width: 240px; }

  /* Images scale up */
  .card img {
    width: 72px !important;
    height: 72px !important;
  }

  /* More generous spacing */
  .combat-grid {
    gap: 2rem;
  }

  .column {
    gap: 1.25rem;
  }

  /* Buttons use more width */
  .btn, .choice {
    max-width: 800px;
  }

  /* Larger game area padding */
  .game-area {
    padding: 2rem;
  }

  /* Neutral encounters - Scale up for large desktop */
  .neutral-stats {
    font-size: 1.2rem;
    padding: 0.75rem 1.25rem;
  }

  .neutral-title {
    font-size: 1.75rem;
    margin-bottom: 1rem;
  }

  .neutral-desc {
    font-size: 1.25rem;
    line-height: 1.6;
  }

  .neutral-outcome {
    font-size: 1.15rem;
    padding: 1rem;
  }

  .neutral-btn {
    padding: 1rem 1.5rem;
    font-size: 1.3rem;
    margin-bottom: 1rem;
  }

  .dice-roll {
    font-size: 1.75rem;
    padding: 1.5rem;
  }
}

/* Ultra-wide Desktop (1920px+) */
@media (min-width: 1920px) {
  .combat-lane {
    max-width: 1600px;
  }

  /* Cards at maximum size */
  .card {
    width: 260px !important;
    max-width: 260px;
  }
  .card.hero { width: 260px; }
  .card.enemy { width: 260px; }

  .btn, .choice {
    max-width: 900px;
  }

  /* Neutral encounters - Maximum scale for ultra-wide */
  .neutral-stats {
    font-size: 1.3rem;
    padding: 0.85rem 1.5rem;
  }

  .neutral-title {
    font-size: 2rem;
    margin-bottom: 1.25rem;
  }

  .neutral-desc {
    font-size: 1.4rem;
    line-height: 1.65;
  }

  .neutral-outcome {
    font-size: 1.25rem;
    padding: 1.25rem;
  }

  .neutral-btn {
    padding: 1.15rem 1.75rem;
    font-size: 1.45rem;
    margin-bottom: 1.25rem;
  }

  .dice-roll {
    font-size: 2rem;
    padding: 1.75rem;
  }
}

/* Dynamic element classes for inline styles */
.card-image {
  width: 48px;
  height: 48px;
  border-radius: 4px;
}

/* Flip neutral portraits that face the wrong direction */
img[src*="healerfull"],
img[src*="warriorfull"],
img[src*="tankfull"] {
  transform: scaleX(-1);
}

.card-emoji {
  text-align: center;
  font-size: 2rem;
  margin-bottom: 0.25rem;
}

.card-stats {
  text-align: center;
  font-size: 0.8rem;
  margin-top: 0.25rem;
  overflow: hidden;
  text-overflow: ellipsis;
  line-height: 1.2;
}

.combat-header {
  text-align: center;
  font-weight: bold;
  padding: 0.75rem;
  background: rgba(0,0,0,0.05);
  border-radius: 6px;
  margin-bottom: 0.75rem;
}

.combat-header-title {
  font-size: 1.1rem;
  color: #dc2626;
}

.combat-header-subtitle {
  font-size: 0.85rem;
  margin-top: 0.25rem;
}

.combat-header-info {
  font-size: 0.75rem;
  opacity: 0.8;
  margin-top: 0.25rem;
}

.section-label {
  text-align: center;
  font-weight: bold;
  padding: 0.25rem;
  background: rgba(0,0,0,0.1);
  border-radius: 6px;
  margin-bottom: 0.5rem;
  font-size: 0.85rem;
}

.empty-slot {
  text-align: center;
  font-size: 0.75rem;
  padding: 0.5rem;
  opacity: 0.5;
  font-style: italic;
  margin-bottom: 0.5rem;
}

/* Tablet scaling for dynamic elements */
@media (min-width: 768px) {
  .card-image {
    width: 56px;
    height: 56px;
  }

  .card-emoji {
    font-size: 2.25rem;
  }

  .card-stats {
    font-size: 0.9rem;
  }

  .combat-header {
    padding: 1rem;
  }

  .combat-header-title {
    font-size: 1.25rem;
  }

  .combat-header-subtitle {
    font-size: 0.95rem;
  }

  .combat-header-info {
    font-size: 0.85rem;
  }

  .section-label {
    font-size: 0.95rem;
    padding: 0.35rem;
  }

  .empty-slot {
    font-size: 0.85rem;
  }
}

/* Desktop scaling for dynamic elements */
@media (min-width: 1024px) {
  .card-image {
    width: 64px;
    height: 64px;
  }

  .card-emoji {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
  }

  .card-stats {
    font-size: 1rem;
    margin-top: 0.35rem;
  }

  .combat-header {
    padding: 1.25rem;
  }

  .combat-header-title {
    font-size: 1.4rem;
  }

  .combat-header-subtitle {
    font-size: 1.05rem;
    margin-top: 0.35rem;
  }

  .combat-header-info {
    font-size: 0.95rem;
  }

  .section-label {
    font-size: 1.05rem;
    padding: 0.5rem 0.75rem;
  }

  .empty-slot {
    font-size: 0.95rem;
    padding: 0.75rem;
  }
}

/* Large desktop scaling */
@media (min-width: 1440px) {
  .card-image {
    width: 72px;
    height: 72px;
  }

  .card-emoji {
    font-size: 2.75rem;
  }

  .card-stats {
    font-size: 1.1rem;
  }

  .combat-header-title {
    font-size: 1.5rem;
  }

  .combat-header-subtitle {
    font-size: 1.15rem;
  }
}

/* Ultra-wide desktop */
@media (min-width: 1920px) {
  .card-image {
    width: 80px;
    height: 80px;
  }

  .card-emoji {
    font-size: 3rem;
  }
}

/* ===== JUICE & POLISH ENHANCEMENTS ===== */

/* Floating damage/heal numbers */
.floating-number {
  position: absolute;
  font-weight: 900;
  font-size: 1.8rem;
  text-shadow: 0 2px 4px rgba(0,0,0,0.8), 0 0 10px currentColor;
  pointer-events: none;
  z-index: 10000;
  animation: floatUp 0.8s ease-out forwards;
  white-space: nowrap;
}
.floating-number.damage { color: #ef4444; }
.floating-number.heal { color: #22c55e; }
.floating-number.shield { color: #94a3b8; }
.floating-number.gold { color: #fbbf24; }
.floating-number.xp { color: #a855f7; }
.floating-number.critical {
  font-size: 2.4rem;
  color: #ff6b6b;
  text-shadow: 0 2px 4px rgba(0,0,0,0.8), 0 0 20px #ff6b6b, 0 0 40px #ff0000;
}
.floating-number.miss { color: #888; font-size: 1.4rem; font-style: italic; }

@keyframes floatUp {
  0% {
    opacity: 1;
    transform: translateY(0) scale(0.5);
  }
  20% {
    opacity: 1;
    transform: translateY(-10px) scale(1.2);
  }
  100% {
    opacity: 0;
    transform: translateY(-60px) scale(0.8);
  }
}

/* Screen shake effect */
.screen-shake {
  animation: shake 0.3s ease-in-out;
}
.screen-shake-heavy {
  animation: shakeHeavy 0.4s ease-in-out;
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
  20%, 40%, 60%, 80% { transform: translateX(4px); }
}

@keyframes shakeHeavy {
  0%, 100% { transform: translate(0, 0) rotate(0deg); }
  10% { transform: translate(-8px, -2px) rotate(-1deg); }
  20% { transform: translate(8px, 2px) rotate(1deg); }
  30% { transform: translate(-6px, -1px) rotate(-0.5deg); }
  40% { transform: translate(6px, 1px) rotate(0.5deg); }
  50% { transform: translate(-4px, 0) rotate(0deg); }
  60% { transform: translate(4px, 0) rotate(0deg); }
  70% { transform: translate(-2px, 0) rotate(0deg); }
  80% { transform: translate(2px, 0) rotate(0deg); }
  90% { transform: translate(-1px, 0) rotate(0deg); }
}

/* Enemy card hover effects */
.card.enemy {
  transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
}
.card.enemy:hover {
  transform: scale(1.03);
  filter: brightness(1.1);
  box-shadow: 0 6px 16px rgba(0,0,0,0.4);
}
.card.enemy.targetable:hover {
  transform: scale(1.05);
  filter: brightness(1.15);
  box-shadow: 0 0 0 4px #dc2626, 0 8px 20px rgba(220,38,38,0.4);
}

/* Button ripple effect */
.btn, .choice, .neutral-btn {
  position: relative;
  overflow: hidden;
}
.btn::after, .choice::after, .neutral-btn::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  background: rgba(255,255,255,0.3);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  transition: width 0.3s ease, height 0.3s ease, opacity 0.3s ease;
  opacity: 0;
}
.btn:active::after, .choice:active::after, .neutral-btn:active::after {
  width: 300px;
  height: 300px;
  opacity: 0;
  transition: width 0s, height 0s, opacity 0.5s ease;
}

/* Sigil hover effects */
.sigil.clickable {
  transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
}
.sigil.clickable:hover {
  transform: scale(1.1) translateY(-2px);
  filter: brightness(1.2);
}

/* Victory confetti container */
.confetti-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 99998;
  overflow: hidden;
}
.confetti {
  position: absolute;
  width: 10px;
  height: 10px;
  animation: confettiFall 3s ease-out forwards;
}
@keyframes confettiFall {
  0% {
    transform: translateY(-20px) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: translateY(100vh) rotate(720deg);
    opacity: 0;
  }
}

/* Combo counter */
.combo-counter {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 4rem;
  font-weight: 900;
  color: #fbbf24;
  text-shadow: 0 4px 8px rgba(0,0,0,0.8), 0 0 30px #fbbf24;
  pointer-events: none;
  z-index: 10001;
  animation: comboPop 0.5s ease-out forwards;
}
@keyframes comboPop {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }
  30% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-30px); }
}

/* Enhanced status effects */
.card.stunned {
  animation: stunPulse 1s ease-in-out infinite;
}
@keyframes stunPulse {
  0%, 100% { filter: brightness(1) saturate(0.7); }
  50% { filter: brightness(0.8) saturate(0.5); }
}

.card.ghosted {
  animation: ghostFloat 2s ease-in-out infinite;
}
@keyframes ghostFloat {
  0%, 100% { transform: translateY(0); opacity: 0.9; }
  50% { transform: translateY(-5px); opacity: 0.7; }
}

.card.shielded::before {
  content: 'üõ°Ô∏è';
  position: absolute;
  top: -8px;
  right: -8px;
  font-size: 1.5rem;
  animation: shieldBob 1.5s ease-in-out infinite;
}
@keyframes shieldBob {
  0%, 100% { transform: translateY(0) scale(1); }
  50% { transform: translateY(-3px) scale(1.1); }
}

/* XP/Gold counter pop animation */
.counter-pop {
  animation: counterPop 0.3s ease-out;
}
@keyframes counterPop {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); color: #fbbf24; }
  100% { transform: scale(1); }
}


/* Death/knockout animation */
.card.knockout {
  animation: knockout 0.6s ease-out forwards;
}
@keyframes knockout {
  0% { transform: scale(1) rotate(0deg); opacity: 1; }
  30% { transform: scale(1.1) rotate(-5deg); }
  100% { transform: scale(0.5) rotate(15deg) translateY(20px); opacity: 0; }
}

/* Level up glow effect */
.level-up-glow {
  animation: levelUpGlow 1s ease-in-out infinite;
}
@keyframes levelUpGlow {
  0%, 100% { box-shadow: 0 0 20px rgba(251,191,36,0.5); }
  50% { box-shadow: 0 0 40px rgba(251,191,36,0.9), 0 0 60px rgba(251,191,36,0.5); }
}

/* Recruit card special styling */
.card.recruit {
  border-style: dashed;
  opacity: 0.85;
  animation: recruitPulse 2s ease-in-out infinite;
}
@keyframes recruitPulse {
  0%, 100% { border-color: #22c55e; box-shadow: 0 0 10px rgba(34,197,94,0.3); }
  50% { border-color: #16a34a; box-shadow: 0 0 20px rgba(34,197,94,0.6); }
}

/* ===== STEAM DECK / CONTROLLER SUPPORT ===== */
/* Controller focus indicator - glowing ring around focused element */
.controller-focus {
  outline: 4px solid #22c55e !important;
  outline-offset: 4px;
  box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.3) !important;
  animation: controllerFocusPulse 1s ease-in-out infinite;
  position: relative;
  z-index: 25001; /* Above tooltips (25000) but below modals (29999) */
}

@keyframes controllerFocusPulse {
  0%, 100% { outline-color: #22c55e; box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.3); }
  50% { outline-color: #16a34a; box-shadow: 0 0 30px rgba(34, 197, 94, 0.8), 0 0 50px rgba(34, 197, 94, 0.4); }
}

/* When controller is active, hide cursor and add focus-visible styles */
body.controller-active {
  cursor: none;
}
body.controller-active * {
  cursor: none;
}

/* Global game area adjustment for controller bar (all screen sizes) */
body.controller-active .game-area {
  height: calc(100vh - 44px - 56px); /* Account for header (44px) + controller prompts bar (~56px) */
}

/* Toast notification adjustment when controller bar is visible */
body.controller-active .toast {
  bottom: 70px; /* Move above controller bar */
}

/* Controller button prompts bar */
.controller-prompts {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.95), rgba(0,0,0,0.8));
  padding: 0.5rem 1rem;
  display: flex;
  justify-content: center;
  gap: 1.25rem;
  flex-wrap: wrap;
  z-index: 50000;
  border-top: 2px solid #3b82f6;
  font-size: 0.85rem;
  color: white;
}

.controller-prompt {
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.controller-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  font-weight: bold;
  font-size: 0.75rem;
  border: 2px solid currentColor;
}

.controller-btn.a { background: #22c55e; color: white; border-color: #16a34a; }
.controller-btn.b { background: #dc2626; color: white; border-color: #b91c1c; }
.controller-btn.x { background: #3b82f6; color: white; border-color: #2563eb; }
.controller-btn.y { background: #fbbf24; color: #1c1b19; border-color: #f59e0b; }
.controller-btn.lb, .controller-btn.rb, .controller-btn.lt, .controller-btn.rt {
  width: auto;
  padding: 0 0.4rem;
  border-radius: 6px;
  background: #6b7280;
  border-color: #4b5563;
}
.controller-btn.lt, .controller-btn.rt {
  background: #4b5563;
}
.controller-btn.start {
  width: auto;
  padding: 0 0.5rem;
  border-radius: 4px;
  background: #374151;
  border-color: #6b7280;
  font-size: 0.65rem;
}
.controller-btn.dpad {
  width: auto;
  padding: 0 0.5rem;
  border-radius: 6px;
  background: #374151;
  border-color: #4b5563;
}

/* Controller tooltip indicator */
.controller-tooltip-active {
  outline: 3px solid #22c55e !important;
  outline-offset: 2px;
}

/* Hero selection overlay buttons for controller navigation */
.hero-select-btn {
  position: absolute;
  bottom: 0;
  height: 100%;
  background: transparent;
  border: none;
  cursor: pointer;
  z-index: 20;
  transition: background 0.2s ease, box-shadow 0.2s ease;
}
.hero-select-btn:hover, .hero-select-btn:focus {
  background: rgba(34, 197, 94, 0.2);
}
.hero-select-btn.controller-focus {
  background: rgba(34, 197, 94, 0.35);
  box-shadow: inset 0 0 0 4px #22c55e;
}
/* Show hero name label on controller focus */
.hero-select-btn.controller-focus::after {
  content: attr(data-hero);
  position: absolute;
  bottom: 8%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.85);
  color: #22c55e;
  padding: 0.3rem 0.6rem;
  border-radius: 6px;
  font-size: 0.85rem;
  font-weight: bold;
  text-transform: capitalize;
  white-space: nowrap;
  pointer-events: none;
}
.hero-select-btn:nth-child(2) { left: 0; width: 25%; }
.hero-select-btn:nth-child(3) { left: 25%; width: 25%; }
.hero-select-btn:nth-child(4) { left: 50%; width: 25%; }
.hero-select-btn:nth-child(5) { left: 75%; width: 25%; }

/* Custom confirm modal for controller support */
.confirm-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.95);
  border: 3px solid #f97316;
  border-radius: 12px;
  padding: 2rem;
  z-index: 100000;
  max-width: 400px;
  width: 90%;
  text-align: center;
  color: white;
}
.confirm-modal h3 {
  margin-bottom: 1rem;
  color: #fbbf24;
}
.confirm-modal p {
  margin-bottom: 1.5rem;
  font-size: 1.1rem;
}
.confirm-modal-buttons {
  display: flex;
  gap: 1rem;
  justify-content: center;
}
.confirm-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 99999;
}

/* Title Screen - Fullscreen splash */
.title-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #1a1612;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

.title-bg-image {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center top;
}

.title-version {
  position: absolute;
  top: 0.75rem;
  right: 0.75rem;
  background: rgba(0, 0, 0, 0.8);
  color: #3b82f6;
  padding: 0.3rem 0.6rem;
  border-radius: 6px;
  font-size: 0.75rem;
  font-weight: bold;
  border: 2px solid rgba(251, 191, 36, 0.7);
  z-index: 10;
}

.title-button-container {
  position: absolute;
  bottom: 10vh;
  left: 2vw;
  display: flex;
  flex-direction: column;
  gap: 1rem;
  z-index: 10;
  width: 18vw;
}

.title-secondary-btn {
  background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
  border: 3px solid #000;
  border-radius: 10px;
  color: white;
  font-family: 'Fredoka One', cursive;
  font-size: 1.1rem;
  padding: 0.8rem 1rem;
  text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.3);
  box-shadow: 0 3px 0 #1d4ed8, 0 5px 10px rgba(0, 0, 0, 0.3);
  transition: all 0.15s ease;
  width: 100%;
}

.title-secondary-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 0 #1d4ed8, 0 7px 14px rgba(0, 0, 0, 0.4);
}

.title-secondary-btn:active {
  transform: translateY(2px);
  box-shadow: 0 1px 0 #1d4ed8, 0 3px 6px rgba(0, 0, 0, 0.2);
}

.title-credits-btn {
  background: linear-gradient(180deg, #6366f1 0%, #4f46e5 100%);
  border: 3px solid #000;
  border-radius: 16px;
  color: white;
  font-family: 'Fredoka One', cursive;
  font-size: 1.1rem;
  padding: 0.6rem 1.5rem;
  text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
  box-shadow: 0 4px 0 #4338ca, 0 6px 12px rgba(0, 0, 0, 0.4);
  transition: all 0.15s ease;
}

.title-credits-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 0 #4338ca, 0 8px 16px rgba(0, 0, 0, 0.5);
}

.title-credits-btn:active {
  transform: translateY(3px);
  box-shadow: 0 1px 0 #4338ca, 0 3px 6px rgba(0, 0, 0, 0.3);
}

.title-play-btn {
  position: absolute;
  right: 2vw;
  bottom: 10vh;
  background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
  border: 4px solid #000;
  border-radius: 12px;
  color: white;
  font-family: 'Fredoka One', cursive;
  font-size: 1.6rem;
  padding: 4rem 0;
  text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
  box-shadow: 0 5px 0 #15803d, 0 8px 16px rgba(0, 0, 0, 0.4);
  transition: all 0.15s ease;
  z-index: 10;
  width: 18vw;
  text-align: center;
}

.title-play-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 0 #15803d, 0 8px 16px rgba(0, 0, 0, 0.5);
}

.title-play-btn:active {
  transform: translateY(2px);
  box-shadow: 0 2px 0 #15803d, 0 4px 8px rgba(0, 0, 0, 0.3);
}

/* Portrait orientation - show portrait image cropped to fit */
@media (max-aspect-ratio: 1/1) {
  .title-bg-image {
    object-position: center center;
  }

  .title-button-container {
    bottom: 2vh;
    left: 2vw;
    width: 22vw;
  }

  .title-play-btn {
    right: 2vw;
    bottom: 2vh;
    width: 22vw;
    font-size: 1.1rem;
    padding: 2rem 0;
  }
}

/* Steam Deck specific optimizations (1280x800 @ 7" screen) */
@media (min-width: 1200px) and (max-width: 1400px) and (min-height: 700px) and (max-height: 900px) {
  /* Larger touch targets for Steam Deck */
  .btn {
    min-height: 64px;
    font-size: 1.2rem;
    padding: 1.25rem;
  }

  .choice {
    min-height: 68px;
    font-size: 1.1rem;
    padding: 1.25rem;
  }

  .card {
    min-width: 170px;
    min-height: 80px;
  }

  .sigil {
    min-width: 40px;
    min-height: 40px;
    font-size: 1.3rem;
  }

  .sigil.compact {
    min-width: 32px;
    min-height: 32px;
    font-size: 1.1rem;
  }

  /* Header adjustments for Steam Deck */
  .header {
    padding: 0.75rem 1rem;
    font-size: 0.95rem;
  }

  .header button {
    padding: 0.4rem 0.6rem !important;
    font-size: 0.85rem !important;
  }

  /* Combat layout optimizations */
  .combat-lane {
    padding: 0.75rem;
    gap: 1rem;
  }

  /* Modal adjustments */
  .modal-container {
    max-width: 600px;
    padding: 2.5rem;
  }

  .modal-container h2 {
    font-size: 1.5rem;
  }

  .modal-checkbox-label {
    padding: 1rem;
    font-size: 1.1rem;
  }

  .modal-checkbox-label input {
    transform: scale(1.5);
    margin-right: 0.75rem;
  }

  /* Reduce death screen scrolling */
  .death-screen-container {
    padding: 1rem !important;
  }
  .death-screen-container img {
    max-width: 250px !important;
    margin-bottom: 0.5rem !important;
  }
  .death-screen-container h1 {
    font-size: 1.8rem !important;
    margin-bottom: 0.5rem !important;
  }
  .going-rate-marquee {
    padding: 0.75rem !important;
    margin: 0.75rem 0 !important;
  }
  .death-screen-container h3, .death-screen-container h4 {
    margin: 0.5rem 0 0.25rem 0 !important;
    font-size: 1rem !important;
  }
  .death-screen-sigil-grid {
    gap: 0.5rem !important;
    margin-bottom: 0.75rem !important;
  }
  .death-screen-sigil-card {
    padding: 0.5rem !important;
  }
}

/* Focusable elements - add data attribute for controller navigation */
[data-focusable] {
  transition: outline 0.15s ease, box-shadow 0.15s ease;
}

/* Hide controller prompts when not in controller mode */
.controller-prompts {
  display: none;
}
body.controller-active .controller-prompts {
  display: flex;
}
</style>
</head>
<body>
<!-- Rotate device prompt (only shows on mobile in portrait) -->
<div id="rotatePrompt" style="display:none;">
<div class="rotate-icon">üì±‚ÜíüîÑ</div>
<div class="rotate-message">Please Rotate Your Device</div>
<div class="rotate-submessage">FROGGLE plays best in landscape mode</div>
</div>

<div class="header" id="gameHeader">
<div id="locationInfo"><span id="locationLabel">Floor</span> <span id="floor">1</span><span id="roundInfo"> | Round <span id="round">1</span></span></div>
<div style="display:flex;gap:0.25rem">
<button onclick="showSigilarium()" style="padding:0.25rem 0.5rem;background:#9333ea;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="Sigilarium">üåÄ</button>
<button onclick="toggleToastLog()" style="padding:0.25rem 0.5rem;background:#22c55e;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="Combat Log">ü™µ</button>
<button onclick="showFAQ()" style="padding:0.25rem 0.5rem;background:#f97316;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="FAQ/Help">‚ùì</button>
<button onclick="showSettingsMenu()" style="padding:0.25rem 0.5rem;background:#3b82f6;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="Settings">‚öôÔ∏è</button>
<div id="debugBtn" style="display:none"><button onclick="showDebugMenu()" style="padding:0.25rem 0.5rem;background:#3b82f6;border:2px solid #000;border-radius:4px;font-weight:bold;font-size:0.7rem;cursor:pointer" title="Debug">üõ†Ô∏è</button></div>
</div>
<div><span id="gold">0</span>G | <span id="xp">0</span>XP</div>
</div>
<div class="game-area" id="gameView"></div>

<!-- Controller button prompts (shown when gamepad is connected) -->
<div id="controllerPrompts" class="controller-prompts">
  <div class="controller-prompt"><span class="controller-btn dpad">D-Pad</span> Move</div>
  <div class="controller-prompt"><span class="controller-btn a">A</span> Select</div>
  <div class="controller-prompt"><span class="controller-btn b">B</span> Back</div>
  <div class="controller-prompt"><span class="controller-btn y">Y</span> Tooltip</div>
  <div class="controller-prompt"><span class="controller-btn start">‚ò∞</span> Menu</div>
</div>

<script>
// ===== VERSION CHECK =====
const GAME_VERSION = '11.82';
console.log(`%cüê∏ FROGGLE v${GAME_VERSION} LOADED`, 'color: #22c55e; font-size: 20px; font-weight: bold;');

// Debug logging - only outputs when S.debugMode is true
function debugLog(...args) {
if(typeof S !== 'undefined' && S.debugMode) console.log(...args);
}

// ===== GAME DATA =====
// Hero images
const HERO_IMAGES = {
        warrior: 'assets/characters/warriorfull.png',
        tank: 'assets/characters/tankfull.png',
        mage: 'assets/characters/magefull.png',
        healer: 'assets/characters/healerfull.png',
        tapo: 'assets/characters/tapofull.png'
    };

// Hero reaction images (happy/pained expressions)
const HERO_REACTIONS = {
    warrior: {
        happy: 'assets/reactions/warrior-happy.jpeg',
        pained: 'assets/reactions/warrior-pained.jpeg'
    },
    tank: {
        happy: 'assets/reactions/tank-happy.jpeg',
        pained: 'assets/reactions/tank-pained.jpeg'
    },
    mage: {
        happy: 'assets/reactions/mage-happy.jpeg',
        pained: 'assets/reactions/mage-pained.jpeg'
    },
    healer: {
        happy: 'assets/reactions/healer-happy.jpeg',
        pained: 'assets/reactions/healer-pained.jpeg'
    }
    // Tapo doesn't have reaction images yet
};

// Get hero image based on current reaction state
function getHeroImage(hero) {
    const heroKey = hero.n.toLowerCase();
    const reactions = HERO_REACTIONS[heroKey];

    // Last stand always shows pained
    if (hero.ls && reactions?.pained) {
        return reactions.pained;
    }

    // Check for temporary reaction
    if (hero.reaction && reactions?.[hero.reaction]) {
        return reactions[hero.reaction];
    }

    // Default image
    return HERO_IMAGES[heroKey] || '';
}

// Set a temporary reaction on a hero (clears after duration)
function setHeroReaction(heroId, reaction, duration = 800) {
    const hero = S.heroes.find(h => h.id === heroId);
    if (!hero) return;

    const heroKey = hero.n.toLowerCase();
    if (!HERO_REACTIONS[heroKey]?.[reaction]) return; // No reaction image available

    hero.reaction = reaction;
    render();

    // Clear reaction after duration (unless it's permanent like last stand pained)
    if (duration > 0) {
        setTimeout(() => {
            if (hero.reaction === reaction) {
                hero.reaction = null;
                render();
            }
        }, duration);
    }
}

// Set reaction on all heroes
function setAllHeroesReaction(reaction, duration = 800) {
    S.heroes.forEach(h => {
        if (!h.ls) { // Don't override last stand
            setHeroReaction(h.id, reaction, duration);
        }
    });
}

// Death's dialogue lines (cycles through without repeating until all used)
const DEATH_QUOTES = [
    "Some days you're the sticky tongue, some days you're the fly.",
    "You must really like pain or something. Weirdo.",
    "Next time bring me a smoothie or something",
    "Hey, have you met those ghost boys in the dungeon? I can't get them to make.. you know.. the transition. Help them out, would you?",
    "Death death lemonade, 'round the coroner I parade. Hehe!",
    "Ribbit? Ribbbbbit? Rib bit?",
    "Oh man, a classic green. You just know he's a jumper.",
    "Hello my baby, hello my honey.",
    "If you refuse me, honey you'll lose me, and you'll be left alooooooone",
    "You guys should check out the Discovery Channel to see what normal frogs do",
    "Toadally froggin died, huh?",
    "Send me a kiss by wire, honey my heart's on fire",
    "Maybe try making a beer commercial or something?",
    "At least you don't have to cross a busy highway!",
    "Stay out of pots full of lukewarm water!",
    "Mark Twain keeps my mornings busy *rimshot*",
    "\"Analyzing humor is like dissecting a frog\". Know why? Look it up.",
    "Where does \"frog in your throat\" come from? Do you guys know?",
    "Is this tadpole really worth it?",
    "Ohh, it's pronounced Ta-po like Tad-pole, not Tah-po. Duh."
];

const H = {
warrior: {n:'Warrior', p:2, h:5, m:5, s:['Attack','D20']},
tank: {n:'Tank', p:1, h:10, m:10, s:['Attack','Shield','D20']},
mage: {n:'Mage', p:1, h:5, m:5, s:['Attack','D20','Expand']},
healer: {n:'Healer', p:1, h:5, m:5, s:['Heal','D20','Expand']},
tapo: {n:'Tapo', p:1, h:1, m:1, s:['Attack','Shield','Heal','Grapple','D20','Alpha','Ghost','Expand','Star','Asterisk']}
};

// Enemy sigil pools and level restrictions:
// - pool: array of sigils enemy can draw (Asterisk only eligible turn 1)
// - maxLevel: default max level for all sigils (default: 1)
// - sigilLevels: override max level for specific sigils {Attack:2, Shield:2, etc}
// - Star and D20 are NEVER available to enemies
const E = {
fly: { n:'Fly', p:1, h:2, m:2, goldDrop:0, x:0, pool:[], gainRate:999, startSigils:[{s:'Attack',l:1}] },
goblin: { n:'Goblin', p:1, h:5, m:5, goldDrop:1, x:2, pool:['Asterisk','Expand','Shield'], maxLevel:1, gainRate:3 },
wolf: { n:'Wolf', p:2, h:5, m:5, goldDrop:2, x:4, pool:['Asterisk','Expand','Shield','Grapple','Alpha'], maxLevel:1, gainRate:2 },
orc: { n:'Orc', p:2, h:10, m:10, goldDrop:3, x:6, pool:['Asterisk','Expand','Shield','Grapple','Alpha','Heal','Ghost'], maxLevel:1, gainRate:2, alternating: true, altSigil: {s:'Attack',l:2} },
giant: { n:'Giant', p:3, h:12, m:12, goldDrop:6, x:12, pool:['Asterisk','Expand','Shield','Grapple','Alpha','Heal','Ghost','Attack'], maxLevel:1, sigilLevels:{Attack:2,Shield:2,Heal:2}, gainRate:1, startSigils:[{s:'Shield',l:1}] },
caveTroll: { n:'Cave Troll', p:4, h:15, m:15, goldDrop:10, x:15, pool:['Expand','Shield','Grapple','Alpha','Heal','Ghost'], maxLevel:2, gainRate:1, rage: true, ragePattern: [1,2,3] },
dragon: { n:'Dragon', p:5, h:20, m:20, goldDrop:20, x:25, pool:['Expand','Shield','Grapple','Alpha','Heal','Ghost'], maxLevel:2, gainRate:1, drawsPerTurn:1, permSigils:[{s:'Attack',l:2},{s:'Expand',l:1}] },
flydra: { n:'Flydra', p:5, h:25, m:25, goldDrop:0, x:50, pool:['Shield','Grapple','Alpha','Heal','Ghost'], maxLevel:2, gainRate:1, isFlydra:true, permSigils:[{s:'Attack',l:2},{s:'Expand',l:2}] }
};

// Enemy emoji icons
const ENEMY_EMOJI = {
'Fly': 'ü™∞',
'Goblin': 'üë∫',
'Wolf': 'üê∫',
'Orc': 'üëπ',
'Giant': 'üóø',
'Cave Troll': 'üëπ',
'Dragon': 'üêâ',
'Flydra': 'üê≤'
};

// Sigil icons - now using extracted PNG images with transparent backgrounds
const SIGIL_IMAGES = {
'Attack': 'assets/sigils/attack.png',
'Shield': 'assets/sigils/shield.png',
'Heal': 'assets/sigils/heal.png',
'D20': 'assets/sigils/d20.png',
'Asterisk': 'assets/sigils/asterisk.png',
'Alpha': 'assets/sigils/alpha.png',
'Expand': 'assets/sigils/expand.png',
'Grapple': 'assets/sigils/grapple.png',
'Star': 'assets/sigils/star.png',
'Ghost': 'assets/sigils/ghost.png'
};

// Helper function to display sigil with icon
function sigilIcon(name) {
const imgPath = SIGIL_IMAGES[name];
if (!imgPath) return `<span>${name}</span>`;
return `<img src="${imgPath}" style="height:1em;vertical-align:middle;display:inline-block;margin-right:0.25em;filter:brightness(0);" alt="${name}">${name}`;
}

// Helper function to display just the icon
function sigilIconOnly(name, level = null) {
const imgPath = SIGIL_IMAGES[name];
if (!imgPath) return `<span>${name}</span>`;
// CSS handles coloring via .sigil.l0 img, .sigil.l1 img, etc.
const icon = `<img src="${imgPath}" style="height:1.4em;vertical-align:middle;display:inline-block;" alt="${name}">`;
// Add level number as superscript for all levels >= 1
if (level !== null && level >= 1) {
return `${icon}<sup>${level}</sup>`;
}
return icon;
}

// Sigil descriptions for tooltips
// Format: scaling values use <b class="sig-scale">ONE</b> to indicate level-dependent values
const SIGIL_DESCRIPTIONS = {
'Attack': 'Deal POW damage to target <b class="sig-scale">ONE</b> time. L2: twice. L3: 3√ó. L4: 4√ó.',
'Shield': 'Grant target <b class="sig-scale">2√óPOW</b> shield. L2: 4√ó. L3: 6√ó. L4: 8√ó. Shields persist between battles (capped at max HP).',
'Heal': 'Restore <b class="sig-scale">2√óPOW</b> HP to target. L2: 4√ó. L3: 6√ó. L4: 8√ó. Cannot exceed max HP.',
'D20': 'Attempt a gambit! Roll <b class="sig-scale">ONE</b> d20. L2: 2 dice (take best). L3: 3 dice. L4: 4 dice.',
'Expand': 'PASSIVE (works automatically): Add <b class="sig-scale">+1</b> target per level to Attack/Shield/Heal. Mage/Healer get +1 built-in.',
'Grapple': 'Stun target for <b class="sig-scale">ONE</b> turn. L2: 2 turns. L3: 3 turns. User takes recoil damage equal to target\'s POW.',
'Ghost': 'Gain <b class="sig-scale">ONE</b> Ghost charge. L2: 2 charges. L3: 3. L4: 4. Each charge prevents one lethal hit. Charges persist between combats (max 9).',
'Asterisk': 'PASSIVE (works automatically): Your first action each combat triggers <b class="sig-scale">ONE</b> extra time. L2: 2 extra. L3: 3 extra. L4: 4 extra.',
'Star': 'PASSIVE (works automatically): Multiply combat XP by <b class="sig-scale">1.5√ó</b>. L2: 2√ó. L3: 2.5√ó. L4: 3√ó. Stacks across all heroes!',
'Alpha': 'Grant target hero <b class="sig-scale">ONE</b> extra action this turn. L2: 2 actions. L3: 3 actions. L4: 4 actions.'
};

// ===== SIGIL ORDERING =====
// Define consistent sigil order for hero cards and displays
// Top row (actives): Attack, Shield, Heal, Grapple, D20 (D20 always top right)
// Bottom row: Alpha (bottom left), Ghost, Expand, Star, Asterisk (bottom right, passive)
const SIGIL_ORDER = ['Attack', 'Shield', 'Heal', 'Grapple', 'D20', 'Alpha', 'Ghost', 'Expand', 'Star', 'Asterisk'];

function sortSigils(sigils) {
if (!Array.isArray(sigils)) return sigils;
return [...sigils].sort((a, b) => {
const aName = typeof a === 'string' ? a : a.sig;
const bName = typeof b === 'string' ? b : b.sig;
const aIndex = SIGIL_ORDER.indexOf(aName);
const bIndex = SIGIL_ORDER.indexOf(bName);
// If not in order array, put at end
if (aIndex === -1 && bIndex === -1) return 0;
if (aIndex === -1) return 1;
if (bIndex === -1) return -1;
return aIndex - bIndex;
});
}

// Render sigils in proper 2-row formation
// Formation: 1-3 = 1 row, 4 = 2x2, 5 = 3+2, 6 = 3+3, 7 = 4+3, 8 = 4+4, 9 = 5+4, 10 = 5+5
function renderSigilRows(sigils, heroIdx, options = {}) {
const { compact = false, clickable = false, onClick = null } = options;
const sorted = sortSigils(sigils);
const count = sorted.length;

// Calculate row distribution
let row1Count, row2Count;
if (count <= 3) {
row1Count = count;
row2Count = 0;
} else if (count === 4) {
row1Count = 2;
row2Count = 2;
} else {
row1Count = Math.ceil(count / 2);
row2Count = count - row1Count;
}

const row1Sigils = sorted.slice(0, row1Count);
const row2Sigils = sorted.slice(row1Count);

// Determine if we need compact sizing for many sigils
const needsCompact = compact || count >= 7;
const sigilClass = needsCompact ? 'sigil-row compact' : 'sigil-row';

const renderSigil = (s) => {
const sigName = typeof s === 'string' ? s : s.sig;
const lvl = typeof heroIdx === 'number' ? getLevel(sigName, heroIdx) : (typeof s === 'object' && s.level !== undefined ? s.level : 1);
const cl = lvl===0?'l0':lvl===1?'l1':lvl===2?'l2':lvl===3?'l3':lvl===4?'l4':'l5';
const passiveClass = ['Expand', 'Asterisk', 'Star'].includes(sigName) ? 'passive' : '';
const clickableClass = clickable ? 'clickable' : '';
const clickHandler = onClick ? `onclick="${onClick}('${sigName}')"` : '';
return `<span class="sigil ${cl} ${passiveClass} ${clickableClass}" ${clickHandler} onmouseenter="showTooltip('${sigName}', this, ${lvl})" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sigName}', this, ${lvl}), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly(sigName, lvl)}</span>`;
};

let html = `<div class="${sigilClass}">`;
row1Sigils.forEach(s => html += renderSigil(s));
html += '</div>';

if (row2Sigils.length > 0) {
html += `<div class="${sigilClass}">`;
row2Sigils.forEach(s => html += renderSigil(s));
html += '</div>';
}

return html;
}

// ===== UTILITY FUNCTIONS =====
// Unified dice rolling utility
function rollDice(count, sides = 20) {
// Play dice roll sound for D20s
if(sides === 20) SoundFX.play('d20roll');

// Debug mode: Oops All 20s
if(S.oopsAll20s && sides === 20) {
const rolls = Array(count).fill(20);
SoundFX.play('nat20');
return {rolls, best: 20};
}
const rolls = [];
for(let i = 0; i < count; i++) {
rolls.push(Math.ceil(Math.random() * sides));
}
const best = Math.max(...rolls);
const worst = Math.min(...rolls);

// Play special sounds for nat 20 and nat 1
if(sides === 20) {
if(best === 20) {
  setTimeout(() => SoundFX.play('nat20'), 350); // After dice roll sound
} else if(worst === 1 && best < 10) {
  setTimeout(() => SoundFX.play('nat1'), 350); // Sad trombone for bad rolls with a 1
}
}
return {rolls, best};
}

// Get display name for enemy with A, B, C suffix if there are duplicates
// Adds "FU " prefix in Frogged Up mode
function getEnemyDisplayName(enemy) {
if (!enemy || !S.enemies) return enemy?.n || '';
const prefix = S.gameMode === 'fu' ? 'FU ' : '';
// Count enemies with same base name
const sameName = S.enemies.filter(e => e.n === enemy.n);
if (sameName.length <= 1) return prefix + enemy.n;
// Find position of this enemy among same-named enemies
const index = sameName.findIndex(e => e.id === enemy.id);
if (index === -1) return prefix + enemy.n;
// Add suffix: A, B, C, etc.
const suffix = String.fromCharCode(65 + index); // 65 = 'A'
return `${prefix}${enemy.n} ${suffix}`;
}

// Helper for enemy attacks - handles targeting, damage, animations, and toast
function executeEnemyAttackOnHeroes(enemy, targetCount, attackName = 'Base Attack') {
// JUICE: Enemy attack slide animation (charges toward heroes)
triggerEnemyAttackAnimation(enemy.id);

const targets = selectEnemyTargets(enemy, targetCount);
if(targets.length === 0) return 0;

const damagedIds = [];
const targetDetails = [];
const dmg = enemy.p;
targets.forEach(target => {
if(target.h > 0) {
const hpBefore = target.h;
damagedIds.push(target.id);
// Apply damage silently (we'll show one toast for all targets)
applyDamageToTarget(target, dmg, {isHero: true, silent: true});
const hpAfter = target.h;
targetDetails.push({name: target.n, before: hpBefore, after: hpAfter, dmg: dmg});
}
});

// Trigger hit animations when enemy "lands" the hit
setTimeout(() => {
damagedIds.forEach((id, idx) => {
triggerHitAnimation(id);
// JUICE: Floating damage numbers for hero damage
showFloatingNumber(id, `-${dmg}`, dmg >= 5 ? 'critical' : 'damage', idx * 15);
// Show pained reaction when hero takes damage
const hero = S.heroes.find(h => h.id === id);
if(hero) setHeroReaction(id, 'pained', hero.ls ? 0 : 600);
});

// JUICE: Sinister sound for enemy attacks on heroes + screen shake
if(damagedIds.length > 0) {
SoundFX.play(dmg >= 5 ? 'enemyCrit' : 'enemyHit');
triggerScreenShake(dmg >= 5); // Heavy shake for big hits
}
}, ANIMATION_TIMINGS.ATTACK_IMPACT);

if(targetDetails.length > 0) {
const targetStrings = targetDetails.map(t => `${t.name} (‚ù§${t.before}‚Üí‚ù§${t.after})`);
toast(`${getEnemyDisplayName(enemy)}'s ${attackName} hit ${targetStrings.join(', ')}!`);
}

return targets.length;
}

// ===== RENDER HELPERS =====
// Render encampment enemy selection screen
function renderEncampmentSelection() {
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets.length;
let html = '<div class="combat-header">';
html += `<div class="combat-header-title">Encampment Early Kill</div>`;
html += `<div class="combat-header-subtitle">Click ${kills} enem${kills>1?'ies':'y'} to remove before combat (${selected}/${kills} selected)</div>`;
html += '</div>';
html += '<div class="combat-grid">';
html += '<div class="column heroes">';
html += '<div class="section-label">HEROES</div>';
S.heroes.forEach((h,i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
const heroImage = getHeroImage(h);
html += `<div class="card hero">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${h.n}</div>
${heroImage ? `<img src="${heroImage}" class="card-image">` : ''}
<div class="sigil-divider"></div>`;
const activeSigils = [...h.s, ...(h.ts || [])];
html += renderSigilRows(activeSigils, i);
html += `<div class="card-stats">${h.p}‚ö° | ${hp}${extra.length>0?' | '+extra.join(' '):''}</div>`;
html += '</div>';
});
html += '</div>';
html += '<div class="column enemies">';
html += '<div class="section-label">ENEMIES</div>';
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });
S.heroes.forEach((hero, laneIdx) => {
const laneEnemies = enemyLanes[laneIdx] || [];
html += `<div class="combat-lane" data-lane="${laneIdx+1}">`;
if(laneEnemies.length === 0) {
html += `<div class="empty-slot">Empty</div>`;
} else {
laneEnemies.forEach(e => {
const isSelected = S.encampmentSelectedTargets.includes(e.id);
let cardClasses = 'card enemy targetable';
if(isSelected) cardClasses += ' targeted';
const extra = [];
if(e.sh > 0) extra.push(`${e.sh}üõ°`);
if(e.g > 0) extra.push(`${e.g}${sigilIconOnly('Ghost')}`);
if(isSelected) extra.push('‚ùå');
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
html += `<div class="${cardClasses}" onclick="selectEncampmentTarget('${e.id}')">
<div class="card-emoji">${enemyEmoji}</div>
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${getEnemyDisplayName(e)}</div>
<div class="card-stats">${e.p}‚ö° | ${e.h}/${e.m}‚ù§${extra.length>0?' | '+extra.join(' '):''}</div>
<div class="sigil-divider"></div>
<div class="sigil-row">`;
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
if(!hasAttackSigil) {
html += `<span class="sigil l1">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig, sigil.level)}</span>`;
});
html += '</div></div>';
});
}
html += '</div>';
});
html += '</div></div>';
if(selected >= kills) {
html += '<button class="btn danger" style="margin-top:1rem" onclick="confirmEncampmentKills()">Confirm Removals</button>';
}
return html;
}

// Render combat status header
function renderCombatStatusHeader() {
let html = '<div class="combat-header">';
if(S.turn!=='player') {
if(S.enemyTurnTotal && S.enemyTurnCurrent) {
html += `<div class="combat-header-title">Enemy Turn</div>`;
html += `<div class="combat-header-subtitle">Enemy ${S.enemyTurnCurrent}/${S.enemyTurnTotal} acting‚Ä¶</div>`;
} else {
html += 'Enemy Turn‚Ä¶';
}
} else if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
const selected = S.targets.length;
html += `<div class="combat-header-title">${S.d20Action} (DC ${S.d20DC})</div>`;
const targetText = maxTargets >= 2 ? `targets: ${selected}/${maxTargets}` : 'Select target';
html += `<div class="combat-header-subtitle">${targetText}</div>`;
} else if(S.pending) {
const targetsPerInstance = getTargetsPerInstance(S.pending, S.activeIdx);
const targetType = needsEnemyTarget(S.pending) ? 'enemy' : 'hero';
if(isMultiInstance(S.pending)) {
const targetsInInstance = S.currentInstanceTargets.length;
html += `<div class="combat-header-title">${S.pending}</div>`;
const targetText = targetsPerInstance >= 2 ? `targets: ${targetsInInstance}/${targetsPerInstance}` : `Select ${targetType}`;
html += `<div class="combat-header-subtitle">${targetText}</div>`;
html += `<div class="combat-header-info">${S.instancesRemaining} instance${S.instancesRemaining>1?'s':''} remaining</div>`;
} else {
const selected = S.targets.length;
const max = targetsPerInstance;
html += `<div class="combat-header-title">${S.pending}</div>`;
const targetText = max >= 2 ? `targets: ${selected}/${max}` : `Select ${targetType}`;
html += `<div class="combat-header-subtitle">${targetText}</div>`;
}
} else if(S.activeIdx === -1) {
const remaining = S.heroes.filter((h,i) => !S.acted.includes(i) && h.st === 0).length;
html += `<div class="combat-header-title pulse-prompt">Tap a hero's sigil</div>`;
html += `<div class="combat-header-subtitle" style="opacity:0.8">${remaining} hero${remaining>1?'es':''} remaining</div>`;
} else {
const h = S.heroes[S.activeIdx];
if(h) {
if(h.ls) html += `${h.n} Last Stand (Turn ${h.lst + 1}) - D20 only!`;
else html += `${h.n}'s Turn`;
}
}
html += '</div>';

// Add action bar when we have targets selected - simplified for controller flow
// D20_TARGET uses S.targets, other actions use S.currentInstanceTargets
const hasTargetsForActionBar = S.pending === 'D20_TARGET'
? (S.targets && S.targets.length > 0)
: (S.currentInstanceTargets && S.currentInstanceTargets.length > 0);
if(S.turn === 'player' && S.pending && hasTargetsForActionBar) {
const targetArray = S.pending === 'D20_TARGET' ? S.targets : S.currentInstanceTargets;
const targetCount = targetArray.length;
const targetNames = targetArray.map(t => {
const unit = [...(S.heroes || []), ...(S.enemies || [])].find(u => u.id === t);
return unit ? unit.n : 'target';
}).join(', ');
html += '<div class="target-action-bar" style="display:flex;flex-direction:column;gap:0.25rem;align-items:center;margin-top:0.5rem">';
html += `<div style="font-size:0.85rem;opacity:0.9">Target${targetCount > 1 ? 's' : ''}: <strong>${targetNames}</strong></div>`;
html += '<div style="display:flex;gap:0.5rem">';
html += `<button class="btn safe" onclick="confirmTargets()" style="padding:0.4rem 1rem;font-size:0.9rem">‚úì Confirm (‚í∂/‚ä°)</button>`;
html += `<button class="btn secondary" onclick="cancelAction()" style="padding:0.4rem 1rem;font-size:0.9rem">‚úó Cancel (‚í∑)</button>`;
html += '</div>';
html += '</div>';
}

return html;
}

// Unified damage application with shield/ghost/laststand handling
function applyDamageToTarget(target, rawDamage, options = {}) {
let dmg = rawDamage;
let shieldLost = 0;
let hpLost = 0;

// Handle shield absorption
if(target.sh > 0) {
if(target.sh >= rawDamage) {
shieldLost = rawDamage;
target.sh -= rawDamage;
dmg = 0;
} else {
shieldLost = target.sh;
dmg = rawDamage - target.sh;
target.sh = 0;
}
}

// Apply damage to HP
hpLost = dmg;
target.h -= dmg;

// LAYER 1: Warning when hero drops below 30% HP (preventive Last Stand warning)
// Skip during tutorial - Tapo intervention handles this without explaining Last Stand
if(options.isHero && !target.ls && target.h > 0 && target.h < target.m * 0.3) {
// Check if this is the first time we're warning about low HP (and not in tutorial)
if(!S.tutorialFlags.last_stand_warning && !(tutorialState && S.floor === 0)) {
showTutorialPop('last_stand_warning', `${target.n} is in danger! If they reach 0 HP, they'll enter Last Stand mode - they can only use D20 gambits, and each turn makes survival harder. Use Ghost charges or heal up to avoid it!`);
}
}

// Handle lethal damage
if(target.h <= 0) {
if(target.g > 0) {
// Ghost charge cancels death
target.g--;
target.h += dmg;
hpLost = 0; // Ghost prevented the HP loss
if(!options.silent) {
toast(`${target.n}'s Ghost charge cancelled the lethal hit!`, 1200);
}
} else {
// Death/Last Stand
target.h = 0;
if(options.isHero) {
// TUTORIAL PHASE 1: Override Last Stand with Tapo rescue
// IMPORTANT: Only trigger during ENEMY turn, not player turn (e.g., Grapple recoil)
console.log('[TAPO] Phase 1 death check - S.turn:', S.turn, 'target:', target.n, 'HP was:', target.h);
if(tutorialState && S.floor === 0 && tutorialState.phase === 1 && S.turn === 'enemy') {
console.log('[TAPO] Rescue triggered! Starting rescue sequence.');
// Tapo saves the day! Prevent actual death
target.h = 1;
// Show the full Tapo rescue sequence with narrative and animated fly deaths
if(typeof showTapoRescueSequence === 'function') {
showTapoRescueSequence();
}
return {hpLost: 0, shieldLost, totalDamage: rawDamage};
}
// Heroes enter Last Stand
target.ls = true;
target.lst = 0;
triggerScreenShake(true); // Heavy shake on entering last stand
if(!options.silent) {
// LAYER 2: Extended toast duration (3000ms instead of default)
toast(`${target.n} entered Last Stand!`, 3000);
// Skip Last Stand explanation during tutorial - Tapo intervention prevents it
if(!(tutorialState && S.floor === 0)) {
showTutorialPop('last_stand_intro', "When a hero drops to 0 HP, they enter Last Stand! They can only use D20 gambits, and each turn makes success harder. Heal them to bring them back!");
}
}
} else {
// Enemies die - award gold/XP and schedule removal
// Skip rewards for Floor 0 tutorial
if(!options.skipRewards && S.floor !== 0) {
// FLYDRA: Skip gold on head "death" - heads can revive! Gold awarded at combat completion
if(!target.isFlydra) {
S.gold += target.goldDrop || 0;
S.combatGold += target.goldDrop || 0;
// JUICE: Coin sound for gold drops
if(target.goldDrop > 0) SoundFX.play('coinDrop');
}
// XP is fine to award per head (player can't spend it after victory anyway)
S.combatXP += target.x;
upd();
}
}
}
}

return {hpLost, shieldLost, totalDamage: rawDamage}; // Return detailed breakdown
}

// ===== TUTORIAL SYSTEM =====
// Centralized Tutorial Manager for Ribbleton combat tutorial
const TutorialManager = {
// Tutorial stage definitions
stages: {
// Phase 1 stages
'waiting_for_start': {allowedActions: []},
'catching_flies': {allowedActions: 'ALL'}, // Phase 1: Free-form fly catching
// Phase 2 stages
'warrior_attack': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'targeting_wolf': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'healer_d20': {allowedActions: [{hero: 'Healer', sig: 'D20'}]},
'd20_menu': {allowedActions: [{hero: 'Healer', sig: 'D20'}]},
'enemy_turn_wait': {allowedActions: []},
'enemy_turn_explained': {allowedActions: []},
'healer_heal': {allowedActions: [{hero: 'Healer', sig: 'Heal'}]},
'expand_targets': {allowedActions: [{hero: 'Healer', sig: 'Heal'}]},
'finish_wolf': {allowedActions: [{hero: 'Warrior', sig: 'Attack'}]},
'shield_sigil': {allowedActions: []},
'free': {allowedActions: 'ALL'} // Tutorial complete, allow all actions
},

// Check if an action is allowed in current tutorial stage
canPerformAction(hero, sig) {
if(!tutorialState || S.floor !== 0) return true; // Not in tutorial
const stage = this.stages[tutorialState.stage];
if(!stage) return true; // Unknown stage, allow
if(stage.allowedActions === 'ALL') return true; // Free-form stage

const allowed = stage.allowedActions;
if(allowed.length === 0) return false; // No actions allowed in this stage

return allowed.some(a => a.hero === hero.n && a.sig === sig);
},

// Get descriptive message for current tutorial stage
getInstructionMessage() {
if(!tutorialState || S.floor !== 0) return "Follow the tutorial instructions!";
const stage = tutorialState.stage;

// Stage-specific messages
const messages = {
'waiting_for_start': "Wait for the tutorial to begin!",
'warrior_attack': "Click the Warrior's Attack sigil, then target the Wolf!",
'targeting_wolf': "Click the Wolf to target it with your Attack!",
'healer_d20': "Click the Healer's D20 to see risky gambit actions!",
'd20_menu': "Select a D20 gambit option!",
'enemy_turn_wait': "Wait for the enemy turn to complete!",
'enemy_turn_explained': "Wait for the next round to begin!",
'healer_heal': "Click the Healer's Heal sigil!",
'expand_targets': "Select targets for your Heal with Expand!",
'finish_wolf': "Use your abilities to defeat the remaining enemies!",
'shield_sigil': "Wait and watch what happens!"
};

return messages[stage] || "Follow the tutorial instructions!";
},

// Advance to next stage based on action completion
advanceStage(context) {
if(!tutorialState || S.floor !== 0) return;

const {action, hero, round} = context;

// Stage transitions based on completed actions
if((tutorialState.stage === 'warrior_attack' || tutorialState.stage === 'targeting_wolf') && tutorialState.wolfDamaged && hero === 'Warrior' && round === 1) {
tutorialState.stage = 'healer_d20';
showTutorialPop('ribbleton_healer_d20', "Nice hit! Before we heal, let's learn about gambits - click the Healer's D20 to see risky actions!", () => {
S.activeIdx = 1;
render();
});
}
else if(tutorialState.stage === 'd20_menu' && hero === 'Healer') {
tutorialState.stage = 'enemy_turn_wait';
}
else if(tutorialState.stage === 'expand_targets' && hero === 'Healer') {
tutorialState.stage = 'finish_wolf';
// REMOVED: "Finish Wolf" popup - trust player to continue combat after heal
}
},

// Handle round transitions during tutorial
onRoundStart(round) {
if(!tutorialState || S.floor !== 0) return;

debugLog('[TUTORIAL] Round transition - Round:', round, 'Stage:', tutorialState.stage);

// PHASE 1 (Fly Catching): Round 2 - Mage already has Expand, just continue
if(tutorialState.phase === 1 && round === 2) {
debugLog('[TUTORIAL] Phase 1 Round 2 - Continuing combat (Mage already has Expand)');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
upd();
render();
return;
}

// PHASE 2 (Ribbleton): Round 2: Healer Heal prompt (NOW BATCHED WITH EXPAND)
if(round === 2 && (tutorialState.stage === 'enemy_turn_explained' || tutorialState.stage === 'finish_wolf') && !S.tutorialFlags.ribbleton_healer_heal) {
debugLog('[TUTORIAL] Triggering PROMPT 4 - Healer Heal + Expand (batched) (stage:', tutorialState.stage, ')');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'healer_heal';
upd();
render();
// Popup now appears when Heal is pending (see render() section) - it includes Expand explanation
S.activeIdx = 1;
render();
} else if(round === 2 && !S.tutorialFlags.ribbleton_healer_heal) {
debugLog('[TUTORIAL] Round 2 but stage is:', tutorialState.stage, '(expected: enemy_turn_explained or finish_wolf) - forcing healer_heal anyway');
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'healer_heal';
upd();
render();
// Popup now appears when Heal is pending (see render() section) - it includes Expand explanation
S.activeIdx = 1;
render();
}
// Round 3: Force Goblin to draw Shield, then PROMPT 5 (Enemy Sigils batched) + PROMPT 6 (Tooltip + Handoff batched)
else if(round === 3 && tutorialState.stage === 'finish_wolf') {
// Force Goblin to draw Shield
const goblin = S.enemies.find(e => e.n === 'Goblin');
if(goblin && !goblin.s.some(s => s.sig === 'Shield')) {
goblin.s.push({sig:'Shield', level:1, perm:false});
toast('Goblin drew Shield L1!');
}
S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
tutorialState.stage = 'shield_sigil';
upd();
render();
// PROMPT 5: Enemy Sigils + Shield
showTutorialPop('enemies_get_sigils', "Enemies draw sigils too! The Goblin drew Shield - he'll activate it AFTER attacking this turn, then it's gone. Try to defeat him before he can shield!", () => {
// Player can now act freely - handoff popup will show after they take an action
tutorialState.stage = 'free';
render();
});
}
},

// Handle enemy turn during tutorial
onEnemyTurnStart() {
if(!tutorialState || S.floor !== 0) return;
if(tutorialState.stage === 'enemy_turn_wait') {
S.locked = true;
tutorialState.stage = 'enemy_turn_explained';
showTutorialPop('ribbleton_enemy_turn', "Uh oh! Enemies attack EVERY turn, and they usually attack straight across from them!", () => {
S.locked = false;
});
}
}
};

// Tutorial system
let tooltipTimeout = null;
let currentTooltip = null;

// Get level-specific description with colored/bolded numbers
function getLevelDescription(sigilName, level) {
const levelColors = {
0: '#666',
1: '#000',
2: '#06b6d4',
3: '#9333ea',
4: '#d97706',
5: '#ff0080'
};
const color = levelColors[level] || '#000';
const boldNum = (num) => `<strong style="color:${color}">${num}</strong>`;

// Level-specific descriptions
const descriptions = {
'Attack': level === 0 ? 'Not unlocked' : level === 1 ? 'Deal POW damage to target' : `Attack ${boldNum(level)} times for POW damage each`,
'Shield': level === 0 ? 'Not unlocked' : level === 1 ? 'Grant target 2√óPOW shield (persists between battles, capped at max HP)' : `Shield ${boldNum(level)} times for 2√óPOW each (persists between battles, capped at max HP)`,
'Heal': level === 0 ? 'Not unlocked' : level === 1 ? 'Restore 2√óPOW HP to target (cannot exceed max HP)' : `Heal ${boldNum(level)} times for 2√óPOW each (cannot exceed max HP)`,
'D20': `Roll ${boldNum(level)}d20, use best result. Choose gambit: Confuse (deal enemy POW to all), Startle (stun), Mend (heal self), Steal (gold), Recruit (join team)`,
'Expand': level === 0 ? 'PASSIVE: Add +1 target to Attack/Shield/Heal. Works automatically. Mage/Healer get +1 built-in' : `PASSIVE: Permanently add ${boldNum(level)} extra target${level > 1 ? 's' : ''} to Attack/Shield/Heal. Works automatically. Mage/Healer get +1 built-in`,
'Grapple': level === 0 ? 'Not unlocked' : `Stun target for ${boldNum(level)} turn${level > 1 ? 's' : ''}. You take damage equal to target's POW`,
'Ghost': level === 0 ? 'Not unlocked' : `Gain ${boldNum(level)} charge${level > 1 ? 's' : ''}. Each charge prevents one death (persists between combats, max 9)`,
'Asterisk': level === 0 ? 'Not unlocked' : `PASSIVE: Next action triggers ${boldNum(level + 1)} times! Resets after each battle`,
'Star': level === 0 ? 'PASSIVE: Not unlocked' : `PASSIVE: Gain ${boldNum(level * 0.5)}√ó extra XP per battle (stacks with other heroes)`,
'Alpha': level === 0 ? 'Not unlocked' : `Grant target hero ${boldNum(level)} extra action${level > 1 ? 's' : ''} this turn`
};

return descriptions[sigilName] || 'No description available';
}

function showTooltip(sigilName, element, level = 1) {
// Check if tooltips are disabled
if(S.tooltipsDisabled) return;

// Tooltip display (tutorial explanation happens in Ribbleton combat)

const desc = getLevelDescription(sigilName, level);
if(!desc) return;

hideTooltip();

const tooltip = document.createElement('div');
tooltip.className = 'tooltip tooltip-green';
tooltip.innerHTML = `
<div class="tooltip-title">${sigilIcon(sigilName)}</div>
<div class="tooltip-desc">${desc}</div>`;

document.body.appendChild(tooltip);
currentTooltip = tooltip;

// Position tooltip near the element
const rect = element.getBoundingClientRect();
const tooltipRect = tooltip.getBoundingClientRect();
let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
let top = rect.top - tooltipRect.height - 10;

// Keep tooltip on screen
if(left < 10) left = 10;
if(left + tooltipRect.width > window.innerWidth - 10) left = window.innerWidth - tooltipRect.width - 10;
if(top < 10) top = rect.bottom + 10;

tooltip.style.left = left + 'px';
tooltip.style.top = top + 'px';

setTimeout(() => tooltip.classList.add('show'), 10);
}

function hideTooltip() {
// Clear any pending tooltip timers
if(tooltipTimeout) {
clearTimeout(tooltipTimeout);
tooltipTimeout = null;
}
// Immediately remove current tooltip
if(currentTooltip) {
currentTooltip.remove();
currentTooltip = null;
}
}

// Helper to create sigil with tooltip (for death screen with longer hover time)
function sigilIconWithTooltip(sig, level = 1, hoverDelay = 500) {
return `<span onmouseenter="showTooltip('${sig}', this, ${level})" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sig}', this, ${level}), ${hoverDelay})" ontouchend="hideTooltip()">${sigilIcon(sig)}</span>`;
}

function generateFibonacci(n) {
const fib = [1, 1];
for(let i = 2; i < n; i++) fib.push(fib[i-1] + fib[i-2]);
return fib;
}
const FIB = generateFibonacci(50);

// Get XP cost for level up - Fibonacci up to 89, then 100, 200, 300, etc.
function getXPCost(levelUpCount) {
// Find the index where Fibonacci reaches 89 (FIB[10] = 89)
if (levelUpCount >= 10) {
// After Fibonacci 89, increment by 100 each time
// levelUpCount 10 = 100, levelUpCount 11 = 200, levelUpCount 12 = 300, etc.
return (levelUpCount - 9) * 100;
}
return FIB[levelUpCount] || 100;
}

// ===== ANIMATION TIMING CONSTANTS =====
// Centralized timing values for easy tuning and consistency
const ANIMATION_TIMINGS = {
  // CSS animation durations (must match CSS @keyframes)
  DAMAGE_FLASH: 400,      // .hit-flash animation duration
  ATTACK_SLIDE: 480,      // .attack-slide animation duration
  ATTACK_IMPACT: 190,     // When attacker "lands" hit (40% of attack slide)
  HEAL_FLASH: 480,        // .heal-flash animation duration
  SHIELD_FLASH: 480,      // .shield-flash animation duration

  // Screen transition timings
  FADE_TRANSITION: 200,   // Screen fade in/out duration
  FLOOR_INTERSTITIAL: 2000, // Floor name display duration

  // Combat turn timings
  TURN_TRANSITION: 250,   // Hero turn ‚Üí Enemy turn delay
  PHASE_TRANSITION: 200,  // Between enemy phases (Alpha/Recruit/Normal)
  ALPHA_PHASE_START: 400, // Enemy turn start ‚Üí Alpha phase
  ENEMY_ACTION_DELAY: 125, // Stagger between enemy actions (reading order)
  ENEMY_TURN_END: 300,    // After last enemy action
  ACTION_COMPLETE: 500,   // After hero action completes

  // Toast message timings
  TOAST_SHORT: 1200,      // Short notification
  TOAST_MEDIUM: 1800,     // Medium notification
  TOAST_LONG: 2000,       // Long notification
  TOAST_FADE: 300,        // Toast fade out duration

  // Tooltip timings
  TOOLTIP_DELAY: 500,     // Long-press delay for mobile tooltips
  TOOLTIP_FADE: 200,      // Tooltip fade in/out

  // Special animations
  BONUS_TURN_STACK: 300,  // Bonus turn card animation
  VICTORY_DELAY: 1000,    // Delay before level up screen
  DEFEAT_DELAY: 1000,     // Delay before death screen
  TUTORIAL_DELAY: 800,    // Tutorial popup delays

  // Juice animations
  FLOATING_NUMBER: 800,   // Floating damage number duration
  SCREEN_SHAKE: 300,      // Screen shake duration
  SCREEN_SHAKE_HEAVY: 400, // Heavy screen shake duration
  CONFETTI_DURATION: 3000, // Confetti fall duration
  COMBO_DISPLAY: 500,     // Combo counter display time
  COUNTER_POP: 300,       // Counter pop animation
  KNOCKOUT: 600,          // Death animation
};

// ===== ANIMATION SPEED SYSTEM =====
// Helper function to apply animation speed multiplier
// Speed: 1 = normal, 2 = 2x faster, 4 = 4x faster, 0 = instant
function T(baseTime) {
  const speed = (typeof S !== 'undefined' && S.animationSpeed) || 1;
  if (speed === 0) return 1; // Instant mode: 1ms minimum
  return Math.max(1, Math.round(baseTime / speed));
}

// Get current animation speed label
function getSpeedLabel() {
  const speed = (typeof S !== 'undefined' && S.animationSpeed) || 1;
  switch(speed) {
    case 0: return 'Instant';
    case 2: return '2x';
    case 4: return '4x';
    default: return 'Normal';
  }
}

// ===== JUICE & POLISH SYSTEM =====
// Floating damage/heal numbers
function showFloatingNumber(targetId, text, type = 'damage', offsetX = 0) {
  const card = document.getElementById(targetId);
  if (!card) return;

  const rect = card.getBoundingClientRect();
  const num = document.createElement('div');
  num.className = `floating-number ${type}`;
  num.textContent = text;

  // Random horizontal offset for variety
  const randomX = (Math.random() - 0.5) * 40 + offsetX;
  num.style.left = (rect.left + rect.width / 2 + randomX) + 'px';
  num.style.top = (rect.top + rect.height / 3) + 'px';

  document.body.appendChild(num);
  setTimeout(() => num.remove(), ANIMATION_TIMINGS.FLOATING_NUMBER);
}

// Screen shake effect
function triggerScreenShake(heavy = false) {
  const gameArea = document.getElementById('gameView');
  if (!gameArea) return;

  const className = heavy ? 'screen-shake-heavy' : 'screen-shake';
  gameArea.classList.add(className);
  setTimeout(() => gameArea.classList.remove(className),
    heavy ? ANIMATION_TIMINGS.SCREEN_SHAKE_HEAVY : ANIMATION_TIMINGS.SCREEN_SHAKE);
}

// Confetti celebration - with frog theme!
function spawnConfetti(count = 50) {
  const container = document.createElement('div');
  container.className = 'confetti-container';
  document.body.appendChild(container);

  // Frog-friendly colors (greens, golds, lily pad colors)
  const colors = ['#22c55e', '#16a34a', '#4ade80', '#fbbf24', '#84cc16', '#10b981', '#34d399', '#a3e635'];
  const frogEmojis = ['üê∏', 'üê∏', 'üê∏', 'ü™∑', 'üíö', '‚ú®'];

  for (let i = 0; i < count; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = Math.random() * 100 + '%';
    confetti.style.animationDelay = Math.random() * 0.5 + 's';
    confetti.style.animationDuration = (2 + Math.random() * 2) + 's';

    const rand = Math.random();
    if (rand < 0.2) {
      // 20% chance: Frog emoji
      confetti.style.backgroundColor = 'transparent';
      confetti.style.width = 'auto';
      confetti.style.height = 'auto';
      confetti.style.fontSize = (16 + Math.random() * 16) + 'px';
      confetti.textContent = frogEmojis[Math.floor(Math.random() * frogEmojis.length)];
    } else if (rand < 0.35) {
      // 15% chance: Tiny Tapo image
      confetti.style.backgroundColor = 'transparent';
      confetti.style.width = (20 + Math.random() * 15) + 'px';
      confetti.style.height = 'auto';
      const img = document.createElement('img');
      img.src = 'assets/tapo-icon.png';
      img.style.width = '100%';
      img.style.height = 'auto';
      confetti.appendChild(img);
    } else {
      // 65% chance: Colored shapes
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      if (Math.random() > 0.5) {
        confetti.style.borderRadius = '50%';
      } else if (Math.random() > 0.5) {
        confetti.style.width = '8px';
        confetti.style.height = '14px';
      }
    }

    container.appendChild(confetti);
  }

  setTimeout(() => container.remove(), ANIMATION_TIMINGS.CONFETTI_DURATION + 500);
}

// Damage counter display - shows cumulative damage during a hero's turn
function showDamageCounter(totalDamage) {
  if (totalDamage < 5) return;

  // Remove existing counter if any
  const existing = document.querySelector('.combo-counter');
  if (existing) existing.remove();

  const counter = document.createElement('div');
  counter.className = 'combo-counter';
  counter.textContent = `${totalDamage} DMG!`;

  // Scale up for bigger damage
  if (totalDamage >= 20) {
    counter.style.fontSize = '6rem';
    counter.style.color = '#ff6b6b';
    counter.style.textShadow = '0 4px 8px rgba(0,0,0,0.8), 0 0 40px #ff6b6b';
  } else if (totalDamage >= 15) {
    counter.style.fontSize = '5.5rem';
    counter.style.color = '#ff9f43';
  } else if (totalDamage >= 10) {
    counter.style.fontSize = '5rem';
    counter.style.color = '#feca57';
  }

  document.body.appendChild(counter);
  setTimeout(() => counter.remove(), ANIMATION_TIMINGS.COMBO_DISPLAY);
}

// Animate counter pop (for XP/gold changes)
function animateCounterPop(elementId) {
  const el = document.getElementById(elementId);
  if (!el) return;

  el.classList.add('counter-pop');
  setTimeout(() => el.classList.remove('counter-pop'), ANIMATION_TIMINGS.COUNTER_POP);
}

// Knockout animation for defeated enemies
function triggerKnockout(targetId) {
  const card = document.getElementById(targetId);
  if (!card) return;

  card.classList.add('knockout');
  // Don't remove - the card will be removed from DOM anyway
}


// ===== SOUND EFFECTS SYSTEM (Web Audio API) =====
const SoundFX = {
  ctx: null,
  enabled: true,
  volume: 0.3,
  musicVolume: 0.2,
  audioBuffers: {},  // Cache for loaded audio files
  currentMusic: null, // Currently playing music source
  musicGain: null,    // Gain node for music volume control

  init() {
    if (this.ctx) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      // Create music gain node
      this.musicGain = this.ctx.createGain();
      this.musicGain.gain.setValueAtTime(this.musicVolume, this.ctx.currentTime);
      this.musicGain.connect(this.ctx.destination);
    } catch(e) {
      console.warn('Web Audio API not supported');
      this.enabled = false;
    }
  },

  // Load an audio file from URL or base64 data
  async loadAudio(name, source) {
    if (!this.ctx) this.init();
    if (!this.ctx) return false;

    try {
      let arrayBuffer;

      if (source.startsWith('data:')) {
        // Base64 encoded audio
        const base64 = source.split(',')[1];
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        arrayBuffer = bytes.buffer;
      } else {
        // URL-based audio file
        const response = await fetch(source);
        arrayBuffer = await response.arrayBuffer();
      }

      const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
      this.audioBuffers[name] = audioBuffer;
      return true;
    } catch (e) {
      console.warn(`Failed to load audio "${name}":`, e);
      return false;
    }
  },

  // Play a loaded audio file
  playAudio(name, options = {}) {
    if (!this.enabled || !this.ctx) return null;
    if (!this.audioBuffers[name]) {
      console.warn(`Audio "${name}" not loaded`);
      return null;
    }

    // Resume audio context if suspended
    if (this.ctx.state === 'suspended') {
      this.ctx.resume();
    }

    const source = this.ctx.createBufferSource();
    const gainNode = this.ctx.createGain();

    source.buffer = this.audioBuffers[name];
    source.loop = options.loop || false;

    const vol = (options.volume !== undefined ? options.volume : 1) * this.volume;
    gainNode.gain.setValueAtTime(vol, this.ctx.currentTime);

    source.connect(gainNode);
    gainNode.connect(this.ctx.destination);

    source.start(0);

    return { source, gainNode };
  },

  // Play music (with loop by default, separate volume control)
  playMusic(name, options = {}) {
    if (!this.enabled || !this.ctx) return null;

    // Stop current music if playing
    this.stopMusic();

    if (!this.audioBuffers[name]) {
      console.warn(`Music "${name}" not loaded`);
      return null;
    }

    if (this.ctx.state === 'suspended') {
      this.ctx.resume();
    }

    const source = this.ctx.createBufferSource();
    source.buffer = this.audioBuffers[name];
    source.loop = options.loop !== false; // Loop by default

    source.connect(this.musicGain);
    source.start(0);

    this.currentMusic = source;
    return source;
  },

  // Stop currently playing music
  stopMusic(fadeOut = 0) {
    if (!this.currentMusic) return;

    if (fadeOut > 0 && this.musicGain) {
      // Fade out
      const now = this.ctx.currentTime;
      this.musicGain.gain.setValueAtTime(this.musicVolume, now);
      this.musicGain.gain.exponentialRampToValueAtTime(0.01, now + fadeOut);
      const music = this.currentMusic;
      setTimeout(() => {
        try { music.stop(); } catch(e) {}
        this.musicGain.gain.setValueAtTime(this.musicVolume, this.ctx.currentTime);
      }, fadeOut * 1000);
    } else {
      try { this.currentMusic.stop(); } catch(e) {}
    }

    this.currentMusic = null;
  },

  // Set music volume (0-1)
  setMusicVolume(vol) {
    this.musicVolume = Math.max(0, Math.min(1, vol));
    if (this.musicGain && this.ctx) {
      this.musicGain.gain.setValueAtTime(this.musicVolume, this.ctx.currentTime);
    }
  },

  // Preload multiple audio files
  async preloadAudio(audioMap) {
    const results = await Promise.all(
      Object.entries(audioMap).map(([name, source]) =>
        this.loadAudio(name, source).then(success => ({ name, success }))
      )
    );
    return results;
  },

  // Play a synthesized sound effect
  play(type) {
    if (!this.enabled || !this.ctx) return;

    // Resume audio context if suspended (required for mobile)
    if (this.ctx.state === 'suspended') {
      this.ctx.resume();
    }

    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);

    const now = this.ctx.currentTime;
    gain.gain.setValueAtTime(this.volume, now);

    switch(type) {
      case 'hit':
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'square';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'crit':
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
        gain.gain.setValueAtTime(this.volume * 1.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.25);
        break;

      case 'enemyHit':
        // Sinister low rumble for enemy attacks on heroes
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
        gain.gain.setValueAtTime(this.volume * 1.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.25);
        break;

      case 'enemyCrit':
        // Heavy sinister impact for enemy crits
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
        gain.gain.setValueAtTime(this.volume * 1.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.35);
        break;

      case 'heal':
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.2);
        break;

      case 'shield':
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.setValueAtTime(400, now + 0.05);
        osc.frequency.setValueAtTime(350, now + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'triangle';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'click':
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.08);
        break;

      case 'victory':
        // Ascending arpeggio
        [523, 659, 784, 1047].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now);
          g.gain.setValueAtTime(this.volume * 0.7, now + i * 0.1);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.3);
          o.type = 'sine';
          o.start(now + i * 0.1);
          o.stop(now + i * 0.1 + 0.3);
        });
        break;

      case 'levelup':
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
        gain.gain.setValueAtTime(this.volume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.3);
        break;

      case 'death':
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.6);
        break;

      case 'gold':
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        gain.gain.setValueAtTime(this.volume * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'select':
        osc.frequency.setValueAtTime(500, now);
        osc.frequency.setValueAtTime(600, now + 0.03);
        gain.gain.setValueAtTime(this.volume * 0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.08);
        break;

      case 'error':
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.setValueAtTime(150, now + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.type = 'square';
        osc.start(now);
        osc.stop(now + 0.2);
        break;

      // ===== FROGGY SOUNDS =====
      case 'ribbit':
        // Classic frog croak - two-tone chirp
        osc.frequency.setValueAtTime(220, now);
        osc.frequency.exponentialRampToValueAtTime(180, now + 0.08);
        osc.frequency.setValueAtTime(260, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.2);
        gain.gain.setValueAtTime(this.volume * 0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.25);
        break;

      case 'splash':
        // Water splash for D20 rolls - noise-like falling tone
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.35);
        break;

      case 'hop':
        // Light hop - quick ascending blip
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(500, now + 0.06);
        osc.frequency.exponentialRampToValueAtTime(350, now + 0.1);
        gain.gain.setValueAtTime(this.volume * 0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.12);
        break;

      case 'croak':
        // Deep croak for enemy defeats - low rumble
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
        osc.frequency.setValueAtTime(100, now + 0.2);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.4);
        gain.gain.setValueAtTime(this.volume * 0.9, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        osc.type = 'triangle';
        osc.start(now);
        osc.stop(now + 0.45);
        break;

      case 'bubble':
        // Bubble pop for shields - playful bloop
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.15);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.18);
        break;

      case 'gulp':
        // Gulp/slurp for healing - descending then up
        osc.frequency.setValueAtTime(500, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.08);
        osc.frequency.exponentialRampToValueAtTime(700, now + 0.15);
        gain.gain.setValueAtTime(this.volume * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.2);
        break;

      case 'd20roll':
        // Dice tumbling - rapid frequency wobble
        osc.frequency.setValueAtTime(400, now);
        for(let i = 0; i < 8; i++) {
          osc.frequency.setValueAtTime(350 + Math.random() * 200, now + i * 0.04);
        }
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.35);
        gain.gain.setValueAtTime(this.volume * 0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.type = 'square';
        osc.start(now);
        osc.stop(now + 0.4);
        break;

      case 'portal':
        // Portal whoosh - sweeping mystical sound
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.5);
        gain.gain.setValueAtTime(this.volume * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.55);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.55);
        break;

      case 'nat20':
        // Natural 20! - triumphant ascending fanfare
        [400, 500, 600, 800].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now);
          g.gain.setValueAtTime(this.volume * 0.8, now + i * 0.08);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.25);
          o.type = 'sine';
          o.start(now + i * 0.08);
          o.stop(now + i * 0.08 + 0.25);
        });
        break;

      case 'nat1':
        // Natural 1 - sad descending trombone
        [300, 280, 250, 150].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now + i * 0.12);
          g.gain.setValueAtTime(this.volume * 0.6, now + i * 0.12);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.12 + 0.15);
          o.type = 'sawtooth';
          o.start(now + i * 0.12);
          o.stop(now + i * 0.12 + 0.15);
        });
        break;

      // ===== MORE FROGGY SOUNDS =====
      case 'tongueSnap':
        // Frog tongue lash attack - quick snap with wet ending
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.05);
        osc.frequency.setValueAtTime(150, now + 0.06);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.12);
        gain.gain.setValueAtTime(this.volume * 0.7, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'lilyPad':
        // Bouncing on lily pad - springy boing
        osc.frequency.setValueAtTime(250, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.08);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
        osc.frequency.exponentialRampToValueAtTime(350, now + 0.2);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.25);
        break;

      case 'flyCatch':
        // Catching a fly - quick zip and crunch
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.04);
        osc.frequency.setValueAtTime(100, now + 0.05);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(this.volume * 0.3, now + 0.04);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.type = 'square';
        osc.start(now);
        osc.stop(now + 0.1);
        break;

      case 'mudSquelch':
        // Stepping in mud - wet squelchy sound
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(120, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.25);
        gain.gain.setValueAtTime(this.volume * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.type = 'triangle';
        osc.start(now);
        osc.stop(now + 0.3);
        break;

      case 'waterDrip':
        // Single water droplet
        osc.frequency.setValueAtTime(1400, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.08);
        gain.gain.setValueAtTime(this.volume * 0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.12);
        break;

      case 'crickets':
        // Cricket chirps - rapid high frequency bursts
        [0, 0.15, 0.18, 0.35, 0.38].forEach((t) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(4000 + Math.random() * 500, now + t);
          g.gain.setValueAtTime(this.volume * 0.15, now + t);
          g.gain.exponentialRampToValueAtTime(0.01, now + t + 0.03);
          o.type = 'sine';
          o.start(now + t);
          o.stop(now + t + 0.03);
        });
        break;

      case 'frogChorus':
        // Multiple frogs croaking in celebration
        [
          { freq: 180, delay: 0, type: 'sine' },
          { freq: 220, delay: 0.1, type: 'triangle' },
          { freq: 160, delay: 0.15, type: 'sine' },
          { freq: 200, delay: 0.25, type: 'triangle' },
          { freq: 240, delay: 0.3, type: 'sine' }
        ].forEach(({ freq, delay, type }) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now + delay);
          o.frequency.exponentialRampToValueAtTime(freq * 0.7, now + delay + 0.15);
          g.gain.setValueAtTime(this.volume * 0.4, now + delay);
          g.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.2);
          o.type = type;
          o.start(now + delay);
          o.stop(now + delay + 0.2);
        });
        break;

      case 'splashBig':
        // Big splash - dramatic water entry
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.4);
        gain.gain.setValueAtTime(this.volume * 0.8, now);
        gain.gain.exponentialRampToValueAtTime(this.volume * 0.3, now + 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.5);
        break;

      case 'rain':
        // Rain ambiance - multiple water drops
        for (let i = 0; i < 12; i++) {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          const t = Math.random() * 0.8;
          o.frequency.setValueAtTime(800 + Math.random() * 1200, now + t);
          o.frequency.exponentialRampToValueAtTime(400 + Math.random() * 400, now + t + 0.06);
          g.gain.setValueAtTime(this.volume * (0.1 + Math.random() * 0.15), now + t);
          g.gain.exponentialRampToValueAtTime(0.01, now + t + 0.1);
          o.type = 'sine';
          o.start(now + t);
          o.stop(now + t + 0.1);
        }
        break;

      case 'treasure':
        // Finding treasure - magical shimmer
        [800, 1000, 1200, 1000, 1400].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now + i * 0.07);
          g.gain.setValueAtTime(this.volume * 0.5, now + i * 0.07);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.07 + 0.15);
          o.type = 'sine';
          o.start(now + i * 0.07);
          o.stop(now + i * 0.07 + 0.15);
        });
        break;

      case 'stun':
        // Stun/grapple effect - dizzy warble
        [0, 0.08, 0.15, 0.2].forEach((t, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(300 - i * 30, now + t);
          o.frequency.exponentialRampToValueAtTime(200, now + t + 0.08);
          g.gain.setValueAtTime(this.volume * 0.4, now + t);
          g.gain.exponentialRampToValueAtTime(0.01, now + t + 0.1);
          o.type = 'triangle';
          o.start(now + t);
          o.stop(now + t + 0.1);
        });
        break;

      case 'menuOpen':
        // Menu/UI panel opening - soft whoosh up
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.12);
        gain.gain.setValueAtTime(this.volume * 0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.15);
        break;

      case 'menuClose':
        // Menu/UI panel closing - soft whoosh down
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        gain.gain.setValueAtTime(this.volume * 0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.12);
        break;

      case 'coinDrop':
        // Gold/coin pickup - bright metallic ding
        osc.frequency.setValueAtTime(1800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.type = 'sine';
        osc.start(now);
        osc.stop(now + 0.15);
        // Add harmonic
        const coinHarm = this.ctx.createOscillator();
        const coinGain = this.ctx.createGain();
        coinHarm.connect(coinGain);
        coinGain.connect(this.ctx.destination);
        coinHarm.frequency.setValueAtTime(2400, now);
        coinHarm.frequency.exponentialRampToValueAtTime(1600, now + 0.06);
        coinGain.gain.setValueAtTime(this.volume * 0.25, now);
        coinGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        coinHarm.type = 'sine';
        coinHarm.start(now);
        coinHarm.stop(now + 0.1);
        break;

      case 'floorEnter':
        // Entering new floor - dramatic swoosh
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.2);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.4);
        gain.gain.setValueAtTime(this.volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(this.volume * 0.3, now + 0.2);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        osc.type = 'triangle';
        osc.start(now);
        osc.stop(now + 0.45);
        break;

      case 'enemySpawn':
        // Enemy appearing - ominous rising tone
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
        gain.gain.setValueAtTime(this.volume * 0.4, now);
        gain.gain.exponentialRampToValueAtTime(this.volume * 0.6, now + 0.2);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        osc.type = 'sawtooth';
        osc.start(now);
        osc.stop(now + 0.35);
        break;

      case 'powerUp':
        // Power up acquired - ascending sparkle
        [400, 600, 800, 1000, 1200].forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.connect(g);
          g.connect(this.ctx.destination);
          o.frequency.setValueAtTime(freq, now + i * 0.05);
          g.gain.setValueAtTime(this.volume * 0.4, now + i * 0.05);
          g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.1);
          o.type = 'sine';
          o.start(now + i * 0.05);
          o.stop(now + i * 0.05 + 0.1);
        });
        break;
    }
  }
};

// Initialize sound on first user interaction
document.addEventListener('click', () => SoundFX.init(), { once: true });
document.addEventListener('touchstart', () => SoundFX.init(), { once: true });

// ===== PROCEDURAL MUSIC SYSTEM =====
const ProceduralMusic = {
  ctx: null,
  enabled: true,
  volume: 0.15,
  currentMode: null,
  oscillators: [],
  gainNodes: [],
  intervalIds: [],

  init() {
    if (!SoundFX.ctx) SoundFX.init();
    this.ctx = SoundFX.ctx;
  },

  stopAll() {
    // Stop all oscillators
    this.oscillators.forEach(osc => {
      try { osc.stop(); } catch(e) {}
    });
    this.oscillators = [];

    // Disconnect gain nodes
    this.gainNodes.forEach(g => {
      try { g.disconnect(); } catch(e) {}
    });
    this.gainNodes = [];

    // Clear intervals
    this.intervalIds.forEach(id => clearInterval(id));
    this.intervalIds = [];

    this.currentMode = null;
  },

  // Ambient swamp drone - mysterious, atmospheric
  startAmbient() {
    if (!this.enabled || this.currentMode === 'ambient') return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    this.currentMode = 'ambient';
    const now = this.ctx.currentTime;

    // Create master gain for ambient
    const masterGain = this.ctx.createGain();
    masterGain.gain.setValueAtTime(0, now);
    masterGain.gain.linearRampToValueAtTime(this.volume, now + 2); // Fade in
    masterGain.connect(this.ctx.destination);
    this.gainNodes.push(masterGain);

    // Deep drone - fundamental (D2, ~73Hz)
    const drone1 = this.ctx.createOscillator();
    const drone1Gain = this.ctx.createGain();
    drone1.frequency.setValueAtTime(73, now);
    drone1.type = 'sine';
    drone1Gain.gain.setValueAtTime(0.4, now);
    drone1.connect(drone1Gain);
    drone1Gain.connect(masterGain);
    drone1.start(now);
    this.oscillators.push(drone1);
    this.gainNodes.push(drone1Gain);

    // Fifth harmonic (A2, ~110Hz) - adds richness
    const drone2 = this.ctx.createOscillator();
    const drone2Gain = this.ctx.createGain();
    drone2.frequency.setValueAtTime(110, now);
    drone2.type = 'sine';
    drone2Gain.gain.setValueAtTime(0.2, now);
    drone2.connect(drone2Gain);
    drone2Gain.connect(masterGain);
    drone2.start(now);
    this.oscillators.push(drone2);
    this.gainNodes.push(drone2Gain);

    // Subtle LFO modulation for "breathing" effect on volume
    const breatheInterval = setInterval(() => {
      if (this.currentMode !== 'ambient' || !this.ctx) return;
      const t = this.ctx.currentTime;
      // Slow breathing (8 second cycle)
      const breath = 0.7 + 0.3 * Math.sin(t * 0.4);
      drone1Gain.gain.setTargetAtTime(0.4 * breath, t, 0.5);
      drone2Gain.gain.setTargetAtTime(0.2 * breath, t, 0.5);
    }, 500);
    this.intervalIds.push(breatheInterval);

    // Occasional water drip sounds
    const dripInterval = setInterval(() => {
      if (this.currentMode !== 'ambient' || !this.ctx) return;
      if (Math.random() < 0.3) { // 30% chance every 2 seconds
        SoundFX.play('waterDrip');
      }
    }, 2000);
    this.intervalIds.push(dripInterval);

    // Occasional cricket chirps (less frequent)
    const cricketInterval = setInterval(() => {
      if (this.currentMode !== 'ambient' || !this.ctx) return;
      if (Math.random() < 0.15) {
        SoundFX.play('crickets');
      }
    }, 4000);
    this.intervalIds.push(cricketInterval);
  },

  // Combat beat - percussive, drum-focused
  startCombat() {
    if (!this.enabled || this.currentMode === 'combat') return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    this.currentMode = 'combat';
    const now = this.ctx.currentTime;
    const bpm = 100;
    const beatDuration = 60 / bpm;

    // Create master gain for combat
    const masterGain = this.ctx.createGain();
    masterGain.gain.setValueAtTime(0, now);
    masterGain.gain.linearRampToValueAtTime(this.volume * 1.2, now + 0.5);
    masterGain.connect(this.ctx.destination);
    this.gainNodes.push(masterGain);

    // Helper: create noise buffer for percussive sounds
    const createNoise = (duration) => {
      const bufferSize = this.ctx.sampleRate * duration;
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      return buffer;
    };

    // Kick pattern: 1-0-0-1-0-1-0-0 (8 steps) - punchy drum hits
    const kickPattern = [1, 0, 0, 1, 0, 1, 0, 0];
    // Snare on beats 3 and 7 (backbeat)
    const snarePattern = [0, 0, 1, 0, 0, 0, 1, 0];
    // Hi-hat on every step for steady pulse
    const hatPattern = [1, 1, 1, 1, 1, 1, 1, 1];
    let step = 0;

    const beatInterval = setInterval(() => {
      if (this.currentMode !== 'combat' || !this.ctx) return;

      const t = this.ctx.currentTime;

      // Kick drum - low thump with noise click
      if (kickPattern[step]) {
        // Low frequency body
        const kickOsc = this.ctx.createOscillator();
        const kickGain = this.ctx.createGain();
        kickOsc.connect(kickGain);
        kickGain.connect(masterGain);
        kickOsc.frequency.setValueAtTime(150, t);
        kickOsc.frequency.exponentialRampToValueAtTime(40, t + 0.08);
        kickGain.gain.setValueAtTime(0.7, t);
        kickGain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);
        kickOsc.type = 'sine';
        kickOsc.start(t);
        kickOsc.stop(t + 0.12);

        // Noise click for attack
        const kickNoise = this.ctx.createBufferSource();
        kickNoise.buffer = createNoise(0.03);
        const kickNoiseGain = this.ctx.createGain();
        const kickNoiseFilter = this.ctx.createBiquadFilter();
        kickNoiseFilter.type = 'lowpass';
        kickNoiseFilter.frequency.value = 200;
        kickNoise.connect(kickNoiseFilter);
        kickNoiseFilter.connect(kickNoiseGain);
        kickNoiseGain.connect(masterGain);
        kickNoiseGain.gain.setValueAtTime(0.3, t);
        kickNoiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.03);
        kickNoise.start(t);
      }

      // Snare drum - mid punch with noise burst
      if (snarePattern[step]) {
        // Body tone
        const snareOsc = this.ctx.createOscillator();
        const snareGain = this.ctx.createGain();
        snareOsc.connect(snareGain);
        snareGain.connect(masterGain);
        snareOsc.frequency.setValueAtTime(180, t);
        snareOsc.frequency.exponentialRampToValueAtTime(120, t + 0.05);
        snareGain.gain.setValueAtTime(0.35, t);
        snareGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        snareOsc.type = 'triangle';
        snareOsc.start(t);
        snareOsc.stop(t + 0.1);

        // Noise rattle
        const snareNoise = this.ctx.createBufferSource();
        snareNoise.buffer = createNoise(0.15);
        const snareNoiseGain = this.ctx.createGain();
        const snareNoiseFilter = this.ctx.createBiquadFilter();
        snareNoiseFilter.type = 'highpass';
        snareNoiseFilter.frequency.value = 2000;
        snareNoise.connect(snareNoiseFilter);
        snareNoiseFilter.connect(snareNoiseGain);
        snareNoiseGain.connect(masterGain);
        snareNoiseGain.gain.setValueAtTime(0.25, t);
        snareNoiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);
        snareNoise.start(t);
      }

      // Hi-hat - quiet tick for steady metronome pulse
      if (hatPattern[step]) {
        const hatNoise = this.ctx.createBufferSource();
        hatNoise.buffer = createNoise(0.04);
        const hatGain = this.ctx.createGain();
        const hatFilter = this.ctx.createBiquadFilter();
        hatFilter.type = 'highpass';
        hatFilter.frequency.value = 7000;
        hatNoise.connect(hatFilter);
        hatFilter.connect(hatGain);
        hatGain.connect(masterGain);
        // Accent on downbeats
        const accent = (step === 0 || step === 4) ? 0.12 : 0.06;
        hatGain.gain.setValueAtTime(accent, t);
        hatGain.gain.exponentialRampToValueAtTime(0.01, t + 0.03);
        hatNoise.start(t);
      }

      step = (step + 1) % 8;
    }, beatDuration * 1000);
    this.intervalIds.push(beatInterval);
  },

  // Victory fanfare - celebratory, ascending
  playVictory() {
    if (!this.enabled) return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    const now = this.ctx.currentTime;

    // Triumphant chord progression: C -> G -> Am -> F -> C (simplified fanfare)
    const fanfare = [
      { notes: [262, 330, 392], time: 0, duration: 0.3 },      // C major
      { notes: [294, 370, 440], time: 0.35, duration: 0.3 },   // D major
      { notes: [330, 415, 494], time: 0.7, duration: 0.3 },    // E major
      { notes: [392, 494, 587], time: 1.05, duration: 0.5 },   // G major (resolve)
      { notes: [523, 659, 784], time: 1.6, duration: 0.8 },    // C major (octave up, finale)
    ];

    fanfare.forEach(chord => {
      chord.notes.forEach((freq, i) => {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.frequency.setValueAtTime(freq, now + chord.time);
        gain.gain.setValueAtTime(this.volume * 0.6, now + chord.time);
        gain.gain.exponentialRampToValueAtTime(0.01, now + chord.time + chord.duration);
        osc.type = i === 0 ? 'sine' : 'triangle'; // Root is fuller
        osc.start(now + chord.time);
        osc.stop(now + chord.time + chord.duration + 0.1);
      });
    });

    // Add a final sparkle
    setTimeout(() => SoundFX.play('frogChorus'), 1800);
  },

  // Death/defeat sound - somber, descending
  playDefeat() {
    if (!this.enabled) return;
    this.stopAll();
    if (!this.ctx) this.init();
    if (!this.ctx) return;

    const now = this.ctx.currentTime;

    // Descending minor progression
    const lament = [
      { freq: 220, time: 0 },
      { freq: 196, time: 0.4 },
      { freq: 175, time: 0.8 },
      { freq: 147, time: 1.2 },
    ];

    lament.forEach(note => {
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      osc.frequency.setValueAtTime(note.freq, now + note.time);
      gain.gain.setValueAtTime(this.volume * 0.5, now + note.time);
      gain.gain.exponentialRampToValueAtTime(0.01, now + note.time + 0.5);
      osc.type = 'sawtooth';
      osc.start(now + note.time);
      osc.stop(now + note.time + 0.6);
    });
  },

  setVolume(vol) {
    this.volume = Math.max(0, Math.min(1, vol));
  }
};


// ===== GAME STATE =====
let S = {
// ===== HERO STATE =====
heroes: [],
sig: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
tempSigUpgrades: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},
sigUpgradeCounts: {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0},

// ===== GAME PROGRESSION =====
floor: 1,
gameMode: 'Standard', // 'Standard' or 'fu'
runNumber: 1,
currentSlot: null,
gold: 0,
xp: 0,
levelUpCount: 0,
goingRate: 1,
runsAttempted: 0,
startingXP: 0,

// ===== COMBAT STATE (resets each combat) =====
activeIdx: -1,      // Currently acting hero index (-1 = none)
acted: [],          // Array of hero indices that have acted this turn
locked: false,      // UI locked during enemy turn
pending: null,      // Currently selected action (e.g., 'Attack', 'Shield')
targets: [],        // Selected target IDs for action
currentInstanceTargets: [], // Targets for current multi-instance iteration
instancesRemaining: 0,      // How many instances left to target
totalInstances: 0,          // Total instances for this action
lastActions: {},            // Last action taken by each hero (for Asterisk)
enemies: [],        // Current enemy array
recruits: [],       // Recruited enemies (fight for player)
round: 1,           // Current combat round
turn: 'player',     // 'player' or 'enemy'
combatXP: 0,        // XP earned this combat
combatGold: 0,      // Gold earned this combat
selectingEncampmentTargets: false, // Special state for Encampment encounter
encampmentEarlyKills: 0,           // Number of enemies to kill early
d20HeroIdx: -1,     // Hero index for D20 action targeting
grappleRepeats: 0,  // Number of grapple repeats for recoil calculation
grappleLevel: 0,    // Grapple level for recoil calculation
turnDamage: 0,      // Damage dealt during current hero's turn (for damage counter)

// ===== NEUTRAL ENCOUNTER STATE (resets each encounter) =====
neutralDeck: [],    // Deck of neutral encounter IDs
lastNeutral: null,  // Last neutral encountered (for non-repeat)
ambushed: false,    // Whether current combat is an ambush

// ===== TEMPORARY NEUTRAL STATE (resets on death) =====
silverKeyHeld: false,     // Silver key from Ghost Boys
oracleHero: null,         // Hero chosen at Oracle
oracleRoll: null,         // Roll result at Oracle
oracleStat: null,         // Stat chosen at Oracle
wizardSigil: null,        // Sigil being tested at Wizard

// ===== PERSISTENT STATE (survives death, saved in permanent storage) =====
ancientStatueDeactivated: false, // Ancient Statue one-time choice made
ghostBoysConverted: false,       // Ghost Boys converted (no longer hostile)
pedestal: [],                    // Champion hero figurines [{hero, mode, stats}]
hasAncientStatuette: false,
hasReachedFloor20: false,        // Unlocks blue portal in Ribbleton
fuUnlocked: false,
tapoUnlocked: false,             // Unlocked after first FU victory
pondHistory: [],                 // Run history for "The Pond" - [{runNumber, heroes, floorReached, gameMode, outcome, killedBy, timestamp}]

// ===== UI STATE =====
toastHistory: [],               // Array of recent toast messages
toastLogLocked: false,          // Whether toast log is locked open (persistent)
toastLogVisible: true,          // Whether toast log button is shown in header
tooltipsDisabled: false,        // Whether sigil tooltips are disabled
helpTipsDisabled: false,        // Whether tutorial help tips are disabled
animationSpeed: 1,              // Animation speed: 1 (normal), 2 (fast), 4 (faster), 0 (instant)
controllerDisabled: false,      // Whether gamepad/controller support is disabled
inRibbleton: false,             // Whether player is in Ribbleton hub

// ===== DEBUG STATE =====
debugMode: false,       // Debug mode toggle
oopsAll20s: false,      // Debug cheat: all d20 rolls = 20

// ===== TUTORIAL STATE (permanent flags) =====
tutorialFlags: {
ribbleton_intro: false,
ribbleton_warrior_attack: false,
ribbleton_targeting: false,
ribbleton_healer_d20: false,
ribbleton_d20_menu: false,
healer_expand_explain: false,
ribbleton_enemy_turn: false,
ribbleton_healer_heal: false,
ribbleton_expand: false,
ribbleton_finish_wolf: false,
enemies_get_sigils: false,
ribbleton_shield_sigil: false,
ribbleton_handoff: false,
ribbleton_tooltip_intro: false,
ribbleton_hub_intro: false,
levelup_intro: false,
levelup_stat_upgrade: false,
levelup_add_active: false,
levelup_upgrade_active: false,
levelup_upgrade_passive: false,
death_intro: false,
death_exit_warning: false,
neutral_intro: false,
neutral_d20_level: false,
faq_intro: false,
last_stand_intro: false,
last_stand_warning: false,
shield_persistence: false,
ghost_intro: false,
grapple_intro: false,
alpha_intro: false,
recruit_intro: false,
run2_hero_lock: false,
first_victory_sequence: false,
first_fu_victory: false,
pedestal_first_placement: false,
tapo_victory_message: false,
tapo_first_attack: false,
auto_target_intro: false,
steam_controller_setup: false
},
usedDeathQuotes: [], // Track which death quotes have been shown

// ===== SUSPEND/AUTOSAVE STATE =====
suspended: false,         // Whether game is currently suspended
lastAutosave: 0,          // Timestamp of last autosave
inCombat: false,          // Whether player is in active combat (for autosave)
combatEnding: false       // Guard flag to prevent multiple checkCombatEnd calls
};

let sel = [];

// ===== RIBBLETON TUTORIAL STATE =====
let tutorialState = null;
// Tutorial state tracks scripted Ribbleton tutorial progress
// {
//   stage: 'warrior_attack' | 'targeting_wolf' | 'healer_d20' | 'd20_menu' | 'enemy_turn_explained' |
//          'healer_heal' | 'expand_targets' | 'finish_wolf' | 'shield_sigil' | 'handoff' | 'free',
//   wolfDamaged: boolean,
//   wolfKilled: boolean,
//   goblinKilled: boolean,
//   round: number
// }

// ===== HELPERS =====
function getFloorBackground(floor) {
// Progressive darkening from floor 1 (light brown) to floor 19 (black)
const colors = [
'#d9cab1', // Floor 1 - light brown (default)
'#cfc0a9', '#c5b6a1', '#bbac99', '#b1a291', '#a79889', // Floors 2-6
'#9d8e81', '#938479', '#897a71', '#7f7069', '#756661', // Floors 7-11
'#6b5c59', '#615251', '#574849', '#4d3e41', '#433439', // Floors 12-16
'#392a31', '#2f2029', '#251621', '#1b0c19' // Floors 17-20
];
return colors[Math.min(floor - 1, colors.length - 1)] || colors[0];
}

function renderHeroCard(hero, idx, onclickHandler, extraInfo = '') {
const hp = hero.ls ? `Last Stand (T${hero.lst+1})` : `${hero.h}/${hero.m}‚ù§`;
const extra = [];
if(hero.sh > 0) extra.push(`${hero.sh}üõ°`);
if(hero.g > 0) extra.push(`${hero.g}${sigilIconOnly('Ghost')}`);
return `<div class="card hero hero-selectable" onclick="${onclickHandler}" style="cursor:pointer;margin-bottom:0.75rem">
<div style="font-weight:bold;text-align:center;margin-bottom:0.25rem">${hero.n}</div>
<div class="card-stats">${hero.p}‚ö° | ${hp}${extra.length>0?' | '+extra.join(' '):''}${extraInfo}</div>
</div>`;
}

function upd() {
const floorEl = document.getElementById('floor');
const roundEl = document.getElementById('round');
const roundInfoEl = document.getElementById('roundInfo');
const locationLabelEl = document.getElementById('locationLabel');

// Ensure floor is a valid number (fix for "Session 0 undefined floor" bug)
if(S.floor === undefined || S.floor === null) {
S.floor = 1;
}

// Update location display based on game state
if(S.floor === 0 && tutorialState) {
// Tutorial mode
floorEl.textContent = '';
locationLabelEl.textContent = 'Tutorial';
roundInfoEl.style.display = S.round > 0 ? '' : 'none';
roundEl.textContent = S.round || '';
} else if(S.floor === 0) {
// Floor 0 without tutorial - show as Ribbleton (pre-game state)
floorEl.textContent = '';
locationLabelEl.textContent = 'Ribbleton';
roundInfoEl.style.display = 'none';
} else if(S.inRibbleton) {
// In Ribbleton hub (before entering dungeon)
floorEl.textContent = '';
locationLabelEl.textContent = 'Ribbleton';
roundInfoEl.style.display = 'none';
} else if(!S.heroes || S.heroes.length === 0) {
// Hero selection screen (no heroes chosen yet)
floorEl.textContent = '';
locationLabelEl.textContent = 'Hero Select';
roundInfoEl.style.display = 'none';
} else if(S.enemies && S.enemies.length > 0) {
// In combat
floorEl.textContent = S.floor || 1;
locationLabelEl.textContent = 'Floor';
roundInfoEl.style.display = '';
roundEl.textContent = S.round || 1;
} else {
// Between combats (neutral floors, level up, etc.)
floorEl.textContent = S.floor || 1;
locationLabelEl.textContent = 'Floor';
roundInfoEl.style.display = 'none';
}

document.getElementById('gold').textContent = S.gold;
// Show combat XP during combat, cumulative XP otherwise
if(S.combatXP !== undefined && S.combatXP > 0) {
document.getElementById('xp').textContent = `${S.xp} (+${S.combatXP})`;
} else {
document.getElementById('xp').textContent = S.xp;
}
// Show/hide debug button
const debugBtn = document.getElementById('debugBtn');
if(debugBtn) debugBtn.style.display = S.debugMode ? 'block' : 'none';
// Update background color based on floor
const gameArea = document.getElementById('gameView');
if(gameArea) gameArea.style.background = getFloorBackground(S.floor);
}

function triggerHitAnimation(targetId) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('hit-flash');
setTimeout(() => {
const el = document.getElementById(targetId);
if(el) el.classList.remove('hit-flash');
}, ANIMATION_TIMINGS.DAMAGE_FLASH);
}
}

function triggerAttackAnimation(attackerId) {
const card = document.getElementById(attackerId);
if(card) {
card.classList.add('attack-slide');
setTimeout(() => {
const el = document.getElementById(attackerId);
if(el) el.classList.remove('attack-slide');
}, ANIMATION_TIMINGS.ATTACK_SLIDE);
}
}

function triggerEnemyAttackAnimation(attackerId) {
const card = document.getElementById(attackerId);
if(card) {
card.classList.add('enemy-attack-slide');
setTimeout(() => {
const el = document.getElementById(attackerId);
if(el) el.classList.remove('enemy-attack-slide');
}, ANIMATION_TIMINGS.ATTACK_SLIDE);
}
}

function triggerHealAnimation(targetId, healAmount = 0) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('heal-flash');
// JUICE: Sound effects - froggy gulp + heal chime
SoundFX.play('gulp');
setTimeout(() => SoundFX.play('heal'), 100);
// JUICE: Floating heal number
if (healAmount > 0) {
  showFloatingNumber(targetId, `+${healAmount}`, 'heal');
}
// Add healing cross overlay
const cross = document.createElement('div');
cross.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:3rem;color:#22c55e;text-shadow:0 0 10px #22c55e;pointer-events:none;z-index:1000;animation:heal-cross-fade 0.48s ease';
cross.textContent = '‚úö';
card.appendChild(cross);
setTimeout(() => {
const el = document.getElementById(targetId);
if(el) el.classList.remove('heal-flash');
if(cross.parentNode) cross.remove();
}, ANIMATION_TIMINGS.HEAL_FLASH);
}
}

function triggerShieldAnimation(targetId, shieldAmount = 0) {
const card = document.getElementById(targetId);
if(card) {
card.classList.add('shield-flash');
// JUICE: Sound effects - froggy bubble + shield chime
SoundFX.play('bubble');
setTimeout(() => SoundFX.play('shield'), 80);
// JUICE: Floating shield number
if (shieldAmount > 0) {
  showFloatingNumber(targetId, `+${shieldAmount}üõ°`, 'shield');
}
setTimeout(() => {
const el = document.getElementById(targetId);
if(el) el.classList.remove('shield-flash');
}, ANIMATION_TIMINGS.SHIELD_FLASH);
}
}

function addBonusTurnStack(cardId, count) {
const card = document.getElementById(cardId);
if(!card || count <= 0) return;
// Remove existing stack if any
removeBonusTurnStack(cardId);
// Create stack container
const stackContainer = document.createElement('div');
stackContainer.className = 'bonus-turn-stack';
stackContainer.id = `stack-${cardId}`;
// Add stacked cards (show just the corners)
for(let i = 0; i < Math.min(count, 5); i++) {
const stackCard = document.createElement('div');
stackCard.className = 'bonus-turn-card';
stackCard.style.transform = `translate(${-3 - i*3}px, ${-3 - i*3}px)`;
stackCard.style.zIndex = -1 - i;
stackContainer.appendChild(stackCard);
}
card.appendChild(stackContainer);
}

function removeBonusTurnStack(cardId, animated = false) {
const stack = document.getElementById(`stack-${cardId}`);
if(!stack) return;
if(animated && stack.children.length > 0) {
// Animate the top card sliding out
const topCard = stack.children[0];
topCard.classList.add('sliding-out');
setTimeout(() => {
topCard.remove();
// If no more cards, remove the whole stack
if(stack.children.length === 0) {
stack.remove();
}
}, 300);
} else {
stack.remove();
}
}

function updateBonusTurnStack(cardId, count) {
if(count <= 0) {
removeBonusTurnStack(cardId, true);
} else {
const stack = document.getElementById(`stack-${cardId}`);
if(!stack) {
addBonusTurnStack(cardId, count);
} else {
// Adjust stack size
const currentCount = stack.children.length;
if(currentCount > count) {
// Remove excess cards with animation
removeBonusTurnStack(cardId, true);
setTimeout(() => addBonusTurnStack(cardId, count), ANIMATION_TIMINGS.BONUS_TURN_STACK);
} else if(currentCount < count) {
// Add more cards
addBonusTurnStack(cardId, count);
}
}
}
}

// Track active toasts for stacking
let activeToasts = [];

function toast(msg, dur=1800) {
// Add to history (strip HTML for text log)
const textMsg = msg.replace(/<[^>]*>/g, '');
S.toastHistory.unshift(textMsg);
if(S.toastHistory.length > 20) S.toastHistory = S.toastHistory.slice(0, 20); // Keep last 20
updateToastLog();
// Show toast popup (supports HTML)
const t = document.createElement('div');
t.className = 'toast';
t.innerHTML = msg;
// Calculate offset based on existing toasts
const toastHeight = 50; // Approximate height + gap
const offset = activeToasts.length * toastHeight;
t.style.bottom = `${20 + offset}px`;
document.body.appendChild(t);
activeToasts.push(t);
setTimeout(() => t.classList.add('show'), 10);
setTimeout(() => {
t.classList.remove('show');
setTimeout(() => {
t.remove();
activeToasts = activeToasts.filter(toast => toast !== t);
// Reposition remaining toasts
activeToasts.forEach((toast, idx) => {
toast.style.bottom = `${20 + idx * toastHeight}px`;
});
}, ANIMATION_TIMINGS.TOAST_FADE);
}, dur);
}

// Controller-friendly confirm modal to replace browser confirm()
let confirmModalCallback = null;
function showConfirmModal(message, onConfirm, onCancel) {
  // Remove existing modal if any
  const existingOverlay = document.querySelector('.confirm-modal-overlay');
  const existingModal = document.querySelector('.confirm-modal');
  if (existingOverlay) existingOverlay.remove();
  if (existingModal) existingModal.remove();

  // Create overlay
  const overlay = document.createElement('div');
  overlay.className = 'confirm-modal-overlay';

  // Create modal
  const modal = document.createElement('div');
  modal.className = 'confirm-modal';
  modal.innerHTML = `
    <h3>Confirm</h3>
    <p>${message}</p>
    <div class="confirm-modal-buttons">
      <button class="btn confirm-btn-yes" style="background:linear-gradient(135deg,#22c55e,#16a34a);min-width:100px">Yes</button>
      <button class="btn confirm-btn-no" style="background:linear-gradient(135deg,#ef4444,#dc2626);min-width:100px">No</button>
    </div>
  `;

  document.body.appendChild(overlay);
  document.body.appendChild(modal);

  const yesBtn = modal.querySelector('.confirm-btn-yes');
  const noBtn = modal.querySelector('.confirm-btn-no');

  function cleanup() {
    overlay.remove();
    modal.remove();
    confirmModalCallback = null;
    // Restore controller focus
    if (typeof GamepadController !== 'undefined' && GamepadController.active) {
      GamepadController.updateFocusableElements();
    }
  }

  yesBtn.onclick = () => {
    cleanup();
    if (onConfirm) onConfirm();
  };

  noBtn.onclick = () => {
    cleanup();
    if (onCancel) onCancel();
  };

  // Store callback for controller B button to cancel
  confirmModalCallback = () => {
    cleanup();
    if (onCancel) onCancel();
  };

  // Keyboard support for desktop users
  function handleKeydown(e) {
    if (e.key === 'Escape') {
      e.preventDefault();
      cleanup();
      document.removeEventListener('keydown', handleKeydown);
      if (onCancel) onCancel();
    }
    // Trap focus within modal (Tab cycles between Yes and No)
    if (e.key === 'Tab') {
      const focusedEl = document.activeElement;
      if (e.shiftKey && focusedEl === yesBtn) {
        e.preventDefault();
        noBtn.focus();
      } else if (!e.shiftKey && focusedEl === noBtn) {
        e.preventDefault();
        yesBtn.focus();
      }
    }
  }
  document.addEventListener('keydown', handleKeydown);

  // Update cleanup to remove keyboard listener
  const originalCleanup = cleanup;
  cleanup = function() {
    document.removeEventListener('keydown', handleKeydown);
    originalCleanup();
  };

  // Focus the Yes button for controller navigation
  if (typeof GamepadController !== 'undefined' && GamepadController.active) {
    GamepadController.updateFocusableElements();
    GamepadController.setFocus(yesBtn);
  } else {
    yesBtn.focus();
  }
}

function initToastLog() {
const existing = document.getElementById('toastLog');
if(existing) return;
const log = document.createElement('div');
log.id = 'toastLog';
log.className = 'toast-log';
document.body.appendChild(log);
updateToastLog();
}

function toggleToastLog() {
// Toggle the locked state
S.toastLogLocked = !S.toastLogLocked;
const log = document.getElementById('toastLog');
if(!log) return;
if(S.toastLogLocked) {
log.classList.add('show', 'locked');
} else {
log.classList.remove('show', 'locked');
}
updateToastLog();
}

function minimizeToastLog() {
// Minimize without changing locked state preference
S.toastLogLocked = false;
const log = document.getElementById('toastLog');
if(log) {
log.classList.remove('show', 'locked');
}
}

function updateToastLog() {
const log = document.getElementById('toastLog');
if(!log) return;
let html = `<div class="toast-log-header">
<span style="font-size:1rem">ü™µ Combat Log</span>
<button onclick="minimizeToastLog()" style="background:#ef4444;border:2px solid #000;border-radius:4px;padding:0.25rem 0.5rem;font-weight:bold;cursor:pointer;font-size:0.8rem">‚úï</button>
</div>`;
html += '<div class="toast-log-entries">';
S.toastHistory.forEach((msg, idx) => {
html += `<div class="toast-log-entry ${idx === 0 ? 'recent' : ''}">${msg}</div>`;
});
if(S.toastHistory.length === 0) {
html += '<div class="toast-log-entry">No messages yet</div>';
}
html += '</div>';
log.innerHTML = html;
}

function showTutorialPop(flagName, message, onDismiss) {
debugLog('[TUTORIAL] showTutorialPop called:', flagName, 'Already shown:', S.tutorialFlags[flagName]);
if(S.helpTipsDisabled || S.tutorialFlags[flagName]) {
debugLog('[TUTORIAL] Skipping pop (disabled or already shown), calling callback directly');
if(onDismiss) onDismiss();
return;
}
// Prevent creating new backdrop while one exists (avoid stacking)
const existingBackdrop = document.querySelector('.tutorial-modal-backdrop');
if(existingBackdrop) {
debugLog('[TUTORIAL] Backdrop already exists, queuing callback');
// Queue this popup for after current one is dismissed
const existingCallback = window.tutorialCallback;
window.tutorialCallback = () => {
if(existingCallback) existingCallback();
// Delay slightly to prevent rapid-fire popups
setTimeout(() => showTutorialPop(flagName, message, onDismiss), 100);
};
return;
}
// Add tutorial message to toast log for reference
S.toastHistory.unshift(`üìñ ${message}`);
if(S.toastHistory.length > 20) S.toastHistory = S.toastHistory.slice(0, 20);
updateToastLog();
// Create blocking modal
const backdrop = document.createElement('div');
backdrop.className = 'tutorial-modal-backdrop';
backdrop.innerHTML = `
<div class="tutorial-modal">
<h2>Tip!</h2>
<p>${message}</p>
<button onclick="dismissTutorialPop('${flagName}')">Got it!</button>
<div class="controller-hint" style="margin-top:0.5rem;font-size:0.8rem;opacity:0.7">‚í∂ to continue</div>
</div>`;
document.body.appendChild(backdrop);
debugLog('[TUTORIAL] Backdrop created and appended');
// Store callback for later
window.tutorialCallback = onDismiss;
}

function dismissTutorialPop(flagName) {
debugLog('[TUTORIAL] dismissTutorialPop called:', flagName);
S.tutorialFlags[flagName] = true;
savePermanent();

// Set cooldown to prevent click-through to game elements behind popup
// This prevents controller A button from selecting sigils after dismissing popup
window.tutorialDismissTime = Date.now();

// Capture callback before removal (prevent race conditions)
const callback = window.tutorialCallback;
window.tutorialCallback = null;

// Remove ALL backdrops synchronously and aggressively
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
allBackdrops.forEach(b => b.remove());

// Use requestAnimationFrame to ensure DOM is updated before callback
requestAnimationFrame(() => {
// Double-check for any zombie backdrops
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
remaining.forEach(r => r.remove());

// Execute callback if exists
if(callback) {
try {
callback();
} catch (error) {
console.error('[TUTORIAL] Callback error:', error);
}
}
});
}

function showRecruitReplaceConfirm(oldName, newName, onKeep, onReplace) {
const backdrop = document.createElement('div');
backdrop.className = 'tutorial-modal-backdrop';
backdrop.innerHTML = `
<div class="tutorial-modal">
<h2>Replace Recruit?</h2>
<p>You already have <strong>${oldName}</strong>. Replace with <strong>${newName}</strong>?</p>
<div style="display:flex;gap:0.5rem;justify-content:center;margin-top:1rem">
<button onclick="confirmRecruitReplace(false)" style="background:#666;padding:0.5rem 1rem">Keep ${oldName}</button>
<button onclick="confirmRecruitReplace(true)" style="background:#4a4;padding:0.5rem 1rem">Replace with ${newName}</button>
</div>
</div>`;
document.body.appendChild(backdrop);
window.recruitReplaceCallback = { onKeep, onReplace };
}

function confirmRecruitReplace(replace) {
const callbacks = window.recruitReplaceCallback;
document.querySelectorAll('.tutorial-modal-backdrop').forEach(b => b.remove());
window.recruitReplaceCallback = null;
if(replace && callbacks && callbacks.onReplace) callbacks.onReplace();
else if(!replace && callbacks && callbacks.onKeep) callbacks.onKeep();
}

function savePermanent() {
try {
localStorage.setItem('froggle8_permanent', JSON.stringify({
gold: S.gold,
goingRate: S.goingRate,
startingXP: S.startingXP,
sig: S.sig,
sigUpgradeCounts: S.sigUpgradeCounts,
ancientStatueDeactivated: S.ancientStatueDeactivated,
ghostBoysConverted: S.ghostBoysConverted,
pedestal: S.pedestal,
hasReachedFloor20: S.hasReachedFloor20,
fuUnlocked: S.fuUnlocked,
tapoUnlocked: S.tapoUnlocked,
runNumber: S.runNumber,
runsAttempted: S.runsAttempted,
tutorialFlags: S.tutorialFlags,
helpTipsDisabled: S.helpTipsDisabled,
tooltipsDisabled: S.tooltipsDisabled,
usedDeathQuotes: S.usedDeathQuotes,
controllerDisabled: S.controllerDisabled,
animationSpeed: S.animationSpeed,
pondHistory: S.pondHistory
}));
} catch(e) {
console.warn('[SAVE] Failed to save permanent data:', e);
if(e.name === 'QuotaExceededError' || (e.code && e.code === 22)) {
toast('Storage full! Try clearing old save slots.', 3000);
} else {
toast('Warning: Progress could not be saved', 2000);
}
}
}

function loadPermanent() {
try {
const d = localStorage.getItem('froggle8_permanent');
if(!d) return;
const j = JSON.parse(d);
S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// One-time fix: Detect and repair old saves with starter actives at L1 (should be L0)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
let needsFix = false;
starterActives.forEach(sig => {
if(S.sig[sig] === 1 && S.sigUpgradeCounts[sig] === 0) {
// Starter active at L1 with no upgrades = old save format, fix it
S.sig[sig] = 0;
needsFix = true;
}
});
if(needsFix) {
debugLog('[SAVE] Fixed old save format: starter actives L1‚ÜíL0');
savePermanent(); // Save the fix
}
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.pedestal = j.pedestal || [];
S.hasReachedFloor20 = j.hasReachedFloor20 || false;
S.fuUnlocked = j.fuUnlocked || false;
S.tapoUnlocked = j.tapoUnlocked || false;
S.runNumber = j.runNumber || 1;
S.runsAttempted = j.runsAttempted || 0;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.tooltipsDisabled = j.tooltipsDisabled || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
S.controllerDisabled = j.controllerDisabled || false;
S.animationSpeed = j.animationSpeed !== undefined ? j.animationSpeed : 1;
S.pondHistory = j.pondHistory || [];
if(j.tutorialFlags) {
Object.assign(S.tutorialFlags, j.tutorialFlags);
}
} catch(e) {
console.warn('[SAVE] Failed to load permanent data:', e);
// Continue with defaults if load fails
}
}

function saveGame() {
try {
localStorage.setItem('froggle8', JSON.stringify({
f:S.floor, x:S.xp, luc:S.levelUpCount,
h:S.heroes,
neutralDeck:S.neutralDeck, lastNeutral:S.lastNeutral,
hasAncientStatuette: S.hasAncientStatuette,
tempSigUpgrades: S.tempSigUpgrades,
gameMode: S.gameMode
}));
savePermanent();
} catch(e) {
console.warn('[SAVE] Failed to save game:', e);
if(e.name === 'QuotaExceededError' || (e.code && e.code === 22)) {
toast('Storage full! Try clearing old save slots.', 3000);
} else {
toast('Warning: Game could not be saved', 2000);
}
}
}

function loadGame() {
loadPermanent(); // Load persistent data first
try {
const d = localStorage.getItem('froggle8');
if(!d) return;
const j = JSON.parse(d);
S.floor=j.f; S.xp=j.x; S.levelUpCount=j.luc || 0;
S.heroes=j.h;
S.neutralDeck=j.neutralDeck || [];
S.lastNeutral=j.lastNeutral || null;
S.hasAncientStatuette = j.hasAncientStatuette || false;
S.tempSigUpgrades = j.tempSigUpgrades || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.gameMode = j.gameMode || 'Standard';
S.recruits = []; // Recruits don't persist across saves
S.heroes.forEach(h => {
if(!h.ts) h.ts = [];
// Migration fix: Remove Attack from Healer (was removed from starting sigils)
if(h.n === 'Healer' && h.s.includes('Attack')) {
h.s = h.s.filter(sig => sig !== 'Attack');
debugLog('[SAVE] Migrated Healer: removed Attack from saved sigils');
}
});
// CRITICAL: Check for invalid save state (all heroes in Last Stand)
// This can happen if game was closed during/after defeat before reaching death screen
const allHeroesInLastStand = S.heroes.length > 0 && S.heroes.every(h => h.ls);
if(allHeroesInLastStand) {
debugLog('[SAVE] Detected invalid save: all heroes in Last Stand, going to death screen');
// Clear the corrupted run save
localStorage.removeItem('froggle8');
// Clear temp upgrades
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
upd();
toast('Continuing from last defeat...', 1800);
setTimeout(() => transitionScreen(showDeathScreen), 500);
return;
}
upd();
startFloor(S.floor);
toast('Loaded!');
} catch(e) {
console.warn('[SAVE] Failed to load game:', e);
toast('Error loading saved game. Starting new game...', ANIMATION_TIMINGS.TOAST_LONG);
setTimeout(() => transitionScreen(title), ANIMATION_TIMINGS.TOAST_LONG);
}
}

// ===== SAVE SLOT SYSTEM =====
// Get metadata for a save slot (without loading it)
function getSlotMetadata(slot) {
try {
// Try new slot system first
let d = localStorage.getItem(`froggle8_permanent_slot${slot}`);
if(d) {
const j = JSON.parse(d);
const runData = localStorage.getItem(`froggle8_slot${slot}`);
let activeFloor = null;
if(runData) {
try {
const r = JSON.parse(runData);
activeFloor = r.f || null;
} catch(e) {}
}
return {
exists: true,
runsAttempted: j.runsAttempted || j.runNumber || 1,
goingRate: j.goingRate || 1,
hasActiveRun: !!runData,
activeFloor: activeFloor
};
}
// Check old system for migration
if(slot === 1) {
d = localStorage.getItem('froggle8_permanent');
if(d) {
const j = JSON.parse(d);
const oldRunData = localStorage.getItem('froggle8');
let activeFloor = null;
if(oldRunData) {
try {
const r = JSON.parse(oldRunData);
activeFloor = r.f || null;
} catch(e) {}
}
return {
exists: true,
runsAttempted: j.runNumber || 1,
goingRate: j.goingRate || 1,
hasActiveRun: !!oldRunData,
activeFloor: activeFloor,
needsMigration: true
};
}
}
return { exists: false };
} catch(e) {
console.warn(`[SAVE] Error reading slot ${slot}:`, e);
return { exists: false };
}
}

// Migrate old save to slot 1
function migrateOldSave() {
try {
const oldPerm = localStorage.getItem('froggle8_permanent');
const oldRun = localStorage.getItem('froggle8');
if(oldPerm) {
// Parse and fix old save data before migrating
const j = JSON.parse(oldPerm);
// Fix starter actives that were incorrectly at L1 (should be L0 for storage)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
if(j.sig) {
starterActives.forEach(sig => {
if(j.sig[sig] === 1) {
j.sig[sig] = 0;
// Also adjust sigUpgradeCounts if it exists
if(j.sigUpgradeCounts && j.sigUpgradeCounts[sig] > 0) {
j.sigUpgradeCounts[sig] = Math.max(0, j.sigUpgradeCounts[sig] - 1);
}
}
});
}
localStorage.setItem('froggle8_permanent_slot1', JSON.stringify(j));
localStorage.removeItem('froggle8_permanent');
debugLog('[SAVE] Migrated and fixed old save to slot 1');
}
if(oldRun) {
localStorage.setItem('froggle8_slot1', oldRun);
localStorage.removeItem('froggle8');
}
} catch(e) {
console.warn('[SAVE] Migration failed:', e);
}
}

// Load a specific slot
function loadSlot(slot) {
S.currentSlot = slot;
localStorage.setItem('froggle8_current_slot', slot.toString());
// Load permanent data
try {
const d = localStorage.getItem(`froggle8_permanent_slot${slot}`);
if(d) {
const j = JSON.parse(d);
S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.runsAttempted = j.runsAttempted || j.runNumber || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// One-time fix: Detect and repair old saves with starter actives at L1 (should be L0)
const starterActives = ['Attack', 'Shield', 'Heal', 'D20'];
let needsFix = false;
starterActives.forEach(sig => {
if(S.sig[sig] === 1 && S.sigUpgradeCounts[sig] === 0) {
// Starter active at L1 with no upgrades = old save format, fix it
S.sig[sig] = 0;
needsFix = true;
}
});
if(needsFix) {
debugLog('[SAVE] Fixed old save format: starter actives L1‚ÜíL0');
savePermanent(); // Save the fix
}
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.pedestal = j.pedestal || [];
S.hasReachedFloor20 = j.hasReachedFloor20 || false;
S.fuUnlocked = j.fuUnlocked || false;
S.tapoUnlocked = j.tapoUnlocked || false;
S.runNumber = j.runNumber || 1;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.tooltipsDisabled = j.tooltipsDisabled || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
if(j.tutorialFlags) Object.assign(S.tutorialFlags, j.tutorialFlags);
}
// Try to load active run
const runData = localStorage.getItem(`froggle8_slot${slot}`);
if(runData) {
const r = JSON.parse(runData);
S.floor = r.f;
S.xp = r.x;
S.levelUpCount = r.luc || 0;
S.heroes = r.h;
S.neutralDeck = r.neutralDeck || [];
S.lastNeutral = r.lastNeutral || null;
S.hasAncientStatuette = r.hasAncientStatuette || false;
S.tempSigUpgrades = r.tempSigUpgrades || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.gameMode = r.gameMode || 'Standard';
S.recruits = []; // Recruits don't persist across saves
S.heroes.forEach(h => {
if(!h.ts) h.ts = [];
// Migration fix: Remove Attack from Healer (was removed from starting sigils)
if(h.n === 'Healer' && h.s.includes('Attack')) {
h.s = h.s.filter(sig => sig !== 'Attack');
debugLog('[SAVE] Migrated Healer: removed Attack from saved sigils');
}
});
// CRITICAL: Check for invalid save state (all heroes in Last Stand)
// This can happen if game was closed during/after defeat before reaching death screen
const allHeroesInLastStand = S.heroes.length > 0 && S.heroes.every(h => h.ls);
if(allHeroesInLastStand) {
debugLog('[SAVE] Detected invalid save: all heroes in Last Stand, going to death screen');
// Clear the corrupted run save
localStorage.removeItem(`froggle8_slot${slot}`);
// Clear temp upgrades
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
upd();
toast('Continuing from last defeat...', 1800);
setTimeout(() => transitionScreen(showDeathScreen), 500);
return true;
}
// CRITICAL: Check for invalid tutorial floor save (floor 0)
// Tutorial shouldn't be saved mid-combat - advance to floor 1
if(S.floor === 0) {
debugLog('[SAVE] Detected invalid tutorial save: floor 0, advancing to floor 1');
S.floor = 1;
// Clear the corrupted save and re-save with correct floor
localStorage.removeItem(`froggle8_slot${slot}`);
}
upd();
startFloor(S.floor);
toast('Slot loaded!');
return true;
}
} catch(e) {
console.warn('[SAVE] Failed to load slot:', e);
}
return false;
}

// Update save functions to use current slot
savePermanent = function() {
if(!S.currentSlot) {
console.warn('[SAVE] No currentSlot set, defaulting to slot 1');
S.currentSlot = 1;
localStorage.setItem('froggle8_current_slot', '1');
}
try {
localStorage.setItem(`froggle8_permanent_slot${S.currentSlot}`, JSON.stringify({
gold: S.gold,
goingRate: S.goingRate,
runsAttempted: S.runsAttempted,
startingXP: S.startingXP,
sig: S.sig,
sigUpgradeCounts: S.sigUpgradeCounts,
ancientStatueDeactivated: S.ancientStatueDeactivated,
ghostBoysConverted: S.ghostBoysConverted,
pedestal: S.pedestal,
hasReachedFloor20: S.hasReachedFloor20,
fuUnlocked: S.fuUnlocked,
tapoUnlocked: S.tapoUnlocked,
runNumber: S.runNumber,
tutorialFlags: S.tutorialFlags,
helpTipsDisabled: S.helpTipsDisabled,
tooltipsDisabled: S.tooltipsDisabled,
usedDeathQuotes: S.usedDeathQuotes,
controllerDisabled: S.controllerDisabled,
animationSpeed: S.animationSpeed,
pondHistory: S.pondHistory
}));
} catch(e) {
console.warn('[SAVE] Failed to save permanent data:', e);
if(e.name === 'QuotaExceededError' || (e.code && e.code === 22)) {
toast('Storage full! Try clearing old save slots.', 3000);
} else {
toast('Warning: Progress could not be saved', 2000);
}
}
};

saveGame = function() {
if(!S.currentSlot) {
console.warn('[SAVE] No currentSlot set, defaulting to slot 1');
S.currentSlot = 1;
localStorage.setItem('froggle8_current_slot', '1');
}
try {
localStorage.setItem(`froggle8_slot${S.currentSlot}`, JSON.stringify({
f:S.floor, x:S.xp, luc:S.levelUpCount,
h:S.heroes,
neutralDeck:S.neutralDeck, lastNeutral:S.lastNeutral,
hasAncientStatuette: S.hasAncientStatuette,
tempSigUpgrades: S.tempSigUpgrades,
gameMode: S.gameMode
}));
savePermanent();
} catch(e) {
console.warn('[SAVE] Failed to save game:', e);
if(e.name === 'QuotaExceededError' || (e.code && e.code === 22)) {
toast('Storage full! Try clearing old save slots.', 3000);
} else {
toast('Warning: Game could not be saved', 2000);
}
}
};

// ===== AUTOSAVE SYSTEM =====
const AUTOSAVE_THROTTLE = 5000; // Minimum 5 seconds between autosaves

function autosave() {
// Only autosave if we have an active slot and are in combat (not during tutorial)
if(!S.currentSlot || !S.inCombat || S.floor === 0) return;

// Throttle autosaves
const now = Date.now();
if(now - S.lastAutosave < AUTOSAVE_THROTTLE) return;

S.lastAutosave = now;
saveGame();
showAutosaveIndicator();
debugLog('[AUTOSAVE] Game autosaved');
}

function showAutosaveIndicator() {
// Show a subtle "‚úì Saved" indicator in the corner
let indicator = document.getElementById('autosave-indicator');
if(!indicator) {
indicator = document.createElement('div');
indicator.id = 'autosave-indicator';
indicator.style.cssText = 'position:fixed;top:8px;right:8px;background:rgba(34,197,94,0.9);color:white;padding:4px 10px;border-radius:4px;font-size:0.75rem;font-weight:bold;opacity:0;transition:opacity 0.3s;z-index:9999;pointer-events:none';
document.body.appendChild(indicator);
}
indicator.textContent = '‚úì Saved';
indicator.style.opacity = '1';
setTimeout(() => { indicator.style.opacity = '0'; }, 1500);
}

// ===== SUSPEND/RESUME SYSTEM =====
function suspendGame() {
if(S.suspended) return;
S.suspended = true;

// Immediately save if we have an active run
if(S.currentSlot && S.heroes.length > 0) {
saveGame();
debugLog('[SUSPEND] Game saved on suspend');
}

// Show suspend overlay
showSuspendOverlay();
}

function resumeGame() {
if(!S.suspended) return;
S.suspended = false;

// Hide suspend overlay
hideSuspendOverlay();

// Resume audio context if needed
if(typeof SoundFX !== 'undefined' && SoundFX.ctx && SoundFX.ctx.state === 'suspended') {
SoundFX.ctx.resume();
}

debugLog('[RESUME] Game resumed');
}

// Global reference for suspend keyboard handler cleanup
let suspendKeyHandler = null;

function showSuspendOverlay() {
// Remove any existing overlay
hideSuspendOverlay();

const overlay = document.createElement('div');
overlay.id = 'suspend-overlay';
overlay.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.9);
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
z-index: 10000;
color: white;
font-family: inherit;
`;
overlay.innerHTML = `
<div style="text-align:center">
<div style="font-size:3rem;margin-bottom:1rem">üê∏</div>
<h2 style="font-size:1.5rem;margin:0 0 0.5rem 0;color:#22c55e">FROGGLE SUSPENDED</h2>
<p style="font-size:1rem;opacity:0.8;margin:0 0 1.5rem 0">Game saved. Tap or press any button to resume.</p>
<div style="font-size:0.9rem;opacity:0.6">Progress has been saved automatically.</div>
</div>
`;

// Resume on any interaction
overlay.addEventListener('click', resumeGame);
overlay.addEventListener('touchstart', resumeGame);

// Also handle keyboard for Steam Deck
suspendKeyHandler = (e) => {
resumeGame();
};
document.addEventListener('keydown', suspendKeyHandler);

// Store handler reference for cleanup (backup)
overlay._keyHandler = suspendKeyHandler;

document.body.appendChild(overlay);
}

function hideSuspendOverlay() {
// Clean up keyboard handler using global reference (most reliable)
if(suspendKeyHandler) {
document.removeEventListener('keydown', suspendKeyHandler);
suspendKeyHandler = null;
}
const overlay = document.getElementById('suspend-overlay');
if(overlay) {
// Backup cleanup via overlay reference
if(overlay._keyHandler) {
document.removeEventListener('keydown', overlay._keyHandler);
}
overlay.remove();
}
}

// Initialize visibility change listener
function initSuspendSystem() {
// Handle page visibility changes (tab switch, minimize, Steam Deck suspend)
document.addEventListener('visibilitychange', () => {
if(document.hidden) {
suspendGame();
} else {
resumeGame();
}
});

// Handle page unload (close tab, navigate away)
window.addEventListener('pagehide', () => {
if(S.currentSlot && S.heroes.length > 0) {
saveGame();
debugLog('[PAGEHIDE] Game saved before unload');
}
});

// Also handle beforeunload for older browsers
window.addEventListener('beforeunload', () => {
if(S.currentSlot && S.heroes.length > 0) {
saveGame();
}
});

debugLog('[SUSPEND] Suspend system initialized');
}


// ===== FLOOR MANAGEMENT =====
function getFloorName(f) {
const floorNames = {
1: 'Goblin Stragglers',
3: 'Wolf Pack',
5: 'Orc Wall',
7: 'Fe Fi Fo Fum',
9: 'Just Trolling',
11: 'Goblin Legion',
13: 'Too Many Wolves',
15: 'Territorial Dragon',
17: 'Chaos Legion',
19: 'Lair of the Flydra'
};
return floorNames[f] || null;
}

function showFloorInterstitial(f, callback) {
const floorName = getFloorName(f);
if(!floorName) {
callback();
return;
}
// JUICE: Floor enter sound
SoundFX.play('floorEnter');
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="position:fixed;top:0;left:0;width:100%;height:100vh;background:#000;display:flex;align-items:center;justify-content:center;z-index:30000">
<div style="text-align:center;color:#fff;animation:fadeIn 0.5s ease">
<div style="font-size:2.5rem;font-weight:bold;margin-bottom:1rem">Floor ${f}</div>
<div style="font-size:1.8rem;font-style:italic">${floorName}</div>
</div>
</div>
<style>
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
</style>`;
setTimeout(callback, T(ANIMATION_TIMINGS.FLOOR_INTERSTITIAL));
}

function startFloor(f) {
console.log(`[FLOOR] startFloor(${f}) called, type=${typeof f}, isOdd=${f % 2 === 1}`);
S.floor=f;
upd();
// Special: Floor 20 in Frogged Up mode shows Old Tapo encounter
if(f === 20 && S.gameMode === 'fu') {
showOldTapo();
return;
}
if(f >= 20) { win(); return; }
// Floor 11 is always ambushed (Goblin Army)
if(f === 11) {
S.ambushed = true;
}
// Show interstitial for combat floors
if(f % 2 === 1) {
console.log(`[FLOOR] Floor ${f} is odd, starting combat`);
showFloorInterstitial(f, () => combat(f));
} else {
console.log(`[FLOOR] Floor ${f} is even, starting neutral`);
neutral(f);
}
}

function getEnemyComp(f) {
const heroCount = S.heroes.length;
if(f===0) {
// Tutorial floor - check phase
if(tutorialState && tutorialState.phase === 1) {
return ['fly', 'fly', 'fly']; // Phase 1: Tapo's Birthday (3 flies)
} else {
return ['goblin', 'wolf']; // Phase 2: Portal Invasion
}
}
if(f===1) return Array(heroCount).fill('goblin');
if(f===3) return Array(heroCount).fill('wolf');
if(f===5) return Array(heroCount * 2).fill('orc');
if(f===7) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('giant', 'wolf', 'goblin');
return comp;
}
if(f===9) return Array(heroCount).fill('caveTroll');
if(f===11) return Array(heroCount * 5).fill('goblin');
if(f===13) return Array(heroCount * 5).fill('wolf');
if(f===15) return Array(heroCount).fill('dragon');
if(f===17) {
const comp = [];
for(let i = 0; i < heroCount; i++) comp.push('caveTroll', 'giant', 'orc', 'wolf', 'goblin');
return comp;
}
if(f===19) return Array(heroCount).fill('flydra'); // 1 Flydra head per hero
return ['goblin'];
}

// ===== COMBAT (v7.2 PERFECT COMBAT - UNCHANGED) =====
/**
 * Initializes combat encounter for given floor.
 *
 * Combat Initialization:
 * - Resets turn state (round=1, turn='player', no actions)
 * - Shields persist from previous combat (capped at max HP)
 * - Ghost charges persist between combats
 * - Stun counters reset to 0
 * - Creates enemies based on floor composition
 * - Handles Ribbleton tutorial special cases
 * - Applies Frogged Up mode multipliers (3x stats and rewards)
 *
 * @param {number} f - Floor number (1-19, or 0 for tutorial)
 */
function combat(f) {
console.log(`[FLOOR] combat(${f}) called, enemies will be created for floor ${f}`);
// Show header during combat
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';
S.inCombat = true; // Mark that we're in active combat for autosave
// JUICE: Start combat music
ProceduralMusic.startCombat();
S.combatEnding = false; // Reset combat ending guard flag
S.round=1; S.turn='player'; S.activeIdx=-1; S.acted=[]; S.locked=false;
S.lastActions={};
S.combatXP=0; S.combatGold=0; // Track combat rewards separately
S.pending=null; S.targets=[]; S.currentInstanceTargets=[]; S.instancesRemaining=0; S.totalInstances=0; S.turnDamage=0;
// Don't clear recruits here - they may have been added before combat (e.g., Encampment straggler)
if(!S.recruits) S.recruits = [];
S.heroes.forEach(h => {
// Shields now persist between battles, but cap at max HP
if(h.sh > h.m) h.sh = h.m;
h.st=0;
if(!h.ts) h.ts=[];
// Passive Asterisk: Reset first action flag each combat
h.firstActionUsed = false;
// If ambushed, stun all heroes turn 1
if(S.ambushed) h.st = 1;
});
let comp = getEnemyComp(f);

S.enemies = comp.map((t,i) => {
const base = E[t];
const fuMultiplier = S.gameMode === 'fu' ? 3 : 1;
const enemy = {
id:`e-${crypto.randomUUID()}`, n:base.n,
p:base.p * fuMultiplier,
h:base.h * fuMultiplier,
m:base.m * fuMultiplier,
goldDrop:(base.goldDrop || 0) * fuMultiplier, x:(base.x || 0) * fuMultiplier, s: [], pool: base.pool,
maxLevel: base.maxLevel || 1, sigilLevels: base.sigilLevels || {},
gainRate: base.gainRate || 3, turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st:0, li: i % S.heroes.length, sh:0, g:0, alphaActed: false
};
// FLYDRA: Set up state and use dynamic sigil level based on hero count
if(base.isFlydra) {
enemy.isFlydra = true;
enemy.flydraState = 'alive'; // 'alive', 'dying', 'reviving'
enemy.flydraReviveTimer = 0;
enemy.flydraLevel = S.heroes.length; // L2 normal, L3 in Frogged Up
}
// Add permanent sigils (Flydra uses hero count for level)
if(base.permSigils) {
base.permSigils.forEach(ps => {
const level = base.isFlydra ? S.heroes.length : ps.l;
enemy.s.push({sig:ps.s, level:level, perm:true});
});
}
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
// Array format: [{s:'Shield', l:1}]
base.startSigils.forEach(ss => enemy.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
// Numeric format: draw N random sigils
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(enemy, base);
}
}
}
// Handle startRandom: draw additional random L1 sigils (used by Troll)
if(base.startRandom) {
for(let j = 0; j < base.startRandom; j++) {
drawEnemyStartSigil(enemy, base, true); // true = force level 1
}
}
// ORC ALTERNATING: Start with either Attack L2 or random pool sigil
if(base.alternating && base.altSigil) {
enemy.alternating = true;
enemy.altSigil = base.altSigil;
// Randomly choose which to start with (true = altSigil/Attack, false = pool)
enemy.altState = Math.random() < 0.5;
if(enemy.altState) {
enemy.s.push({sig: base.altSigil.s, level: base.altSigil.l, perm: false});
} else {
drawEnemyStartSigil(enemy, base, false);
}
}
// CAVE TROLL RAGE: Rolling Attack L1‚ÜíL2‚ÜíL3‚ÜíL1 pattern
if(base.rage && base.ragePattern) {
enemy.rage = true;
enemy.ragePattern = base.ragePattern;
enemy.rageIndex = 0; // Start at first level (L1)
// Start with Attack at first level of pattern
enemy.s.push({sig: 'Attack', level: base.ragePattern[0], perm: false});
}
return enemy;
});
if(S.ambushed) {
toast('AMBUSHED! All heroes stunned Turn 1!', 1800);
S.ambushed = false; // Clear flag after use
}
// Check if we need to show Encampment enemy selection
if(S.encampmentEarlyKills && S.encampmentEarlyKills > 0) {
S.selectingEncampmentTargets = true;
S.encampmentSelectedTargets = [];
}
render();
// Auto-target tutorial: show on second+ run, floor 1
if(S.runNumber >= 2 && f === 1 && !S.tutorialFlags.auto_target_intro) {
const isTouchDevice = 'ontouchstart' in window;
const inputHint = isTouchDevice ? "Press SELECT on controller" : "Right-click any sigil (or SELECT on controller)";
showTutorialPop('auto_target_intro', `Pro tip: ${inputHint} to auto-target the best enemy! This quickly attacks the lowest-HP target without manual selection.`);
}
}

function getLevel(sig, heroIdx) {
const h = S.heroes[heroIdx];
// Calculate total level (permanent + temporary XP upgrades)
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
// Star, Asterisk, and Expand are global passives - all heroes get them when upgraded
if(sig === 'Star' || sig === 'Asterisk' || sig === 'Expand') {
// Special case: Mage and Healer get +1 to Expand
if(sig === 'Expand') {
console.log('[EXPAND] Check - heroIdx:', heroIdx, 'h:', h, 'h?.n:', h?.n, 'isMageOrHealer:', h?.n === 'Mage' || h?.n === 'Healer', 'totalLevel:', totalLevel);
}
if(sig === 'Expand' && (h.n === 'Mage' || h.n === 'Healer')) {
console.log('[EXPAND] Mage/Healer bonus applied! Returning:', totalLevel + 1);
return totalLevel + 1;
}
if(sig === 'Expand') console.log('[EXPAND] No bonus applied, returning:', totalLevel);
return totalLevel;
}
// For other sigils, check if hero has it
const hasSigil = h.s.includes(sig) || (h.ts && h.ts.includes(sig));
if(!hasSigil) return 0;
// Actives always display +1 higher (perm 0 = L1, perm 1 = L2, etc.)
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
if(actives.includes(sig)) return totalLevel + 1;
return totalLevel;
}

function getTargetsPerInstance(action, heroIdx) {
const expandLevel = getLevel('Expand', heroIdx);
const hero = S.heroes[heroIdx];
console.log('[TARGETING] getTargetsPerInstance:', action, 'heroIdx:', heroIdx, 'hero.n:', hero?.n, 'expandLevel:', expandLevel, 'totalTargets:', 1 + expandLevel);
return 1 + expandLevel;
}

function needsEnemyTarget(action) { return ['Attack', 'Grapple'].includes(action); }
function needsHeroTarget(action) { return ['Heal', 'Shield', 'Alpha'].includes(action); }
function isMultiInstance(action) { return ['Attack', 'Shield', 'Heal'].includes(action); }

function getD20DC(baseDC, heroIdx, gambitName) {
const h = S.heroes[heroIdx];
if(!h || !h.ls) return baseDC;
// Last Stand: +2 immediately, then +2 each turn (h.lst counts turns in Last Stand)
const lastStandBonus = (h.lst + 1) * 2;
// Confuse caps at DC 20, all other gambits continue increasing
if(gambitName === 'CONFUSE') {
return Math.min(baseDC + lastStandBonus, 20);
}
return baseDC + lastStandBonus;
}

function selectHero(idx) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending) return;
const h = S.heroes[idx];
if(!h) { console.error('Invalid hero index:', idx); return; }
if(S.acted.includes(idx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
S.activeIdx = idx;
// Show happy reaction when hero is selected for their turn
if(!h.ls) setHeroReaction(h.id, 'happy', 1200);
if(h.ls) toast(`${h.n} in Last Stand - D20 only!`);
render();
}

function act(sig, heroIdx) {
// Hide any pending tooltips when action is selected
hideTooltip();

// RIBBLETON TUTORIAL: Check for scripted actions using TutorialManager
const h = S.heroes[heroIdx];
if(!h) { console.error('Invalid hero index in act():', heroIdx); return; }
if(!TutorialManager.canPerformAction(h, sig)) {
toast(TutorialManager.getInstructionMessage());
return;
}

if(S.locked) { toast('Wait for enemy turn!'); return; }
// Allow switching actions only if no instances have been completed yet
if(S.pending) {
// Check if any instances have been completed
if(S.instancesRemaining > 0 && S.totalInstances && S.instancesRemaining < S.totalInstances) {
toast('Must complete remaining instances!');
return;
}
// Allow switching if no instances completed yet
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
}
if(S.acted.includes(heroIdx)) { toast(`${h.n} already acted!`); return; }
if(h.st > 0) { toast(`${h.n} is stunned!`); return; }
if(h.ls && sig !== 'D20') { toast('Last Stand - D20 only!'); return; }
S.activeIdx = heroIdx;

// PASSIVE ASTERISK: Auto-apply on first action per combat
const asteriskLevel = getLevel('Asterisk', heroIdx);
const hasAsterisk = asteriskLevel > 0;
const firstAction = !h.firstActionUsed;
let repeats = 1;

if(hasAsterisk && firstAction) {
repeats = asteriskLevel + 1;
h.firstActionUsed = true;
toast(`Asterisk activated! ${sig} √ó${repeats}!`, 1500);
}

if(sig === 'Ghost') {
const level = getLevel('Ghost', heroIdx);
if(level === 0) { toast(`${h.n} doesn't have Ghost! Add it in Level-Up menu (costs XP).`); return; }
// Ghost tutorial: show first time player clicks Ghost
showTutorialPop('ghost_intro', "Ghost charges prevent lethal hits! Each charge blocks one death, and they persist between battles. Max 9 charges per hero.");
const totalCharges = level * repeats;
h.g = Math.min((h.g || 0) + totalCharges, 9);
toast(`${h.n} gained ${totalCharges} Ghost charge${totalCharges>1?'s':''}!`);
finishAction(heroIdx);
} else if(sig === 'D20') {
S.pending = 'D20';
S.asteriskD20Repeats = repeats;
S.asteriskD20Count = 0;
d20Menu(heroIdx);
} else if(isMultiInstance(sig)) {
const level = getLevel(sig, heroIdx);
if(level === 0) { toast(`${h.n} doesn't have ${sig}! Add it in Level-Up menu (costs XP).`); return; }
S.pending = sig;
S.instancesRemaining = level * repeats;
S.totalInstances = level * repeats; // Track for color roll-down
S.targets = [];
S.currentInstanceTargets = [];
// Shield persistence tutorial: show first time player clicks Shield
if(sig === 'Shield') {
showTutorialPop('shield_persistence', "Shields persist between battles! They're capped at max HP, so you can shield up before finishing a floor to enter the next fight with protection.");
}
render();
// Auto-focus target for controller users
if(sig === 'Attack') {
autoFocusTargetForController(heroIdx, 'enemy');
} else {
autoFocusTargetForController(heroIdx, 'hero');
}
} else if(sig === 'Grapple') {
const level = getLevel('Grapple', heroIdx);
if(level === 0) { toast(`${h.n} doesn't have Grapple! Add it in Level-Up menu (costs XP).`); return; }
// Grapple tutorial: show first time player clicks Grapple
showTutorialPop('grapple_intro', "Grapple stuns an enemy for 1 or more turns, but your hero takes recoil damage equal to the target's POW. High risk, high reward!");
S.pending = 'Grapple';
S.grappleRepeats = repeats;
S.grappleLevel = level;
S.targets = [];
render();
autoFocusTargetForController(heroIdx, 'enemy');
} else if(sig === 'Alpha') {
const level = getLevel('Alpha', heroIdx);
if(level === 0) { toast(`${h.n} doesn't have Alpha! Add it in Level-Up menu (costs XP).`); return; }
// Alpha tutorial: show first time player clicks Alpha
showTutorialPop('alpha_intro', "Alpha lets you give bonus actions to an ally! You spend your turn, but they get to act again immediately - great for letting your strongest attacker strike twice!");
const expandLevel = getLevel('Expand', heroIdx);
const targetsNeeded = 1 + expandLevel;
S.pending = 'Alpha';
S.alphaLevel = level;
S.alphaTargetsNeeded = targetsNeeded;
S.targets = [];
toast(`Alpha: Grant ${level} action${level>1?'s':''} to ${targetsNeeded} hero${targetsNeeded>1?'es':''}!`);
render();
autoFocusTargetForController(heroIdx, 'hero');
}
}

// Right-click on sigil: select action AND auto-target
function actAndAutoTarget(sig, heroIdx) {
// First, select the action normally
act(sig, heroIdx);

// Then auto-target after a brief delay to let state update
setTimeout(() => {
if (!S.pending) return; // Action didn't set pending (e.g., Ghost completes instantly)

const hero = S.heroes[heroIdx];
if (!hero) return;

// Calculate targets needed
const expandLevel = getLevel('Expand', heroIdx);
const hasBuiltInExpand = (hero.c === 'Mage' || hero.c === 'Healer');
const totalTargets = 1 + expandLevel + (hasBuiltInExpand ? 1 : 0);
const targetsNeeded = Math.max(1, totalTargets - (S.currentInstanceTargets ? S.currentInstanceTargets.length : 0));

if (['Attack', 'Grapple'].includes(S.pending)) {
  // Target enemies - prioritize lowest HP
  const aliveEnemies = S.enemies.filter(e => e.h > 0);
  if (aliveEnemies.length === 0) return;

  aliveEnemies.sort((a, b) => {
    if (a.h !== b.h) return a.h - b.h;
    const aLaneDist = Math.abs((a.li !== undefined ? a.li : 0) - heroIdx);
    const bLaneDist = Math.abs((b.li !== undefined ? b.li : 0) - heroIdx);
    return aLaneDist - bLaneDist;
  });

  const toTarget = aliveEnemies.slice(0, targetsNeeded);
  for (const enemy of toTarget) {
    const card = document.getElementById(enemy.id);
    if (card) card.click();
  }
  if (toTarget.length > 0) {
    toast(`Auto-targeted ${toTarget.length} enem${toTarget.length === 1 ? 'y' : 'ies'}!`, 1200);
  }

} else if (['Heal', 'Shield', 'Alpha'].includes(S.pending)) {
  let aliveHeroes = S.heroes.filter(h => h.h > 0 || h.ls);
  if (aliveHeroes.length === 0) return;

  if (S.pending === 'Heal') {
    aliveHeroes.sort((a, b) => {
      if (a.ls && !b.ls) return -1;
      if (!a.ls && b.ls) return 1;
      return (a.h / a.m) - (b.h / b.m);
    });
  } else if (S.pending === 'Shield') {
    aliveHeroes.sort((a, b) => {
      const aShield = a.sh || 0;
      const bShield = b.sh || 0;
      if (aShield !== bShield) return aShield - bShield;
      return a.h - b.h;
    });
  } else if (S.pending === 'Alpha') {
    aliveHeroes.sort((a, b) => b.p - a.p);
  }

  const toTarget = aliveHeroes.slice(0, targetsNeeded);
  for (const h of toTarget) {
    const card = document.getElementById(h.id);
    if (card) card.click();
  }
  if (toTarget.length > 0) {
    toast(`Auto-targeted ${toTarget.length} hero${toTarget.length === 1 ? '' : 'es'}!`, 1200);
  }
}
}, 50);
}

function d20Menu(heroIdx) {
if(S.locked) return;

// RIBBLETON TUTORIAL: PROMPT 2 - Explain D20 gambit
if(tutorialState && S.floor === 0 && tutorialState.stage === 'healer_d20') {
tutorialState.stage = 'd20_menu';
showTutorialPop('ribbleton_d20_menu', "Choose a gambit! Each has a DC (Difficulty Check) - you need to roll that number or higher to succeed. Pick CONFUSE to damage the Wolf!", () => {
// After prompt, show the d20 menu
renderD20MenuAfterTutorial(heroIdx);
});
return;
}

renderD20MenuAfterTutorial(heroIdx);
}

function renderD20MenuAfterTutorial(heroIdx) {
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];

// RIBBLETON TUTORIAL: Special D20 menu that doesn't block view
const isTutorial = tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu';

let html = '';
if(isTutorial) {
// Tutorial version: overlay on left side only, keep enemies visible
html = '<div style="position:fixed;top:50%;left:10px;transform:translateY(-50%);z-index:15000;max-width:380px;background:white;border:4px solid #3b82f6;border-radius:12px;padding:1.5rem;box-shadow:0 8px 32px rgba(0,0,0,0.5)">';
html += '<h3 style="margin-bottom:1rem;color:#6b4423">D20: Do Something Crazy</h3>';
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, 10, 'CONFUSE')" style="margin-bottom:0.5rem;background:#3b82f6;border:3px solid #f97316;font-size:1.1rem;cursor:pointer">
<strong style="font-size:1.2rem">‚úÖ DC 10: CONFUSE</strong><br>
<span style="font-size:0.95rem">Deal this enemy's POW to all enemies</span>
</div>`;
// Show other options greyed out
const lockedOptions = [
{dc:12, name:'STARTLE', desc:'Stun for 1 turn'},
{dc:15, name:'MEND', desc:'Heal self for POW'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
lockedOptions.forEach(opt => {
html += `<div style="margin-bottom:0.5rem;background:#e0e0e0;border:2px solid #999;border-radius:8px;padding:0.75rem;opacity:0.5;cursor:not-allowed">
<strong style="font-size:0.95rem">üîí DC ${opt.dc}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
html += '</div>';
// Tutorial: Append as overlay, don't replace combat view
render(); // First render combat view
v.insertAdjacentHTML('beforeend', html);
return;
} else {
// Normal D20 menu (centered, blocks view)
html = '<div style="text-align:center;padding:1rem;background:white;border:3px solid #000;border-radius:8px;margin:1rem auto;max-width:400px">';
html += '<h3 style="margin-bottom:1rem">D20: Do Something Crazy</h3>';
const expandLevel = getLevel('Expand', heroIdx);
const maxTargets = 1 + expandLevel;
if(expandLevel > 0) html += `<p style="margin-bottom:0.75rem;color:#22c55e;font-weight:bold;font-size:1.05rem;background:rgba(34,197,94,0.1);padding:0.5rem;border-radius:6px;border:2px solid #22c55e">‚ú® Expand L${expandLevel} Active: Target up to ${maxTargets} enemies!</p>`;
if(S.asteriskD20Repeats > 1) {
html += `<p style="margin-bottom:0.5rem;color:#f97316">Asterisk Active: Pick ${S.asteriskD20Repeats} actions!</p>`;
html += `<p style="margin-bottom:1rem;font-size:0.85rem">(${S.asteriskD20Count}/${S.asteriskD20Repeats} used)</p>`;
}
if(h.ls && h.lst >= 0) {
const lsBonus = (h.lst + 1) * 2;
html += `<p style="margin-bottom:0.5rem;color:#dc2626;font-weight:bold">Last Stand Turn ${h.lst + 1}: DCs +${lsBonus}</p>`;
}
const options = [
{dc:10, name:'CONFUSE', desc:'Deal this enemy\'s POW to all enemies'},
{dc:12, name:'STARTLE', desc:'Stun for 1 turn'},
{dc:15, name:'MEND', desc:'Heal self for POW'},
{dc:18, name:'STEAL', desc:'Gain Gold = enemy POW'},
{dc:20, name:'RECRUIT', desc:'Enemy joins team'}
];
options.forEach(opt => {
const adjustedDC = getD20DC(opt.dc, heroIdx, opt.name);
const dcText = adjustedDC > opt.dc ? `DC ${adjustedDC} (${opt.dc}+${adjustedDC - opt.dc})` : `DC ${opt.dc}`;
html += `<div class="choice" onclick="selectD20Action(${heroIdx}, ${adjustedDC}, '${opt.name}')" style="margin-bottom:0.5rem">
<strong>${dcText}: ${opt.name}</strong><br>
<span style="font-size:0.85rem">${opt.desc}</span>
</div>`;
});
if(S.asteriskD20Count > 0) html += `<button class="btn safe" onclick="finishD20Asterisk(${heroIdx})">Finish (${S.asteriskD20Count} used)</button>`;
else html += `<button class="btn secondary" onclick="cancelAction()">Cancel</button>`;
html += '</div>';
v.innerHTML = html;
}
}

function selectD20Action(heroIdx, dc, actionName) {
if(S.locked) return;
S.d20Action = actionName;
S.d20DC = dc;
S.d20HeroIdx = heroIdx;

// RIBBLETON TUTORIAL: Show Expand explanation after choosing CONFUSE
if(tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu' && actionName === 'CONFUSE') {
showTutorialPop('healer_expand_explain', "Healer has Expand, which adds extra targets to actions! This lets you Confuse multiple enemies at once. Try selecting 2 enemies!", () => {
S.pending = 'D20_TARGET';
S.targets = [];
render();
});
return;
}

// RECRUIT TUTORIAL: Show explanation when first selecting Recruit
if(actionName === 'RECRUIT') {
showTutorialPop('recruit_intro', "Recruited enemies will stand behind the hero who recruited them and fight alongside you until death! Each hero can have 1 recruit.", () => {
S.pending = 'D20_TARGET';
S.targets = [];
render();
});
return;
}

// MEND is self-targeting, execute immediately
if(actionName === 'MEND') {
const d20Level = getLevel('D20', heroIdx);
const {rolls, best} = rollDice(d20Level, 20);
const rollText = formatD20Compact(rolls, best);
const h = S.heroes[heroIdx];
if(best >= dc) {
const healAmount = h.p;
h.h = Math.min(h.h + healAmount, h.m);
toast(`${rollText} <span style="color:#22c55e;font-weight:bold">SUCCESS!</span> ${h.n} healed for ${healAmount} HP!`, 2000);
} else {
toast(`${rollText} needed ${dc} - <span style="color:#ef4444;font-weight:bold">FAILED!</span>`, 1800);
}
// Handle Asterisk repeats for MEND
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null;
render();
setTimeout(() => d20Menu(heroIdx), ANIMATION_TIMINGS.TUTORIAL_DELAY);
return;
}
}
finishD20Asterisk(heroIdx);
return;
}

S.pending = 'D20_TARGET';
S.targets = [];
render();
// Auto-focus the enemy across from the active hero for controller users
autoFocusTargetForController(S.d20HeroIdx);
}

// Auto-focus an enemy/hero target for controller navigation
function autoFocusTargetForController(heroIdx, targetType = 'enemy') {
if (typeof GamepadController === 'undefined' || !GamepadController.active) return;

setTimeout(() => {
if (targetType === 'enemy') {
// Find the enemy at the same index as the hero (or first enemy)
const enemyCards = Array.from(document.querySelectorAll('.card.enemy:not(.dead)'));
if (enemyCards.length > 0) {
const targetIdx = Math.min(heroIdx || 0, enemyCards.length - 1);
GamepadController.setFocus(enemyCards[targetIdx]);
}
} else {
// For hero targeting (Heal, Shield, Alpha), focus the hero themselves or first other hero
const heroCards = Array.from(document.querySelectorAll('.card.hero:not(.dead)'));
if (heroCards.length > 0) {
// Try to focus the acting hero first (for self-targeting like Heal)
GamepadController.setFocus(heroCards[heroIdx] || heroCards[0]);
}
}
}, 100);
}

function rollD20() {
if(S.locked) return;
const heroIdx = S.d20HeroIdx;
const h = S.heroes[heroIdx];
const dc = S.d20DC;
const actionName = S.d20Action;
const d20Level = getLevel('D20', heroIdx);
let rolls, best;

// RIBBLETON TUTORIAL: Fudge roll to always succeed (17-18)
if(tutorialState && S.floor === 0 && tutorialState.stage === 'd20_menu') {
const fudgedRoll = 17 + Math.floor(Math.random() * 2); // 17 or 18
rolls = [fudgedRoll];
best = fudgedRoll;
} else {
({rolls, best} = rollDice(d20Level, 20));
}
const rollText = formatD20Compact(rolls, best);

if(best >= dc) {
toast(`${rollText} <span style="color:#22c55e;font-weight:bold">SUCCESS!</span>`, 1800);
const targetNames = S.targets.map(id => {
const e = S.enemies.find(e => e.id === id);
return e ? e.n : null;
}).filter(n => n);
S.targets.forEach(targetId => executeD20ActionOnTarget(targetId, actionName));
if(targetNames.length > 0) {
const actionDesc = {'CONFUSE': 'confused', 'STARTLE': 'startled and stunned', 'STEAL': 'robbed', 'RECRUIT': 'recruited'};
if(actionName !== 'STEAL') toast(`${targetNames.join(', ')} ${actionDesc[actionName]}!`, 2500);
}
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), ANIMATION_TIMINGS.TUTORIAL_DELAY);
return;
}
}
finishD20Asterisk(heroIdx);
} else {
toast(`${rollText} needed ${dc} - <span style="color:#ef4444;font-weight:bold">FAILED!</span>`, ANIMATION_TIMINGS.TOAST_MEDIUM);
if(S.asteriskD20Repeats > 1) {
S.asteriskD20Count++;
if(S.asteriskD20Count < S.asteriskD20Repeats) {
S.pending = null; S.targets = [];
render();
setTimeout(() => d20Menu(heroIdx), ANIMATION_TIMINGS.TUTORIAL_DELAY);
return;
}
}
finishD20Asterisk(heroIdx);
}
}

function executeD20ActionOnTarget(enemyId, action) {
const enemy = S.enemies.find(e => e.id === enemyId);
if(!enemy) return;
if(action === 'CONFUSE') {
const dmg = enemy.p;
// Deal this enemy's POW to all enemies
S.enemies.forEach(e => {
dealDamageToEnemy(e, dmg);
});
} else if(action === 'STARTLE') {
enemy.st = 1;
// Check royal quest completion
if(S.royalQuestActive && S.round === 1 && !S.royalQuestCompleted) {
S.royalQuestCompleted = true;
toast(`Royal Quest completed! Ring retrieved!`, 1800);
}
} else if(action === 'STEAL') {
const gold = enemy.p;
S.gold += gold;
upd();
toast(`Stole ${gold} Gold from ${getEnemyDisplayName(enemy)}!`);
} else if(action === 'RECRUIT') {
const heroIdx = S.d20HeroIdx;
const hero = S.heroes[heroIdx];
const recruitName = getEnemyDisplayName(enemy);
// Remove enemy from enemies array immediately
S.enemies = S.enemies.filter(e => e.id !== enemyId);
if(!S.recruits) S.recruits = [];
const existingRecruit = S.recruits.find(r => r.recruitedBy === heroIdx);
if(existingRecruit) {
// Show choice popup: keep current or replace
render();
showRecruitReplaceConfirm(existingRecruit.n, recruitName, () => {
// KEEP current
toast(`Kept ${existingRecruit.n}.`, 1200);
render();
checkCombatEnd();
}, () => {
// REPLACE with new
S.recruits = S.recruits.filter(r => r.recruitedBy !== heroIdx);
const recruit = {...enemy, recruitedBy: heroIdx, isRecruit: true};
S.recruits.push(recruit);
toast(`${recruitName} replaces ${existingRecruit.n}!`, 1500);
render();
checkCombatEnd();
});
} else {
// No existing recruit, just add
const MAX_RECRUITS = 10;
if(S.recruits.length < MAX_RECRUITS) {
const recruit = {...enemy, recruitedBy: heroIdx, isRecruit: true};
S.recruits.push(recruit);
toast(`${recruitName} recruited by ${hero.n}!`, 1500);
} else {
toast(`Squad full! Cannot recruit ${recruitName}.`, 1500);
}
setTimeout(() => {
render();
checkCombatEnd();
}, 300);
}
}
}

function finishD20Asterisk(heroIdx) {
S.acted.push(heroIdx);
S.pending = null;
S.targets = [];
S.asteriskD20Repeats = 1;
S.asteriskD20Count = 0;
checkTurnEnd();
render();
}

function cancelAction() {
if(S.locked) return;
// If we have targets selected, just clear targets (stay in pending mode)
if(S.currentInstanceTargets && S.currentInstanceTargets.length > 0) {
// Remove targets from S.targets as well
S.currentInstanceTargets.forEach(id => {
  const idx = S.targets.indexOf(id);
  if(idx > -1) S.targets.splice(idx, 1);
});
S.currentInstanceTargets = [];
render();
return;
}
// No targets - fully cancel the action
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
render();
}

// Confirm and execute the currently selected targets
function confirmTargets() {
if(S.locked) return;
if(!S.pending) return;

// D20_TARGET uses S.targets, not S.currentInstanceTargets - check first
if(S.pending === 'D20_TARGET') {
if(!S.targets || S.targets.length === 0) {
  toast('Select at least one target first!');
  return;
}
rollD20();
return;
}

// For other actions, check S.currentInstanceTargets
if(!S.currentInstanceTargets || S.currentInstanceTargets.length === 0) {
toast('Select at least one target first!');
return;
}
const heroIdx = S.activeIdx;

if(S.pending === 'Attack') {
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) {
  setTimeout(() => finishAction(heroIdx), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
} else {
  setTimeout(() => render(), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}
} else if(S.pending === 'Grapple') {
// Safety check for grapple
const hero = S.heroes[heroIdx];
const totalRecoil = S.currentInstanceTargets.reduce((sum, tgtId) => {
  const enemy = S.enemies.find(e => e.id === tgtId);
  return sum + (enemy ? enemy.p : 0);
}, 0) * S.grappleRepeats;
const effectiveHP = (hero.h || 0) + (hero.sh || 0);
if(totalRecoil >= effectiveHP && !hero.g && !hero.ls) {
  toast('Grapple would kill you! Pick weaker targets.', 2000);
  return;
}
for(let i = 0; i < S.grappleRepeats; i++) executeGrapple(heroIdx, [...S.currentInstanceTargets], S.grappleLevel);
S.currentInstanceTargets = [];
finishAction(heroIdx);
} else if(S.pending === 'Shield' || S.pending === 'Heal') {
executeInstance(S.pending, heroIdx, [...S.currentInstanceTargets]);
S.instancesRemaining--;
S.currentInstanceTargets = [];
if(S.instancesRemaining <= 0) {
  setTimeout(() => finishAction(heroIdx), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
} else {
  setTimeout(() => render(), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}
} else if(S.pending === 'Alpha') {
executeAlpha(heroIdx, [...S.currentInstanceTargets]);
S.currentInstanceTargets = [];
finishAction(heroIdx);
}
}

function tgtEnemy(id) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(S.pending === 'D20_TARGET') {
const heroIdx = S.d20HeroIdx;
const maxTargets = 1 + getLevel('Expand', heroIdx);
// Toggle: if already targeted, remove it
if(S.targets.includes(id)) {
  S.targets = S.targets.filter(t => t !== id);
  render();
  return;
}
// Check if we can add more
if(S.targets.length >= maxTargets) {
  toast(`Max ${maxTargets} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
// Auto-confirm when targets are full OR all available enemies selected (manual only, not auto-select)
const aliveEnemies = S.enemies.filter(e => e.h > 0 && !S.targets.includes(e.id)).length;
const shouldAutoConfirm = (S.targets.length >= maxTargets || aliveEnemies === 0) && !S.autoSelectInProgress;
if(shouldAutoConfirm) {
  executeD20Action();
} else {
  render();
}
return;
}
if(!S.pending || !needsEnemyTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
console.log('[SELECTENEMY] heroIdx:', heroIdx, 'hero:', S.heroes[heroIdx]?.n, 'targetsPerInstance:', targetsPerInstance, 'S.sig.Expand:', S.sig?.Expand);
if(S.pending === 'Attack') {
// Toggle: if already targeted, remove it
if(S.currentInstanceTargets.includes(id)) {
  S.currentInstanceTargets = S.currentInstanceTargets.filter(t => t !== id);
  S.targets = S.targets.filter(t => t !== id);
  render();
  return;
}
// Check if we can add more
if(S.currentInstanceTargets.length >= targetsPerInstance) {
  toast(`Max ${targetsPerInstance} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
S.currentInstanceTargets.push(id);
// Count available targets (enemies not yet targeted)
const availableEnemies = S.enemies.filter(e => e.h > 0 && !S.currentInstanceTargets.includes(e.id)).length;
// Auto-confirm when targets are full OR all available enemies selected (manual only, not auto-select)
const shouldAutoConfirm = (S.currentInstanceTargets.length >= targetsPerInstance || availableEnemies === 0) && !S.autoSelectInProgress;
if(shouldAutoConfirm) {
  confirmTargets();
} else {
  render();
}
} else if(S.pending === 'Grapple') {
// Toggle: if already targeted, remove it
if(S.currentInstanceTargets.includes(id)) {
  S.currentInstanceTargets = S.currentInstanceTargets.filter(t => t !== id);
  S.targets = S.targets.filter(t => t !== id);
  render();
  return;
}
// Check if we can add more
if(S.currentInstanceTargets.length >= targetsPerInstance) {
  toast(`Max ${targetsPerInstance} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
S.currentInstanceTargets.push(id);
// Grapple L2+ NEVER auto-confirms - player may want to stun fewer targets (less recoil damage)
const grappleLevel = getLevel('Grapple', heroIdx);
const availableEnemiesForGrapple = S.enemies.filter(e => e.h > 0 && !S.currentInstanceTargets.includes(e.id)).length;
// Only auto-confirm for Grapple L1 when all available targets selected
const shouldAutoConfirmGrapple = grappleLevel <= 1 && availableEnemiesForGrapple === 0 && !S.autoSelectInProgress;
if(shouldAutoConfirmGrapple) {
  confirmTargets();
} else {
  render();
}
}
}

function tgtHero(id) {
if(S.locked) { toast('Wait for enemy turn!'); return; }
if(!S.pending || !needsHeroTarget(S.pending)) return;
const heroIdx = S.activeIdx;
const h = S.heroes[heroIdx];
const target = S.heroes.find(x => x.id === id);
if(!target) return;
const targetsPerInstance = getTargetsPerInstance(S.pending, heroIdx);
if(S.pending === 'Shield' || S.pending === 'Heal') {
// Toggle: if already targeted, remove it
if(S.currentInstanceTargets.includes(id)) {
  S.currentInstanceTargets = S.currentInstanceTargets.filter(t => t !== id);
  S.targets = S.targets.filter(t => t !== id);
  render();
  return;
}
// Check if we can add more
if(S.currentInstanceTargets.length >= targetsPerInstance) {
  toast(`Max ${targetsPerInstance} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
S.currentInstanceTargets.push(id);
// Count available heroes (alive heroes not yet targeted)
const availableHeroes = S.heroes.filter(hero => (hero.h > 0 || hero.ls) && !S.currentInstanceTargets.includes(hero.id)).length;
// Auto-confirm when targets are full OR all available heroes selected (manual only, not auto-select)
const shouldAutoConfirm = (S.currentInstanceTargets.length >= targetsPerInstance || availableHeroes === 0) && !S.autoSelectInProgress;
if(shouldAutoConfirm) {
  confirmTargets();
} else {
  render();
}
} else if(S.pending === 'Alpha') {
// Alpha: can't target self or already-acted heroes
const alphaUser = S.heroes[S.activeIdx];
if(!alphaUser) return; // Guard against invalid activeIdx
if(id === alphaUser.id) { toast('Cannot Alpha yourself!'); return; }
const targetIdx = S.heroes.findIndex(x => x.id === id);
if(S.acted.includes(targetIdx)) { toast('That hero already acted!'); return; }
// Toggle: if already targeted, remove it
if(S.currentInstanceTargets.includes(id)) {
  S.currentInstanceTargets = S.currentInstanceTargets.filter(t => t !== id);
  S.targets = S.targets.filter(t => t !== id);
  render();
  return;
}
// Check if we can add more
if(S.currentInstanceTargets.length >= S.alphaTargetsNeeded) {
  toast(`Max ${S.alphaTargetsNeeded} targets! Click a target to remove it.`);
  return;
}
S.targets.push(id);
S.currentInstanceTargets.push(id);
// Count available Alpha targets (alive heroes who haven't acted, not self, not already targeted)
const availableAlphaTargets = S.heroes.filter((hero, idx) => {
  if(hero.id === alphaUser.id) return false; // Can't target self
  if(S.acted.includes(idx)) return false; // Already acted
  if(hero.h <= 0 && !hero.ls) return false; // Dead
  if(S.currentInstanceTargets.includes(hero.id)) return false; // Already targeted
  return true;
}).length;
// Auto-confirm when targets are full OR all available heroes selected (manual only, not auto-select)
const shouldAutoConfirmAlpha = (S.currentInstanceTargets.length >= S.alphaTargetsNeeded || availableAlphaTargets === 0) && !S.autoSelectInProgress;
if(shouldAutoConfirmAlpha) {
  confirmTargets();
} else {
  render();
}
}
}

function executeAlphaAction(alphaUserIdx, targetIds) {
const alphaUser = S.heroes[alphaUserIdx];
const actionsToGrant = S.alphaLevel;
// Mark Alpha user as acted (forfeits ALL actions)
S.acted.push(alphaUserIdx);
S.pending = null;
S.targets = [];
toast(`${alphaUser.n} used Alpha! Granting ${actionsToGrant} action${actionsToGrant>1?'s':''} to ${targetIds.length} hero${targetIds.length>1?'es':''}!`);
// Set up multi-action state for granted heroes
S.alphaGrantedActions = [];
targetIds.forEach(id => {
const targetIdx = S.heroes.findIndex(h => h.id === id);
if(targetIdx >= 0) {
for(let i = 0; i < actionsToGrant; i++) {
S.alphaGrantedActions.push(targetIdx);
}
}
});
S.alphaCurrentAction = 0;
// Start first granted action
if(S.alphaGrantedActions.length > 0) {
const nextHeroIdx = S.alphaGrantedActions[0];
S.activeIdx = nextHeroIdx;
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
}
render();
}

function selectEncampmentTarget(enemyId) {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const currentSelected = S.encampmentSelectedTargets;
// Toggle selection
if(currentSelected.includes(enemyId)) {
S.encampmentSelectedTargets = currentSelected.filter(id => id !== enemyId);
} else {
if(currentSelected.length >= kills) {
toast(`Already selected ${kills} enem${kills>1?'ies':'y'}!`);
return;
}
S.encampmentSelectedTargets.push(enemyId);
}
render();
}

function confirmEncampmentKills() {
if(!S.selectingEncampmentTargets) return;
const kills = S.encampmentEarlyKills;
const selected = S.encampmentSelectedTargets;
if(selected.length !== kills) {
toast(`Select ${kills} enem${kills>1?'ies':'y'} to remove!`);
return;
}
// Remove selected enemies from S.enemies
S.enemies = S.enemies.filter(e => !selected.includes(e.id));
toast(`${kills} enem${kills>1?'ies':'y'} removed!`, 1200);
// Clear flags
S.selectingEncampmentTargets = false;
S.encampmentEarlyKills = 0;
S.encampmentSelectedTargets = [];
// Start combat normally
render();
}

function executeInstance(action, heroIdx, targets) {
const h = S.heroes[heroIdx];
const pow = h.p;
if(action === 'Attack') {
// Trigger attacker animation
triggerAttackAnimation(h.id);

const targetDetails = [];
const damagedEnemyIds = [];
// First pass: Apply damage to all targets
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
const hpBefore = e.h;
damagedEnemyIds.push(e.id);
// Apply damage (without animation yet)
applyDamageToTarget(e, pow, {isHero: false, skipRewards: false});
const hpAfter = e.h;
targetDetails.push({name: e.n, before: hpBefore, after: hpAfter});
// Track turn damage for damage counter
S.turnDamage += pow;
// RIBBLETON TUTORIAL: Track Wolf damage/death
if(tutorialState && S.floor === 0 && e.n === 'Wolf') {
debugLog('[TUTORIAL] Wolf took damage! HP now:', e.h, 'wolfDamaged was:', tutorialState.wolfDamaged);
if(e.h > 0 && !tutorialState.wolfDamaged) {
tutorialState.wolfDamaged = true;
debugLog('[TUTORIAL] Set wolfDamaged = true');
}
}
});
// Second pass: Trigger hit animations when attacker "lands" the hit
setTimeout(() => {
damagedEnemyIds.forEach((id, idx) => {
triggerHitAnimation(id);
// JUICE: Floating damage numbers
const isBigHit = pow >= 5;
showFloatingNumber(id, `-${pow}`, isBigHit ? 'critical' : 'damage', idx * 15);
});

// JUICE: Sound (screen shake only on defeat/last stand)
if(damagedEnemyIds.length > 0) {
SoundFX.play(pow >= 5 ? 'crit' : 'hit');
// Show cumulative damage counter for this hero's turn
showDamageCounter(S.turnDamage);
// Show happy reaction when hero lands a hit
setHeroReaction(h.id, 'happy', 1000);
}
}, ANIMATION_TIMINGS.ATTACK_IMPACT);
// Third pass: Handle deaths and cleanup
const deadEnemies = [];
const dyingFlydras = [];
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
if(e.h <= 0 && e.g === 0) {
// FLYDRA: Special death handling
if(e.isFlydra && e.flydraState === 'alive') {
handleFlydraDeath(e);
dyingFlydras.push(e);
} else if(!e.isFlydra) {
// JUICE: Knockout animation and death sound
triggerKnockout(e.id);
deadEnemies.push(e);
// RIBBLETON TUTORIAL: Track Wolf/Goblin kills
if(tutorialState && S.floor === 0) {
if(e.n === 'Wolf') tutorialState.wolfKilled = true;
if(e.n === 'Goblin') tutorialState.goblinKilled = true;
}
}
}
});
// Remove dead enemies after short delay for knockout animation
if(deadEnemies.length > 0) {
SoundFX.play('croak'); // Froggy croak for enemy defeat
triggerScreenShake(true); // Heavy shake on enemy defeat
// All heroes smile when enemy is killed (gold/xp awarded)
setAllHeroesReaction('happy', 1200);
setTimeout(() => {
deadEnemies.forEach(e => {
S.enemies = S.enemies.filter(enemy => enemy.id !== e.id);
});
render();
// Check combat end AFTER enemies are removed
checkCombatEnd();
}, 200);
}
// FLYDRA: Check if all heads are now dying (victory condition)
if(dyingFlydras.length > 0 && isFlydraDefeated()) {
SoundFX.play('croak');
triggerScreenShake(true);
setTimeout(() => {
S.enemies = S.enemies.filter(e => !e.isFlydra);
render();
checkCombatEnd();
}, 300);
} else if(dyingFlydras.length > 0) {
render(); // Re-render to show flipped cards
}
if(targetDetails.length > 0) {
const targetStrings = targetDetails.map(t => `${t.name} (‚ù§${t.before}‚Üí‚ù§${t.after})`);
toast(`${h.n} attacked ${targetStrings.join(', ')}!`);
}
// Combat end check now happens inside the setTimeout after enemies are removed
} else if(action === 'Shield') {
const targetNames = [];
const shieldedIds = [];
const shieldAmt = 2 * pow;
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
target.sh += shieldAmt;
if(target.sh > target.m) target.sh = target.m;
targetNames.push(target.n);
shieldedIds.push(target.id);
});
// Trigger all shield animations simultaneously with amounts
shieldedIds.forEach(id => triggerShieldAnimation(id, shieldAmt));
if(targetNames.length > 0) {
toast(`${targetNames.join(' and ')} gained ${shieldAmt} shield!`);
}
} else if(action === 'Heal') {
const healed = [];
const revived = [];
const healedIds = [];
const healAmt = 2 * pow;
targets.forEach(tgtId => {
const target = S.heroes.find(x => x.id === tgtId);
if(!target) return;
healedIds.push(target.id);
if(target.ls) {
target.ls = false;
target.lst = 0;
target.h = healAmt;
revived.push(target.n);
} else {
target.h += healAmt;
if(target.h > target.m) target.h = target.m;
healed.push(target.n);
}
});
// Trigger all heal animations simultaneously with amounts
healedIds.forEach(id => triggerHealAnimation(id, healAmt));
// Show happy reaction on the healer
setHeroReaction(h.id, 'happy', 1000);
// Healed targets also smile
healedIds.forEach(id => setHeroReaction(id, 'happy', 1200));
if(healed.length > 0) toast(`${healed.join(' and ')} restored ${healAmt} HP!`);
if(revived.length > 0) toast(`${revived.join(' and ')} revived with ${healAmt} HP!`);
}
}

function executeGrapple(heroIdx, targets, stunDuration) {
const h = S.heroes[heroIdx];
// Trigger attacker animation (grapple uses same animation as attack)
triggerAttackAnimation(h.id);
// JUICE: Stun/grapple sound effect
SoundFX.play('stun');
let totalDmg = 0;
const targetNames = [];
targets.forEach(tgtId => {
const e = S.enemies.find(x => x.id === tgtId);
if(!e) return;
totalDmg += e.p;
e.st += stunDuration;
targetNames.push(e.n);
// Check royal quest completion
if(S.royalQuestActive && S.round === 1 && !S.royalQuestCompleted) {
S.royalQuestCompleted = true;
toast(`Royal Quest completed! Ring retrieved!`, 1800);
}
});
if(targetNames.length > 0) toast(`${h.n} grappled ${targetNames.join(', ')} - stunned ${stunDuration} turn${stunDuration>1?'s':''}!`);
if(totalDmg > 0) {
// Hero takes recoil damage - trigger hit animation
triggerHitAnimation(h.id);
const damage = applyDamageToTarget(h, totalDmg, {isHero: true, silent: true});
let msg = `${h.n} took Grapple recoil:`;
if(damage.shieldLost > 0 && damage.hpLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è -${damage.hpLost}‚ù§Ô∏è`;
} else if(damage.shieldLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è`;
} else if(damage.hpLost > 0) {
msg += ` -${damage.hpLost}‚ù§Ô∏è`;
}
toast(msg);
}
}

function dealDamageToEnemy(enemy, dmg) {
triggerHitAnimation(enemy.id);
const hpBefore = enemy.h;

// Apply damage using unified function
applyDamageToTarget(enemy, dmg, {isHero: false, skipRewards: false});
const hpAfter = enemy.h;

// JUICE: Floating damage number
const isBigHit = dmg >= 10;
showFloatingNumber(enemy.id, `-${dmg}`, isBigHit ? 'critical' : 'damage');

// JUICE: Sound effect (screen shake only on defeat/last stand)
SoundFX.play(isBigHit ? 'crit' : 'hit');

// Show damage toast
toast(`${getEnemyDisplayName(enemy)} took ${dmg} damage (‚ù§${hpBefore}‚Üí‚ù§${hpAfter})!`);

// RIBBLETON TUTORIAL: Track Wolf damage/death
if(tutorialState && S.floor === 0 && enemy.n === 'Wolf') {
debugLog('[TUTORIAL] Wolf took damage! HP now:', enemy.h, 'wolfDamaged was:', tutorialState.wolfDamaged);
if(enemy.h > 0 && !tutorialState.wolfDamaged) {
tutorialState.wolfDamaged = true;
debugLog('[TUTORIAL] Set wolfDamaged = true');
}
}

// Handle enemy death
if(enemy.h <= 0 && enemy.g === 0) {
// FLYDRA: Special death handling
if(enemy.isFlydra && enemy.flydraState === 'alive') {
handleFlydraDeath(enemy);
// Check if all Flydra heads are now dying
if(isFlydraDefeated()) {
SoundFX.play('croak');
triggerScreenShake(true);
setTimeout(() => {
S.enemies = S.enemies.filter(e => !e.isFlydra);
render();
checkCombatEnd();
}, 300);
} else {
render(); // Re-render to show flipped card
}
} else if(!enemy.isFlydra) {
// JUICE: Knockout animation and death sound
triggerKnockout(enemy.id);
SoundFX.play('death');
triggerScreenShake(true); // Heavy shake on enemy defeat

// RIBBLETON TUTORIAL: Track Wolf/Goblin kills
if(tutorialState && S.floor === 0) {
if(enemy.n === 'Wolf') tutorialState.wolfKilled = true;
if(enemy.n === 'Goblin') tutorialState.goblinKilled = true;
}

// Remove enemy after knockout animation
setTimeout(() => {
  S.enemies = S.enemies.filter(e => e.id !== enemy.id);
  render();
  checkCombatEnd();
}, 300);
}
}
}

function finishAction(heroIdx) {
// Check if this is an Alpha-granted action
if(S.alphaGrantedActions && S.alphaGrantedActions.length > 0) {
S.alphaCurrentAction++;
// Remove one bonus turn stack from the current hero
const currentHero = S.heroes[heroIdx];
if(currentHero) {
removeBonusTurnStack(currentHero.id, true);
}
if(S.alphaCurrentAction < S.alphaGrantedActions.length) {
// More Alpha-granted actions remain
const nextHeroIdx = S.alphaGrantedActions[S.alphaCurrentAction];
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = nextHeroIdx;
// Keep turnDamage - Alpha bonus turns count as same turn for damage counter
toast(`${S.heroes[nextHeroIdx].n}'s turn (Alpha-granted ${S.alphaCurrentAction + 1}/${S.alphaGrantedActions.length})!`);
render();
return;
} else {
// All Alpha-granted actions complete
S.alphaGrantedActions = [];
S.alphaCurrentAction = 0;
}
}
// Normal action finish
S.acted.push(heroIdx);
S.pending = null;
S.targets = [];
S.currentInstanceTargets = [];
S.instancesRemaining = 0;
S.totalInstances = 0;
S.activeIdx = -1;
S.turnDamage = 0; // Reset damage counter for next hero's turn

// RIBBLETON TUTORIAL: Check advancement after action using TutorialManager
const h = S.heroes[heroIdx];
TutorialManager.advanceStage({action: 'finish', hero: h.n, round: S.round});

// Autosave after each hero action
autosave();

checkTurnEnd();
render();
}

function checkTurnEnd() {
// First check if combat has ended (all enemies dead or all heroes in last stand)
// This prevents continuing turn progression after victory/defeat
if(S.enemies.length === 0 || S.heroes.every(h => h.ls)) {
return; // Combat ended, don't process turn logic
}

// Check if all non-stunned heroes have acted (optimized single-pass)
const allActedIncludingLS = S.heroes.every((h, idx) => {
return h.st > 0 || S.acted.includes(idx);
});
if(allActedIncludingLS) {
S.heroes.forEach(h => { if(h.ls) h.lst++; });

// RIBBLETON TUTORIAL: Handle enemy turn start using TutorialManager
TutorialManager.onEnemyTurnStart();
setTimeout(() => { S.locked = true; enemyTurn(); }, T(ANIMATION_TIMINGS.TURN_TRANSITION));
}
}

// ===== FLYDRA MECHANICS =====
/**
 * Handle Flydra death - grants ghost charges to other heads, enters dying state
 * Returns true if this was a Flydra (death handled specially), false otherwise
 */
function handleFlydraDeath(flydra) {
if(!flydra.isFlydra) return false;

// Grant ghost charges to all OTHER living Flydra heads
const ghostCharges = S.heroes.length;
const otherFlydras = S.enemies.filter(e => e.isFlydra && e.id !== flydra.id && e.flydraState === 'alive');

otherFlydras.forEach(other => {
other.g = Math.min((other.g || 0) + ghostCharges, 9);
});

if(otherFlydras.length > 0) {
toast(`${flydra.n} falls! Grants ${ghostCharges} Ghost to ${otherFlydras.length} other head${otherFlydras.length > 1 ? 's' : ''}!`, 2000);
}

// Enter dying state - card will flip
flydra.flydraState = 'dying';
flydra.h = 0;

return true;
}

/**
 * Check if dying Flydras should revive (called at start of enemy turn)
 */
function checkFlydraRevival() {
const dyingFlydras = S.enemies.filter(e => e.isFlydra && e.flydraState === 'dying');
const aliveFlydras = S.enemies.filter(e => e.isFlydra && e.flydraState === 'alive');

if(dyingFlydras.length === 0) return;

// If any Flydras are still alive, revive the dying ones
if(aliveFlydras.length > 0) {
dyingFlydras.forEach(flydra => {
const reviveHP = Math.ceil(flydra.m / 2); // 50% HP
flydra.h = reviveHP;
flydra.flydraState = 'alive';
toast(`${flydra.n} regenerates with ${reviveHP} HP!`, 1800);
triggerHealAnimation(flydra.id, reviveHP);
});
} else {
// All Flydras are dying - they all die for real
// Award flat 100 gold for defeating the Flydra (entire boss, not per-head)
const flydraGold = 100 * (S.gameMode === 'fu' ? 3 : 1); // Frogged Up multiplier
S.gold += flydraGold;
S.combatGold += flydraGold;
SoundFX.play('coinDrop');
upd();
dyingFlydras.forEach(flydra => {
flydra.flydraState = 'dead';
});
// Remove all dead Flydras
S.enemies = S.enemies.filter(e => !e.isFlydra || e.flydraState !== 'dead');
toast('All Flydra heads defeated!', 2000);
checkCombatEnd();
}
}

/**
 * Check if Flydra fight is won (all heads dying/dead simultaneously)
 */
function isFlydraDefeated() {
const flydras = S.enemies.filter(e => e.isFlydra);
if(flydras.length === 0) return false; // No Flydras in this fight

// Victory if all Flydras are in 'dying' state (none alive)
const aliveFlydras = flydras.filter(f => f.flydraState === 'alive');
return aliveFlydras.length === 0;
}

function enemyTurn() {
// FLYDRA: Check for revival at start of enemy turn
checkFlydraRevival();

// Safety check: don't start enemy turn if combat has ended
if(S.enemies.length === 0 || S.heroes.every(h => h.ls)) {
checkCombatEnd();
return;
}

S.turn = 'enemy';
S.acted = [];
S.activeIdx = -1;
render();
S.enemies.forEach(e => {
// NOTE: Stun decrement moved to endEnemyTurn() so enemies actually skip their turn
e.turnsSinceGain++;
e.alphaActed = false;
});
// Process recruits - increment turnsSinceGain (stun decrement moved to endEnemyTurn)
if(S.recruits) {
S.recruits.forEach(r => {
if(!r.turnsSinceGain) r.turnsSinceGain = 0;
r.turnsSinceGain++;
});
}
setTimeout(() => executeAlphaPhase(), ANIMATION_TIMINGS.ALPHA_PHASE_START);
}

function drawEnemyStartSigil(enemy, base, forceLevel1 = false) {
const pool = base.pool;
if(!pool || !Array.isArray(pool) || pool.length === 0) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
// Filter to available sigils (not already held)
const availableSigils = pool.filter(s => !heldSigils.includes(s));
if(availableSigils.length === 0) return;
// Pick random sigil
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
// Calculate level: use sigilLevels override if defined, otherwise maxLevel
let level;
if(forceLevel1) {
level = 1;
} else {
const maxLvl = (base.sigilLevels && base.sigilLevels[sig]) || base.maxLevel || 1;
level = maxLvl === 1 ? 1 : 1 + Math.floor(Math.random() * maxLvl);
}
enemy.s.push({sig, level, perm:false});
}

function drawEnemySigil(enemy) {
const pool = enemy.pool;
if(!pool || !Array.isArray(pool) || pool.length === 0) return;
const heldSigils = enemy.s.map(sigil => sigil.sig);
// Filter pool: exclude held sigils AND Asterisk (only allowed turn 1)
const availableSigils = pool.filter(s => !heldSigils.includes(s) && s !== 'Asterisk');
if(availableSigils.length === 0) return;
// Pick random sigil
const sig = availableSigils[Math.floor(Math.random() * availableSigils.length)];
// Calculate level based on enemy type
let level;
if(enemy.isFlydra) {
// Flydra: level = number of heroes (L2 normal, L3 in Frogged Up)
level = enemy.flydraLevel || S.heroes.length;
} else {
// Other enemies: use sigilLevels override if defined, otherwise maxLevel
const maxLvl = (enemy.sigilLevels && enemy.sigilLevels[sig]) || enemy.maxLevel || 1;
level = maxLvl === 1 ? 1 : 1 + Math.floor(Math.random() * maxLvl);
}
enemy.s.push({sig, level, perm:false});
toast(`${getEnemyDisplayName(enemy)} drew ${sig} L${level}!`);
}

/**
 * Executes Alpha phase of enemy turn.
 *
 * Alpha Mechanic:
 * - Enemies with Alpha sigil grant bonus actions to allies
 * - Alpha enemy does NOT act themselves (skips normal turn)
 * - Chooses strongest ally (highest POW, then most sigils)
 * - Grants Level √ó Attack actions to chosen ally
 * - All Alpha actions resolve before Recruit/Normal phases
 *
 * Execution Order:
 * 1. Find all non-stunned enemies with Alpha sigil
 * 2. For each Alpha enemy: Grant attacks to best ally
 * 3. Mark Alpha enemy as "acted" (skips normal phase)
 * 4. Continue to Recruit phase
 */
function executeAlphaPhase() {
const alphaEnemies = S.enemies.filter(e => e.st === 0 && e.s.some(sigil => sigil.sig === 'Alpha' && !sigil.perm));
if(alphaEnemies.length === 0) { setTimeout(executeRecruitPhase, T(ANIMATION_TIMINGS.PHASE_TRANSITION)); return; }
// Execute all Alpha enemies in reading order with minimal stagger
let delay = 0;
alphaEnemies.forEach((alphaEnemy, idx) => {
setTimeout(() => {
const allies = S.enemies.filter(e => e.id !== alphaEnemy.id && e.h > 0 && !e.s.some(s => s.sig === 'Alpha' && !s.perm));
if(allies.length === 0) { toast(`${alphaEnemy.n}'s Alpha has no valid allies!`); alphaEnemy.alphaActed = true; return; }
allies.sort((a, b) => { if(b.p !== a.p) return b.p - a.p; return b.s.length - a.s.length; });
const bestAlly = allies[0];
const alphaSigil = alphaEnemy.s.find(s => s.sig === 'Alpha');
const attacks = alphaSigil.level;
toast(`${alphaEnemy.n} grants ${bestAlly.n} ${attacks} attack${attacks>1?'s':''}!`);
for(let i = 0; i < attacks; i++) executeEnemyBaseAttack(bestAlly);
alphaEnemy.alphaActed = true;
}, delay);
delay += T(ANIMATION_TIMINGS.ENEMY_ACTION_DELAY); // Minimal stagger (was 600ms)
});
// Wait for longest animation to complete
setTimeout(() => executeRecruitPhase(), delay + T(600));
}

function executeRecruitPhase() {
if(!S.recruits || S.recruits.length === 0) { setTimeout(executeNormalEnemyPhase, T(ANIMATION_TIMINGS.PHASE_TRANSITION)); return; }
// Execute all recruits in reading order with minimal stagger
let delay = 0;
S.recruits.forEach((recruit, idx) => {
setTimeout(() => executeRecruitTurn(recruit), delay);
delay += T(ANIMATION_TIMINGS.ENEMY_ACTION_DELAY); // Minimal stagger (was 600ms)
});
// Wait for longest animation to complete
setTimeout(() => executeNormalEnemyPhase(), delay + T(600));
}

function executeRecruitTurn(recruit) {
if(recruit.st > 0) { toast(`${recruit.n} (Recruit) is stunned!`); return; }
if(recruit.h <= 0) return; // Dead recruit
// Recruit attacks enemies (not heroes)
executeRecruitBaseAttack(recruit);
const drawnSigils = recruit.s.filter(s => !s.perm && s.sig !== 'Alpha');
drawnSigils.forEach(sigil => executeRecruitSigil(recruit, sigil));
recruit.s = recruit.s.filter(s => s.perm);
render();
}

function executeRecruitBaseAttack(recruit) {
// Target lowest HP enemy
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) attacked ${target.n} for ${recruit.p}!`);
}

function executeRecruitSigil(recruit, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
for(let i = 0; i < level; i++) {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
dealDamageToEnemy(target, recruit.p);
toast(`${recruit.n} (Recruit) ${sig} attacked ${target.n} for ${recruit.p}!`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * recruit.p * level;
recruit.sh = (recruit.sh || 0) + shieldAmt;
if(recruit.sh > recruit.m) recruit.sh = recruit.m;
toast(`${recruit.n} (Recruit) gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * recruit.p * level;
// Heal lowest HP hero
const targets = S.heroes.filter(h => h.h > 0 && !h.ls);
if(targets.length > 0) {
targets.sort((a, b) => a.h - b.h);
const healTarget = targets[0];
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${recruit.n} (Recruit) healed ${healTarget.n} for ${healAmt}!`);
}
} else if(sig === 'Grapple') {
if(S.enemies.length === 0) return;
const targets = S.enemies.filter(e => e.h > 0);
if(targets.length === 0) return;
targets.sort((a, b) => a.h - b.h);
const target = targets[0];
const dmgToRecruit = target.p;
recruit.h -= dmgToRecruit;
toast(`${recruit.n} (Recruit) grappled ${target.n}!`);
if(recruit.h <= 0) {
recruit.h = 0;
toast(`${recruit.n} (Recruit) defeated by grapple recoil!`);
S.recruits = S.recruits.filter(r => r.id !== recruit.id);
} else {
target.st = level;
toast(`${target.n} stunned for ${level} turns!`);
}
} else if(sig === 'Ghost') {
recruit.g = (recruit.g || 0) + level;
if(recruit.g > 9) recruit.g = 9;
toast(`${recruit.n} (Recruit) gained ${level} Ghost charge!`);
}
}

function executeNormalEnemyPhase() {
// Execute all enemies in reading order (top-down, left-right) with minimal stagger
const allEnemies = [...S.enemies].sort((a, b) => a.li - b.li); // Sort by lane index

// Track enemy turn progress for UI
S.enemyTurnTotal = allEnemies.length;
S.enemyTurnCurrent = 0;

let delay = 0;
allEnemies.forEach((enemy, idx) => {
setTimeout(() => {
S.enemyTurnCurrent = idx + 1;
render(); // Update header to show progress
executeEnemyTurn(enemy);
}, delay);
delay += T(ANIMATION_TIMINGS.ENEMY_ACTION_DELAY); // Just enough stagger for visual clarity (was 600ms)
});

// Wait for longest animation to complete (600ms per enemy action + stagger)
setTimeout(() => endEnemyTurn(), delay + T(600));
}

function executeEnemyTurn(enemy) {
// FLYDRA: Dying Flydras don't act
if(enemy.isFlydra && enemy.flydraState === 'dying') { return; }
if(enemy.st > 0) { toast(`${getEnemyDisplayName(enemy)} is stunned!`); return; }
if(enemy.alphaActed) {
toast(`${getEnemyDisplayName(enemy)} used Alpha (skipping normal turn)`);
enemy.s = enemy.s.filter(s => s.perm);
return;
}
// Filter out Attack sigil - the base attack mechanism handles it
// Attack sigil is a marker indicating the enemy attacks, not an additional action
const drawnSigils = enemy.s.filter(s => !s.perm && s.sig !== 'Alpha' && s.sig !== 'Attack');
executeEnemyBaseAttack(enemy);

// Filter out suicidal grapples - enemies should never kill themselves
const safeSigils = drawnSigils.filter(sigil => {
if(sigil.sig === 'Grapple') {
const target = S.heroes[enemy.li];
if(target && target.h > 0) {
const recoilDamage = target.p;
// Skip grapple if it would kill the enemy
if(enemy.h <= recoilDamage) {
toast(`${getEnemyDisplayName(enemy)} considered Grapple but chose to survive instead!`);
return false;
}
}
}
return true;
});

safeSigils.forEach(sigil => executeEnemySigil(enemy, sigil));
enemy.s = enemy.s.filter(s => s.perm);
render();
}

function getEnemyExpandLevel(enemy) {
const expandSigil = enemy.s.find(s => s.sig === 'Expand');
return expandSigil ? expandSigil.level : 0;
}

function selectEnemyTargets(enemy, count) {
// Priority:
// 1. Hero directly across (lane index)
// 2. That hero's recruited ally (if present)
// 3. Heroes nearest to that first hero
// 4. Any remaining heroes
// 5. Nearest hero's recruited ally
// 6. Any remaining allies

let targets = [];
const added = new Set();

// 1. Primary target: Hero in enemy's lane
const primaryHero = S.heroes[enemy.li];
if(primaryHero && primaryHero.h > 0) {
targets.push(primaryHero);
added.add(primaryHero.id);
}
if(targets.length >= count) return targets;

// 2. That hero's recruited ally (if present)
if(S.recruits && S.recruits.length > 0) {
const primaryRecruit = S.recruits.find(r => r.li === enemy.li && r.h > 0);
if(primaryRecruit) {
targets.push(primaryRecruit);
added.add(primaryRecruit.id);
}
}
if(targets.length >= count) return targets;

// 3-4. Expand to nearby heroes by distance from primary lane
const aliveHeroes = S.heroes.filter(h => h.h > 0 && !added.has(h.id));
// Sort by distance from enemy lane
aliveHeroes.sort((a, b) => {
const aIdx = S.heroes.indexOf(a);
const bIdx = S.heroes.indexOf(b);
return Math.abs(aIdx - enemy.li) - Math.abs(bIdx - enemy.li);
});

for(const hero of aliveHeroes) {
if(targets.length >= count) break;
targets.push(hero);
added.add(hero.id);
}
if(targets.length >= count) return targets;

// 5-6. Recruited allies of nearby heroes, then any remaining
if(S.recruits && S.recruits.length > 0) {
const aliveRecruits = S.recruits.filter(r => r.h > 0 && !added.has(r.id));
// Sort by lane distance from enemy
aliveRecruits.sort((a, b) => Math.abs(a.li - enemy.li) - Math.abs(b.li - enemy.li));

for(const recruit of aliveRecruits) {
if(targets.length >= count) break;
targets.push(recruit);
added.add(recruit.id);
}
}

return targets;
}

function executeEnemyBaseAttack(enemy) {
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;
executeEnemyAttackOnHeroes(enemy, targetCount, 'Base Attack');
}

function executeEnemySigil(enemy, sigil) {
const {sig, level} = sigil;
if(sig === 'Attack') {
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;

for(let i = 0; i < level; i++) {
executeEnemyAttackOnHeroes(enemy, targetCount, `Attack ${i+1}/${level}`);
}
} else if(sig === 'Shield') {
const shieldAmt = 2 * enemy.p * level;
enemy.sh = (enemy.sh || 0) + shieldAmt;
if(enemy.sh > enemy.m) enemy.sh = enemy.m;
toast(`${getEnemyDisplayName(enemy)} gained ${shieldAmt} shield!`);
} else if(sig === 'Heal') {
const healAmt = 2 * enemy.p * level;
const allies = S.enemies.filter(e => e.id !== enemy.id && e.h > 0);
if(allies.length > 0) {
allies.sort((a,b) => a.h - b.h);
const healTarget = allies[0];
healTarget.h += healAmt;
if(healTarget.h > healTarget.m) healTarget.h = healTarget.m;
toast(`${getEnemyDisplayName(enemy)} healed ${getEnemyDisplayName(healTarget)} for ${healAmt}!`);
}
} else if(sig === 'Grapple') {
const target = S.heroes[enemy.li];
if(target && target.h > 0) {
const dmgToEnemy = target.p;
enemy.h -= dmgToEnemy;
toast(`${getEnemyDisplayName(enemy)} grappled ${target.n}!`);
if(enemy.h <= 0) {
enemy.h = 0;
toast(`${getEnemyDisplayName(enemy)} defeated by grapple recoil!`);
S.enemies = S.enemies.filter(e => e.id !== enemy.id);
} else {
target.st = level;
toast(`${target.n} stunned for ${level} turns!`);
}
}
} else if(sig === 'Ghost') {
enemy.g = (enemy.g || 0) + level;
if(enemy.g > 9) enemy.g = 9;
toast(`${getEnemyDisplayName(enemy)} gained ${level} Ghost charge!`);
} else if(sig === 'Expand') {
toast(`${getEnemyDisplayName(enemy)} used Expand (affects their attacks)`);
} else if(sig === 'Asterisk') {
// Asterisk for enemies: Multiply attacks by (level + 1)
const expandLevel = getEnemyExpandLevel(enemy);
const targetCount = 1 + expandLevel;
const multiplier = level + 1;
toast(`${getEnemyDisplayName(enemy)} used Asterisk: √ó${multiplier} attacks!`);
for(let i = 0; i < multiplier; i++) {
executeEnemyAttackOnHeroes(enemy, targetCount, `Asterisk Attack ${i+1}/${multiplier}`);
}
}
}

function dealDamageToHero(hero, dmg, source) {
triggerHitAnimation(hero.id);
const hpBefore = hero.h;
const damage = applyDamageToTarget(hero, dmg, {isHero: true});
const hpAfter = hero.h;
// Show pained reaction when hero takes damage (flash briefly, permanent if last stand)
if(damage.hpLost > 0 || damage.shieldLost > 0) {
setHeroReaction(hero.id, 'pained', hero.ls ? 0 : 600);
}
// Build detailed damage message with HP change
let msg = `${source} hit ${hero.n} (‚ù§${hpBefore}‚Üí‚ù§${hpAfter}):`;
if(damage.shieldLost > 0 && damage.hpLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è -${damage.hpLost}‚ù§Ô∏è`;
} else if(damage.shieldLost > 0) {
msg += ` -${damage.shieldLost}üõ°Ô∏è`;
} else if(damage.hpLost > 0) {
msg += ` -${damage.hpLost}‚ù§Ô∏è`;
}
toast(msg);
}

function endEnemyTurn() {
// Decrement hero stun at end of enemy turn (heroes skip player turn, then decrement)
S.heroes.forEach(h => {
if(h.st > 0) {
h.st--;
if(h.st === 0) toast(`${h.n} is no longer stunned!`);
}
});
// Decrement enemy stun at end of enemy turn (enemies skip their turn, then decrement)
S.enemies.forEach(e => {
if(e.st > 0) {
e.st--;
if(e.st === 0) toast(`${getEnemyDisplayName(e)} is no longer stunned!`);
}
});
// Decrement recruit stun at end of enemy turn (recruits act during enemy turn)
if(S.recruits) {
S.recruits.forEach(r => {
if(r.st > 0) {
r.st--;
if(r.st === 0) toast(`${r.n} (Recruit) is no longer stunned!`);
}
});
}
if(checkCombatEnd()) return;
S.round++;

// Enemies draw sigils at start of player turn (so player can strategize)
S.enemies.forEach(e => {
// RIBBLETON TUTORIAL: Enemies don't gain sigils (except Goblin on Round 3)
const isTutorial = tutorialState && S.floor === 0;
const isGoblinRound3 = isTutorial && e.n === 'Goblin' && S.round === 3;

// CAVE TROLL RAGE: Rolling Attack L1‚ÜíL2‚ÜíL3‚ÜíL1 pattern (every turn)
if(e.rage && !isTutorial) {
const oldIndex = e.rageIndex;
e.rageIndex = (e.rageIndex + 1) % e.ragePattern.length;
const isReset = oldIndex === e.ragePattern.length - 1; // Was at L3, now at L1

// Update Attack level to match current rage index
const attackSigil = e.s.find(sig => sig.sig === 'Attack');
if(attackSigil) {
attackSigil.level = e.ragePattern[e.rageIndex];
}

// Draw additional sigil every turn EXCEPT on reset turns
if(!isReset) {
drawEnemySigil(e);
}
render();
}
// ORC ALTERNATING: Toggle between Attack L2 and random pool sigil
else if(e.alternating && e.turnsSinceGain >= e.gainRate && (!isTutorial || isGoblinRound3)) {
e.turnsSinceGain = 0;
e.altState = !e.altState; // Toggle
// Clear non-permanent sigils and set the new one
e.s = e.s.filter(sig => sig.perm);
if(e.altState) {
e.s.push({sig: e.altSigil.s, level: e.altSigil.l, perm: false});
} else {
drawEnemySigil(e);
}
render();
}
// Normal sigil drawing for other enemies
else if(e.turnsSinceGain >= e.gainRate && (!isTutorial || isGoblinRound3)) {
e.turnsSinceGain = 0;
// Draw multiple sigils per turn if specified (Dragons draw 2)
const draws = e.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(e);
}
// Immediately render to show new sigils
render();
}
});
// Process recruit sigil drawing
if(S.recruits) {
S.recruits.forEach(r => {
if(r.turnsSinceGain >= r.gainRate) {
r.turnsSinceGain = 0;
const draws = r.drawsPerTurn || 1;
for(let i = 0; i < draws; i++) {
drawEnemySigil(r);
}
// Immediately render to show new sigils
render();
}
});
}

// RIBBLETON TUTORIAL: Handle round transitions using TutorialManager
if(tutorialState && S.floor === 0) {
tutorialState.round = S.round;
TutorialManager.onRoundStart(S.round);
// If onRoundStart handled the transition (showed a popup), return early
if(S.turn === 'player') {
return;
}
}

S.turn = 'player';
S.activeIdx = -1;
S.acted = [];
S.locked = false;
S.enemyTurnCurrent = 0; // Clear enemy turn progress tracking
S.enemyTurnTotal = 0;
upd();

// Show "Your turn!" toast to indicate player can act again
const aliveHeroes = S.heroes.filter(h => h.h > 0);
if(aliveHeroes.length > 0) {
toast('Your turn!', ANIMATION_TIMINGS.TOAST_SHORT);
}

// Auto-skip stunned heroes
S.heroes.forEach((h, idx) => {
if(h.st > 0 && !S.acted.includes(idx)) {
S.acted.push(idx);
toast(`${h.n} is stunned and skips their turn!`);
}
});

// Autosave at start of each new round (after enemy turn completes)
autosave();

checkTurnEnd();
render();
}

/**
 * Checks for combat victory or defeat conditions.
 *
 * Victory Conditions:
 * - All enemies defeated (S.enemies.length === 0)
 * - Tutorial Floor 0: Special handling with no rewards
 * - Normal combat: Awards XP with Star bonus multipliers
 *
 * Defeat Conditions:
 * - All heroes in Last Stand mode (allDead check)
 * - Clears temporary XP upgrades immediately for clean Death screen
 *
 * @returns {boolean} - True if combat ended (victory or defeat), false if ongoing
 */
function checkCombatEnd() {
// Guard against multiple simultaneous calls (race condition from async death handling)
if(S.combatEnding) return false;

// Clean up any lingering tooltips when combat ends
if(typeof hideTooltip === 'function') hideTooltip();
if(S.enemies.length === 0) {
S.combatEnding = true; // Prevent duplicate victory handling
S.inCombat = false; // Combat ended - disable autosave
// Tutorial Floor 0: Special ending (no XP/Gold rewards)
if(S.floor === 0) {
S.combatXP = 0;
S.combatGold = 0;
setTimeout(() => {
toast('Victory!');
if(tutorialState && tutorialState.phase === 1) {
// Phase 1 complete: Transition to Phase 2
setTimeout(finishTaposBirthdayPhase, T(ANIMATION_TIMINGS.VICTORY_DELAY));
} else {
// Phase 2 complete: Show handoff popup, then finish tutorial
setTimeout(() => {
showTutorialPop('ribbleton_handoff', "Hover / long-press any sigil to see what it does, and check out the FAQ and Sigilarium for tips. You're on your own now - good luck!", () => {
finishRibbletonTutorial();
});
}, T(ANIMATION_TIMINGS.VICTORY_DELAY));
}
}, 500);
return true;
}

// Normal combat victory
// JUICE: Victory celebration!
spawnConfetti(60);
ProceduralMusic.playVictory(); // Victory fanfare!
SoundFX.play('ribbit'); // Celebratory frog croak!

setTimeout(() => {
const combatXP = S.combatXP || 0;
let starBonus = 0;
S.heroes.forEach(h => {
const starLevel = getLevel('Star', S.heroes.indexOf(h));
starBonus += starLevel * 0.5;
});
const bonusXP = Math.floor(combatXP * (1 + starBonus));
S.xp += bonusXP;
S.combatXP = 0; // Reset combat XP
// Recruits persist until killed - don't clear here
if(starBonus > 0) toast(`Star Bonus! ${combatXP} √ó ${(1 + starBonus).toFixed(1)} = ${bonusXP} XP`, 3000);
// JUICE: Counter pop for XP gain
animateCounterPop('xp');
upd();
toast('Victory!');
setTimeout(levelUp, T(ANIMATION_TIMINGS.VICTORY_DELAY));
}, 500);
return true;
}
const allDead = S.heroes.every(h => h.ls);
if(allDead) {
S.combatEnding = true; // Prevent duplicate defeat handling
S.inCombat = false; // Combat ended - disable autosave
// Clear temporary XP upgrades immediately so Death screen shows clean permanent levels
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// CRITICAL: Clear run save immediately to prevent loading into invalid state
// This ensures player can't reload into a battle where all heroes are in Last Stand
if(S.currentSlot) {
localStorage.removeItem(`froggle8_slot${S.currentSlot}`);
}
localStorage.removeItem('froggle8'); // Also clear old format for backwards compatibility
// Record to The Pond - determine what killed the heroes
const killedBy = S.enemies.length > 0 ? S.enemies[0].n : 'Unknown';
recordPondHistory('defeat', killedBy);
// JUICE: Defeat sound and music
ProceduralMusic.playDefeat();
SoundFX.play('death');
setTimeout(() => {
toast('Defeated!');
setTimeout(() => transitionScreen(showDeathScreen), T(ANIMATION_TIMINGS.DEFEAT_DELAY));
}, ANIMATION_TIMINGS.ACTION_COMPLETE);
return true;
}
return false;
}

/**
 * Smoothly transitions between major game screens with fade effect.
 *
 * Animation Flow:
 * 1. Fade out current screen (200ms)
 * 2. Execute callback to update content
 * 3. Fade in new screen (200ms)
 *
 * Total transition time: 400ms
 *
 * Used for: error‚Üítitle, tutorial skip‚Üítitle, defeat‚Üídeath, etc.
 *
 * @param {Function} callback - Function to call during fade (updates screen content)
 */
function transitionScreen(callback) {
// Clean up tooltips before screen transition
if(typeof hideTooltip === 'function') hideTooltip();
const v = document.getElementById('gameView');
v.classList.add('fade-out');
setTimeout(() => {
v.classList.remove('fade-out');
callback();
v.classList.add('fade-in');
setTimeout(() => v.classList.remove('fade-in'), ANIMATION_TIMINGS.FADE_TRANSITION);
}, ANIMATION_TIMINGS.FADE_TRANSITION);
}

function render() {
// Save controller focus state before DOM update
if (typeof GamepadController !== 'undefined' && GamepadController.active) {
GamepadController.saveFocusState();
}

const v = document.getElementById('gameView');
// Combat screens are scrollable (no-scroll is for narrative/cutscene screens)
v.classList.remove('no-scroll');
// Toggle FU mode class for compact 3-hero layout
v.classList.toggle('fu-mode', S.gameMode === 'fu');
// Special state: Encampment enemy selection
if(S.selectingEncampmentTargets) {
v.innerHTML = renderEncampmentSelection();
// Restore controller focus after DOM update
if (typeof GamepadController !== 'undefined' && GamepadController.active) {
GamepadController.restoreFocusState();
}
return;
}

// RIBBLETON TUTORIAL: Show targeting prompts
if(tutorialState && S.floor === 0 && S.pending) {
// REMOVED: Targeting popup is now batched with Attack popup
// Auto-advance stage when Attack is pending
if(tutorialState.stage === 'warrior_attack' && S.pending === 'Attack' && S.targets.length === 0) {
tutorialState.stage = 'targeting_wolf';
// No popup - already explained in popup 1
}
// PROMPT 4: Heal + Expand (BATCHED)
else if(tutorialState.stage === 'healer_heal' && S.pending === 'Heal' && S.currentInstanceTargets.length === 0 && S.targets.length === 0) {
tutorialState.stage = 'expand_targets';
showTutorialPop('ribbleton_expand', "Use Healer's Expand to heal both wounded heroes!", () => {
render();
});
return;
}
}

let html = renderCombatStatusHeader();
// New layout: Each hero and their enemies in a horizontal lane
const enemyLanes = {};
S.enemies.forEach(e => { if(!enemyLanes[e.li]) enemyLanes[e.li] = []; enemyLanes[e.li].push(e); });

S.heroes.forEach((h,i) => {
html += `<div class="combat-lane">`;
html += '<div class="lane-content" style="display:flex;gap:2rem;justify-content:center;align-items:stretch">';

// Hero section (left side of lane)
html += '<div style="flex:0 0 auto;display:flex;flex-direction:column;gap:0.3rem">';

// Show recruit BEHIND (before) hero if exists
if(S.recruits) {
const heroRecruits = S.recruits.filter(r => r.recruitedBy === i);
if(heroRecruits.length > 0) {
// Sort by POW descending, then by current HP descending
heroRecruits.sort((a, b) => {
if(b.p !== a.p) return b.p - a.p;
return b.h - a.h;
});
const recruit = heroRecruits[0];
const extra = [];
if(recruit.sh > 0) extra.push(`${recruit.sh}üõ°`);
if(recruit.g > 0) extra.push(`${recruit.g}${sigilIconOnly('Ghost')}`);
if(recruit.st > 0) extra.push(`üí•${recruit.st}T`);
html += `<div id="${recruit.id}" class="card hero" style="opacity:0.85;border:2px dashed #22c55e">`;
// Power at top
html += `<div style="text-align:center;font-size:1rem;font-weight:bold;margin-bottom:0.25rem">${recruit.p}</div>`;
// Recruited label with emoji
html += `<div style="text-align:center;font-size:1.5rem;margin-bottom:0.25rem">ü§ù</div>`;
// HP
html += `<div style="text-align:center;font-size:0.85rem;margin-bottom:0.25rem">${recruit.h}/${recruit.m}</div>`;
// Extra info
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils
const recruitTotalSigils = recruit.s.length + 1;
const compactClass = recruitTotalSigils >= 4 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">
<span class="sigil l1">${sigilIconOnly('Attack')}</span>`;
recruit.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${sigil.sig}', this), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly(sigil.sig, sigil.level)}</span>`;
});
html += '</div></div>';
}
}

// LAST STAND: Flipped card visual (similar to dying Flydra)
if(h.ls) {
const isTargetable = S.pending && needsHeroTarget(S.pending);
const hasActed = S.acted.includes(i);
const isActive = S.activeIdx === i;
let lsClasses = 'card hero last-stand-flipped';
if(i === 0) lsClasses += ' chosen-one';
if(isActive) lsClasses += ' active';
if(isTargetable) lsClasses += ' targetable';
if(hasActed) lsClasses += ' acted';
const isTargeted = S.targets.includes(h.id);
if(isTargeted) lsClasses += ' targeted';
let onclick = '';
if(isTargetable) onclick = `onclick="tgtHero('${h.id}')"`;
else if(!hasActed && h.st === 0 && !S.pending) onclick = `onclick="selectHero(${i})"`;
const heroImage = getHeroImage(h);
html += `<div id="${h.id}" class="${lsClasses}" style="background:linear-gradient(135deg,#450a0a,#7f1d1d);border:3px solid #dc2626" ${onclick}>`;
html += `<div style="text-align:center;font-size:0.7rem;font-weight:bold;color:#fca5a5;margin-bottom:0.25rem;animation:pulse-text 1s infinite">‚ö†Ô∏è LAST STAND ‚ö†Ô∏è</div>`;
html += `<div style="text-align:center;font-size:0.8rem;font-weight:bold;color:#f1f5f9;margin-bottom:0.25rem">${h.n}</div>`;
if(heroImage) html += `<div style="text-align:center"><img src="${heroImage}" style="width:48px;height:48px;border-radius:4px;object-fit:contain;background:#d4c4a8;filter:sepia(30%) brightness(0.8);border:2px solid #dc2626"></div>`;
html += `<div style="text-align:center;font-size:1.5rem;margin:0.3rem 0">üíÄ</div>`;
html += `<div style="text-align:center;font-size:0.75rem;color:#fca5a5;line-height:1.3;padding:0.25rem">`;
html += `<div style="font-weight:bold;color:#fbbf24">Turn ${h.lst + 1}</div>`;
html += `<div>D20 only!</div>`;
html += `<div style="font-size:0.65rem;opacity:0.8;margin-top:0.2rem">Heal to revive</div>`;
html += `</div>`;
// Show shield/ghost if any
const lsExtra = [];
if(h.sh > 0) lsExtra.push(`${h.sh}üõ°`);
if(h.g > 0) lsExtra.push(`${h.g}${sigilIconOnly('Ghost')}`);
if(hasActed) lsExtra.push('‚úì');
if(lsExtra.length > 0) html += `<div style="text-align:center;font-size:0.7rem;color:#f1f5f9">${lsExtra.join(' ')}</div>`;
html += `</div>`;
} else {
// Normal hero card
const hp = `${h.h}/${h.m}‚ù§`;
const isActive = S.activeIdx === i;
const isTargetable = S.pending && needsHeroTarget(S.pending);
const hasActed = S.acted.includes(i);
const isStunned = h.st > 0;
let cardClasses = 'card hero';
if(i === 0) cardClasses += ' chosen-one';
if(isActive) cardClasses += ' active';
if(isTargetable) cardClasses += ' targetable';
if(hasActed) cardClasses += ' acted';
if(isStunned) cardClasses += ' stunned';
const isTargeted = S.targets.includes(h.id);
if(isTargeted) cardClasses += ' targeted';
const extra = [];
if(h.sh > 0) extra.push(`${h.sh}üõ°`);
if(h.g > 0) extra.push(`${h.g}${sigilIconOnly('Ghost')}`);
if(h.st > 0) extra.push(`üí•${h.st}T`);
if(hasActed) extra.push('‚úì');
let onclick = '';
if(isTargetable) onclick = `onclick="tgtHero('${h.id}')"`;
else if(!hasActed && h.st === 0 && !S.pending) onclick = `onclick="selectHero(${i})"`;
const heroImage = getHeroImage(h);
html += `<div id="${h.id}" class="${cardClasses}" ${onclick}>`;
// Status banner for stunned/acted heroes
if(isStunned && !isTargetable) {
html += `<div style="text-align:center;font-size:0.65rem;font-weight:bold;color:#fff;background:#ef4444;padding:2px 6px;border-radius:4px;margin-bottom:4px">STUNNED ${h.st}T</div>`;
} else if(hasActed && !isTargetable) {
html += `<div style="text-align:center;font-size:0.65rem;font-weight:bold;color:#fff;background:#6b7280;padding:2px 6px;border-radius:4px;margin-bottom:4px">DONE</div>`;
}
// Name at top
html += `<div style="text-align:center;font-size:0.75rem;font-weight:bold;margin-bottom:0.25rem;opacity:0.8">${h.n}</div>`;
// POW - portrait - HP (horizontal)
html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.25rem;gap:0.25rem">`;
html += `<div style="font-size:1rem;font-weight:bold;min-width:30px;text-align:center">${h.p}</div>`;
if(heroImage) html += `<img src="${heroImage}" style="width:48px;height:48px;border-radius:4px;object-fit:contain;background:#d4c4a8">`;
html += `<div style="font-size:0.85rem;min-width:50px;text-align:center">${hp}</div>`;
html += `</div>`;
// Extra info
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils with proper 2-row formation
const activeSigils = sortSigils([...h.s, ...(h.ts || [])]);
const sigilCount = activeSigils.length;

// Calculate row distribution for 2-row max
let row1Count, row2Count;
if (sigilCount <= 3) {
row1Count = sigilCount;
row2Count = 0;
} else if (sigilCount === 4) {
row1Count = 2;
row2Count = 2;
} else {
row1Count = Math.ceil(sigilCount / 2);
row2Count = sigilCount - row1Count;
}

const row1Sigils = activeSigils.slice(0, row1Count);
const row2Sigils = activeSigils.slice(row1Count);
const needsCompact = sigilCount >= 7;
const rowClass = needsCompact ? 'sigil-row compact' : 'sigil-row';

const renderCombatSigil = (s) => {
const lvl = getLevel(s, i);
// Calculate visual level for roll-down effect
let visualLvl = lvl;
if(S.activeIdx === i && S.pending === s && isMultiInstance(s) && S.totalInstances) {
const usedInstances = S.totalInstances - S.instancesRemaining;
visualLvl = Math.max(0, lvl - usedInstances);
}
const cl = visualLvl===0?'l0':visualLvl===1?'l1':visualLvl===2?'l2':visualLvl===3?'l3':visualLvl===4?'l4':'l5';
// Allow clicking sigils if: hero hasn't acted, not stunned, and either (no pending action OR pending but no instances committed yet)
const canSwitchAction = !S.pending || (S.instancesRemaining === S.totalInstances);
const canClick = !S.acted.includes(i) && h.st === 0 && canSwitchAction && ['Attack','Shield','Grapple','Heal','Ghost','D20','Alpha'].includes(s);
const isActiveAction = (S.pending === s && S.activeIdx === i);
const isPassive = ['Expand', 'Star', 'Asterisk'].includes(s);
return `<span class="sigil ${cl} ${isPassive?'passive':''} ${isActiveAction?'active-action':''} ${canClick?'clickable':''}" ${canClick?`onclick="act('${s}', ${i})" oncontextmenu="actAndAutoTarget('${s}', ${i}); return false;"`:''}
onmouseenter="showTooltip('${s}', this, ${visualLvl})" onmouseleave="hideTooltip()"
ontouchstart="tooltipTimeout = setTimeout(() => showTooltip('${s}', this, ${visualLvl}), ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip()">${sigilIconOnly(s, visualLvl)}</span>`;
};

html += `<div class="${rowClass}">`;
row1Sigils.forEach(s => html += renderCombatSigil(s));
html += '</div>';
if (row2Sigils.length > 0) {
html += `<div class="${rowClass}">`;
row2Sigils.forEach(s => html += renderCombatSigil(s));
html += '</div>';
}
html += '</div>';
} // End of else (normal hero card)
html += '</div>'; // Close hero section

// Divider between heroes and enemies
html += '<div style="width:3px;background:linear-gradient(to bottom,transparent,rgba(0,0,0,0.3) 20%,rgba(0,0,0,0.3) 80%,transparent);flex-shrink:0"></div>';

// Enemy section (right side of lane)
html += '<div style="flex:0 0 auto;display:flex;flex-wrap:wrap;gap:0.3rem;justify-content:flex-start;align-items:flex-start;align-content:flex-start;min-height:80px">';
const laneEnemies = enemyLanes[i] || [];
if(laneEnemies.length === 0) {
html += `<div style="flex:1;text-align:center;font-size:1.2rem;padding:1.5rem;background:rgba(0,0,0,0.1);border:3px dashed rgba(0,0,0,0.3);border-radius:8px;color:rgba(0,0,0,0.4);font-style:italic;display:flex;align-items:center;justify-content:center">No Enemies</div>`;
} else {
laneEnemies.forEach(e => {
// FLYDRA: Check if this is a dying Flydra - render flipped card
if(e.isFlydra && e.flydraState === 'dying') {
html += `<div id="${e.id}" class="card enemy flydra-dying" style="background:linear-gradient(135deg,#1a1a2e,#16213e);border:3px solid #e94560;opacity:0.9">`;
html += `<div style="text-align:center;font-size:0.8rem;font-weight:bold;color:#e94560;margin-bottom:0.5rem">‚ö†Ô∏è ${e.n} ‚ö†Ô∏è</div>`;
html += `<div style="text-align:center;font-size:2.5rem;margin:0.5rem 0;filter:grayscale(50%)">üíÄ</div>`;
html += `<div style="text-align:center;font-size:0.75rem;color:#f1f5f9;line-height:1.4;padding:0.5rem">`;
html += `<div style="font-weight:bold;color:#fbbf24;margin-bottom:0.3rem">REGENERATING...</div>`;
html += `<div>Revives at ${Math.ceil(e.m/2)} HP next turn unless ALL heads are defeated!</div>`;
html += `</div></div>`;
return;
}
const isTargetable = (S.pending && needsEnemyTarget(S.pending)) || S.pending === 'D20_TARGET';
const selectCount = S.targets.filter(t => t === e.id).length;
let cardClasses = 'card enemy';
if(e.isFlydra) cardClasses += ' flydra';
if(isTargetable) cardClasses += ' targetable';
if(selectCount > 0) cardClasses += ' targeted';
const extra = [];
if(e.sh > 0) extra.push(`${e.sh}üõ°`);
// Show ghost charges if enemy has them
if(e.g > 0) extra.push(`${e.g}${sigilIconOnly('Ghost')}`);
if(e.st > 0) extra.push(`üí•${e.st}T`);
if(selectCount > 0) extra.push(`√ó${selectCount}`);
const enemyEmoji = ENEMY_EMOJI[e.n] || 'üëæ';
html += `<div id="${e.id}" class="${cardClasses}" ${isTargetable?`onclick="tgtEnemy('${e.id}')"`:''}">`;
// Name at top
html += `<div style="text-align:center;font-size:0.75rem;font-weight:bold;margin-bottom:0.25rem;opacity:0.8">${getEnemyDisplayName(e)}</div>`;
// POW - emoji - HP row (horizontal)
html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.25rem;gap:0.25rem">`;
html += `<div style="font-size:1rem;font-weight:bold;min-width:30px;text-align:center">${e.p}</div>`;
html += `<div style="font-size:2rem">${enemyEmoji}</div>`;
html += `<div style="font-size:0.85rem;min-width:50px;text-align:center">${e.h}/${e.m}</div>`;
html += `</div>`;
// Extra info
if(extra.length>0) html += `<div style="text-align:center;font-size:0.7rem;margin-bottom:0.25rem">${extra.join(' ')}</div>`;
html += '<div class="sigil-divider"></div>';
// Sigils with smart wrapping
const hasAttackSigil = e.s.some(s => s.sig === 'Attack');
const totalSigils = e.s.length + (hasAttackSigil ? 0 : 1);
const compactClass = totalSigils >= 4 ? 'compact' : '';
html += `<div class="sigil-row ${compactClass}">`;
if(!hasAttackSigil) {
html += `<span class="sigil l1">${sigilIconOnly('Attack')}</span>`;
}
e.s.forEach(sigil => {
const cl = sigil.level===0?'l0':sigil.level===1?'l1':sigil.level===2?'l2':sigil.level===3?'l3':sigil.level===4?'l4':'l5';
html += `<span class="sigil ${cl}" onmouseenter="showTooltip('${sigil.sig}', this)" onmouseleave="hideTooltip()" ontouchstart="if(tooltipTimeout)clearTimeout(tooltipTimeout);tooltipTimeout=setTimeout(()=>showTooltip('${sigil.sig}',this),ANIMATION_TIMINGS.TOOLTIP_DELAY)" ontouchend="hideTooltip();if(tooltipTimeout)clearTimeout(tooltipTimeout)">${sigilIconOnly(sigil.sig, sigil.level)}</span>`;
});
html += '</div></div>';
});
}
html += '</div>'; // Close enemy section
html += '</div>'; // Close flex container
html += '</div>'; // Close combat-lane
});
v.innerHTML = html;

// Apply bonus turn stacks after DOM is updated
setTimeout(() => {
// Show Alpha-granted action stacks
if(S.alphaGrantedActions && S.alphaGrantedActions.length > 0) {
// Count remaining actions for each hero
const actionCounts = {};
for(let i = S.alphaCurrentAction || 0; i < S.alphaGrantedActions.length; i++) {
const heroIdx = S.alphaGrantedActions[i];
actionCounts[heroIdx] = (actionCounts[heroIdx] || 0) + 1;
}
// Apply stacks to heroes
Object.keys(actionCounts).forEach(heroIdx => {
const hero = S.heroes[heroIdx];
if(hero) {
addBonusTurnStack(hero.id, actionCounts[heroIdx]);
}
});
}

// Restore controller focus after DOM update
if (typeof GamepadController !== 'undefined' && GamepadController.active) {
GamepadController.restoreFocusState();
}
}, 0);
}

// ===== LEVEL UP =====
function levelUp() {
// JUICE: Level up sound
SoundFX.play('levelup');

// Unlock blue portal and award statuette after completing Floor 19 (combat before floor 20)
if(S.floor === 19) {
S.hasReachedFloor20 = true;
S.hasAncientStatuette = true;
savePermanent();
toast('üóø Ancient Statuette acquired! The blue portal in Ribbleton has awakened!', 2500);
}

const v = document.getElementById('gameView');
const nextCost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Level Up!</h2>
<p style="text-align:center;margin-bottom:0.5rem">Floor ${S.floor} Complete</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Current XP: ${S.xp} | Next Level: ${nextCost}XP</p>
<div class="choice" onclick="levelUpMenu()">Spend XP</div>
<button class="btn safe" onclick="nextFloor()">Next Floor</button>`;
}

function nextFloor() {
console.log(`[FLOOR] nextFloor() called, S.floor=${S.floor}`);
// Clear any pending recruit replacement choice
S.pendingNewRecruit = null;
S.pendingOldRecruitId = null;
saveGame();
// Show header buttons tutorial after first neutral encounter (Floor 2 complete)
if(S.floor === 2 && !S.tutorialFlags.faq_intro) {
console.log(`[FLOOR] Floor 2 complete, showing faq_intro tutorial`);
S.tutorialFlags.faq_intro = true;
showTutorialPop('faq_intro', "You're (mostly) on your own from here - good luck! Need help? Check the header buttons at the top:<br><br>üåÄ <strong>Sigilarium</strong> - View all sigils and their effects<br>ü™µ <strong>Log</strong> - See combat message history<br>‚ùì <strong>FAQ</strong> - Frequently asked questions about game mechanics<br>‚öôÔ∏è <strong>Settings</strong> - Adjust game options and preferences", () => {
console.log(`[FLOOR] faq_intro callback, calling startFloor(${S.floor + 1})`);
startFloor(S.floor + 1);
});
return;
}
console.log(`[FLOOR] Calling startFloor(${S.floor + 1})`);
startFloor(S.floor + 1);
}

function showStartingXPScreen() {
const v = document.getElementById('gameView');
const nextCost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem;color:#a855f7">Starting XP Bonus!</h2>
<p style="text-align:center;margin-bottom:0.5rem;font-size:1.1rem">You start this run with <strong>${S.startingXP} XP</strong> from Death Boy sacrifices!</p>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;opacity:0.8">Spend it now or bank it for later. Remaining XP: <strong>${S.xp}</strong> | Next Level Cost: <strong>${nextCost}XP</strong></p>
<div class="choice" onclick="startingXPMenu()">Spend XP</div>
<button class="btn safe" onclick="startFloor(1)">Start Run (Bank XP)</button>`;
}

function startingXPMenu() {
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend Starting XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="startingHeroStats()">Upgrade Hero Stats</div>
<div class="choice" onclick="showStartingSigilUpgradeMenu()">Upgrade/Add Sigil</div>
<button class="btn secondary" onclick="showStartingXPScreen()">Back</button>`;
}

function showStartingSigilUpgradeMenu() {
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Upgrade/Add Sigil</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>

<div style="background:rgba(44,99,199,0.1);border:2px solid #2c63c7;border-radius:8px;padding:1rem;margin-bottom:1rem">
<h3 style="color:#2c63c7;margin:0 0 0.5rem 0;font-size:1rem">‚öîÔ∏è Core Sigils</h3>
<p style="font-size:0.85rem;margin:0;line-height:1.4">Basic actions that heroes start with: Attack, Shield, Heal, D20. Every hero can learn these.</p>
</div>

<div style="background:rgba(249,115,22,0.1);border:2px solid #f97316;border-radius:8px;padding:1rem;margin-bottom:1rem">
<h3 style="color:#f97316;margin:0 0 0.5rem 0;font-size:1rem">üî• Advanced Sigils</h3>
<p style="font-size:0.85rem;margin:0;line-height:1.4">Alternative specialist actions for your turn: Ghost, Alpha, Grapple. Heroes don't start with these, but any hero can learn them!</p>
</div>

<div style="background:rgba(147,51,234,0.1);border:2px solid #9333ea;border-radius:8px;padding:1rem;margin-bottom:1rem">
<h3 style="color:#9333ea;margin:0 0 0.5rem 0;font-size:1rem">‚ú® Passive Sigils</h3>
<p style="font-size:0.85rem;margin:0;line-height:1.4">Global enhancements that automatically improve all heroes: Expand, Asterisk, Star. <strong>All heroes benefit immediately from passive upgrades!</strong></p>
</div>

<div style="background:rgba(34,197,94,0.1);border:2px solid #22c55e;border-radius:8px;padding:1rem;margin-bottom:1.5rem">
<p style="font-size:0.9rem;margin:0;line-height:1.5"><strong>üí° Upgrading a sigil makes it stronger everywhere:</strong> in the Sigilarium, on every hero who has it, and for any hero who learns it later!</p>
</div>

<div class="choice" onclick="startingUpgradeSigil()">Upgrade Existing Sigil</div>
<div class="choice" onclick="startingAddSigilToHero()">Add New Sigil to Hero</div>
<button class="btn secondary" onclick="startingXPMenu()">Back</button>`;
}

function startingHeroStats() {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Hero Stats</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
S.heroes.forEach((h, idx) => {
html += `<div class="choice" onclick="startingUpPow(${idx})"><strong>${h.n} POW</strong> (${h.p} ‚Üí ${h.p+1})</div>`;
html += `<div class="choice" onclick="startingUpHP(${idx})"><strong>${h.n} HP</strong> (${h.m} ‚Üí ${h.m+5})</div>`;
});
}
html += `<button class="btn secondary" onclick="startingXPMenu()">Back</button>`;
v.innerHTML = html;
}

function startingUpPow(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].p++;
toast(`${S.heroes[idx].n} POW +1!`);
upd();
startingXPMenu();
}

function startingUpHP(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].m += 5;
S.heroes[idx].h += 5;
toast(`${S.heroes[idx].n} HP +5!`);
upd();
startingXPMenu();
}

function startingUpgradeSigil() {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Sigil</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
const allSigils = [...coreSigils, ...advancedSigils, ...passiveSigils];

const available = allSigils.filter(s => {
const totalLevel = (S.sig[s] || 0) + (S.tempSigUpgrades[s] || 0);
return totalLevel < 4;
});

if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">All sigils maxed!</p>`;
} else {
const actives = [...coreSigils, ...advancedSigils];

const renderSigilChoices = (sigils, categoryName, categoryColor) => {
const availableInCategory = sigils.filter(s => available.includes(s));
if(availableInCategory.length === 0) return '';
let categoryHtml = `<h3 style="color:${categoryColor};margin:1rem 0 0.5rem 0;font-size:1rem">${categoryName}</h3>`;
availableInCategory.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const isActive = actives.includes(sig);
const displayLevel = (isActive && level === 0) ? 1 : level;
const nextDisplayLevel = displayLevel + 1;
const anyHeroHasSigil = S.heroes.some(hero => hero.s.includes(sig) || (hero.ts && hero.ts.includes(sig)));
const newSigilNote = !anyHeroHasSigil ? `<br><span style="color:#dc2626;font-size:0.85rem">*No hero has this yet!</span>` : '';
categoryHtml += `<div class="choice" onclick="startingUpSigil('${sig}')"><strong>${sigilIcon(sig)} L${displayLevel} ‚Üí L${nextDisplayLevel}</strong>${newSigilNote}</div>`;
});
return categoryHtml;
};

html += renderSigilChoices(coreSigils, '‚öîÔ∏è Core Sigils', '#2c63c7');
html += renderSigilChoices(advancedSigils, 'üî• Advanced Sigils', '#f97316');
html += renderSigilChoices(passiveSigils, '‚ú® Passive Sigils', '#9333ea');
}
}
html += `<button class="btn secondary" onclick="showStartingSigilUpgradeMenu()">Back</button>`;
v.innerHTML = html;
}

function startingUpSigil(sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.tempSigUpgrades[sig] = (S.tempSigUpgrades[sig] || 0) + 1;
toast(`${sig} upgraded!`);
upd();
startingUpgradeSigil();
}

function startingAddSigilToHero() {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to Hero</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a hero:</p><div style="max-width:400px;margin:0 auto">`;
S.heroes.forEach((h, idx) => {
const sigilInfo = `<br><span style="font-size:0.75rem;opacity:0.8">Current: ${h.s.join(', ')}</span>`;
html += renderHeroCard(h, idx, `startingSelectHeroForSigil(${idx})`, sigilInfo);
});
html += '</div>';
}
html += `<button class="btn secondary" onclick="showStartingSigilUpgradeMenu()">Back</button>`;
v.innerHTML = html;
}

function startingSelectHeroForSigil(heroIdx) {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
const allSigils = [...coreSigils, ...advancedSigils, ...passiveSigils];
const available = allSigils.filter(sig => !h.s.includes(sig) && !(h.ts && h.ts.includes(sig)));
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Sigil to ${h.n}</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">${h.n} already has all sigils!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a sigil to add:</p>`;

const actives = [...coreSigils, ...advancedSigils];

const renderCategorySigils = (sigils, categoryName, categoryColor) => {
const availableInCategory = sigils.filter(s => available.includes(s));
if(availableInCategory.length === 0) return '';
let categoryHtml = `<h3 style="color:${categoryColor};margin:1rem 0 0.5rem 0;font-size:1rem">${categoryName}</h3>`;
availableInCategory.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const isActive = actives.includes(sig);
const displayLevel = (isActive && level === 0) ? 1 : level;
const levelText = (level === 0 && !isActive) ? `L${displayLevel} (Passive only)` : `L${displayLevel}`;
const anyHeroHasSigil = S.heroes.some(hero => hero.s.includes(sig) || (hero.ts && hero.ts.includes(sig)));
const newSigilNote = !anyHeroHasSigil ? `<span style="color:#dc2626;font-size:0.85rem"> *No hero has this yet!</span>` : '';
categoryHtml += `<div class="choice" onclick="startingAddSigilConfirm(${heroIdx}, '${sig}')">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">(${levelText})</span>${newSigilNote}
</div>`;
});
return categoryHtml;
};

html += renderCategorySigils(coreSigils, '‚öîÔ∏è Core Sigils', '#2c63c7');
html += renderCategorySigils(advancedSigils, 'üî• Advanced Sigils', '#f97316');
html += renderCategorySigils(passiveSigils, '‚ú® Passive Sigils', '#9333ea');
}
html += `<button class="btn secondary" onclick="startingAddSigilToHero()">Back</button>`;
v.innerHTML = html;
}

function startingAddSigilConfirm(heroIdx, sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
const h = S.heroes[heroIdx];
if(!h.ts) h.ts = [];
h.ts.push(sig);
toast(`${h.n} learned ${sig}!`);
upd();
startingAddSigilToHero();
}

function levelUpMenu() {
// First-time tutorial: multi-modal popup explaining all options
if(!S.tutorialFlags.levelup_intro) {
S.tutorialFlags.levelup_intro = true;
showLevelUpIntroTutorial();
return;
}
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="addActiveToHero()">Add Active Sigil to Hero</div>
<div class="choice" onclick="upgradeActiveSigil()">Upgrade Active Sigil (All Heroes)</div>
<div class="choice" onclick="upgradePassiveSigil()">Add/Upgrade Passive Sigil (All Heroes)</div>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<button class="btn secondary" onclick="levelUp()">Back</button>`;
}

// Multi-modal tutorial for first-time level-up
function showLevelUpIntroTutorial() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="tutorial-modal-backdrop" onclick="event.stopPropagation()">
<div class="tutorial-modal" style="max-width:550px;text-align:left">
<h2 style="text-align:center;color:#22c55e;margin-bottom:1rem">Level Up!</h2>
<p style="text-align:center;margin-bottom:1.5rem;font-size:1rem">Nice! You earned enough XP for your first upgrade! Here are your options:</p>

<div style="background:rgba(59,130,246,0.1);border:2px solid #3b82f6;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem">
<h4 style="color:#3b82f6;margin:0 0 0.25rem 0;font-size:0.95rem">1. Add Active Sigil to Hero</h4>
<p style="font-size:0.85rem;margin:0;line-height:1.3">Teach a hero a NEW ability they don't have yet.<br><em>Example: Give your Tank the Grapple sigil to stun enemies!</em></p>
</div>

<div style="background:rgba(34,197,94,0.1);border:2px solid #22c55e;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem">
<h4 style="color:#22c55e;margin:0 0 0.25rem 0;font-size:0.95rem">2. Upgrade Active Sigil (All Heroes)</h4>
<p style="font-size:0.85rem;margin:0;line-height:1.3">Make an active sigil stronger for EVERYONE who has it.<br><em>Example: Attack L2 = 2 hits, Shield L2 = 4√óPOW shields!</em></p>
</div>

<div style="background:rgba(147,51,234,0.1);border:2px solid #9333ea;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem">
<h4 style="color:#9333ea;margin:0 0 0.25rem 0;font-size:0.95rem">3. Add/Upgrade Passive Sigil (All Heroes)</h4>
<p style="font-size:0.85rem;margin:0;line-height:1.3">Passives (Expand, Asterisk, Star) work automatically for ALL heroes!<br><em>Example: Expand +1 = all heroes can target one extra enemy/ally!</em></p>
</div>

<div style="background:rgba(249,115,22,0.1);border:2px solid #f97316;border-radius:8px;padding:0.75rem;margin-bottom:1rem">
<h4 style="color:#f97316;margin:0 0 0.25rem 0;font-size:0.95rem">4. Upgrade Hero Stats</h4>
<p style="font-size:0.85rem;margin:0;line-height:1.3">Add +1 POW or +5 HP to a hero of your choice.<br><em>Great for boosting your key damage dealer or keeping tanks alive!</em></p>
</div>

<button class="btn" onclick="showLevelUpMenuAfterTutorial()" style="width:100%;margin-top:0.5rem">Got it! Show me the options</button>
</div>
</div>`;
}

function showLevelUpMenuAfterTutorial() {
const v = document.getElementById('gameView');
const cost = getXPCost(S.levelUpCount);
v.innerHTML = `
<h2 style="text-align:center;margin-bottom:1rem">Spend XP</h2>
<p style="text-align:center;margin-bottom:1rem">Current: ${S.xp} XP | Cost: ${cost} XP</p>
<div class="choice" onclick="addActiveToHero()">Add Active Sigil to Hero</div>
<div class="choice" onclick="upgradeActiveSigil()">Upgrade Active Sigil (All Heroes)</div>
<div class="choice" onclick="upgradePassiveSigil()">Add/Upgrade Passive Sigil (All Heroes)</div>
<div class="choice" onclick="heroStats()">Upgrade Hero Stats</div>
<button class="btn secondary" onclick="levelUp()">Back</button>`;
}

// NEW: Add Active Sigil to Hero (only active sigils)
function addActiveToHero() {
showTutorialPop('levelup_add_active', "Teach a hero a NEW active ability! Heroes only get 1 action per turn, but more choices = more tactics. Pick a hero, then pick the sigil they'll learn!");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Active Sigil to Hero</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose a hero to teach a new ability:</p><div style="max-width:400px;margin:0 auto">`;
S.heroes.forEach((h, idx) => {
const sigilInfo = `<br><span style="font-size:0.75rem;opacity:0.8">Current: ${h.s.join(', ')}</span>`;
html += renderHeroCard(h, idx, `selectHeroForActiveSigil(${idx})`, sigilInfo);
});
html += '</div>';
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function selectHeroForActiveSigil(heroIdx) {
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
const h = S.heroes[heroIdx];
const activeSigils = ['Attack', 'Shield', 'Heal', 'D20', 'Ghost', 'Alpha', 'Grapple'];
const available = activeSigils.filter(sig => !h.s.includes(sig) && !(h.ts && h.ts.includes(sig)));
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add Active Sigil to ${h.n}</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">${h.n} already has all active sigils!</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:1rem;font-size:0.9rem">Choose an active sigil to learn:</p>`;
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];

const renderActiveSigils = (sigils, categoryName, categoryColor) => {
const availableInCategory = sigils.filter(s => available.includes(s));
if(availableInCategory.length === 0) return '';
let categoryHtml = `<h3 style="color:${categoryColor};margin:1rem 0 0.5rem 0;font-size:1rem">${categoryName}</h3>`;
availableInCategory.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const displayLevel = level === 0 ? 1 : level;
categoryHtml += `<div class="choice" onclick="confirmAddActiveSigil(${heroIdx}, '${sig}')">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">(L${displayLevel})</span>
</div>`;
});
return categoryHtml;
};

html += renderActiveSigils(coreSigils, '‚öîÔ∏è Core Sigils', '#2c63c7');
html += renderActiveSigils(advancedSigils, 'üî• Advanced Sigils', '#f97316');
}
html += `<button class="btn secondary" onclick="addActiveToHero()">Back</button>`;
v.innerHTML = html;
}

function confirmAddActiveSigil(heroIdx, sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
const h = S.heroes[heroIdx];
if(h.s.includes(sig) || (h.ts && h.ts.includes(sig))) { toast(`${h.n} already has ${sig}!`); return; }
S.xp -= cost;
S.levelUpCount++;
if(!h.ts) h.ts = [];
h.ts.push(sig);
h.ts = sortSigils(h.ts);
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const displayLevel = totalLevel === 0 ? 1 : totalLevel;
toast(`${h.n} learned ${sig} (L${displayLevel})!`);
upd();
saveGame();
levelUpMenu();
}

// NEW: Upgrade Active Sigil (All Heroes)
function upgradeActiveSigil() {
showTutorialPop('levelup_upgrade_active', "Upgrading an active sigil makes it MORE POWERFUL for every hero who has it! For example, Attack L2 = hit twice, Shield L2 = 4√óPOW shields!");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Active Sigil</h2>
<p style="text-align:center;margin-bottom:0.5rem">Cost: ${cost} XP</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.85rem;opacity:0.8">Upgrades apply to ALL heroes who have this sigil!</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
const activeSigils = ['Attack', 'Shield', 'Heal', 'D20', 'Ghost', 'Alpha', 'Grapple'];
const available = activeSigils.filter(s => {
const totalLevel = (S.sig[s] || 0) + (S.tempSigUpgrades[s] || 0);
return totalLevel < 4;
});

if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">All active sigils maxed!</p>`;
} else {
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];

const renderUpgradeSigils = (sigils, categoryName, categoryColor) => {
const availableInCategory = sigils.filter(s => available.includes(s));
if(availableInCategory.length === 0) return '';
let categoryHtml = `<h3 style="color:${categoryColor};margin:1rem 0 0.5rem 0;font-size:1rem">${categoryName}</h3>`;
availableInCategory.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const displayLevel = level === 0 ? 1 : level;
const nextDisplayLevel = displayLevel + 1;
const anyHeroHasSigil = S.heroes.some(hero => hero.s.includes(sig) || (hero.ts && hero.ts.includes(sig)));
const heroNote = !anyHeroHasSigil ? `<br><span style="color:#dc2626;font-size:0.85rem">*No hero has this yet!</span>` : '';
categoryHtml += `<div class="choice" onclick="confirmUpgradeActive('${sig}')"><strong>${sigilIcon(sig)} L${displayLevel} ‚Üí L${nextDisplayLevel}</strong>${heroNote}</div>`;
});
return categoryHtml;
};

html += renderUpgradeSigils(coreSigils, '‚öîÔ∏è Core Sigils', '#2c63c7');
html += renderUpgradeSigils(advancedSigils, 'üî• Advanced Sigils', '#f97316');
}
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function confirmUpgradeActive(sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
if(totalLevel >= 4) { toast(`${sig} is already maxed!`); return; }
S.xp -= cost;
S.levelUpCount++;
S.tempSigUpgrades[sig] = (S.tempSigUpgrades[sig] || 0) + 1;
const newLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const displayLevel = newLevel === 0 ? 1 : newLevel;
toast(`${sig} upgraded to L${displayLevel}!`);
upd();
saveGame();
levelUpMenu();
}

// NEW: Add/Upgrade Passive Sigil (All Heroes)
function upgradePassiveSigil() {
showTutorialPop('levelup_upgrade_passive', "Passive sigils (Expand, Asterisk, Star) work AUTOMATICALLY for ALL heroes! They enhance your existing actions without needing to click them.");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Add/Upgrade Passive Sigil</h2>
<p style="text-align:center;margin-bottom:0.5rem">Cost: ${cost} XP</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.85rem;opacity:0.8">Passive sigils automatically benefit ALL heroes!</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
const available = passiveSigils.filter(s => {
const totalLevel = (S.sig[s] || 0) + (S.tempSigUpgrades[s] || 0);
return totalLevel < 4;
});

if(available.length === 0) {
html += `<p style="text-align:center;margin-bottom:1rem">All passive sigils maxed!</p>`;
} else {
html += `<div style="background:rgba(147,51,234,0.1);border:2px solid #9333ea;border-radius:8px;padding:1rem;margin-bottom:1rem">
<h3 style="color:#9333ea;margin:0 0 0.5rem 0;font-size:1rem">‚ú® Passive Sigils</h3>
<p style="font-size:0.85rem;margin:0;line-height:1.4"><strong>Expand:</strong> +1 target for Attack/Shield/Heal<br><strong>Asterisk:</strong> Next action triggers multiple times<br><strong>Star:</strong> Multiply XP earned in combat</p>
</div>`;

available.forEach(sig => {
const level = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
const isNew = level === 0;
const displayText = isNew ? `Add ${sig}` : `${sig} L${level} ‚Üí L${level + 1}`;
html += `<div class="choice" onclick="confirmUpgradePassive('${sig}')"><strong>${sigilIcon(sig)} ${displayText}</strong></div>`;
});
}
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function confirmUpgradePassive(sig) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
const totalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
if(totalLevel >= 4) { toast(`${sig} is already maxed!`); return; }
S.xp -= cost;
S.levelUpCount++;
S.tempSigUpgrades[sig] = (S.tempSigUpgrades[sig] || 0) + 1;
const newLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
toast(`${sig} ${newLevel === 1 ? 'added' : 'upgraded to L' + newLevel}! All heroes benefit!`);
upd();
saveGame();
levelUpMenu();
}

function heroStats() {
showTutorialPop('levelup_stat_upgrade', "This one is pretty straightforward - add +1 POW or +5 HP to a hero of your choice.");
const cost = getXPCost(S.levelUpCount);
const v = document.getElementById('gameView');
let html = `<h2 style="text-align:center;margin-bottom:1rem">Upgrade Hero Stats</h2>
<p style="text-align:center;margin-bottom:1rem">Cost: ${cost} XP</p>`;
if(S.xp < cost) {
html += `<p style="text-align:center;margin-bottom:1rem;color:#b64141">Not enough XP!</p>`;
} else {
S.heroes.forEach((h, idx) => {
html += `<div class="choice" onclick="upPow(${idx})"><strong>${h.n} POW</strong> (${h.p} ‚Üí ${h.p+1})</div>`;
html += `<div class="choice" onclick="upHP(${idx})"><strong>${h.n} HP</strong> (${h.m} ‚Üí ${h.m+5})</div>`;
});
}
html += `<button class="btn secondary" onclick="levelUpMenu()">Back</button>`;
v.innerHTML = html;
}

function upPow(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].p++;
toast(`${S.heroes[idx].n} POW +1!`);
upd();
saveGame();
levelUpMenu();
}

function upHP(idx) {
const cost = getXPCost(S.levelUpCount);
if(S.xp < cost) return;
S.xp -= cost;
S.levelUpCount++;
S.heroes[idx].m += 5;
S.heroes[idx].h += 5;
if(S.heroes[idx].ls) {
S.heroes[idx].ls = false;
S.heroes[idx].lst = 0;
S.heroes[idx].h = 5;
toast(`${S.heroes[idx].n} revived with 5 HP!`);
} else toast(`${S.heroes[idx].n} HP +5!`);
upd();
saveGame();
levelUpMenu();
}


// ===== NEUTRAL DECK SYSTEM =====
function initNeutralDeck() {
S.neutralDeck = [
'shopkeeper1', 'wishingwell1', 'treasurechest1',
'wizard1', 'oracle1', 'encampment1',
'gambling1', 'ghost1', 'royal1'
];
S.lastNeutral = null;
}

function getNeutralEncounter() {
// TUTORIAL: Floor 2 always gets Oracle Stage 1
if(S.floor === 2 && !S.tutorialFlags.neutral_intro) {
return 'oracle1';
}

// Level 18: Prioritize Stage 2s
if(S.floor === 18) {
const stage2s = S.neutralDeck.filter(n => n.includes('2'));
if(stage2s.length > 0) {
const pick = stage2s[Math.floor(Math.random() * stage2s.length)];
return pick;
}
}

// Filter out last neutral for back-to-back prevention
let available = S.neutralDeck;
if(S.lastNeutral) {
const base = S.lastNeutral.replace(/[12]$/, '');
available = available.filter(n => !n.startsWith(base));
}

// Floor 10: NEVER allow Enemy Encampment (Floor 11 is always ambush)
if(S.floor === 10) {
available = available.filter(n => !n.startsWith('encampment'));
}

if(available.length === 0) {
available = S.neutralDeck;
}

const pick = available[Math.floor(Math.random() * available.length)];
S.lastNeutral = pick;
return pick;
}

function removeNeutralFromDeck(base) {
S.neutralDeck = S.neutralDeck.filter(n => !n.startsWith(base));
}

function replaceStage1WithStage2(base) {
S.neutralDeck = S.neutralDeck.filter(n => n !== `${base}1`);
S.neutralDeck.push(`${base}2`);
}

// ===== D20 ROLLS FOR NEUTRALS =====
function rollD20Neutral() {
// Include both permanent AND temporary upgrades for neutral D20 rolls
const d20Level = ((S.sig.D20 || 0) + (S.tempSigUpgrades.D20 || 0)) || 1;
// TUTORIAL: Explain D20 level affects neutral rolls
showTutorialPop('neutral_d20_level', "These D20 checks use the same Level as your D20 sigil from combat - leveling it up improves your odds everywhere!");
return rollDice(d20Level, 20);
}

function showD20Result(rolls, best) {
// Visual dice display with highlighted best roll - improved contrast
const diceHTML = rolls.map(r => {
const isBest = r === best;
return `<span style="display:inline-block;width:2.5rem;height:2.5rem;line-height:2.5rem;text-align:center;background:${isBest ? '#166534' : '#1e293b'};border:2px solid ${isBest ? '#15803d' : '#475569'};border-radius:0.5rem;margin:0.2rem;font-weight:bold;color:${isBest ? '#bbf7d0' : '#f1f5f9'};font-size:1.2rem;${isBest ? 'box-shadow:0 0 12px rgba(22,163,74,0.6);' : ''}">${r}</span>`;
}).join(' ');
return `<div style="margin:0.5rem 0"><div style="font-size:0.9rem;margin-bottom:0.5rem;color:#666">Rolling ${rolls.length}d20:</div>${diceHTML}</div>`;
}

function formatD20Compact(rolls, best) {
// Compact dice display for toasts/combat - improved contrast
const diceHTML = rolls.map(r => {
const isBest = r === best;
return `<span style="display:inline-block;width:1.8rem;height:1.8rem;line-height:1.8rem;text-align:center;background:${isBest ? '#166534' : '#1e293b'};border:2px solid ${isBest ? '#15803d' : '#475569'};border-radius:0.4rem;margin:0 0.15rem;font-weight:bold;color:${isBest ? '#bbf7d0' : '#f1f5f9'};font-size:1rem;vertical-align:middle;${isBest ? 'box-shadow:0 0 8px rgba(22,163,74,0.6);' : ''}">${r}</span>`;
}).join('');
return diceHTML;
}

function buildNeutralHTML(options) {
const {
bgImage,
title,
description,
outcomes = [],
diceRoll = '',
buttons = '',
showStats = true
} = options;

let html = `<div class="neutral-container">`;

// Left side - Content
html += '<div class="neutral-left">';

// Header with stats and narrative
html += '<div class="neutral-header">';
if(showStats) {
html += `<div class="neutral-stats">üí∞ ${S.gold}G | üéØ Floor ${S.floor}</div>`;
}
html += '<div class="neutral-narrative">';
if(title) html += `<div class="neutral-title">${title}</div>`;
if(description) html += `<div class="neutral-desc">${description}</div>`;
if(diceRoll) html += `<div class="dice-roll">${diceRoll}</div>`;
outcomes.forEach(outcome => {
if(outcome) html += `<div class="neutral-outcome">${outcome}</div>`;
});
html += '</div></div>'; // close narrative and header

// Footer with buttons
if(buttons) {
html += `<div class="neutral-footer">${buttons}</div>`;
}

html += '</div>'; // close neutral-left

// Right side - Art
html += `<div class="neutral-right" style="background-image: url('${bgImage}')"></div>`;

html += '</div>'; // close container
return html;
}

// ===== MAIN TITLE PAGE =====
function mainTitlePage() {
debugLog('[FROGGLE] mainTitlePage START');
// Hide game header on title screen
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'none';

const v = document.getElementById('gameView');
debugLog('[FROGGLE] gameView element:', v);
// Check for old saves and migrate
migrateOldSave();
// If migration created slot 1 but currentSlot not set, set it
if(!S.currentSlot && localStorage.getItem('froggle8_permanent_slot1')) {
S.currentSlot = 1;
localStorage.setItem('froggle8_current_slot', '1');
debugLog('[SAVE] Set currentSlot to 1 after migration');
}
v.innerHTML = `
<div class="title-screen">
<!-- Background image - landscape for wide screens, portrait for narrow -->
<picture>
<source media="(min-aspect-ratio: 1/1)" srcset="assets/froggle_title_wide.jpeg">
<img src="assets/froggle_title.png" alt="FROGGLE" class="title-bg-image">
</picture>

<!-- Version badge -->
<div class="title-version">v${GAME_VERSION}</div>

<!-- Left side buttons stacked -->
<div class="title-button-container">
<button class="btn title-secondary-btn" onclick="showCredits()">Credits</button>
<button class="btn title-secondary-btn" onclick="openSettingsMenu()">Settings</button>
</div>
<!-- Play button on the right -->
<button class="btn title-play-btn" onclick="showSaveSlotSelection()">PLAY</button>
</div>`;
}

// Show credits screen
function showCredits() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;background:linear-gradient(180deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%);padding:1rem;overflow-y:auto">
<div style="background:rgba(255,255,255,0.95);border:4px solid #000;border-radius:16px;padding:2rem;max-width:500px;width:100%;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
<h2 style="text-align:center;margin:0 0 1rem 0;font-size:1.8rem;color:#4f46e5">üê∏ FROGGLE üê∏</h2>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.95rem;margin:0 0 0.25rem 0;color:#1e1b4b">A DubsPubs game by</p>
<p style="font-size:1.3rem;font-weight:bold;margin:0;color:#22c55e">Preston Wesley Evans</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.9rem;margin:0;color:#1e1b4b"><strong>Design, Art, & Code:</strong> Preston + Claude</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.85rem;margin:0 0 0.25rem 0;color:#6366f1;font-weight:bold">Playtesting</p>
<p style="font-size:0.85rem;margin:0;color:#4b5563;line-height:1.5">Michael Griffin, Charlie Schmidt, Carolyn Powell, Matt Sutz, Ryan Evertz, Noel McKillip, Ray Willess</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.85rem;margin:0 0 0.25rem 0;color:#6366f1;font-weight:bold">Inspiration</p>
<p style="font-size:0.85rem;margin:0;color:#4b5563">Inscryption, Slay the Spire, Balatro, and too much coffee</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.85rem;margin:0 0 0.25rem 0;color:#6366f1;font-weight:bold">Sanity</p>
<p style="font-size:0.85rem;margin:0;color:#4b5563">Erin Keif, Adal Rfai, JPC, Odell Brewing</p>
</div>

<div style="text-align:center;margin-bottom:1rem">
<p style="font-size:0.85rem;margin:0 0 0.25rem 0;color:#6366f1;font-weight:bold">Support</p>
<p style="font-size:0.85rem;margin:0;color:#4b5563">Lisa Evans</p>
</div>

<div style="text-align:center;margin-bottom:1rem;padding:0.5rem;background:#fef3c7;border-radius:8px">
<p style="font-size:0.8rem;margin:0;color:#92400e">Version ${GAME_VERSION}</p>
</div>

<button class="btn" onclick="mainTitlePage()" style="width:100%;background:#6366f1;border:3px solid #4f46e5;font-weight:bold">Back to Title</button>
</div>
</div>`;
}

// Show save slot selection screen
function showSaveSlotSelection() {
const v = document.getElementById('gameView');
const slot1 = getSlotMetadata(1);
const slot2 = getSlotMetadata(2);

v.innerHTML = `
<div style="height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#1a1a1a;padding:1rem;overflow:hidden;box-sizing:border-box">
<div style="background:#22c55e;border:4px solid #000;border-radius:12px;padding:1rem;max-width:500px;width:100%;box-shadow:0 8px 16px rgba(0,0,0,0.5)">
<h2 style="text-align:center;margin-bottom:1rem;font-size:1.3rem">Select Save Slot</h2>

<!-- Slot 1 -->
<div style="background:white;border:3px solid #000;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.25rem">
<h3 style="font-size:1.1rem;margin:0">Slot 1</h3>
</div>
${slot1.exists ? `
<div style="font-size:0.85rem;opacity:0.8;margin-bottom:0.5rem">
<div>üìä Runs: <strong>${slot1.runsAttempted}</strong> | üí∞ Rate: <strong>${slot1.goingRate}G</strong></div>
${slot1.hasActiveRun ? `<div style="color:#22c55e;font-weight:bold">üéÆ Active Run${slot1.activeFloor ? ` - Floor ${slot1.activeFloor}` : ''}</div>` : ''}
</div>
<div style="display:flex;gap:0.5rem">
<button class="btn" onclick="continueSlot(1)" style="flex:1;background:#22c55e;border:3px solid #16a34a;font-weight:bold;padding:0.5rem">${slot1.hasActiveRun ? '‚ñ∂Ô∏è Continue' : 'üÜï New Run'}</button>
<button class="btn secondary icon" onclick="confirmDeleteSlot(1)" style="padding:0.5rem">üóëÔ∏è</button>
</div>
` : `
<p style="opacity:0.6;margin-bottom:0.5rem;font-size:0.9rem">Empty Slot</p>
<button class="btn" onclick="createNewSlot(1)" style="width:100%;background:#3b82f6;border:3px solid #f97316;font-weight:bold;padding:0.5rem">üÜï New Game</button>
`}
</div>

<!-- Slot 2 -->
<div style="background:white;border:3px solid #000;border-radius:8px;padding:0.75rem;margin-bottom:0.75rem">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.25rem">
<h3 style="font-size:1.1rem;margin:0">Slot 2</h3>
</div>
${slot2.exists ? `
<div style="font-size:0.85rem;opacity:0.8;margin-bottom:0.5rem">
<div>üìä Runs: <strong>${slot2.runsAttempted}</strong> | üí∞ Rate: <strong>${slot2.goingRate}G</strong></div>
${slot2.hasActiveRun ? `<div style="color:#22c55e;font-weight:bold">üéÆ Active Run${slot2.activeFloor ? ` - Floor ${slot2.activeFloor}` : ''}</div>` : ''}
</div>
<div style="display:flex;gap:0.5rem">
<button class="btn" onclick="continueSlot(2)" style="flex:1;background:#22c55e;border:3px solid #16a34a;font-weight:bold;padding:0.5rem">${slot2.hasActiveRun ? '‚ñ∂Ô∏è Continue' : 'üÜï New Run'}</button>
<button class="btn secondary icon" onclick="confirmDeleteSlot(2)" style="padding:0.5rem">üóëÔ∏è</button>
</div>
` : `
<p style="opacity:0.6;margin-bottom:0.5rem;font-size:0.9rem">Empty Slot</p>
<button class="btn" onclick="createNewSlot(2)" style="width:100%;background:#3b82f6;border:3px solid #f97316;font-weight:bold;padding:0.5rem">üÜï New Game</button>
`}
</div>

<button class="btn secondary" onclick="mainTitlePage()" style="width:100%;padding:0.5rem">‚Üê Back</button>
</div>
</div>`;
}

// Continue/start a slot
function continueSlot(slot) {
const meta = getSlotMetadata(slot);
if(meta.hasActiveRun) {
// Load existing run
if(loadSlot(slot)) {
// Success - game already started
} else {
toast('Failed to load slot');
}
} else {
// Start new run in existing slot
S.runsAttempted = (meta.runsAttempted || 0) + 1;
newGameInSlot(slot);
}
}

// Create new game in empty slot
function createNewSlot(slot) {
S.currentSlot = slot;
localStorage.setItem('froggle8_current_slot', slot.toString());
S.runsAttempted = 1;
S.runNumber = 1;
newGame();
}

// Start new game in existing slot
function newGameInSlot(slot) {
S.currentSlot = slot;
localStorage.setItem('froggle8_current_slot', slot.toString());
S.runNumber = (S.runsAttempted || 1);
if(S.runNumber === 1 && !S.helpTipsDisabled) {
showTutorialStory();
} else {
title();
}
}

// Delete slot with confirmation
function confirmDeleteSlot(slot) {
showConfirmModal(`Delete Save Slot ${slot}? This cannot be undone!`, () => {
try {
localStorage.removeItem(`froggle8_slot${slot}`);
localStorage.removeItem(`froggle8_permanent_slot${slot}`);
toast(`Slot ${slot} deleted`);
showSaveSlotSelection(); // Refresh
} catch(e) {
toast('Failed to delete slot');
}
});
}

function newGame() {
// Reset runNumber to 1 for new game (allows tutorial to show)
S.runNumber = 1;
debugLog('[FROGGLE] newGame called - runNumber:', S.runNumber, 'helpTipsDisabled:', S.helpTipsDisabled);
if(S.runNumber === 1 && !S.helpTipsDisabled) {
debugLog('[FROGGLE] Showing tutorial story');
showTutorialStory();
} else {
debugLog('[FROGGLE] Skipping tutorial, going to title()');
title();
}
}

function loadGameFromTitle() {
const s = localStorage.getItem('froggle8');
if(s) {
loadGame();
} else {
toast('No saved game found!');
}
}

function exitGame() {
showConfirmModal('Thanks for playing FROGGLE! Close the window to exit.', () => {
window.close();
});
}

function exportSave() {
const saveData = localStorage.getItem('froggle8');
const permanentData = localStorage.getItem('froggle8_permanent');
if(!saveData && !permanentData) {
toast('No save data to export!');
return;
}
const exportData = {
save: saveData ? JSON.parse(saveData) : null,
permanent: permanentData ? JSON.parse(permanentData) : null,
exportDate: new Date().toISOString(),
version: GAME_VERSION
};
const dataStr = JSON.stringify(exportData, null, 2);
const blob = new Blob([dataStr], {type: 'application/json'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `froggle-save-${new Date().toISOString().split('T')[0]}.json`;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);
toast('Save exported!');
}

function importSave() {
const input = document.createElement('input');
input.type = 'file';
input.accept = '.json';
input.onchange = (e) => {
const file = e.target.files[0];
if(!file) return;
const reader = new FileReader();
reader.onload = (event) => {
try {
const importData = JSON.parse(event.target.result);
if(importData.save) {
localStorage.setItem('froggle8', JSON.stringify(importData.save));
}
if(importData.permanent) {
localStorage.setItem('froggle8_permanent', JSON.stringify(importData.permanent));
}
toast('Save imported successfully!');
setTimeout(() => {
mainTitlePage();
}, 1000);
} catch(err) {
toast('Error: Invalid save file!');
console.error('Import error:', err);
}
};
reader.readAsText(file);
};
input.click();
}

// ===== NARRATIVE SLIDE SYSTEM =====
// Slides can have: text, html, bg (background image), buttonText
// If slide has 'bg' property, renders in full-art mode
function showNarrativeSlide(slides, currentIndex = 0) {
debugLog('[FROGGLE] showNarrativeSlide called - currentIndex:', currentIndex, 'total slides:', slides.length);
if(currentIndex >= slides.length) {
// All slides shown, call completion callback
debugLog('[FROGGLE] All slides complete, calling onComplete');
// Remove no-scroll class when narrative is done
const gameArea = document.getElementById('gameView');
if(gameArea) gameArea.classList.remove('no-scroll');
if(slides.onComplete) slides.onComplete();
return;
}

const slide = slides[currentIndex];
debugLog('[FROGGLE] Rendering slide', currentIndex);
const v = document.getElementById('gameView');
debugLog('[FROGGLE] gameView element:', v);
// Add no-scroll class to prevent scrolling on full-screen slides
v.classList.add('no-scroll');
const skipButton = slides.skippable ? `<button class="btn" onclick="skipTutorialFromSlide()" style="padding:0.75rem 1.5rem;background:rgba(100,100,100,0.8);border:2px solid #666;font-size:1rem">Skip</button>` : '';
debugLog('[FROGGLE] Setting innerHTML for slide', currentIndex);

// Full-art mode: background image takes up screen, text in bottom bar
if(slide.bg) {
v.innerHTML = `
<div style="position:relative;width:100%;height:calc(100vh - 44px);overflow:hidden">
<!-- Full-page background image -->
<img src="${slide.bg}" style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:0">

<!-- Text bar at bottom with gradient fade -->
<div style="position:absolute;bottom:0;left:0;right:0;z-index:10;background:linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.85) 60%, rgba(0,0,0,0.4) 85%, transparent 100%);padding:1.5rem 1rem 1rem 1rem">
<div style="max-width:700px;margin:0 auto">
${slide.html || `<div style="font-size:1.15rem;line-height:1.7;text-align:center;color:#fff;text-shadow:1px 1px 3px rgba(0,0,0,0.8)">${slide.text}</div>`}
<div style="display:flex;gap:1rem;justify-content:center;margin-top:1rem;flex-wrap:wrap">
<button class="btn" onclick="continueNarrative()" style="padding:0.75rem 2rem;font-size:1.1rem;background:#22c55e;border:2px solid #15803d">${slide.buttonText || 'Continue'}</button>
${skipButton}
</div>
<div style="text-align:center;margin-top:0.5rem;font-size:0.8rem;color:rgba(255,255,255,0.5)">‚í∂ to continue${slides.skippable ? ' ‚Ä¢ ‚í∑ to skip' : ''}</div>
</div>
</div>
</div>`;
} else {
// Standard mode: fullscreen centered content (no scrolling allowed)
v.innerHTML = `
<div style="width:100%;height:calc(100vh - 44px);display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden;padding:1rem">
<div style="max-width:600px;text-align:center">
${slide.html || `<div style="font-size:1.15rem;line-height:1.7;margin-bottom:1.5rem">${slide.text}</div>`}
<div style="display:flex;gap:1rem;justify-content:center;flex-wrap:wrap;margin-top:1rem">
<button class="btn" onclick="continueNarrative()" style="padding:0.75rem 2rem;font-size:1.1rem">${slide.buttonText || 'Continue'}</button>
${skipButton}
</div>
<div style="margin-top:0.75rem;font-size:0.85rem;opacity:0.6">‚í∂ to continue${slides.skippable ? ' ‚Ä¢ ‚í∑ to skip' : ''}</div>
</div>
</div>`;
}

window.currentNarrativeSlides = slides;
window.currentNarrativeIndex = currentIndex;
window.narrativeSlideShownAt = Date.now(); // Track when slide was shown for minimum display time
debugLog('[FROGGLE] Slide', currentIndex, 'rendered successfully');
}

function continueNarrative() {
// Enforce minimum 500ms display time to prevent accidental skips
if(window.narrativeSlideShownAt && Date.now() - window.narrativeSlideShownAt < 500) {
return; // Too soon, ignore the click
}

const slides = window.currentNarrativeSlides;
const currentSlide = slides[window.currentNarrativeIndex];
const nextIndex = window.currentNarrativeIndex + 1;

// Check if current slide has an action that needs to be handled
if(currentSlide && currentSlide.action && window.firstVictorySlideAction) {
const handled = window.firstVictorySlideAction(currentSlide.action, window.currentNarrativeIndex, () => {
// Action complete, continue to next slide
showNarrativeSlide(slides, nextIndex);
});
if(handled) return; // Action handler will call callback when done
}

showNarrativeSlide(slides, nextIndex);
}

function showSkipTutorialConfirmation(proceedCallback) {
// Show friendly skip confirmation with visual indicators for FAQ/Sigilarium
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:500px">
<h2 style="font-size:1.5rem;margin-bottom:1rem;text-align:center">Alright champ! üí™</h2>
<p style="font-size:1.1rem;line-height:1.6;text-align:center;margin-bottom:1.5rem">
You're on your own - get going and save Tapo!
</p>
<div style="background:rgba(59,130,246,0.1);border:2px solid #3b82f6;border-radius:12px;padding:1rem;margin-bottom:1.5rem">
<p style="font-size:0.95rem;line-height:1.5;text-align:center;margin-bottom:0.75rem">
Need help? Look for these buttons:
</p>
<div style="display:flex;justify-content:center;gap:1.5rem;flex-wrap:wrap">
<div style="text-align:center">
<div style="font-size:1.5rem;margin-bottom:0.25rem">üëá</div>
<div style="background:#f97316;color:white;padding:0.5rem 1rem;border-radius:8px;font-weight:bold;border:2px solid #000">‚ùì Help/FAQ</div>
</div>
<div style="text-align:center">
<div style="font-size:1.5rem;margin-bottom:0.25rem">üëá</div>
<div style="background:#9333ea;color:white;padding:0.5rem 1rem;border-radius:8px;font-weight:bold;border:2px solid #000">üìñ Sigilarium</div>
</div>
</div>
</div>
<p style="font-size:0.8rem;line-height:1.4;text-align:center;margin-bottom:1.5rem;opacity:0.7">
(Help/tips can be disabled in ‚öôÔ∏è Settings)
</p>
<button onclick="confirmSkipTutorial()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer;display:block;margin:0 auto">Let's go!</button>
</div>`;
document.body.appendChild(overlay);
window.skipTutorialProceedCallback = proceedCallback;
}

function confirmSkipTutorial() {
const overlay = document.querySelector('.tutorial-modal-backdrop');
if(overlay) overlay.remove();
if(window.skipTutorialProceedCallback) {
window.skipTutorialProceedCallback();
window.skipTutorialProceedCallback = null;
}
}

function skipTutorialFromSlide() {
// Show confirmation popup before skipping
showSkipTutorialConfirmation(() => {
// Remove no-scroll class when leaving narrative
const gameArea = document.getElementById('gameView');
if(gameArea) gameArea.classList.remove('no-scroll');
toast('Tutorial skipped!', ANIMATION_TIMINGS.TOAST_SHORT);
setTimeout(() => transitionScreen(showTitleCard), ANIMATION_TIMINGS.ACTION_COMPLETE);
});
}

// ===== RIBBLETON TUTORIAL INTRO =====
function showTutorialStory() {
debugLog('[FROGGLE] showTutorialStory START');
const slides = [
{
// Full-art: Ribbleton background with text overlay
bg: 'assets/ribbleton.png',
text: `Welcome to the beautiful, tranquil town of <strong style="color:#22c55e">Ribbleton</strong>.<br><br>Today is a very special day!! Why, you ask?`
},
{
// Tapo with birthday vibes - signature double jump + flip animation
html: `
<h2 style="font-size:1.8rem;margin-bottom:1rem">Today is <strong style="color:#22c55e">Tapo's First Birthday!</strong> üéÇ</h2>
<div style="animation:tapoSignature 4.8s ease-in-out infinite;display:inline-block;margin:1.5rem 0">
<img src="assets/tapo-nobg.png" style="width:170px;height:auto">
</div>
<p style="font-size:1.15rem;line-height:1.7;margin-top:1rem">The whole town is celebrating the little tadpole's special day!</p>
<style>
@keyframes tapoSignature {
  0% { transform: translateY(0) scaleX(1); }
  10% { transform: translateY(-25px) scaleX(1); }
  20% { transform: translateY(0) scaleX(1); }
  30% { transform: translateY(-35px) scaleX(1); }
  40% { transform: translateY(0) scaleX(1); }
  45% { transform: translateY(-10px) scaleX(0); }
  50% { transform: translateY(0) scaleX(-1); }
  60% { transform: translateY(-25px) scaleX(-1); }
  70% { transform: translateY(0) scaleX(-1); }
  80% { transform: translateY(-35px) scaleX(-1); }
  90% { transform: translateY(0) scaleX(-1); }
  95% { transform: translateY(-10px) scaleX(0); }
  100% { transform: translateY(0) scaleX(1); }
}
</style>
`
},
{
html: `
<h2 style="font-size:1.7rem;margin-bottom:1rem;color:#2c63c7">A Special Gift</h2>
<div style="display:flex;justify-content:center;align-items:center;gap:2rem;margin:1.5rem 0">
<div>
<img src="assets/characters/magefull.png" style="width:130px;height:auto;border-radius:8px;border:2px solid #22c55e;box-shadow:0 4px 8px rgba(0,0,0,0.2)">
<div style="margin-top:0.5rem;font-weight:bold;font-size:1rem">Mage</div>
</div>
<div style="font-size:2.5rem">üéÅ</div>
<div style="animation:tapoSignature 4.8s ease-in-out infinite">
<img src="assets/tapo-nobg.png" style="width:110px;height:auto">
<div style="margin-top:0.5rem;font-weight:bold;font-size:1rem">Tapo</div>
</div>
</div>
<p style="font-size:1.15rem;line-height:1.7;margin-top:1rem">
As a birthday gift, <strong>Mage</strong> promised to teach Tapo how to catch flies.
</p>
`
}
];
slides.skippable = true;
slides.onComplete = () => {
// Start Phase 1: Tapo's Birthday tutorial
startTaposBirthdayTutorial();

setTimeout(() => {
showTaposBirthdayOverlay();
}, 100);
};
debugLog('[FROGGLE] About to call showNarrativeSlide with', slides.length, 'slides');
showNarrativeSlide(slides, 0);
debugLog('[FROGGLE] showNarrativeSlide called');
}

function showTaposBirthdayOverlay() {
// Show Phase 1 narrative overlay
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:600px">
<p style="font-size:1.5rem;line-height:1.7;margin-bottom:2rem;text-align:center">
ü™∞ Here come three <strong>flies</strong> now - you're up! ü™∞
</p>
<button onclick="dismissTaposBirthdayOverlay()" style="padding:1rem 2.5rem;font-size:1.3rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer;display:block;margin:0 auto">Let's catch flies!</button>
</div>`;
document.body.appendChild(overlay);
}

function dismissTaposBirthdayOverlay() {
try {
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
allBackdrops.forEach(backdrop => backdrop.remove());
} catch (error) {
console.error('[TUTORIAL] Error removing Tapo birthday backdrops:', error);
}
// Show first tutorial popup - explain Expand from the start
showTutorialPop('tapo_first_attack', "Mage has two sigils: <strong>Attack</strong> (active) and <strong>Expand</strong> (passive). Active sigils require a click to use - you get one action per turn. Passive sigils work automatically! Expand gives +1 target to your actions. Click Attack and try hitting multiple flies!", () => {
tutorialState.stage = 'catching_flies';
// Mage is happy to teach Tapo to catch flies!
const mage = S.heroes.find(h => h.n === 'Mage');
if(mage) setHeroReaction(mage.id, 'happy', 2000);
render();
});
}

function startTaposBirthdayTutorial() {
// Phase 1: Mage vs 3 Flies - Mage starts with Attack and Expand (no D20, too confusing)
// NOTE: Permanent sigils (Asterisk/Star) are NOT added to Phase 1 tutorial
// to ensure consistent tutorial experience for all players
S.floor = 0;
S.xp = 0;
S.levelUpCount = 0;
// Initialize sigils to base levels for clean tutorial state
S.sig = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// Reset tutorial-specific flags to ensure popups show for fresh tutorial
S.tutorialFlags.tapo_first_attack = false;
// Force help tips enabled for tutorial (critical popups must show)
S.helpTipsDisabled = false;
console.log('[TUTORIAL] Phase 1 init - S.sig.Expand:', S.sig.Expand, 'helpTipsDisabled:', S.helpTipsDisabled);
S.heroes = [
{id:'h_tutorial_mage', n:'Mage', p:1, h:5, m:5, s:['Attack', 'Expand'], sh:0, g:0, ls:false, lst:0, ts:[], st:0}
];

// Initialize Phase 1 tutorial state
tutorialState = {
stage: 'waiting_for_start',
phase: 1, // Track which phase we're in
fliesKilled: 0,
round: 1
};

// Start combat with 3 Flies
combat(0);
}

// Tapo rescue sequence - called when Mage would die in Phase 1 tutorial
// Shows a narrative interstitial, then animates flies dying one by one
function showTapoRescueSequence() {
// Save reference to remaining flies for the death sequence
const remainingFlies = [...S.enemies];
const flyCount = remainingFlies.length;
const flyText = flyCount === 1 ? 'fly' : 'flies';

// Create narrative overlay explaining what happened
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:600px">
<div style="text-align:center">
<div style="font-size:4rem;margin-bottom:1rem;animation:tapoJump 0.6s ease-in-out infinite">üê∏</div>
<h2 style="color:#22c55e;margin-bottom:1rem">Tapo to the Rescue!</h2>
<p style="font-size:1.1rem;line-height:1.7;margin-bottom:1.5rem">
Just as the ${flyText} ${flyCount === 1 ? 'was' : 'were'} about to finish off Mage, <strong style="color:#22c55e">Tapo</strong> leaps into action!
<br><br>
His sticky tongue lashes out and <strong>swallows the ${flyText} whole!</strong>
<br><br>
<span style="font-size:0.9rem;opacity:0.8">(In normal combat, your hero would enter "Last Stand" mode - but Tapo's got your back for now!)</span>
</p>
<button onclick="continueTapoRescue()" style="padding:1rem 2.5rem;font-size:1.3rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer">
*ribbit* ü™∞
</button>
</div>
</div>
<style>
@keyframes tapoJump {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(-15px); }
}
</style>`;
document.body.appendChild(overlay);

// Store flies for death animation
window.tapoRescueFlies = remainingFlies;
}

// Continue after Tapo rescue narrative - animate flies dying
function continueTapoRescue() {
// Remove narrative overlay
const backdrops = document.querySelectorAll('.tutorial-modal-backdrop');
backdrops.forEach(b => b.remove());

// Play ribbit sound
SoundFX.play('ribbit');

// Get the saved flies
const flies = window.tapoRescueFlies || [];
window.tapoRescueFlies = null;

// Re-render combat view to show the battlefield
render();

// Kill flies one by one with staggered timing
flies.forEach((fly, index) => {
setTimeout(() => {
// Set fly HP to 0
fly.h = 0;
// Trigger knockout animation
if(typeof triggerKnockout === 'function') {
triggerKnockout(fly.id);
}
// Remove fly after animation
setTimeout(() => {
S.enemies = S.enemies.filter(e => e.id !== fly.id);
render();

// After last fly is removed, wait then proceed
if(index === flies.length - 1) {
setTimeout(() => {
// Show brief "battlefield clear" moment, then proceed
finishTaposBirthdayPhase();
}, 800); // Pause on empty battlefield
}
}, 300); // Death animation duration
}, index * 500); // Stagger each fly death by 500ms
});

// If no flies for some reason, just proceed
if(flies.length === 0) {
setTimeout(() => {
finishTaposBirthdayPhase();
}, 500);
}
}

function finishTaposBirthdayPhase() {
// Phase 1 victory celebration
const v = document.getElementById('gameView');
v.classList.add('no-scroll');
v.innerHTML = `
<div style="width:100%;height:calc(100vh - 44px);display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden;padding:1rem">
<div style="max-width:600px;text-align:center">
<h2 style="font-size:2rem;margin-bottom:1rem;color:#22c55e">Success!</h2>
<p style="font-size:1.2rem;line-height:1.7;margin:1rem 0">
Tapo squeals with delight as you knock the flies out of the air!<br>
Belly overflowing with delicious fresh flies, Mage and Tapo return to Ribbleton. üéâ
</p>
<button onclick="transitionToPortalInvasion()" style="padding:1rem 2rem;font-size:1.2rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer;margin-top:1.5rem">Continue</button>
</div>
</div>`;
}

function transitionToPortalInvasion() {
// Show portal opening narrative
const slides = [
{
html: `
<h2 style="font-size:1.8rem;margin-bottom:1rem;color:#dc2626;animation:shake 0.5s ease-in-out infinite">DANGER!</h2>
<div style="margin:1.5rem 0;position:relative">
<div style="width:160px;height:160px;margin:0 auto;position:relative;border-radius:50%;background:radial-gradient(circle, #dc2626, #7c2d12);animation:narrativePortalPulse 1s ease-in-out infinite;box-shadow:0 0 40px #dc2626"></div>
<div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:3.5rem;animation:spin 2s linear infinite">üåÄ</div>
</div>
<p style="font-size:1.1rem;line-height:1.7;margin:1rem 0">
As Mage and Tapo enter Ribbleton, something seems off..<br>
Whoa! <strong>A dark portal</strong> is open in the center of square!
</p>
<div style="display:flex;justify-content:center;gap:2rem;margin:1rem 0;font-size:2.5rem">
<div style="animation:enemyAppear 1s ease-out">üë∫</div>
<div style="animation:enemyAppear 1.3s ease-out">üê∫</div>
</div>
<style>
@keyframes shake {
0%, 100% { transform: translateX(0); }
25% { transform: translateX(-5px); }
75% { transform: translateX(5px); }
}
@keyframes narrativePortalPulse {
0%, 100% { transform: scale(1); opacity: 0.8; }
50% { transform: scale(1.1); opacity: 1; }
}
@keyframes spin {
from { transform: translate(-50%, -50%) rotate(0deg); }
to { transform: translate(-50%, -50%) rotate(360deg); }
}
@keyframes enemyAppear {
from { transform: scale(0) rotate(-180deg); opacity: 0; }
to { transform: scale(1) rotate(0deg); opacity: 1; }
}
</style>
`
}
];
slides.onComplete = () => {
// Start Phase 2: Portal Invasion
startRibbletonTutorial();

setTimeout(() => {
showTutorialStoryOverlay();
}, 100);
};
showNarrativeSlide(slides, 0);
}

function showTutorialStoryOverlay() {
// Show narrative on TOP of combat screen with Ribbleton background
const overlay = document.createElement('div');
overlay.className = 'tutorial-modal-backdrop';
overlay.style.cssText = 'background:none;';
overlay.innerHTML = `
<div style="position:relative;width:100%;height:100%;overflow:hidden">
<!-- Full-page Ribbleton background -->
<img src="assets/ribbleton.png" style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:0;filter:brightness(0.7)">

<!-- Content overlay -->
<div style="position:relative;z-index:10;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100%;padding:1rem">
<div style="background:rgba(0,0,0,0.85);border-radius:16px;padding:1.5rem;max-width:550px;border:3px solid #dc2626;box-shadow:0 0 30px rgba(220,38,38,0.5)">
<p style="font-size:1.1rem;line-height:1.6;margin-bottom:1.5rem;color:#fff;text-align:center">
Strange, hostile creatures spill out of the <strong style="color:#dc2626">portal</strong>. Tank rushes over to help protect Tapo. Take control of Warrior and Healer to fend them off!
</p>
<div style="display:grid;grid-template-columns:1fr auto 1fr;gap:1.5rem;align-items:center;margin:1.5rem 0">
<div style="display:flex;gap:0.5rem;align-items:center;justify-content:center">
<div style="animation:defensiveStance 1.5s ease-in-out infinite">
<img src="assets/characters/tankfull.png" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem;color:#22c55e">üõ° On Guard!</div>
</div>
<div style="text-align:center;animation:tapoSignatureSmall 4.8s ease-in-out infinite">
<img src="assets/tapo-nobg.png" style="width:60px;height:auto">
<div style="font-size:0.65rem;color:#22c55e;margin-top:0.25rem">Protected!</div>
</div>
<div style="animation:defensiveStance 1.3s ease-in-out infinite">
<img src="assets/characters/magefull.png" style="width:70px;height:auto;border-radius:6px;border:2px solid #22c55e">
<div style="text-align:center;font-size:0.65rem;font-weight:bold;margin-top:0.25rem;color:#22c55e">üìñ On Guard!</div>
</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.75rem;align-items:center;font-size:2.5rem">
<div style="animation:enemyThreat 1s ease-in-out infinite">üë∫</div>
<div style="animation:enemyThreat 1.2s ease-in-out infinite">üê∫</div>
</div>
<div style="display:flex;flex-direction:column;gap:0.5rem;align-items:center">
<div style="animation:chargeForward 0.8s ease-out infinite alternate">
<img src="assets/characters/warriorfull.png" style="width:80px;height:auto;border-radius:6px;border:2px solid #3b82f6;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem;color:#3b82f6">‚öîÔ∏è Attacking!</div>
</div>
<div style="animation:chargeForward 1s ease-out infinite alternate">
<img src="assets/characters/healerfull.png" style="width:80px;height:auto;border-radius:6px;border:2px solid #3b82f6;transform:scaleX(-1)">
<div style="text-align:center;font-size:0.7rem;font-weight:bold;margin-top:0.25rem;color:#3b82f6">‚úö Attacking!</div>
</div>
</div>
</div>
<p style="font-size:1rem;line-height:1.6;text-align:center;font-style:italic;color:rgba(255,255,255,0.9);margin-top:1rem">
Tank and Mage stand guard around Tapo while Warrior and Healer charge toward the portal!
</p>
<div style="margin-top:1.5rem;display:flex;gap:1rem;justify-content:center;flex-wrap:wrap">
<button onclick="dismissStoryOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#22c55e;color:#fff;border:2px solid #15803d;border-radius:8px;cursor:pointer">Let's fight!</button>
<button onclick="skipTutorialFromOverlay()" style="padding:0.75rem 2rem;font-size:1.1rem;font-weight:bold;background:#666;color:#fff;border:2px solid #444;border-radius:8px;cursor:pointer">Skip Tutorial</button>
</div>
</div>
</div>
</div>
<style>
@keyframes chargeForward {
0% { transform: translateX(0) scale(1); }
100% { transform: translateX(15px) scale(1.05); }
}
@keyframes defensiveStance {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(-5px); }
}
@keyframes enemyThreat {
0%, 100% { transform: scale(1) rotate(0deg); }
50% { transform: scale(1.2) rotate(10deg); }
}
@keyframes tapoSignatureSmall {
  /* Double jump RIGHT */
  0% { transform: translateY(0) scaleX(1); }
  10% { transform: translateY(-15px) scaleX(1); }
  20% { transform: translateY(0) scaleX(1); }
  30% { transform: translateY(-20px) scaleX(1); }
  40% { transform: translateY(0) scaleX(1); }
  /* Flip to LEFT */
  45% { transform: translateY(-5px) scaleX(0); }
  50% { transform: translateY(0) scaleX(-1); }
  /* Double jump LEFT */
  60% { transform: translateY(-15px) scaleX(-1); }
  70% { transform: translateY(0) scaleX(-1); }
  80% { transform: translateY(-20px) scaleX(-1); }
  90% { transform: translateY(0) scaleX(-1); }
  /* Flip back to RIGHT */
  95% { transform: translateY(-5px) scaleX(0); }
  100% { transform: translateY(0) scaleX(1); }
}
</style>`;
document.body.appendChild(overlay);
}

function dismissStoryOverlay() {
debugLog('[TUTORIAL] Dismissing story overlay');
// Remove ALL backdrops before showing the tutorial pop
try {
const allBackdrops = document.querySelectorAll('.tutorial-modal-backdrop');
debugLog('[TUTORIAL] Found', allBackdrops.length, 'backdrops to remove');
allBackdrops.forEach((backdrop, idx) => {
debugLog('[TUTORIAL] Removing backdrop', idx);
backdrop.remove();
});
} catch (error) {
console.error('[TUTORIAL] Error removing story overlay backdrops:', error);
}

// Double-check they're gone
setTimeout(() => {
try {
const remaining = document.querySelectorAll('.tutorial-modal-backdrop');
debugLog('[TUTORIAL] Remaining overlays after dismiss:', remaining.length);
if(remaining.length > 0) {
console.error('[TUTORIAL] ERROR: Still have backdrops!', remaining);
remaining.forEach(r => r.remove());
}

// PROMPT 1: Warrior Attack + Targeting (BATCHED)
showTutorialPop('ribbleton_warrior_attack', "In FROGGLE, you'll usually control 2 heroes. Warrior hits harder than Mage! Click the Warrior's Attack sigil.", () => {
debugLog('[TUTORIAL] Prompt 1 dismissed - transitioning to warrior_attack stage');
tutorialState.stage = 'warrior_attack';
S.activeIdx = 0;
debugLog('[TUTORIAL] S.activeIdx is now:', S.activeIdx);
render();
});
} catch (error) {
console.error('[TUTORIAL] Error in story overlay cleanup:', error);
}
}, 50);
}

function skipTutorialFromOverlay() {
const overlay = document.querySelector('.tutorial-modal-backdrop');
if(overlay) overlay.remove();
// Show confirmation popup before skipping
showSkipTutorialConfirmation(() => {
toast('Tutorial skipped!', ANIMATION_TIMINGS.TOAST_SHORT);
setTimeout(() => transitionScreen(showTitleCard), ANIMATION_TIMINGS.ACTION_COMPLETE);
});
}

function skipTutorial() {
// This function is for legacy "skip tutorial" - just go to title
toast('Going to hero selection...');
title();
}

// ===== RIBBLETON TUTORIAL (PHASE 2) =====
function startRibbletonTutorial() {
// Phase 2: Portal Invasion - Wolf and Goblin fight with Warrior and Healer
S.floor = 0;
S.xp = 0;
S.levelUpCount = 0;
S.heroes = [
{id:'h_tutorial_warrior', n:'Warrior', p:2, h:5, m:5, s:['Attack','D20'], sh:0, g:0, ls:false, lst:0, ts:[], st:0},
{id:'h_tutorial_healer', n:'Healer', p:1, h:5, m:5, s:['Heal','D20','Expand'], sh:0, g:0, ls:false, lst:0, ts:[], st:0}
];

// Add permanently upgraded passives (Expand, Asterisk, Star) to tutorial heroes
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
S.heroes.forEach(hero => {
passiveSigils.forEach(passive => {
const permLevel = S.sig[passive] || 0;
if(permLevel > 0 && !hero.s.includes(passive)) {
hero.s.push(passive);
}
});
});

// Initialize Phase 2 tutorial state
tutorialState = {
stage: 'waiting_for_start',
phase: 2, // Phase 2: Portal Invasion
wolfDamaged: false,
wolfKilled: false,
goblinKilled: false,
round: 1
};

// Start combat using real combat system!
combat(0);
}


function finishRibbletonTutorial() {
// Post-combat narrative with full-art backgrounds
const slides = [
{bg: 'assets/ribbleton.png', text: "Scattered, the remaining enemies scamper back into the portal. The frog heroes unite, wipe their brows, and sheathe their weapons. <strong style='color:#22c55e'>Close call!</strong> At least Tapo is safe.... wait..."},
{bg: 'assets/ribbleton-tadpole.png', text: "A familiar squeal of delight pierces the air as Tapo crawls toward the portal. <strong style='color:#dc2626'>No, Tapo, don't go in there!!</strong>"},
{bg: 'assets/ribbleton.png', text: "But it is too late - the portal flares with <strong style='color:#9333ea'>dark energy</strong>. The heroes have no choice but to dive in after, to save their adorable little Tapo!"}
];
slides.onComplete = showTitleCard;
showNarrativeSlide(slides, 0);
}

function showTitleCard() {
const v = document.getElementById('gameView');
v.classList.add('no-scroll');
v.innerHTML = `
<div style="width:100%;height:calc(100vh - 44px);background:#000;display:flex;align-items:center;justify-content:center">
<div style="text-align:center;color:#fff">
<div style="font-size:3.5rem;font-weight:bold;margin-bottom:1rem">FROGGLE</div>
<div style="font-size:1.5rem;font-style:italic">A Froggy Roguelike</div>
</div>
</div>`;

setTimeout(() => {
tutorialState = null;
v.classList.remove('no-scroll');
showRibbleton(); // Go to Ribbleton hub
}, 3000); // Reduced from 5500ms to 3000ms for faster flow
}

// ===== TITLE & HERO SELECT =====
let selectedHeroView = null; // Track which hero card is currently displayed

function title() {
debugLog('[FROGGLE] title() called - Hero selection screen');
// Show header on hero selection
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';
// JUICE: Ambient music for title/hero select
ProceduralMusic.startAmbient();
upd();
// Reset selection first
sel = [];

const v = document.getElementById('gameView');
// Hero selection is a normal scrollable screen
v.classList.remove('no-scroll');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;

v.innerHTML = `
<h1 style="text-align:center;margin:0.75rem 0;font-size:1.8rem;color:${S.gameMode === 'fu' ? '#dc2626' : '#22c55e'}">${S.gameMode === 'fu' ? 'FROGGED UP üî•' : 'FROGGLE üê∏'}</h1>

<div style="max-width:600px;margin:0 auto;padding:0 0.5rem">
<h2 style="text-align:center;margin-bottom:0.5rem;font-size:1.1rem">Choose ${requiredHeroes} Heroes</h2>
<div id="hero-select-container" style="position:relative;max-width:100%;margin:0 auto;cursor:pointer" onclick="handleHeroImageClick(event, this)">
<img src="assets/hero-select.png" style="width:100%;height:auto;display:block;border-radius:8px;border:3px solid #000;pointer-events:none">
<!-- Controller-friendly hero selection buttons -->
<button type="button" class="hero-select-btn" data-hero="warrior" onclick="event.stopPropagation();toggleHeroSelection('warrior')" aria-label="Select Warrior"></button>
<button type="button" class="hero-select-btn" data-hero="tank" onclick="event.stopPropagation();toggleHeroSelection('tank')" aria-label="Select Tank"></button>
<button type="button" class="hero-select-btn" data-hero="mage" onclick="event.stopPropagation();toggleHeroSelection('mage')" aria-label="Select Mage"></button>
<button type="button" class="hero-select-btn" data-hero="healer" onclick="event.stopPropagation();toggleHeroSelection('healer')" aria-label="Select Healer"></button>
<!-- Hero card overlays -->
<div id="warrior-card" style="position:absolute;bottom:10%;left:1%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="tank-card" style="position:absolute;bottom:10%;left:26%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="mage-card" style="position:absolute;bottom:10%;left:51%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
<div id="healer-card" style="position:absolute;bottom:10%;left:76%;width:23%;display:none;z-index:10;pointer-events:none;"></div>
</div>

${S.tapoUnlocked ? `
<div style="margin-top:1rem;text-align:center">
<button class="btn" onclick="toggleHeroSelection('tapo')" style="background:linear-gradient(135deg,#3b82f6 0%,#22c55e 100%);padding:0.75rem 1.5rem;font-size:1rem;font-weight:bold;border:3px solid #000">
üéâ View Tapo (UNLOCKED!) üéâ
</button>
</div>` : ''}

<!-- Selection display -->
<div style="text-align:center;margin:0.5rem 0;padding:0.5rem;background:rgba(0,0,0,0.05);border-radius:6px">
<strong>Selected:</strong> <span id="selection-display" style="font-size:1rem;color:#2563eb"></span>
</div>

<button class="btn" id="start" onclick="start()" style="width:100%;padding:0.75rem;font-size:1rem">Delve into Floor 1</button>
</div>`;

debugLog('[FROGGLE] title() innerHTML set successfully');

// Update selection display
updateSelectionDisplay();
}

function handleHeroImageClick(event, container) {
// Validate inputs
if (!event || !container) {
console.warn('Invalid event or container, ignoring click');
return;
}

// Calculate which hero was clicked based on X position
const rect = container.getBoundingClientRect();
if (!rect) {
console.warn('Could not get container bounds, ignoring click');
return;
}

const x = event.clientX - rect.left;
const percent = (x / rect.width) * 100;

// Validate coordinates - if invalid, ignore the click
if (Number.isNaN(percent) || percent < 0 || percent > 100) {
console.warn('Invalid click coordinates, ignoring');
return;
}

// Determine hero based on position (4 equal 25% sections)
let heroType;
if (percent < 25) heroType = 'warrior';
else if (percent < 50) heroType = 'tank';
else if (percent < 75) heroType = 'mage';
else heroType = 'healer';

toggleHeroSelection(heroType);
}

function updateHeroCards() {
// Hero data matches H constant in constants.js
const heroData = {
warrior: {name: 'Warrior', pow: 2, hp: 5, maxhp: 5, sigils: ['Attack', 'D20'], bonus: '+1 POW'},
tank: {name: 'Tank', pow: 1, hp: 10, maxhp: 10, sigils: ['Attack', 'Shield', 'D20'], bonus: '+5 HP'},
mage: {name: 'Mage', pow: 1, hp: 5, maxhp: 5, sigils: ['Attack', 'D20', 'Expand'], bonus: '+1 Expand'},
healer: {name: 'Healer', pow: 1, hp: 5, maxhp: 5, sigils: ['Heal', 'D20', 'Expand'], bonus: '+1 Expand'},
tapo: {name: 'Tapo', pow: 1, hp: 1, maxhp: 1, sigils: ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha'], bonus: 'ALL sigils'}
};

// Update all card displays
['warrior', 'tank', 'mage', 'healer'].forEach(h => {
const cardEl = document.getElementById(`${h}-card`);
if(!cardEl) return;

if(sel.includes(h)) {
const hData = heroData[h];
const hPixelImage = HERO_IMAGES[h] || '';
const sigilsHTML = hData.sigils.map(s => {
const passiveClass = ['Expand', 'Asterisk', 'Star'].includes(s) ? 'passive' : '';
return `<span class="sigil l1 ${passiveClass}" style="font-size:0.7rem;padding:3px 5px;margin:1px;display:inline-block" onmouseenter="showTooltip('${s}', this, 1)" onmouseleave="hideTooltip()">${sigilIconOnly(s)}</span>`;
}).join('');
cardEl.innerHTML = `
<div style="background:white;border:3px solid #22c55e;border-radius:8px;padding:0.5rem;box-shadow:0 4px 6px rgba(0,0,0,0.3);pointer-events:auto;cursor:pointer"
onclick="event.stopPropagation();toggleHeroSelection('${h}')">
<div style="text-align:center">
<div style="font-size:0.8rem;font-weight:bold;margin-bottom:0.25rem">${hData.name}</div>
${hPixelImage ? `<img src="${hPixelImage}" style="width:100%;height:auto;border-radius:4px;margin-bottom:0.25rem">` : ''}
<div style="font-size:0.7rem;opacity:0.8">${hData.pow}‚ö° | ${hData.hp}‚ù§</div>
<div style="font-size:0.7rem;margin-top:0.25rem">${sigilsHTML}</div>
<div style="font-size:0.65rem;color:#22c55e;font-weight:bold;margin-top:0.25rem">${hData.bonus}</div>
<div style="font-size:0.55rem;opacity:0.7;margin-top:0.15rem">‚úì SELECTED</div>
</div>
</div>`;
cardEl.style.display = 'block';
} else {
cardEl.style.display = 'none';
}
});
}

function toggleHeroSelection(heroType) {
// Toggle selection
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
const isSelected = sel.includes(heroType);
if(isSelected) {
sel = sel.filter(h => h !== heroType);
SoundFX.play('click');
} else {
if(sel.length < requiredHeroes) {
sel.push(heroType);
SoundFX.play('hop'); // Froggy hop for hero selection
}
}

// Update card displays and selection display
updateHeroCards();
updateSelectionDisplay();
}


function updateSelectionDisplay() {
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
const display = document.getElementById('selection-display');
if(!display) return;

if(sel.length === 0) {
display.textContent = 'None';
display.style.color = '#6b7280';
} else {
const heroNames = sel.map(h => H[h].n);
display.textContent = heroNames.join(' + ');
display.style.color = '#2563eb';
}

const btn = document.getElementById('start');
if(btn) {
const isDisabled = sel.length !== requiredHeroes;
btn.disabled = isDisabled;
if(isDisabled) {
btn.classList.add('disabled');
} else {
btn.classList.remove('disabled');
}
btn.style.opacity = sel.length === requiredHeroes ? '1' : '0.4';
}
}

function toggleMode() {
S.gameMode = S.gameMode === 'Standard' ? 'fu' : 'Standard';
savePermanent();
title();
}

function pick(t) {
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
const i = sel.indexOf(t);
if(i>=0) {
sel.splice(i,1);
} else if(sel.length<requiredHeroes) {
sel.push(t);
} else {
toast(`Maximum ${requiredHeroes} heroes!`);
return;
}

// Update selection display
updateSelectionDisplay();
}

function start() {
const requiredHeroes = S.gameMode === 'fu' ? 3 : 2;
if(sel.length!==requiredHeroes) return;
// Show game header when entering gameplay
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';

S.floor=1; S.xp=0; S.levelUpCount=0;
// Reset temporary XP sigil upgrades (these don't persist between runs)
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
// Reset recruits from any previous run
S.recruits = [];
// NOTE: Gold persists between runs! Only reset on victory or spent at Death Screen
S.heroes = sel.map((t,i) => ({
id:`h-${crypto.randomUUID()}`,
n:H[t].n, p:H[t].p, h:H[t].h, m:H[t].m,
s:[...H[t].s], sh:0, g:0, ls:false, lst:0, ts:[], st:0
}));

// Add permanently upgraded passives (Expand, Asterisk, Star) to all heroes
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
S.heroes.forEach(hero => {
passiveSigils.forEach(passive => {
const permLevel = S.sig[passive] || 0;
// If this passive has been upgraded with gold (L1+) and hero doesn't have it, add it
if(permLevel > 0 && !hero.s.includes(passive)) {
hero.s.push(passive);
}
});
});

// Apply pedestal buffs
S.pedestal.forEach(slot => {
if(slot.mode !== S.gameMode) return; // Only apply buffs for current mode
const hero = S.heroes.find(h => h.n === slot.hero);
if(!hero) return;
if(slot.stat === 'POW') {
hero.p += 1;
} else if(slot.stat === 'HP') {
hero.m += 5;
hero.h += 5;
}
});
initNeutralDeck();
upd();
// Check if player has starting XP from Death Boy sacrifices
if(S.startingXP > 0) {
S.xp = S.startingXP;
showStartingXPScreen();
} else {
startFloor(1);
}
}


// ===== NEUTRAL ENCOUNTERS =====
// Neutral encounter display names for floor interstitials
const NEUTRAL_NAMES = {
shopkeeper1: 'Potions for Sale',
shopkeeper2: "Death's Bargain",
wishingwell1: 'The Old Wishing Well',
wishingwell2: 'Crystal Waters',
treasurechest1: 'A Mysterious Chest',
treasurechest2: 'The Silver Key',
wizard1: 'Trials of Arcane Power',
wizard2: 'The Hieroglyphs',
oracle1: 'Consult the Oracle',
oracle2: "The Oracle's Promise",
encampment1: 'Enemy Encampment',
encampment2: 'Abandoned Encampment',
gambling1: 'Between the 20s',
gambling2: 'Between the 20s Extreme',
ghost1: 'The Haunted Playroom',
ghost2: 'Passing On',
royal1: 'The Flummoxed Royal',
royal2: 'Royal Wedding'
};

function showNeutralInterstitial(f, encName, callback) {
const displayName = NEUTRAL_NAMES[encName] || encName;
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="position:fixed;top:0;left:0;width:100%;height:100vh;background:#000;display:flex;align-items:center;justify-content:center;z-index:30000">
<div style="text-align:center;color:#fff;animation:fadeIn 0.5s ease">
<div style="font-size:2.5rem;font-weight:bold;margin-bottom:1rem;font-family:'Fredoka One',cursive">Floor ${f}</div>
<div style="font-size:1.8rem;font-style:italic;font-family:'Fredoka One',cursive">${displayName}</div>
</div>
</div>
<style>
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
</style>`;
setTimeout(callback, T(ANIMATION_TIMINGS.FLOOR_INTERSTITIAL));
}

function neutral(f) {
console.log(`[FLOOR] neutral(${f}) called for neutral encounter`);
// Show header during neutral encounters
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';
// JUICE: Ambient music for neutral/exploration
ProceduralMusic.startAmbient();
upd();
// TUTORIAL: Show neutral intro on Floor 2
if(f === 2) {
showTutorialPop('neutral_intro', "Neutral floors offer choices and opportunities! You can walk straight through, or take a risk for potential rewards.");
}

const enc = getNeutralEncounter();

if(S.ghostBoysConverted && enc.startsWith('ghost')) {
showEmptyPlayroom();
return;
}

// Show interstitial then launch encounter
const launchEncounter = () => {
if(enc === 'shopkeeper1') showShopkeeper1();
else if(enc === 'shopkeeper2') showShopkeeper2();
else if(enc === 'wishingwell1') showWishingWell1();
else if(enc === 'wishingwell2') showWishingWell2();
else if(enc === 'treasurechest1') showTreasureChest1();
else if(enc === 'treasurechest2') showTreasureChest2();
else if(enc === 'wizard1') showWizard1();
else if(enc === 'wizard2') showWizard2();
else if(enc === 'oracle1') showOracle1();
else if(enc === 'oracle2') showOracle2();
else if(enc === 'encampment1') showEncampment1();
else if(enc === 'encampment2') showEncampment2();
else if(enc === 'gambling1') showGambling1();
else if(enc === 'gambling2') showGambling2();
else if(enc === 'ghost1') showGhost1();
else if(enc === 'ghost2') showGhost2();
else if(enc === 'royal1') showRoyal1();
else if(enc === 'royal2') showRoyal2();
else {
const v = document.getElementById('gameView');
v.innerHTML = `
<h2 style="text-align:center;margin:2rem 0">Floor ${f}</h2>
<p style="text-align:center;margin-bottom:2rem">${enc}</p>
<button class="btn" onclick="nextFloor()">Continue</button>`;
}
};

showNeutralInterstitial(f, enc, launchEncounter);
}

// ===== 1. SHOPKEEPER =====
function showShopkeeper1() {
// Reset shopkeeper state at start of each encounter (fixes bug where state persisted between runs)
shopSmallBought = false;
shopLargeBought = false;
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Potions for Sale',
description: 'A cheerful gnome stands behind a small cart laden with vials and bottles. Their voice is excited and earnest: "Healing Potions for sale!"',
buttons: `
<button class="neutral-btn safe" onclick="buySmallPotion()">Small Potion (3G) - Restore 3 HP</button>
<button class="neutral-btn safe" onclick="buyLargePotion()">Large Potion (5G) - Restore 8 HP</button>
<button class="neutral-btn secondary" onclick="declineShopkeeper()">Do Not Engage</button>
`
});
}

let shopSmallBought = false;
let shopLargeBought = false;

function buySmallPotion() {
if(S.gold < 3) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn" onclick="applySmallPotion(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Choose Hero',
description: 'Select a hero to restore 3 HP.',
buttons: heroButtons + `<button class="neutral-btn secondary" onclick="showShopkeeper1()">Back</button>`
});
}

function applySmallPotion(idx) {
S.gold -= 3;
const h = S.heroes[idx];
h.h = Math.min(h.h + 3, h.m);
upd();
toast(`${h.n} restored 3 HP!`);
shopSmallBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 1800);
}
showShopkeeper1();
}

function buyLargePotion() {
if(S.gold < 5) { toast('Not enough Gold!'); return; }
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn" onclick="applyLargePotion(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper1.png',
title: 'Choose Hero',
description: 'Select a hero to restore 8 HP.',
buttons: heroButtons + `<button class="neutral-btn secondary" onclick="showShopkeeper1()">Back</button>`
});
}

function applyLargePotion(idx) {
S.gold -= 5;
const h = S.heroes[idx];
h.h = Math.min(h.h + 8, h.m);
upd();
toast(`${h.n} restored 8 HP!`);
shopLargeBought = true;
if(shopSmallBought && shopLargeBought) {
replaceStage1WithStage2('shopkeeper');
toast('Death will remember this...', 1800);
}
showShopkeeper1();
}

function declineShopkeeper() {
shopSmallBought = false;
shopLargeBought = false;
nextFloor();
}

function showShopkeeper2() {
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const available = allSigils.filter(s => (S.sig[s] || 0) < 4);
const cost = S.goingRate;
let description = `The cheerful gnome shopkeeper has been replaced by an ominous figure: your old friend, Death. "I sent the kid home. Thanks for supporting my side hustle. I can keep this one off the books."<br><br><p style="text-align:center;font-weight:bold;margin:1rem 0">Cost: ${cost} Gold</p>`;
let buttons = '';
let outcomes = [];

if(available.length === 0) {
outcomes.push('All your sigils are already at maximum power. Death nods approvingly and fades away.');
buttons = `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else if(S.gold < cost) {
outcomes.push('<span style="color:#dc2626">"Darn. Not enough gold. Maybe next time, I guess?"</span>');
buttons = `<button class="btn" onclick="finishDeathsBargain()">Continue</button>`;
} else {
description += `<div style="font-size:0.9rem;margin-bottom:1rem">Choose one sigil to upgrade permanently (costs ${cost}G, Going Rate does NOT increase):</div>`;
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
available.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives.includes(sig);
// Actives display +1 (storage L0 = display L1)
const displayLevel = isActive ? permLevel + 1 : permLevel;
const nextDisplayLevel = displayLevel + 1;
buttons += `<div class="choice" onclick="acceptDeathsBargain('${sig}', ${cost})">
<strong>${sigilIcon(sig)}</strong> <span style="opacity:0.7">L${displayLevel} ‚Üí L${nextDisplayLevel}</span>
</div>`;
});
buttons += `<button class="btn risky" onclick="finishDeathsBargain()">Decline</button>`;
}

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/shopkeeper2.png',
title: 'Death\'s Bargain',
description,
outcomes,
buttons
});
}

function acceptDeathsBargain(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }
S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
// NOTE: Going Rate does NOT increase for Death's Bargain!
upd();
savePermanent();
toast(`${sig} permanently upgraded to L${S.sig[sig]}! (GR unchanged)`, 3000);
removeNeutralFromDeck('shopkeeper');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Good choice. See you soon."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}, 1000);
}

function finishDeathsBargain() {
removeNeutralFromDeck('shopkeeper');
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-outcome">"Shame. You don't get a chance like this every day. Oh well, it's your funeral."</div>
<div class="neutral-outcome">The shadows recede. The chamber returns to normal as you proceed to Floor ${S.floor + 1}.</div>
<button class="btn" onclick="nextFloor()">Continue</button>
</div>`;
}

// ===== 2. WISHING WELL =====
function showWishingWell1() {
const v = document.getElementById('gameView');
const buttons = `
<button class="btn risky" onclick="climbWell()">Climb down and get coins</button>
<button class="btn" onclick="tossWish()">Toss in a coin and make a wish</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'The Old Wishing Well',
description: 'An ancient stone well sits in the center of the chamber. You hear the faint sound of trickling water far below. A glint of gold catches your eye at the bottom.',
buttons
});
}

function climbWell() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
let goldGain = 0;
let hpLoss = 0;

if(best === 1) {
outcome = 'You lose your grip and plummet, smacking your head on the stone! The landing is brutal, and some coins get knocked out of your pouch.';
hpLoss = 3;
goldGain = -5;
} else if(best >= 2 && best <= 10) {
outcome = 'You climb carefully and manage to grab a single coin, but scrape yourself climbing out of the well.';
hpLoss = 1;
goldGain = 1;
} else if(best >= 11 && best <= 19) {
outcome = 'Your climbing skills are impressive! You retrieve a small cache of coins from the bottom.';
goldGain = 3;
} else if(best === 20) {
outcome = 'Your descent is flawless! At the bottom, you discover a hidden cache of coins. As you climb out, the well begins to fill with crystal-clear water!';
goldGain = 2 * S.heroes.length;
replaceStage1WithStage2('wishingwell');
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'Climbing the Well',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="applyWellClimb(${hpLoss}, ${goldGain})">Continue</button>`
});
}

function applyWellClimb(hpLoss, goldGain) {
if(hpLoss > 0) {
// Show hero selection screen
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="applyWellDamage(${idx}, ${hpLoss}, ${goldGain})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'Choose Who Takes Damage',
description: `Choose which hero takes ${hpLoss} damage from climbing the well:`,
buttons: heroButtons
});
} else {
// No damage, just apply gold
S.gold += goldGain;
if(S.gold < 0) S.gold = 0;
upd();
if(goldGain > 0) toast(`Gained ${goldGain} Gold!`);
else if(goldGain < 0) toast(`Lost ${Math.abs(goldGain)} Gold!`);
nextFloor();
}
}

function applyWellDamage(heroIdx, hpLoss, goldGain) {
const hero = S.heroes[heroIdx];
hero.h -= hpLoss;
if(hero.h <= 0 && !hero.ls) {
if(hero.g > 0) {
hero.g--;
hero.h += hpLoss;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
hero.h = 0;
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`, 3000);
}
}
toast(`${hero.n} took ${hpLoss} damage!`);

S.gold += goldGain;
if(S.gold < 0) S.gold = 0;
upd();
if(goldGain > 0) toast(`Gained ${goldGain} Gold!`);
else if(goldGain < 0) toast(`Lost ${Math.abs(goldGain)} Gold!`);
nextFloor();
}

function tossWish() {
const cost = S.heroes.length;
if(S.gold < cost) {
toast(`Need ${cost} Gold to make a wish!`);
return;
}
S.gold -= cost;
upd();
replaceStage1WithStage2('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell1.png',
title: 'A Wish Made',
outcomes: [`You toss ${cost} gold coin${cost>1?'s':''} into the well and make a silent wish. The water begins to glow softly, then surges upward, overflowing the well's edge!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showWishingWell2() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell2.png',
title: 'Overflowing Crystal Waters',
description: 'The well now overflows with sparkling, crystal-clear water that pools around its base. The water pulses with pure, restorative energy.',
buttons: `<button class="btn safe" onclick="drinkCrystalWater()">Drink from the well</button>`
});
}

function drinkCrystalWater() {
S.heroes.forEach(h => {
if(h.ls) {
h.ls = false;
h.lst = 0;
h.h = h.m;
toast(`${h.n} revived to full HP!`);
} else {
h.h = h.m;
}
});
toast('All heroes fully healed!', 1800);
removeNeutralFromDeck('wishingwell');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wishingwell2.png',
title: 'Fully Restored',
outcomes: [
'The water tastes impossibly pure and refreshing. Warmth spreads through your body as all wounds close and exhaustion fades. You feel completely restored.',
'The well\'s glow fades as the water recedes to its normal level. Its magic has been spent, for now.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 3. TREASURE CHEST =====
function showTreasureChest1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'A Mysterious Chest',
description: 'An unadorned wooden chest sits against the far wall, worn brass fittings gleaming in the torchlight. No lock is visible, but there are drops of blood around the chest.',
buttons: `
<button class="btn risky" onclick="openChest()">Open the chest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`
});
}

function openChest() {
const {rolls: trapRolls, best: trapBest} = rollD20Neutral();
const trapText = showD20Result(trapRolls, trapBest);

let trapOutcome = '';
let trapDmg = 0;
let secretFound = false;

if(trapBest === 1) {
trapOutcome = 'It\'s a trap! Thick, noxious smoke fills the chamber.';
trapDmg = 3;
} else if(trapBest >= 2 && trapBest <= 9) {
trapOutcome = 'It\'s a trap! A hidden dart flies from the wall and strikes you in the neck! Ouch.';
trapDmg = 1;
} else if(trapBest >= 10 && trapBest <= 18) {
trapOutcome = 'You carefully open the chest without triggering any traps.';
} else {
trapOutcome = 'You open the chest without issue. Your keen eyes spot a hidden compartment in the chest\'s lid!';
secretFound = true;
}

// Show trap result with Continue button
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Opening the Chest',
diceRoll: trapText,
outcomes: [trapOutcome],
buttons: `<button class="btn" onclick="openChestPart2(${trapDmg}, ${secretFound})">Continue</button>`
});
}

function openChestPart2(trapDmg, secretFound) {
setTimeout(() => {
const {rolls: contentRolls, best: contentBest} = rollD20Neutral();
const contentText = showD20Result(contentRolls, contentBest);

let contentOutcome = '';
let goldGain = 0;

if(contentBest >= 1 && contentBest <= 9) {
contentOutcome = 'The chest is empty. Someone got here first.';
} else if(contentBest >= 10 && contentBest <= 19) {
goldGain = Math.ceil(Math.random() * 10);
contentOutcome = `The chest contains a small stack of ${goldGain} gold coins!`;
} else {
goldGain = Math.ceil(Math.random() * 10) * S.heroes.length;
contentOutcome = `The chest is filled to the brim with ${goldGain} gold coins!`;
}

if(secretFound && contentBest >= 10) {
S.silverKeyHeld = true;
replaceStage1WithStage2('treasurechest');
contentOutcome += ' Inside the secret compartment, you find a small silver key!';
}

const v = document.getElementById('gameView');
if(trapDmg > 0) {
// Show hero selection for trap damage
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="finishChestOpen(${idx}, ${trapDmg}, ${goldGain})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Chest Contents',
description: `Choose which hero takes ${trapDmg} damage:`,
diceRoll: contentText,
outcomes: [contentOutcome],
buttons: heroButtons
});
} else {
// No trap damage, just show results and continue
S.gold += goldGain;
upd();
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest1.png',
title: 'Chest Contents',
diceRoll: contentText,
outcomes: [contentOutcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}, 0);
}

function finishChestOpen(heroIdx, trapDmg, goldGain) {
const hero = S.heroes[heroIdx];
hero.h -= trapDmg;
if(hero.h <= 0 && !hero.ls) {
if(hero.g > 0) {
hero.g--;
hero.h += trapDmg;
toast(`${hero.n}'s Ghost charge cancelled the lethal hit!`);
} else {
hero.h = 0;
hero.ls = true;
hero.lst = 0;
toast(`${hero.n} entered Last Stand!`, 3000);
}
}
toast(`${hero.n} took ${trapDmg} damage!`);

S.gold += goldGain;
upd();
nextFloor();
}

function showTreasureChest2() {
if(!S.silverKeyHeld) {
nextFloor();
return;
}
const goldGain = 10 * S.heroes.length;
S.gold += goldGain;
S.silverKeyHeld = false;
upd();
removeNeutralFromDeck('treasurechest');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/treasurechest2.png',
title: 'Small Silver Chest',
description: 'A small, beautifully-adorned silver chest sits on a stone pedestal. The silver keyhole is perfectly sized for the key you found earlier.',
outcomes: [`What a windfall! Gold coins overflow from the open chest. You gather and pocket ${goldGain} before moving on.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 4. MUMBLING WIZARD =====
function showWizard1() {
const v = document.getElementById('gameView');
let description = 'An elderly wizard stands with arms outstretched toward a wall covered in glowing hieroglyphs. He mutters to himself, but stops when you walk in. "Do you see it? CAN you see it? Look closely!" He pulls you toward the wall.<br><br>Choose which hero will approach the wizard:';
let buttons = '';
S.heroes.forEach((h, idx) => {
buttons += `<button class="neutral-btn safe" onclick="heroApproachesWizard(${idx})">${h.n}</button>`;
});
buttons += `<button class="btn secondary" onclick="nextFloor()">Do Not Engage</button>`;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'Hieroglyphs on the Wall',
description,
buttons
});
}

function heroApproachesWizard(heroIdx) {
const h = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= 1 && best <= 10) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText,
outcomes: [`${h.n} stares at the glowing symbols but can't make sense of them. The wizard sighs heavily: "You... you don't see it? Hmmm." The wizard turns back to the wall and continues mumbling to himself. He seems to have forgotten about you.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Non-starter sigil pool
const nonStarterPool = ['Alpha', 'Asterisk', 'Star', 'Grapple', 'Ghost'];

// Get sigils hero has from non-starter pool
const heroNonStarters = nonStarterPool.filter(sig => h.s.includes(sig) || (h.ts && h.ts.includes(sig)));

let chosenSigil;
if(heroNonStarters.length > 0) {
// Prioritize passives (Star, Asterisk, Ghost) if hero has any
const heroPassives = heroNonStarters.filter(sig => ['Star', 'Asterisk', 'Ghost'].includes(sig));
if(heroPassives.length > 0) {
// On natural 20, prioritize lower level sigils
if(best === 20) {
heroPassives.sort((a, b) => getLevel(a, heroIdx) - getLevel(b, heroIdx));
chosenSigil = heroPassives[0];
} else {
chosenSigil = heroPassives[Math.floor(Math.random() * heroPassives.length)];
}
} else {
// No passives, pick from actives hero has
if(best === 20) {
heroNonStarters.sort((a, b) => getLevel(a, heroIdx) - getLevel(b, heroIdx));
chosenSigil = heroNonStarters[0];
} else {
chosenSigil = heroNonStarters[Math.floor(Math.random() * heroNonStarters.length)];
}
}
} else {
// Hero has no non-starters, pick random from pool
chosenSigil = nonStarterPool[Math.floor(Math.random() * nonStarterPool.length)];
}

const currentLevel = getLevel(chosenSigil, heroIdx);
const bonusLevels = best === 20 ? 2 : 1;

// Check if hero has the sigil
const heroHasSigil = h.s.includes(chosenSigil) || (h.ts && h.ts.includes(chosenSigil));

if(!heroHasSigil) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText,
outcomes: [
`The hieroglyphs shift around, finally revealing the symbol for ${chosenSigil}! The wizard beams with pride.`,
`But ${h.n} doesn't possess this sigil. The wizard's face falls: "Ah, shame. Not the outcome I expected. Return when you have become more powerful."`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Hero has it! Grant temp upgrade
if(!h.ts) h.ts = [];
if(!h.ts.includes(chosenSigil)) h.ts.push(chosenSigil);

// Use tempSigUpgrades for temporary upgrades (not S.sig which is permanent!)
const oldTotalLevel = (S.sig[chosenSigil] || 0) + (S.tempSigUpgrades[chosenSigil] || 0);
S.tempSigUpgrades[chosenSigil] = (S.tempSigUpgrades[chosenSigil] || 0) + bonusLevels;
const newTotalLevel = oldTotalLevel + bonusLevels;

S.wizardHero = heroIdx;
S.wizardSigil = chosenSigil;

const critText = best === 20 ? ` <span style="color:#3b82f6;font-weight:bold">(CRITICAL!)</span>` : '';
toast(`${chosenSigil} temporarily upgraded to L${newTotalLevel} for ${h.n}!`, 1800);

replaceStage1WithStage2('wizard');
setTimeout(() => {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard1.png',
title: 'The Hieroglyphs',
diceRoll: rollText + critText,
outcomes: [
`The hieroglyph reveals itself as the symbol for ${chosenSigil}! "Yes! YES! You see! You understand!" The wizard touches the sigil, then reaches towards ${h.n}.`,
`${h.n} feels power surge through them. ${chosenSigil} temporarily upgraded from L${currentLevel} to L${currentLevel + bonusLevels}!`,
'"Your journey has just begun... Seek me again this night." He disappears.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}, 500);
}

function showWizard2() {
if(S.wizardHero === undefined || !S.wizardSigil) {
nextFloor();
return;
}

// Initialize wizard challenge state
if(!S.wizardChallenges) {
S.wizardChallenges = [5, 10, 15, 20];
S.wizardChallengeIndex = 0;
S.wizardUpgradedSigils = [];
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: 'Trials of Arcane Power',
description: 'The wizard\'s eyes gleam with arcane power: "You have returned! Just as I knew you would. You are ready now to face my trials. Each success earns you greater strength!"<br><br><div style="font-size:0.85rem;margin-top:1rem;color:#666">Four trials: DC 5, DC 10, DC 15, DC 20<br>Each success: Choose a sigil to upgrade temporarily<br>On failure: Keep all upgrades earned so far</div>',
buttons: `<button class="btn risky" onclick="startWizardChallenges()">Accept the Trials</button>
<button class="btn secondary" onclick="declineWizardChallenges()">Decline</button>`
});
}

function startWizardChallenges() {
attemptWizardChallenge();
}

function attemptWizardChallenge() {
const heroIdx = S.wizardHero;
const h = S.heroes[heroIdx];
const challengeIndex = S.wizardChallengeIndex;
const dc = S.wizardChallenges[challengeIndex];

const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best < dc) {
// Failed! Keep what you got
const upgradeCount = S.wizardUpgradedSigils.length;
let outcomeText = upgradeCount > 0
? `${h.n} earned ${upgradeCount} temporary upgrade${upgradeCount > 1 ? 's' : ''} before failing!`
: `${h.n} failed the first trial. No upgrades earned.`;

removeNeutralFromDeck('wizard');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: `Trial ${challengeIndex + 1} - DC ${dc}`,
diceRoll: rollText + ` - <span style="color:#dc2626">FAILED</span>`,
outcomes: [
`${h.n} could not quite meet the challenge.`,
outcomeText,
'"A good effort, but you have reached your limit. Take what you have earned and go."'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Success! Choose a sigil to upgrade
const heroSigils = [...h.s];
if(h.ts) heroSigils.push(...h.ts);
const availableSigils = heroSigils.filter(sig => !S.wizardUpgradedSigils.includes(sig));

if(availableSigils.length === 0) {
// No more sigils to upgrade
removeNeutralFromDeck('wizard');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: `Trial ${challengeIndex + 1} - DC ${dc}`,
diceRoll: rollText + ` - <span style="color:#22c55e">SUCCESS</span>`,
outcomes: [
`${h.n} passed the trial!`,
`But ${h.n} has no more sigils available to upgrade!`,
`Total upgrades earned: ${S.wizardUpgradedSigils.length}`,
'"You have taken all I can offer. Go now."'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Show sigil selection
let description = `${h.n} passed the trial! Choose a sigil to upgrade temporarily (cannot pick the same sigil twice):`;
let buttons = '';
availableSigils.forEach(sig => {
const currentLevel = getLevel(sig, heroIdx);
buttons += `<button class="neutral-btn safe" onclick="selectWizardUpgrade('${sig}')">${sigilIcon(sig)} ${sig} - L${currentLevel} ‚Üí L${currentLevel + 1}</button>`;
});

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
title: `Trial ${challengeIndex + 1} - DC ${dc}`,
diceRoll: rollText + ` - <span style="color:#22c55e">SUCCESS</span>`,
description,
buttons
});
}

function selectWizardUpgrade(sig) {
const heroIdx = S.wizardHero;
const h = S.heroes[heroIdx];

// Apply temp upgrade (use tempSigUpgrades, not S.sig which is permanent!)
if(!h.ts) h.ts = [];
if(!h.ts.includes(sig)) h.ts.push(sig);

const oldTotalLevel = (S.sig[sig] || 0) + (S.tempSigUpgrades[sig] || 0);
S.tempSigUpgrades[sig] = (S.tempSigUpgrades[sig] || 0) + 1;
const newTotalLevel = oldTotalLevel + 1;

S.wizardUpgradedSigils.push(sig);
toast(`${sig} temporarily upgraded to L${newTotalLevel} for ${h.n}!`, 1800);

S.wizardChallengeIndex++;

// Check if more challenges remain
if(S.wizardChallengeIndex >= S.wizardChallenges.length) {
// All trials complete!
removeNeutralFromDeck('wizard');
setTimeout(() => {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
outcomes: [
`${h.n} has completed all trials!`,
`Total upgrades: ${S.wizardUpgradedSigils.length}`,
'"Merlin\'s Toad! You have proven yourself worthy. Now go forth with your newfound power, my disciple!"'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}, ANIMATION_TIMINGS.ACTION_COMPLETE);
} else {
// Continue to next challenge
setTimeout(() => attemptWizardChallenge(), ANIMATION_TIMINGS.TUTORIAL_DELAY);
}
}

function declineWizardChallenges() {
removeNeutralFromDeck('wizard');
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/wizard2.png',
outcomes: ['The wizard\'s glow fades. "You would refuse my arcane boons? Very well." He grabs his books and disappears.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 5. ORACLE =====
function showOracle1() {
// Mark tutorial as seen so future runs have random neutrals
S.tutorialFlags.neutral_intro = true;
const v = document.getElementById('gameView');
let description = 'A figure shrouded in mist sits cross-legged before a glowing crystal sphere. Their voice echoes: "Step forward, child, and I shall ponder your future within my orb. Tell me, child, crave you Power or Life?" Choose a hero and their desired fortune:';
let buttons = '';
S.heroes.forEach((h, idx) => {
buttons += `<button class="neutral-btn risky" onclick="oracleChoose(${idx}, 'POW')">${h.n} - Power (+1‚ö°)</button>`;
buttons += `<button class="neutral-btn safe" onclick="oracleChoose(${idx}, 'HP')">${h.n} - Life (+5‚ù§ max)</button>`;
});
buttons += `<button class="neutral-btn secondary" onclick="nextFloor()">Do Not Engage</button>`;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle1.png',
title: 'Consult the Oracle',
description,
buttons
});
}

function oracleChoose(heroIdx, stat) {
S.oracleHero = heroIdx;
S.oracleStat = stat;

const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);
S.oracleRoll = best;

const h = S.heroes[heroIdx];
let fortune = '';
let stage2Effect = '';

if(best === 1) {
fortune = '"No...This cannot be! You are cursed! CURSED! Begone from me at once, and cross not my path again!"';
stage2Effect = 'CURSE';
replaceStage1WithStage2('oracle');
} else if(best >= 2 && best <= 9) {
fortune = '"Alas... The orb is cruel. Your desires shall not come to pass this night."';
stage2Effect = 'NO UNLOCK';
} else if(best >= 10 && best <= 15) {
fortune = 'The Oracle gives a knowing smile. "Great things in your future, but perhaps not what you want."';
stage2Effect = 'OPPOSITE';
replaceStage1WithStage2('oracle');
} else if(best >= 16 && best <= 19) {
fortune = 'The Oracle gives a kind wink. "Your desired future just may come to pass, if you are patient."';
stage2Effect = 'DESIRED';
replaceStage1WithStage2('oracle');
} else {
fortune = `"Incredible.. Could it be... Now? Before my very eyes?!" A strange light emanates from the orb, infusing the room. ${h.n} feels ${stat === 'POW' ? 'stronger' : 'healthier'} already!`;
stage2Effect = 'IMMEDIATE DOUBLE';
replaceStage1WithStage2('oracle');
}

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle1.png',
title: 'The Oracle\'s Fortune',
diceRoll: rollText,
outcomes: [
`${h.n} steps forward seeking ${stat === 'POW' ? 'Power' : 'Life'}.`,
`The Oracle gazes into the crystal sphere, then speaks: ${fortune}`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showOracle2() {
if(S.oracleHero === null || S.oracleRoll === null) {
nextFloor();
return;
}

const heroIdx = S.oracleHero;
const stat = S.oracleStat;
const roll = S.oracleRoll;
const h = S.heroes[heroIdx];

let outcome = '';

if(roll === 1) {
// CURSE
if(stat === 'HP') {
h.m = Math.max(1, h.m - 5);
if(h.h > h.m) h.h = h.m;
outcome = `"Cursed! Cursed!" Dark light surges from the orb, and ${h.n} feels weaker. Maximum HP reduced by 5!`;
} else {
h.p = Math.max(0, h.p - 1);
outcome = `"Cursed! Cursed!" Dark light surges from the orb, and ${h.n} feels their strength fade. POW reduced by 1!`;
}
} else if(roll >= 10 && roll <= 15) {
// OPPOSITE
if(stat === 'HP') {
h.p++;
outcome = `"We cannot always choose our destiny", the Oracle intones. The light coalesces around ${h.n}. ${h.n} gains unexpected Power! POW +1!`;
} else {
h.m += 5;
h.h += 5;
outcome = `"We cannot always choose our destiny", the Oracle intones. The light coalesces around ${h.n}. ${h.n} gains unexpected Life! Maximum HP +5!`;
}
} else if(roll >= 16 && roll <= 19) {
// DESIRED
if(stat === 'HP') {
h.m += 5;
h.h += 5;
outcome = `"I knew you were destined to grow healthier." The light coalesces around ${h.n}. ${h.n}'s Maximum HP +5! "Alas, the orb grows cloudy. What does the future hold for you, I wonder..."`;
} else {
h.p++;
outcome = `"I knew you were destined to grow stronger." The light coalesces around ${h.n}. ${h.n}'s POW +1! "Alas, the orb grows cloudy. What does the future hold for you, I wonder..."`;
}
} else if(roll === 20) {
// IMMEDIATE DOUBLE
if(stat === 'HP') {
h.m += 10;
h.h += 10;
outcome = `Your blessings overflow! The Oracle's orb sends glittering light dancing around the room as ${h.n} surges with life force! Maximum HP +10!`;
} else {
h.p += 2;
outcome = `Your blessings overflow! The Oracle's orb sends glittering light dancing around the room as ${h.n} surges with power! POW +2!`;
}
} else {
// Rolls 2-9 shouldn't reach Stage 2, but handle defensively
outcome = 'The Oracle\'s fortune was unclear. The crystal sphere dims.';
}

removeNeutralFromDeck('oracle');

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/oracle2.png',
title: 'The Oracle\'s Promise',
outcomes: [
`The Oracle has been expecting ${h.n}. Strange chanting fills the room. As you enter her chamber, the crystal sphere flares brightly!`,
outcome
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 6. ENEMY ENCAMPMENT =====
function showEncampment1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Enemy Encampment',
description: 'From the last chamber\'s exit, you spy some enemies in their encampment, preparing for their next battle. They haven\'t noticed you yet. You might be able to sneak by, or this could be a good chance to get the jump on them.',
buttons: `
<button class="btn risky" onclick="chooseEncampmentAction('sneak')">Sneak by?</button>
<button class="btn risky" onclick="chooseEncampmentAction('engage')">Engage early</button>
`
});
}

function chooseEncampmentAction(action) {
const v = document.getElementById('gameView');
let buttons = '';
S.heroes.forEach((h, i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
buttons += `<button class="neutral-btn ${action === 'sneak' ? '' : 'risky'}" onclick="${action === 'sneak' ? 'sneakByEncampment' : 'engageEarlyEncampment'}(${i})">${h.n} - ${h.p}‚ö° | ${hp}</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: action === 'sneak' ? 'Choose Scout' : 'Choose Leader',
description: `Which hero will ${action === 'sneak' ? 'sneak past the encampment' : 'lead the charge'}?`,
buttons
});
}

function sneakByEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

let outcome = '';
if(best >= 1 && best <= 10) {
outcome = `Well, that's why the enemies set up a trip wire. It worked. It's an ambush!`;
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 1800);

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Sneaking Past',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else if(best >= 11 && best <= 19) {
outcome = `You slip past quietly. The enemies remain unaware.`;

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Sneaking Past',
diceRoll: rollText,
outcomes: [outcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else {
// Roll 20 - recruit a straggler! Ask which hero should recruit them
const comp = getEnemyComp(S.floor + 1);
const stragglerType = comp[Math.floor(Math.random() * comp.length)];
const base = E[stragglerType];

// Store straggler data for selection
window.pendingStragglerData = { base, stragglerType };

outcome = `As you sneak by, you spy an enemy straggler who appears to be hiding from the group... It looks like they want to join your party!`;

// Show hero selection for who should recruit
const v = document.getElementById('gameView');
let heroButtons = '';
S.heroes.forEach((h, i) => {
const hp = h.ls ? `Last Stand (T${h.lst+1})` : `${h.h}/${h.m}‚ù§`;
heroButtons += `<button class="neutral-btn safe" onclick="assignRecruitToHero(${i})">${h.n} - ${h.p}‚ö° | ${hp}</button>`;
});

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Sneaking Past - NAT 20!',
diceRoll: rollText,
description: `${outcome}<br><br><strong>Who should recruit the ${base.n}?</strong>`,
buttons: heroButtons
});
}
}

function assignRecruitToHero(heroIdx) {
const { base, stragglerType } = window.pendingStragglerData;
const hero = S.heroes[heroIdx];
const fuMultiplier = S.gameMode === 'fu' ? 3 : 1;
const straggler = {
id: `recruit-${crypto.randomUUID()}`,
n: base.n,
p: base.p * fuMultiplier,
h: base.h * fuMultiplier,
m: base.m * fuMultiplier,
g: base.g,
x: base.x,
s: [],
pool: base.pool,
maxLevel: base.maxLevel || 1,
sigilLevels: base.sigilLevels || {},
gainRate: base.gainRate || 3,
turnsSinceGain: 0,
drawsPerTurn: base.drawsPerTurn || 1,
st: 0,
li: heroIdx,
sh: 0,
alphaActed: false,
recruitedBy: heroIdx,
isRecruit: true
};
// Add permanent sigils
if(base.permSigils) base.permSigils.forEach(ps => straggler.s.push({sig:ps.s, level:ps.l, perm:true}));
// Add start sigils
if(base.startSigils) {
if(Array.isArray(base.startSigils)) {
base.startSigils.forEach(ss => straggler.s.push({sig:ss.s, level:ss.l, perm:false}));
} else {
for(let j = 0; j < base.startSigils; j++) {
drawEnemyStartSigil(straggler, base);
}
}
}
// Handle startRandom: draw additional random L1 sigils
if(base.startRandom) {
for(let j = 0; j < base.startRandom; j++) {
drawEnemyStartSigil(straggler, base, true);
}
}
if(!S.recruits) S.recruits = [];

// Check if hero already has a recruit
const existingRecruit = S.recruits.find(r => r.recruitedBy === heroIdx);
if(existingRecruit) {
// Store both for replacement choice
S.pendingNewRecruit = straggler;
S.pendingOldRecruitId = existingRecruit.id;
const v = document.getElementById('gameView');
const oldName = existingRecruit.n;
const newName = straggler.n;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Replace Recruit?',
outcomes: [`${hero.n} already has ${oldName}... Replace them with the new ${newName}?`],
buttons: `<button class="btn" onclick="keepCurrentRecruit()">Keep ${oldName}</button><button class="btn safe" style="margin-left:0.5rem" onclick="replaceWithNewRecruit()">Replace with ${newName}</button>`
});
} else {
S.recruits.push(straggler);
const outcome = `The Recruited ${base.n} looks glad to join ${hero.n}'s side and will fight loyally!`;
toast(`${base.n} recruited! Will fight in ${hero.n}'s lane!`, 1800);
window.pendingStragglerData = null;

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Recruit Joined!',
outcomes: [outcome],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function keepCurrentRecruit() {
S.pendingNewRecruit = null;
S.pendingOldRecruitId = null;
window.pendingStragglerData = null;
toast('Kept current recruit.', 1200);
nextFloor();
}

function replaceWithNewRecruit() {
if(!S.pendingNewRecruit || !S.pendingOldRecruitId) { nextFloor(); return; }
const oldRecruit = S.recruits.find(r => r.id === S.pendingOldRecruitId);
S.recruits = S.recruits.filter(r => r.id !== S.pendingOldRecruitId);
S.recruits.push(S.pendingNewRecruit);
toast(`${S.pendingNewRecruit.n} replaces ${oldRecruit?.n || 'old recruit'}!`, 1500);
S.pendingNewRecruit = null;
S.pendingOldRecruitId = null;
window.pendingStragglerData = null;
nextFloor();
}

function engageEarlyEncampment(heroIdx) {
const hero = S.heroes[heroIdx];
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= 1 && best <= 15) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`As the heroes sneak up to the camp, a scout's horn sounds. You've been spotted, and you're surrounded! It's an ambush!`],
buttons: `<button class="btn" onclick="finishEncampmentFail()">Continue</button>`
});
} else if(best >= 16 && best <= 19) {
S.encampmentEarlyKills = 1;
replaceStage1WithStage2('encampment');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`Your frogs work together to lure one enemy away and take him out! He screams as he dies, though, and by the time you turn, the rest are scrambling to form ranks.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else {
S.encampmentEarlyKills = 2;
replaceStage1WithStage2('encampment');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment1.png',
title: 'Engaging Early',
diceRoll: rollText,
outcomes: [`With an excellent ploy, you succeed at picking off 2 enemies! The next combat should be a walk in the pond!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function finishEncampmentFail() {
replaceStage1WithStage2('encampment');
S.ambushed = true;
toast('Next combat will be AMBUSHED!', 1800);
nextFloor();
}

// ===== 6b. ENCAMPMENT STAGE 2 =====
function showEncampment2() {
const healAmt = Math.floor(S.heroes[0].m * 0.5);
const goldGain = 2 * S.heroes.length;

S.heroes.forEach(h => {
if(!h.ls) {
h.h = Math.min(h.h + healAmt, h.m);
}
});

S.gold += goldGain;
upd();
toast(`All heroes healed ${healAmt} HP!`, 1200);
toast(`Gained ${goldGain} Gold!`, 1200);

removeNeutralFromDeck('encampment');

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/encampment2.png',
title: 'Abandoned Encampment',
description: 'You spy another enemy encampment from a distance, but this one appears abandoned. The bedrolls stink and the tack is stale, but you are able to enter and rest safely.',
outcomes: [
`All heroes restored ${healAmt} HP!`,
`Found ${goldGain} Gold in supplies!`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== 7. BETWEEN THE 20s =====
function showGambling1() {
const v = document.getElementById('gameView');
// Entry requirement: minimum 2 gold
if(S.gold < 2) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
description: 'A mysterious gambling den with glowing dice floating in the air. A sign reads: "Minimum 2 Gold to play."',
outcomes: ['<span style="color:#ef4444">You don\'t have enough gold to play.</span>'],
buttons: `<button class="btn safe" onclick="nextFloor()">Leave</button>`
});
return;
}

// Calculate wager: max 10, or highest even number player has
const maxWager = 10;
let wager = Math.min(maxWager, Math.floor(S.gold / 2) * 2);
if(wager < 2) wager = 2;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
description: `A mysterious gambling den beckons. Roll dice to set your range, then try to land between them. Wager: ${wager}G for a ${wager * 2}G payout.`,
outcomes: [],
buttons: `
<button class="btn safe" onclick="nextFloor()">Walk away</button>
<button class="btn risky" onclick="playBetween20s(1, ${wager})">Play (${wager}G)</button>
`
});
}

function playBetween20s(stage, wager) {
const v = document.getElementById('gameView');
// Include both permanent AND temporary upgrades
const d20Level = ((S.sig.D20 || 0) + (S.tempSigUpgrades.D20 || 0)) || 1;

// PHASE 1: Establish Range
const boundsCount = stage === 1 ? (d20Level + 1) : 2; // Stage 1: level+1, Stage 2: always 2
const boundsRolls = [];
for(let i = 0; i < boundsCount; i++) {
boundsRolls.push(Math.floor(Math.random() * 20) + 1);
}
const minBound = Math.min(...boundsRolls);
const maxBound = Math.max(...boundsRolls);

// Format dice display
const diceDisplay = formatDiceRolls(boundsRolls);

// Check instant loss (bounds are equal)
if(minBound === maxBound) {
S.gold -= wager;
upd();
v.innerHTML = buildNeutralHTML({
bgImage: stage === 1 ? 'assets/neutrals/gambling1.png' : 'assets/neutrals/gambling2.jpeg',
title: stage === 1 ? 'Between the 20s' : 'Between the 20s Extreme',
description: `Rolling ${boundsCount} dice to set bounds...`,
outcomes: [
`${diceDisplay}`,
`<span style="color:#ef4444">INSTANT LOSS! Both bounds are ${minBound}!</span>`,
`Lost ${wager}G.`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Store game state for phase 2/3
window.between20sState = { stage, wager, minBound, maxBound, boundsRolls };

// PHASE 2: Decision Point (Stage 1 only)
if(stage === 1) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
description: `Rolling ${boundsCount} dice to set bounds...`,
outcomes: [
`${diceDisplay}`,
`Range set: <span style="color:#22c55e">${minBound}</span> to <span style="color:#22c55e">${maxBound}</span>`,
'You can back out for half your wager, or continue for a chance at double.'
],
buttons: `
<button class="btn risky" onclick="backOutBetween20s()">Back out (get ${Math.floor(wager / 2)}G back)</button>
<button class="btn danger" onclick="targetRollBetween20s()">Continue to target roll</button>
`
});
} else {
// Stage 2: No backing out, go straight to target roll
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling2.jpeg',
title: 'Between the 20s Extreme',
description: `Rolling ${boundsCount} dice to set bounds...`,
outcomes: [
`${diceDisplay}`,
`Range set: <span style="color:#22c55e">${minBound}</span> to <span style="color:#22c55e">${maxBound}</span>`,
'<span style="color:#3b82f6">NO BACKING OUT! Rolling for target...</span>'
],
buttons: `<button class="btn danger" onclick="targetRollBetween20s()">Roll target dice</button>`
});
}
}

function formatDiceRolls(rolls) {
return rolls.map(r => `<span style="display:inline-block;width:2.5rem;height:2.5rem;line-height:2.5rem;text-align:center;background:#1e293b;border:2px solid #475569;border-radius:0.5rem;margin:0.2rem;font-weight:bold;color:#f1f5f9;font-size:1.2rem;">${r}</span>`).join(' ');
}

function backOutBetween20s() {
const state = window.between20sState;
const refund = Math.floor(state.wager / 2);
S.gold -= state.wager;
S.gold += refund;
upd();

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling1.png',
title: 'Between the 20s',
outcomes: [
'You decide to play it safe and back out.',
`Net loss: ${state.wager - refund}G`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function targetRollBetween20s() {
const state = window.between20sState;
const v = document.getElementById('gameView');
// Include both permanent AND temporary upgrades
const d20Level = ((S.sig.D20 || 0) + (S.tempSigUpgrades.D20 || 0)) || 1;

// PHASE 3: Target Roll
const targetRolls = [];
for(let i = 0; i < d20Level; i++) {
targetRolls.push(Math.floor(Math.random() * 20) + 1);
}

// Check if ANY die lands between bounds (inclusive)
const winners = targetRolls.filter(r => r >= state.minBound && r <= state.maxBound);
const won = winners.length > 0;

const targetDisplay = formatDiceRolls(targetRolls);

if(won) {
// Calculate payout
let payout = state.wager * (state.stage === 1 ? 2 : 4);
if(state.stage === 2) {
payout = Math.min(payout, 40); // Cap at 40G for Stage 2
}
const netGain = payout - state.wager;
S.gold += payout;
upd();

// Unlock Stage 2 after Stage 1 win
if(state.stage === 1) {
replaceStage1WithStage2('gambling');
toast('Between the 20s Extreme unlocked!', 1800);
}

v.innerHTML = buildNeutralHTML({
bgImage: state.stage === 1 ? 'assets/neutrals/gambling1.png' : 'assets/neutrals/gambling2.jpeg',
title: state.stage === 1 ? 'Between the 20s - WIN!' : 'Between the 20s Extreme - WIN!',
description: `Rolling ${d20Level} target ${d20Level === 1 ? 'die' : 'dice'}...`,
outcomes: [
`${targetDisplay}`,
`<span style="color:#22c55e">SUCCESS! ${winners.map(w => `[${w}]`).join(' ')} landed in range [${state.minBound}-${state.maxBound}]!</span>`,
`Won ${payout}G! (Net: +${netGain}G)`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
} else {
S.gold -= state.wager;
upd();

v.innerHTML = buildNeutralHTML({
bgImage: state.stage === 1 ? 'assets/neutrals/gambling1.png' : 'assets/neutrals/gambling2.jpeg',
title: state.stage === 1 ? 'Between the 20s - Loss' : 'Between the 20s Extreme - Loss',
description: `Rolling ${d20Level} target ${d20Level === 1 ? 'die' : 'dice'}...`,
outcomes: [
`${targetDisplay}`,
`<span style="color:#ef4444">MISS! No dice landed in range [${state.minBound}-${state.maxBound}].</span>`,
`Lost ${state.wager}G.`
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}
}

function showGambling2() {
const v = document.getElementById('gameView');
// Entry requirement: minimum 2 gold
if(S.gold < 2) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling2.jpeg',
title: 'Between the 20s Extreme',
description: 'The high-stakes gambling den glows with intense energy. A sign reads: "Minimum 2 Gold to play - 4x payout, capped at 40G."',
outcomes: ['<span style="color:#ef4444">You don\'t have enough gold to play.</span>'],
buttons: `<button class="btn safe" onclick="nextFloor()">Leave</button>`
});
return;
}

// Calculate wager: max 10, or highest even number player has
const maxWager = 10;
let wager = Math.min(maxWager, Math.floor(S.gold / 2) * 2);
if(wager < 2) wager = 2;

// Calculate potential payout (capped at 40)
const potentialPayout = Math.min(wager * 4, 40);

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/gambling2.jpeg',
title: 'Between the 20s Extreme',
description: `The EXTREME version! Only 2 dice for bounds, NO backing out, but ${potentialPayout}G payout! High risk, high reward.`,
outcomes: ['<span style="color:#3b82f6">WARNING: No safety net here. You\'re all in once you start.</span>'],
buttons: `
<button class="btn safe" onclick="nextFloor()">Walk away</button>
<button class="btn danger" onclick="playBetween20s(2, ${wager})">Play EXTREME (${wager}G for ${potentialPayout}G)</button>
`
});
}

// ===== 8. GHOST =====
function showGhost1() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'The Haunted Playroom',
description: 'Various toys and games litter a dusty playroom. Two translucent boys appear before you, giggling. "Play with us! Play with us!" They reach out with spectral hands.',
buttons: `
<button class="btn danger" onclick="playWithGhostBoys()">Play with the ghost boys</button>
<button class="btn risky" onclick="nextFloor()">Avoid?</button>
`
});
}

let ghostEscapeDC = 18;
let ghostEscapeAttempts = 0;

function playWithGhostBoys() {
ghostEscapeDC = 18;
ghostEscapeAttempts = 0;
attemptGhostEscape();
}

function attemptGhostEscape() {
const {rolls, best} = rollD20Neutral();
const rollText = showD20Result(rolls, best);

const v = document.getElementById('gameView');

if(best >= ghostEscapeDC) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Escaping the Ghost Boys',
diceRoll: rollText,
outcomes: ['You clear your head and break free from the strange trance. The boys look sad to stop playing, but let you go. "Come back and play sometime... We\'re so lonely..."'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Failed - show hero selection
let heroButtons = '';
S.heroes.forEach((h, idx) => {
heroButtons += `<button class="neutral-btn danger" onclick="applyGhostDamage(${idx})">${h.n} (${h.h}/${h.m}‚ù§)</button>`;
});
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Trapped with the Ghost Boys',
diceRoll: rollText,
description: 'Choose which hero takes 1 damage:',
outcomes: ['You don\'t notice time passing, but pangs of hunger and fatigue make it clear you\'ve been here longer than it feels like. The boys are having a great time playing.'],
buttons: heroButtons
});
}

function applyGhostDamage(heroIdx) {
const hero = S.heroes[heroIdx];
const hadGhostCharge = hero.g > 0;

hero.h -= 1;
if(hero.h <= 0) {
hero.h = 0;
if(hero.g > 0) {
hero.g--;
hero.h = hero.m;
// EASTER EGG: Ghost charge consumed during Ghost encounter triggers conversion
if(hadGhostCharge) {
replaceStage1WithStage2('ghost');
toast(`${hero.n}'s Ghost keeps them from entering Last Stand! The boys stare in awe...`, 1800);
upd();
// Trigger the full Ghost Boys conversion (showGhost2)
showGhost2();
return;
}
} else {
hero.ls = true;
hero.lst = 0;
upd();
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Escaping the Ghost Boys',
outcomes: [
`Unable to withstand the hunger, ${hero.n} takes 1 damage and enters Last Stand! The shock breaks the ghost boys' hold!`,
'"Oops! We didn\'t realize..." they say in unison, staring at each other in horror. They begin to sob, and quickly disappear.'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}
}

toast(`${hero.n} took 1 damage!`);
ghostEscapeAttempts++;
ghostEscapeDC -= 2;
upd();

const v = document.getElementById('gameView');

if(ghostEscapeAttempts >= 9) {
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Finally Free',
outcomes: ['After many attempts, the ghost boys grow bored and fade away.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost1.png',
title: 'Try Again',
description: `<div style="font-size:0.9rem;margin:1rem 0">Attempts: ${ghostEscapeAttempts}/9 | Next DC: ${ghostEscapeDC}</div>`,
outcomes: [`${hero.n} took 1 damage!`],
buttons: `<button class="btn danger" onclick="attemptGhostEscape()">Try to Escape (DC ${ghostEscapeDC})</button>`
});
}

function showGhost2() {
S.ghostBoysConverted = true;
toast('Ghost Boys permanently converted to Empty Playroom!', 1800);
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost2.png',
title: 'Passing On',
description: 'The ghost boys stare at each other, then at their translucent hands. "We\'re... we\'re dead. We\'re ghosts."',
outcomes: [
'Tears form in their spectral eyes. "We didn\'t know. We want to go home."',
'They hold hands and embrace you in a ghostly hug. "We would never have figured it out without you. Thank you." They vanish peacefully.',
'<span style="color:#22c55e">This room is now an Empty Playroom - you can pass safely in future runs.</span>'
],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showEmptyPlayroom() {
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/ghost2.png',
title: 'Empty Playroom',
description: 'An empty chamber, dust motes drifting in pale light. It might have been a playroom once, but whatever haunted it is long gone. The air feels peaceful.',
outcomes: ['Nothing stops you here. You pass through quietly.'],
buttons: `<button class="btn" onclick="nextFloor()">Continue to Floor ${S.floor + 1}</button>`
});
}

// ===== 9. FLUMMOXED ROYAL =====
// Helper to get random royal title
function getRandomRoyalTitle() {
return Math.random() < 0.5 ? 'Prince' : 'Princess';
}

function showRoyal1() {
// Generate random titles for each royal (the one asking for help and their beloved)
const askerTitle = getRandomRoyalTitle();
const belovedTitle = getRandomRoyalTitle();
// Store for use in acceptRoyalQuest callback
S.royalAskerTitle = askerTitle;
S.royalBelovedTitle = belovedTitle;

const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal1.png',
title: 'The Flummoxed Royal',
description: `A flummoxed ${askerTitle} paces anxiously: "Please, you must help! A creature in the next chamber ate my beloved's engagement ring! But I have cooked up a stratagem to retrieve it! If you can but stun a foe on the first turn of battle, I can search for the ring!"`,
buttons: `
<button class="btn" onclick="acceptRoyalQuest()">Accept the quest</button>
<button class="btn safe" onclick="nextFloor()">Do Not Engage</button>
`
});
}

function acceptRoyalQuest() {
toast('Stun any enemy Turn 1 of next combat!', 1800);
S.royalQuestActive = true;
S.royalQuestCompleted = false;
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal1.png',
outcomes: [`The ${S.royalAskerTitle} looks hopeful: "Thank you! I'll follow you and grab it when you stun the creature!"`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

function showRoyal2() {
const v = document.getElementById('gameView');
// Use stored titles from showRoyal1, or generate new ones if not present
const askerTitle = S.royalAskerTitle || getRandomRoyalTitle();
const belovedTitle = S.royalBelovedTitle || getRandomRoyalTitle();

// Check if quest was completed
if(!S.royalQuestCompleted) {
// Quest failed
S.royalQuestActive = false;
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal1.png',
title: 'Quest Failed',
description: `The ${askerTitle} returns, dejected: "The creature fled before I could retrieve the ring. I'll have to find another way..."`,
outcomes: [`The ${askerTitle} departs sadly. No reward.`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
return;
}

// Quest succeeded - show wedding
const allSigils = ['Attack', 'Shield', 'Heal', 'Grapple', 'Ghost', 'D20', 'Expand', 'Asterisk', 'Star', 'Alpha'];
const eligible = allSigils.filter(s => (S.sig[s] || 0) < 4);

eligible.sort((a, b) => {
const costA = S.sig[a] || 0;
const costB = S.sig[b] || 0;
return costA - costB;
});

const sigil1 = eligible[0] || 'Attack';
const sigil2 = eligible[1] || 'Shield';

removeNeutralFromDeck('royal');
S.royalQuestActive = false;

let buttons = '';
buttons += `<div class="choice" onclick="chooseRoyalSigil('${sigil1}')">
<strong>${sigilIcon(sigil1)}</strong> <span style="opacity:0.7">L${S.sig[sigil1] || 0} ‚Üí L${(S.sig[sigil1] || 0) + 1}</span>
</div>`;
buttons += `<div class="choice" onclick="chooseRoyalSigil('${sigil2}')">
<strong>${sigilIcon(sigil2)}</strong> <span style="opacity:0.7">L${S.sig[sigil2] || 0} ‚Üí L${(S.sig[sigil2] || 0) + 1}</span>
</div>`;

v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal2.png',
title: 'Royal Wedding',
description: `The ${askerTitle} welcomes you with a grand sweep of their open arms. "Ah, here are the very heroes who saved our wedding day, my love! Shall we give them the blessing we discussed?" The ${belovedTitle} beside them nods warmly.`,
outcomes: ['Each wears a garment displaying a sigil of power. As thanks for your help, you may choose one:'],
buttons
});
}

function chooseRoyalSigil(sig) {
S.sig[sig] = (S.sig[sig] || 0) + 1;
toast(`${sig} permanently upgraded to L${S.sig[sig]}!`, 1800);
const v = document.getElementById('gameView');
v.innerHTML = buildNeutralHTML({
bgImage: 'assets/neutrals/royal2.png',
outcomes: [`The royal couple thanks you profusely. The ${sig} sigil glows and merges with your power!`],
buttons: `<button class="btn" onclick="nextFloor()">Continue</button>`
});
}

// ===== OLD TAPO ENCOUNTER (FLOOR 20) =====
function showOldTapo() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/old-tapo.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #8b5cf6;box-shadow:0 0 20px rgba(139,92,246,0.5)">
<div class="neutral-title" style="color:#8b5cf6;font-size:1.8rem">The Master of Space and Time</div>
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;background:rgba(139,92,246,0.1);border-radius:8px;margin:1rem 0">
"Tapo, you say? Yes... I was called Tapo once, wasn't I? That was 'Before'... Before I mastered the speculae of space, the tesseracts of time... before I became one with the universe. You would save me? Why, I need no saving... In a universe of infinite and terrifying possibility, there need be no fear, no hate, no pain."
</div>
<button class="btn" onclick="oldTapoSlide2()" style="background:linear-gradient(135deg, #8b5cf6, #6366f1);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Continue</button>
</div>`;
}

function oldTapoSlide2() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<img src="assets/old-tapo.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #8b5cf6;box-shadow:0 0 20px rgba(139,92,246,0.5)">
<div class="neutral-title" style="color:#8b5cf6;font-size:1.8rem">The Master of Space and Time</div>
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;background:rgba(139,92,246,0.1);border-radius:8px;margin:1rem 0">
"Noble frogs of my youth, do you understand? Of course not... For you are the true tadpoles, on this fleeting cosmic scale. But you cannot understand, not as I have understood... There is only love, and joy, and progress... And flies. I have transcended the need for food, but that Flydra sure looked yummy..."
</div>
<button class="btn" onclick="oldTapoTransform()" style="background:linear-gradient(135deg, #8b5cf6, #6366f1);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Continue</button>
</div>`;
}

function oldTapoTransform() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div class="neutral-container">
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;background:rgba(139,92,246,0.1);border-radius:8px;margin:1rem 0;text-align:center">
"Ah! I know!" <em>*Poof*</em>
</div>
<div style="text-align:center;margin:2rem 0">
<img src="assets/tapo-nobg.png" style="max-width:100%;height:auto;max-width:300px;margin:0 auto 1rem auto;display:block;animation:bounce 1s ease-in-out 3">
<div class="neutral-desc" style="font-size:1.1rem;line-height:1.8;padding:1rem;margin:1rem 0">
<em>Squeals.</em> The heroes know this sound well - Baby Tapo is hungry for flies!
</div>
<div style="font-size:2.5rem;font-weight:bold;color:#3b82f6;text-shadow:0 0 10px rgba(251,191,36,0.5);margin:2rem 0;animation:glow 1s ease-in-out infinite">
‚ú® Tapo Unlocked! ‚ú®
</div>
<div class="neutral-outcome" style="font-size:1.1rem;margin:1.5rem 0">
Baby Tapo has been added to your hero roster!<br>
<span style="color:#22c55e">Stats: 1 HP / 1 POW</span><br>
<span style="color:#8b5cf6">Starts with ALL active sigils!</span>
</div>
</div>
<button class="btn" onclick="completeTapoUnlock()" style="background:linear-gradient(135deg, #3b82f6, #f97316);font-size:1.2rem;padding:1rem 2rem;margin-top:1rem">Victory!</button>
</div>
<style>
@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-20px); }
}
@keyframes glow {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}
</style>`;
}

function completeTapoUnlock() {
S.tapoUnlocked = true;
savePermanent();
win();
}

// ===== DEATH DIALOGUE SEQUENCE =====
function showDeathIntroDialogue() {
const v = document.getElementById('gameView');
v.innerHTML = `
<div style="background:#2c2416;padding:2rem;border-radius:8px;max-width:800px;margin:2rem auto;color:#e8dcc4">
<img src="assets/neutrals/shopkeeper2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #dc2626;box-shadow:0 0 20px rgba(220,38,38,0.5)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:2rem;text-align:center">
"Oh hey, it's you! I'm the one who's been giving you tips along the way."
</p>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:2rem;text-align:center">
"I'm supposed to take you to the next life‚Ä¶ but you're not from this realm, are you?"
</p>
<div class="choice" onclick="showDeathResponseDialogue(true)" style="cursor:pointer">
<strong>Yes, I'm from a place called Ribbleton!</strong>
</div>
<div class="choice" onclick="showDeathResponseDialogue(false)" style="cursor:pointer">
<strong>No, I sure am from this realm!</strong>
</div>
</div>`;
}

function showDeathResponseDialogue(fromRibbleton) {
const v = document.getElementById('gameView');
const responseText = fromRibbleton
? "Ribbleton! I thought so. Not many travelers make it here from other realms."
: "Is that so? Well, regardless of where you're from...";

v.innerHTML = `
<div style="background:#2c2416;padding:2rem;border-radius:8px;max-width:800px;margin:2rem auto;color:#e8dcc4">
<img src="assets/neutrals/shopkeeper2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #dc2626;box-shadow:0 0 20px rgba(220,38,38,0.5)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:1.5rem;text-align:center">
"${responseText}"
</p>
<p style="font-size:1.2rem;line-height:1.6;margin-bottom:2rem;text-align:center">
"Well, it might be more profitable for <em>both</em> of us if I don't, you know‚Ä¶ kill you. I have another arrangement in mind."
</p>
<button class="btn danger" onclick="completeDeathIntro()" style="font-size:1.2rem;padding:1rem 2rem;margin:0 auto;display:block">Continue...</button>
</div>`;
}

function completeDeathIntro() {
// Mark the intro as seen
S.tutorialFlags.death_intro = true;
savePermanent();
// Show the actual death screen with upgrades
showDeathScreen();
}


// ===== THE POND - RUN HISTORY =====
// Records a run's outcome to the permanent history
function recordPondHistory(outcome, killedBy = null) {
const heroNames = S.heroes.map(h => h.n);
const entry = {
runNumber: S.runNumber,
heroes: heroNames,
floorReached: S.floor,
gameMode: S.gameMode,
outcome: outcome, // 'defeat' or 'victory'
killedBy: killedBy,
timestamp: Date.now(),
xpEarned: S.xp - S.startingXP,
goldEarned: S.gold
};
// Add to history (limit to last 50 runs to save localStorage space)
S.pondHistory.unshift(entry);
if(S.pondHistory.length > 50) {
S.pondHistory = S.pondHistory.slice(0, 50);
}
savePermanent();
}

// Show The Pond - a reflective place for remembering past adventures
function showPond() {
const v = document.getElementById('gameView');
const history = S.pondHistory || [];

// Generate lily pad for each run
function renderLilyPad(run, idx) {
const isVictory = run.outcome === 'victory';
const isFUVictory = isVictory && run.gameMode === 'fu';
const isStandardVictory = isVictory && run.gameMode !== 'fu';

// Size based on floor reached (40px base + up to 60px more for floor 20)
const baseSize = 45;
const maxBonus = 55;
const floorReached = Math.max(1, run.floorReached || 1); // Guard against undefined/NaN
const floorProgress = Math.min(floorReached, 20) / 20;
const size = Math.round(baseSize + (maxBonus * floorProgress));

// Colors: green (defeat), gold (standard win), prismatic (FU win)
let background, border, glow, animation;
if (isFUVictory) {
  // Prismatic rainbow gradient
  background = 'linear-gradient(135deg, #ff6b6b 0%, #feca57 17%, #48dbfb 34%, #ff9ff3 51%, #54a0ff 68%, #5f27cd 85%, #ff6b6b 100%)';
  border = '3px solid #fff';
  glow = '0 0 15px rgba(255,255,255,0.8), 0 0 30px rgba(138,43,226,0.5)';
  animation = 'animation: prismatic-shimmer 3s linear infinite;';
} else if (isStandardVictory) {
  // Golden
  background = 'linear-gradient(135deg, #fbbf24 0%, #f59e0b 50%, #d97706 100%)';
  border = '3px solid #fcd34d';
  glow = '0 0 12px rgba(251,191,36,0.6)';
  animation = '';
} else {
  // Green lily pad (defeat) - brighter green for higher floors
  const greenIntensity = 0.5 + (floorProgress * 0.4);
  background = `linear-gradient(135deg, rgba(34,197,94,${greenIntensity}) 0%, rgba(22,163,74,${greenIntensity + 0.15}) 100%)`;
  border = '2px solid rgba(34,197,94,0.7)';
  glow = '0 2px 8px rgba(0,0,0,0.3)';
  animation = '';
}

return `
<div class="lily-pad" onclick="showLilyPadDetail(${idx})" style="
  width:${size}px;
  height:${size}px;
  border-radius:50% 50% 50% 20%;
  background:${background};
  border:${border};
  box-shadow:${glow};
  cursor:pointer;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  transition:transform 0.2s, box-shadow 0.2s;
  position:relative;
  ${animation}
" onmouseover="this.style.transform='scale(1.15)'"
   onmouseout="this.style.transform='scale(1)'"
   title="Run #${run.runNumber} - Floor ${run.floorReached}${isVictory ? ' üèÜ' : ''}">
  <span style="font-size:${Math.max(11, size/4)}px;font-weight:bold;color:${isVictory ? '#000' : '#fff'};text-shadow:${isVictory ? 'none' : '1px 1px 2px rgba(0,0,0,0.6)'}">${run.floorReached}</span>
  ${isVictory ? `<span style="font-size:${Math.max(10, size/5)}px">üèÜ</span>` : ''}
</div>`;
}

let html = `
<style>
@keyframes prismatic-shimmer {
  0% { filter: hue-rotate(0deg); }
  100% { filter: hue-rotate(360deg); }
}
@keyframes pond-ripple {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}
.pond-water {
  background: linear-gradient(135deg,
    rgba(30,58,138,0.4) 0%,
    rgba(59,130,246,0.25) 25%,
    rgba(30,64,175,0.35) 50%,
    rgba(59,130,246,0.25) 75%,
    rgba(30,58,138,0.4) 100%);
  background-size: 200% 200%;
  animation: pond-ripple 8s ease-in-out infinite;
}
.lily-pad-container {
  display:flex;
  flex-wrap:wrap;
  gap:15px;
  justify-content:center;
  align-items:center;
  padding:2rem 1.5rem;
  min-height:180px;
}
</style>
<div style="max-width:900px;margin:0 auto;padding:1rem">
<h1 style="text-align:center;margin-bottom:0.5rem;font-size:2rem;color:#60a5fa;text-shadow:2px 2px 4px rgba(0,0,0,0.3)">
üåø The Pond üåø
</h1>
<p style="text-align:center;color:#94a3b8;margin-bottom:1rem;font-size:0.95rem">
A quiet place to reflect on adventures past...
</p>

<!-- Legend -->
<div style="display:flex;justify-content:center;gap:1.5rem;margin-bottom:1rem;flex-wrap:wrap;font-size:0.85rem">
<span style="color:#22c55e">üü¢ Good Try</span>
<span style="color:#fbbf24">üü° Good Job</span>
${S.fuUnlocked ? `<span style="background:linear-gradient(90deg,#ff6b6b,#feca57,#48dbfb,#ff9ff3);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-weight:bold">üåà ${(S.pondHistory || []).some(r => r.gameMode === 'fu') ? 'Frogged Up Win' : 'What the Frog?'}</span>` : ''}
<span style="color:#64748b;font-size:0.8rem">(bigger = higher floor)</span>
</div>

${history.length === 0 ? `
<div class="pond-water" style="text-align:center;padding:4rem 2rem;border-radius:24px;max-width:500px;margin:0 auto;border:3px solid rgba(59,130,246,0.3)">
<p style="font-size:2rem;margin-bottom:1rem">ü™∑</p>
<p style="color:#94a3b8;font-size:1.1rem">The water is still...</p>
<p style="color:#64748b;margin-top:0.5rem">Lily pads will appear here after your first adventure and grow the further you progress.</p>
</div>
` : `
<div class="pond-water" style="border-radius:20px;border:3px solid rgba(59,130,246,0.3)">
<div class="lily-pad-container">
${history.map((run, idx) => renderLilyPad(run, idx)).join('')}
</div>
</div>

<!-- Stats summary -->
<div style="margin-top:1.5rem;display:grid;grid-template-columns:repeat(auto-fit, minmax(100px, 1fr));gap:0.75rem;text-align:center">
<div style="background:rgba(30,41,59,0.8);padding:0.75rem;border-radius:8px;border:2px solid #334155">
<div style="font-size:1.4rem;font-weight:bold;color:#f1f5f9">${history.length}</div>
<div style="color:#94a3b8;font-size:0.85rem">Journeys</div>
</div>
<div style="background:rgba(30,41,59,0.8);padding:0.75rem;border-radius:8px;border:2px solid #334155">
<div style="font-size:1.4rem;font-weight:bold;color:#fbbf24">${history.filter(r => r.outcome === 'victory').length}</div>
<div style="color:#94a3b8;font-size:0.85rem">Victories</div>
</div>
<div style="background:rgba(30,41,59,0.8);padding:0.75rem;border-radius:8px;border:2px solid #334155">
<div style="font-size:1.4rem;font-weight:bold;color:#60a5fa">${Math.max(...history.map(r => r.floorReached), 0)}</div>
<div style="color:#94a3b8;font-size:0.85rem">Best Floor</div>
</div>
<div style="background:rgba(30,41,59,0.8);padding:0.75rem;border-radius:8px;border:2px solid #334155">
<div style="font-size:1.4rem;font-weight:bold;color:#f59e0b">${getMostUsedHero(history)}</div>
<div style="color:#94a3b8;font-size:0.85rem">Favorite</div>
</div>
</div>
`}

<div style="text-align:center;margin-top:1.5rem">
<button class="btn" onclick="showRibbleton()" style="padding:1rem 2rem;font-size:1.1rem">üê∏ Return to Ribbleton</button>
</div>
</div>`;

v.innerHTML = html;
}

// Show detail popup when clicking a lily pad
function showLilyPadDetail(idx) {
const run = S.pondHistory[idx];
if (!run) return;

const date = new Date(run.timestamp);
const dateStr = date.toLocaleDateString(undefined, {weekday: 'short', month: 'short', day: 'numeric'});
const isVictory = run.outcome === 'victory';
const isFUVictory = isVictory && run.gameMode === 'fu';
const modeText = run.gameMode === 'fu' ? 'Frogged Up' : 'Standard';

let headerBg, headerColor;
if (isFUVictory) {
headerBg = 'linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff)';
headerColor = '#000';
} else if (isVictory) {
headerBg = 'linear-gradient(135deg, #fbbf24, #f59e0b)';
headerColor = '#000';
} else {
headerBg = 'linear-gradient(135deg, #22c55e, #16a34a)';
headerColor = '#fff';
}

const v = document.getElementById('gameView');
const html = `
<div class="modal-container" style="max-width:350px">
<div style="background:${headerBg};padding:1rem;border-radius:8px 8px 0 0;text-align:center">
<h2 style="margin:0;color:${headerColor};font-size:1.3rem">${isVictory ? 'üèÜ Victory!' : 'ü™∑ Journey'} #${run.runNumber}</h2>
</div>
<div style="padding:1rem">
<div style="display:grid;gap:0.5rem;font-size:0.95rem">
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Date:</span>
<span style="color:#f1f5f9">${dateStr}</span>
</div>
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Mode:</span>
<span style="color:#f1f5f9">${run.gameMode === 'fu' ? 'üî• ' : '‚öîÔ∏è '}${modeText}</span>
</div>
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Floor Reached:</span>
<span style="color:#f1f5f9;font-weight:bold">${run.floorReached}</span>
</div>
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Heroes:</span>
<span style="color:#f1f5f9">${run.heroes.join(' + ')}</span>
</div>
${!isVictory && run.killedBy ? `
<div style="display:flex;justify-content:space-between">
<span style="color:#94a3b8">Fell to:</span>
<span style="color:#f87171">${run.killedBy}</span>
</div>
` : ''}
${isVictory ? `
<div style="text-align:center;margin-top:0.5rem;padding:0.5rem;background:rgba(34,197,94,0.2);border-radius:4px">
<span style="color:#22c55e;font-weight:bold">üéâ Tapo Rescued!</span>
</div>
` : ''}
</div>
<button class="btn" onclick="this.closest('.modal-container').remove();document.querySelector('.modal-overlay')?.remove()" style="margin-top:1rem;width:100%">Close</button>
</div>
</div>
<div class="modal-overlay" onclick="document.querySelector('.modal-container')?.remove();this.remove()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
SoundFX.play('hop');
}

function getMostUsedHero(history) {
if(history.length === 0) return '-';
const counts = {};
history.forEach(run => {
run.heroes.forEach(hero => {
  counts[hero] = (counts[hero] || 0) + 1;
});
});
const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
return sorted.length > 0 ? sorted[0][0] : '-';
}

// ===== DEATH SCREEN =====
function showDeathScreen() {
savePermanent(); // Save gold, goingRate, sig upgrades
// Recruits persist until killed - don't clear here

// Check if this is the first time meeting Death
if(!S.tutorialFlags.death_intro) {
showDeathIntroDialogue();
return;
}

const v = document.getElementById('gameView');
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];
const passiveSigils = ['Expand', 'Asterisk', 'Star'];
const allSigils = [...coreSigils, ...advancedSigils, ...passiveSigils];

// Select a random Death quote that hasn't been used yet
let deathQuote = "";
if(S.usedDeathQuotes.length >= DEATH_QUOTES.length) {
// All quotes used - reset the pool
S.usedDeathQuotes = [];
}
const availableQuotes = DEATH_QUOTES.filter((_, idx) => !S.usedDeathQuotes.includes(idx));
if(availableQuotes.length > 0) {
const randomIdx = Math.floor(Math.random() * availableQuotes.length);
deathQuote = availableQuotes[randomIdx];
// Mark this quote as used
const quoteIndex = DEATH_QUOTES.indexOf(deathQuote);
S.usedDeathQuotes.push(quoteIndex);
savePermanent(); // Save the updated usedDeathQuotes
}

let html = `
<style>
@keyframes marquee-flash {
  0%, 100% { border-color: #dc2626; box-shadow: 0 0 10px rgba(220,38,38,0.8), 0 0 20px rgba(220,38,38,0.5); }
  50% { border-color: #3b82f6; box-shadow: 0 0 15px rgba(251,191,36,0.9), 0 0 30px rgba(251,191,36,0.6); }
}
.going-rate-marquee {
  animation: marquee-flash 1.5s ease-in-out infinite;
  border: 4px solid #dc2626;
  padding: 1.5rem;
  border-radius: 12px;
  background: linear-gradient(135deg, rgba(220,38,38,0.1), rgba(251,191,36,0.1));
  margin: 1.5rem 0;
}
</style>
<div class="death-screen-container" style="background:#f5f4ed;padding:2rem;border-radius:8px;max-width:900px;margin:0 auto;color:#2c2416;box-shadow:0 4px 12px rgba(0,0,0,0.15)">
<img src="assets/neutrals/shopkeeper2.png" style="max-width:100%;height:auto;max-width:400px;margin:0 auto 1rem auto;display:block;border-radius:8px;border:3px solid #dc2626;box-shadow:0 0 20px rgba(220,38,38,0.5)">
<h1 style="text-align:center;margin-bottom:1rem;font-size:2.5rem;color:#dc2626">‚ò†Ô∏è DEATH ‚ò†Ô∏è</h1>
${deathQuote ? `<p style="text-align:center;margin-bottom:1rem;font-size:1rem;color:#666;font-style:italic">"${deathQuote}"</p>` : ''}
<div class="going-rate-marquee">
<p style="text-align:center;font-size:1.3rem;margin:0">Gold: <strong style="color:#d97706">${S.gold}</strong></p>
<p style="text-align:center;font-size:1.5rem;margin:0.5rem 0 0 0;font-weight:bold;color:#dc2626">‚ö° Going Rate: ${S.goingRate}G ‚ö°</p>
</div>`;

if(S.gold === 0) {
html += `<p style="text-align:center;margin:2rem 0;font-size:1.2rem;color:#dc2626;font-style:italic">"Nothing? Really? Come back when you have something to offer."</p>`;
} else {
html += `<h3 style="margin-bottom:1rem;text-align:center;font-size:1.3rem;color:#2c2416">Upgrade Sigilarium:</h3>`;

// Helper function to render sigil upgrade cards
const renderSigilCards = (sigils) => {
let cards = '';
sigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
// Actives show their effective level (perm + 1 for display)
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const nextLevel = currentLevel + 1;
if(currentLevel >= 5) return; // Max level (5 for display)

const upgradeCount = S.sigUpgradeCounts[sig] || 0;
const baseCost = S.goingRate;
const escalationTable = [0, 25, 50, 100, 150];
const escalation = escalationTable[upgradeCount] || 150;
const cost = baseCost + escalation;

const canAfford = S.gold >= cost;
const colors = ['#666', '#000', '#0d9488', '#9333ea', '#d97706', '#ff00ff'];
const colorClass = colors[currentLevel] || '#666';
const nextColorClass = colors[nextLevel] || '#ff00ff';

cards += `
<div class="death-screen-sigil-card" style="background:#ffffff;padding:1rem;border-radius:8px;border:2px solid #2c2416;box-shadow:0 2px 4px rgba(0,0,0,0.1)">
<div style="font-weight:bold;margin-bottom:0.75rem;font-size:1.1rem">${sigilIconWithTooltip(sig, currentLevel, 750)}</div>
<div style="font-size:1rem;margin-bottom:0.75rem;font-weight:bold">
<span style="color:${colorClass}">L${currentLevel}</span> ‚Üí <span style="color:${nextColorClass}">L${nextLevel}</span>
</div>
<div style="font-size:0.9rem;margin-bottom:0.75rem;color:#666;font-weight:600">Cost: ${cost}G</div>
<button class="btn" ${!canAfford ? 'disabled style="opacity:0.4"' : ''} onclick="purchaseSigilUpgrade('${sig}', ${cost})" style="padding:0.5rem 1rem;font-size:0.9rem;width:100%">
${canAfford ? 'Purchase' : 'Too Expensive'}
</button>
</div>`;
});
return cards;
};

// Core Sigils
html += `<h4 style="color:#2c63c7;margin:1rem 0 0.5rem 0;text-align:center;font-size:1.1rem">‚öîÔ∏è Core Sigils</h4>`;
html += `<div class="death-screen-sigil-grid" style="display:grid;grid-template-columns:repeat(4,1fr);gap:1rem;margin-bottom:1.5rem;max-width:850px;margin-left:auto;margin-right:auto">`;
html += renderSigilCards(coreSigils);
html += `</div>`;

// Advanced Sigils
html += `<h4 style="color:#f97316;margin:1rem 0 0.5rem 0;text-align:center;font-size:1.1rem">üî• Advanced Sigils</h4>`;
html += `<div class="death-screen-sigil-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-bottom:1.5rem;max-width:850px;margin-left:auto;margin-right:auto">`;
html += renderSigilCards(advancedSigils);
html += `</div>`;

// Passive Sigils
html += `<h4 style="color:#9333ea;margin:1rem 0 0.5rem 0;text-align:center;font-size:1.1rem">‚ú® Passive Sigils</h4>`;
html += `<div class="death-screen-sigil-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-bottom:1.5rem;max-width:850px;margin-left:auto;margin-right:auto">`;
html += renderSigilCards(passiveSigils);
html += `</div>`;
}

// Death Boys (only if Ghost Boys converted)
if(S.ghostBoysConverted) {
html += `
<div style="border-top:2px solid rgba(255,255,255,0.2);padding-top:2rem;margin-top:2rem">
<h2 style="text-align:center;margin-bottom:0.5rem;font-size:1.5rem;color:#a855f7">The Death Boys</h2>
<p style="text-align:center;margin-bottom:1.5rem;font-size:0.9rem;font-style:italic;opacity:0.8">"We work for Death now! It's WAY cooler than being ghosts!"</p>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-bottom:1.5rem">
<!-- Boy 1: Sell Back -->
<div style="background:rgba(34,197,94,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(34,197,94,0.3)">
<h3 style="color:#22c55e;margin-bottom:0.5rem">Death Boy 1: "Sell Back"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Remove one upgrade level from any sigil and get Gold equal to the current Going Rate (no +5G increase)</p>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G</div>`;

// List all sigils that can be sold back
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const canSellBack = permLevel > 0;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIconWithTooltip(sig, currentLevel, 750)} L${currentLevel}</span>
<button class="btn" ${!canSellBack ? 'disabled style="opacity:0.4"' : ''} onclick="deathBoySellBack('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSellBack ? `Sell for ${S.goingRate}G` : 'Cannot Sell'}
</button>
</div>`;
});

html += `</div>

<!-- Boy 2: Sacrifice for XP -->
<div style="background:rgba(168,85,247,0.1);padding:1.5rem;border-radius:8px;border:2px solid rgba(168,85,247,0.3)">
<h3 style="color:#a855f7;margin-bottom:0.5rem">Death Boy 2: "Sacrifice"</h3>
<p style="font-size:0.85rem;margin-bottom:1rem;opacity:0.9">Sacrifice one upgrade level to gain ${S.goingRate} Starting XP permanently. Going Rate decreases by 5G.</p>
<div style="font-size:0.8rem;margin-bottom:0.5rem;opacity:0.7">Current Starting XP: ${S.startingXP}</div>
<div style="font-size:0.8rem;margin-bottom:1rem;opacity:0.7">Going Rate: ${S.goingRate}G ‚Üí ${Math.max(1, S.goingRate - 5)}G</div>`;

// List all sigils that can be sacrificed
const actives2 = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
allSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const isActive = actives2.includes(sig);
const currentLevel = isActive ? permLevel + 1 : permLevel;
const canSacrifice = permLevel > 0 && S.goingRate > 1;
html += `
<div style="background:rgba(0,0,0,0.3);padding:0.5rem;margin-bottom:0.5rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center">
<span>${sigilIconWithTooltip(sig, currentLevel, 750)} L${currentLevel}</span>
<button class="btn" ${!canSacrifice ? 'disabled style="opacity:0.4"' : ''} onclick="deathBoySacrifice('${sig}')" style="padding:0.3rem 0.6rem;font-size:0.75rem">
${canSacrifice ? `+${S.goingRate}XP` : 'Cannot'}
</button>
</div>`;
});

html += `</div>
</div>
</div>`;
}

html += `
<div style="text-align:center;margin-top:2rem">
<button class="btn danger" onclick="restartAfterDeath()" style="font-size:1.2rem;padding:1rem 2rem">Return to Ribbleton</button>
</div>
</div>`;

v.innerHTML = html;
}

function purchaseSigilUpgrade(sig, cost) {
if(S.gold < cost) { toast('Not enough Gold!'); return; }

// Check max level: actives max at perm L4 (displays as L5), passives max at perm L5
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const permLevel = S.sig[sig] || 0;
const maxLevel = isActive ? 4 : 5;

if(permLevel >= maxLevel) {
toast('Already at maximum level!', 1800);
return;
}

S.gold -= cost;
S.sig[sig] = (S.sig[sig] || 0) + 1;
S.sigUpgradeCounts[sig] = (S.sigUpgradeCounts[sig] || 0) + 1;
S.goingRate += 5;
// JUICE: Power up sound for sigil upgrade
SoundFX.play('powerUp');
toast(`${sig} upgraded to L${S.sig[sig]}!`, 1200);
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySellBack(sig) {
const permLevel = S.sig[sig] || 0;
if(permLevel <= 0) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
// Sell back: get gold, lower sigil level, no going rate change
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const oldLevel = isActive ? permLevel + 1 : permLevel;
S.gold += S.goingRate;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
const newPermLevel = S.sig[sig];
const newLevel = isActive ? newPermLevel + 1 : newPermLevel;
toast(`Sold ${sig} L${oldLevel}‚ÜíL${newLevel} for ${S.goingRate}G!`, 1800);
savePermanent();
showDeathScreen(); // Refresh
}

function deathBoySacrifice(sig) {
const permLevel = S.sig[sig] || 0;
if(permLevel <= 0) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
if(S.goingRate <= 1) {
toast("Whoa, something's weird. I can't do that", 1800);
return;
}
// Sacrifice: get starting XP, lower sigil level, decrease going rate
const actives = ['Attack', 'Shield', 'Grapple', 'Heal', 'Ghost', 'D20', 'Alpha'];
const isActive = actives.includes(sig);
const oldLevel = isActive ? permLevel + 1 : permLevel;
const xpGained = S.goingRate;
S.startingXP += xpGained;
S.sig[sig]--;
S.sigUpgradeCounts[sig] = Math.max(0, (S.sigUpgradeCounts[sig] || 0) - 1);
S.goingRate = Math.max(1, S.goingRate - 5);
const newPermLevel = S.sig[sig];
const newLevel = isActive ? newPermLevel + 1 : newPermLevel;
toast(`Sacrificed ${sig} L${oldLevel}‚ÜíL${newLevel} for +${xpGained}XP permanently!`, 1800);
savePermanent();
showDeathScreen(); // Refresh
}

function restartAfterDeath() {
// Check if player has unspent gold
if(S.gold >= S.goingRate && !S.tutorialFlags.death_exit_warning) {
showTutorialPop('death_exit_warning', "Are you sure? This is some <span style='font-size:0.7em'>great value</span> and you'll end up giving it to me sooner or later...", () => {
// After tutorial, ask for confirmation
showConfirmModal('Leave Death Screen with unspent gold?', () => {
actuallyRestartAfterDeath();
}, () => {
showDeathScreen();
});
});
return;
}
actuallyRestartAfterDeath();
}

function actuallyRestartAfterDeath() {
// Increment run number
S.runNumber++;
savePermanent();
// Clear run-specific save (slot-specific)
if(S.currentSlot) {
localStorage.removeItem(`froggle8_slot${S.currentSlot}`);
}
// Also clear old save format for backwards compatibility
localStorage.removeItem('froggle8');
// Return to Ribbleton hub
toast('Returning to Ribbleton...', 1200);
setTimeout(() => transitionScreen(showRibbleton), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}

// ===== CHAMPIONS MENU =====
function showChampionsMenu() {
const v = document.getElementById('gameView');
const pedestalCount = S.pedestal.filter(p => p.mode === S.gameMode).length;
const maxSlots = 8;

let html = `
<style>
@keyframes champions-portal-pulse {
  0%, 100% { transform: scale(1); opacity: 0.9; }
  50% { transform: scale(1.08); opacity: 1; }
}
@keyframes champions-portal-spin {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}
</style>
<div style="position:relative;max-width:800px;margin:0 auto">
<h1 style="text-align:center;margin:1rem 0;font-size:2rem;background:linear-gradient(135deg,#3b82f6,#f97316);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text">
üèÜ The Flydra's Conquerors üèÜ
</h1>

<div style="position:relative;width:100%;margin:0 auto">
<img src="assets/champions-hall.png" style="width:100%;display:block;border-radius:8px;border:3px solid #000">

<!-- Clickable pedestal hotspot (center) -->
<div onclick="showPedestal()" style="position:absolute;left:35%;top:30%;width:30%;height:50%;cursor:pointer" title="View Pedestal"></div>

<!-- Clickable left portal (blue portal - leads to Standard mode) -->
<div onclick="enterPortal('Standard')" style="position:absolute;left:5%;top:20%;width:20%;height:60%;cursor:pointer" title="${S.gameMode === 'Standard' ? 'Current Mode' : 'Enter Standard Realm'}"></div>

<!-- Clickable right portal (green portal - leads to FU mode) - Animated swirling portal -->
<div onclick="enterPortal('fu')" style="position:absolute;right:5%;top:20%;width:20%;height:60%;cursor:pointer;transition:transform 0.2s;display:flex;align-items:center;justify-content:center"
     onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"
     title="${S.gameMode === 'fu' ? 'Current Mode' : 'Enter Frogged Up Realm üî•'}">
  <div style="width:100px;height:100px;position:relative;border-radius:50%;background:radial-gradient(circle, #22c55e, #064e3b);animation:champions-portal-pulse 1s ease-in-out infinite;box-shadow:0 0 40px #22c55e">
    <div style="position:absolute;top:50%;left:50%;font-size:3.5rem;animation:champions-portal-spin 2s linear infinite">üåÄ</div>
  </div>
</div>
</div>

<div style="text-align:center;margin-top:1.5rem;padding:1rem;background:rgba(251,191,36,0.1);border:2px solid #3b82f6;border-radius:8px">
<p style="margin:0.5rem 0;font-size:1rem"><strong>Current Mode:</strong> <span style="color:${S.gameMode === 'fu' ? '#22c55e' : '#3b82f6'}">${S.gameMode === 'Standard' ? 'Standard' : 'FROGGED UP üî•'}</span></p>
<p style="margin:0.5rem 0;font-size:0.9rem;opacity:0.8">Click the <strong>pedestal</strong> to manage figurines (${pedestalCount}/${maxSlots})</p>
<p style="margin:0.5rem 0;font-size:0.9rem"><strong>üîµ Blue Portal:</strong> Standard Mode | <strong>üü¢ Green Portal:</strong> Frogged Up Mode</p>
</div>

<div style="text-align:center;margin-top:1rem">
<button class="btn secondary" onclick="title()">Back to Title</button>
</div>
</div>`;

v.innerHTML = html;
}

function enterPortal(targetMode) {
if(S.gameMode === targetMode) {
toast('You are already in this realm!');
return;
}
S.gameMode = targetMode;
toast(`Entered ${targetMode === 'Standard' ? 'Standard' : 'Frogged Up üî•'} Realm!`);
showChampionsMenu();
}

// NOTE: Waiting on Champions Hall toggle button image asset from Preston
// This function will be used for a visual toggle button in the Champions menu
function toggleModeFromChampions() {
S.gameMode = S.gameMode === 'Standard' ? 'fu' : 'Standard';
showChampionsMenu();
}

// ===== PEDESTAL UI =====
function showPedestal() {
const v = document.getElementById('gameView');
const heroes = ['Warrior', 'Tank', 'Mage', 'Healer'];
const heroIcons = {'Warrior': '‚öî', 'Tank': 'üõ°', 'Mage': 'üìñ', 'Healer': '‚úö'};
const stats = ['POW', 'HP'];

// Build slot grid overlay on the pedestal image
let slotsHTML = '';
stats.forEach((stat, rowIdx) => {
heroes.forEach((hero, colIdx) => {
const slotted = S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
const isSlotted = !!slotted;

// Position slots in a 2x4 grid over the pedestal image
// Adjust these percentages to match the actual slot positions on the pedestal art
const left = 20 + (colIdx * 20); // Distribute 4 columns across width
const top = 40 + (rowIdx * 25); // Distribute 2 rows across height

slotsHTML += `
<div style="position:absolute;left:${left}%;top:${top}%;width:15%;height:20%;display:flex;align-items:center;justify-content:center;cursor:pointer" onclick="${isSlotted ? `removeFigurine('${hero}','${stat}')` : `slotFigurine('${hero}','${stat}')`}">
<div style="width:100%;height:100%;background:${isSlotted ? 'rgba(251,191,36,0.3)' : 'rgba(255,255,255,0.1)'};border:2px solid ${isSlotted ? '#3b82f6' : 'rgba(255,255,255,0.3)'};border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;backdrop-filter:blur(2px)">`;

if(isSlotted) {
const displayIcon = slotted.source === 'statuette' ? 'üóø' : heroIcons[hero];
slotsHTML += `<div style="font-size:2rem;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.5))">${displayIcon}</div>
<div style="font-size:0.7rem;background:#000;color:#fff;padding:2px 4px;border-radius:3px;margin-top:2px">${stat === 'POW' ? '+1' : '+5'}</div>`;
} else {
slotsHTML += `<div style="font-size:1.5rem;color:rgba(255,255,255,0.4);text-shadow:0 2px 4px rgba(0,0,0,0.5)">+</div>`;
}

slotsHTML += `</div></div>`;
});
});

// Add legend showing hero names at top
let legendHTML = '<div style="position:absolute;top:10%;left:0;right:0;display:flex;justify-content:space-around;padding:0 15%">';
heroes.forEach(hero => {
legendHTML += `<div style="text-align:center;color:#fff;text-shadow:0 2px 4px rgba(0,0,0,0.8)">
<div style="font-size:1.5rem;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.8))">${heroIcons[hero]}</div>
<div style="font-size:0.75rem;font-weight:bold">${hero}</div>
</div>`;
});
legendHTML += '</div>';

// Add stat labels on left
let statLabelsHTML = '<div style="position:absolute;left:5%;top:40%;display:flex;flex-direction:column;gap:25%">';
stats.forEach(stat => {
statLabelsHTML += `<div style="color:#fff;font-weight:bold;text-shadow:0 2px 4px rgba(0,0,0,0.8);font-size:1.2rem">${stat}</div>`;
});
statLabelsHTML += '</div>';

let html = `
<div class="neutral-container">
<div class="neutral-left" style="position:relative;min-height:600px">
<div class="neutral-header">
<div class="neutral-stats">üí∞ ${S.gold}G | üéØ Floor ${S.floor}</div>
<div class="neutral-narrative">
<h2 style="margin:0">‚ö±Ô∏è Pedestal of Champions</h2>
<p style="margin:0.5rem 0;font-size:0.9rem">${S.gameMode} Mode - Place figurines for permanent stat buffs</p>
</div>
</div>

${legendHTML}
${statLabelsHTML}
${slotsHTML}

${S.hasAncientStatuette ? `<div style="position:absolute;bottom:15%;left:10%;right:10%;padding:1rem;background:rgba(251,191,36,0.9);border-radius:6px;text-align:center;border:2px solid #000">
<p style="font-weight:bold;margin-bottom:0.5rem">üóø Ancient Statuette Available!</p>
<p style="font-size:0.9rem;margin:0">Click any empty slot to place it</p>
</div>` : ''}

<div style="position:absolute;bottom:5%;left:50%;transform:translateX(-50%)">
<button class="btn secondary" onclick="showChampionsMenu()">Back to Victory Room</button>
</div>
</div>
<div class="neutral-right" style="background-image:url('assets/neutrals/statue2.png')"></div>
</div>`;

v.innerHTML = html;
}

function slotFigurine(hero, stat) {
// Check if slot is available
if(S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode)) {
toast('Slot already filled!');
return;
}

// Check if we have 8 slots filled
const slotsUsed = S.pedestal.filter(p => p.mode === S.gameMode).length;
if(slotsUsed >= 8) {
toast('All 8 slots filled! Remove a figurine first.');
return;
}

// Use Ancient Statuette if available (can go in any slot)
if(S.hasAncientStatuette) {
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'statuette'});
S.hasAncientStatuette = false;
savePermanent();
toast(`Ancient Statuette placed on ${hero} ${stat}!`, 1800);
showPedestal();
return;
}

// Otherwise, check if this hero can have a figurine (max 2 per hero per mode)
const existingCount = S.pedestal.filter(p => p.hero === hero && p.mode === S.gameMode).length;
if(existingCount >= 2) {
toast(`${hero} already has 2 figurines in ${S.gameMode} mode!`, 1800);
return;
}

// Place the hero figurine
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'hero'});
savePermanent();
toast(`${hero} ${stat} figurine placed!`, 1800);
showPedestal();
}

function removeFigurine(hero, stat) {
const idx = S.pedestal.findIndex(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
if(idx >= 0) {
S.pedestal.splice(idx, 1);
savePermanent();
toast(`${hero} ${stat} figurine removed!`);
showPedestal();
}
}

// ===== WIN =====
function win() {
// JUICE: Victory music and treasure sound!
ProceduralMusic.playVictory();
SoundFX.play('treasure');

// Record victory to The Pond!
recordPondHistory('victory');

// Reset run state on victory
S.gold = 0; // Gold is lost on victory
S.tempSigUpgrades = {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0}; // Clear temp upgrades
S.recruits = []; // Clear recruits
savePermanent();

// Award figurines for heroes who survived (HP > 0, not Last Stand)
const survivedHeroes = S.heroes.filter(h => h.h > 0 && !h.ls);
const earnedFigurines = [];
survivedHeroes.forEach(h => {
// Check if this hero already has 2 figurines for this mode
const existingCount = S.pedestal.filter(slot => slot.hero === h.n && slot.mode === S.gameMode).length;
if(existingCount < 2) {
earnedFigurines.push(h.n);
}
});

// Unlock Frogged Up mode if Standard victory
const firstStandardVictory = S.gameMode === 'Standard' && !S.tutorialFlags.first_victory_sequence;
if(S.gameMode === 'Standard') {
S.fuUnlocked = true;
if(firstStandardVictory) {
S.tutorialFlags.first_victory_sequence = true;
}
}

const firstFU = S.gameMode === 'fu' && !S.tutorialFlags.first_fu_victory;
if(firstFU) {
S.tutorialFlags.first_fu_victory = true;
// Note: Tapo is now unlocked at Floor 20 via Old Tapo encounter
}

savePermanent();

// Store earned figurines for later display
window.earnedFigurines = earnedFigurines;

// FIRST STANDARD VICTORY: Show cutscene
if(firstStandardVictory) {
showFirstVictoryCutscene();
return;
}

// FIRST FU VICTORY: Show credits
if(firstFU) {
showFUVictoryCredits();
return;
}

// TAPO IN PARTY: Show heartfelt thank you (only if Tapo is alive)
const tapoInParty = S.heroes.some(h => h.n === 'Tapo' && h.h > 0 && !h.ls);
if(tapoInParty && !S.tutorialFlags.tapo_victory_message) {
S.tutorialFlags.tapo_victory_message = true;
savePermanent();
showTapoVictoryMessage();
return;
}

// SUBSEQUENT VICTORIES: Go directly to Pedestal if figurines earned
if(earnedFigurines.length > 0 || S.hasAncientStatuette) {
showStatueRoom();
return;
}

// No figurines earned: show simple victory screen
showSimpleVictoryScreen();
}

function showFirstVictoryCutscene() {
const slides = [
{bg: 'assets/victory-room.png', text: "19 grueling floors later, your heroes finally find him - <strong style='color:#22c55e'>Tapo the Tadpole</strong>, happily playing with a collection of strange glowing figurines!"},
{bg: 'assets/victory-room.png', text: "The little tadpole squeaks excitedly as the heroes approach. Around him lay scattered statues - each one depicting a heroic frog warrior."},
{bg: 'assets/victory-room.png', text: "The heroes carefully gather the mysterious figurines. The statues pulse with magical energy, and match the carvings on the nearby ancient pedestal.", action: 'statue_slotting'},
{bg: 'assets/ribbleton.png', text: "As the heroes slot the statues, they feel immense power surge through them! Each figurine permanently boosts a hero's <strong style='color:#ef4444'>POW (+1)</strong> or <strong style='color:#22c55e'>HP (+5)</strong>. With Tapo safely in the hero's arms, the heroes step back through the portal..."},
{bg: 'assets/ribbleton.png', text: "The portal deposits them back in <strong style='color:#22c55e'>Ribbleton's square</strong>. The townspeople erupt in cheers as the heroes emerge victorious, and Tapo is carried away on an epic froggy crowd surf!"},
{bg: 'assets/ribbleton.png', text: "Exhausted but triumphant, the heroes finally get a moment to rest and celebrate their victory. The red portal behind them shimmers ominously. Had Tapo gone back through?"},
{bg: 'assets/victory-room.png', text: "A quick trip back to the statue room later, and there's Tapo! But he's staring at a <strong style='color:#9333ea'>new portal</strong> that has emerged in the room, crackling with black and green arcane energy."},
{bg: 'assets/victory-room.png', text: "Before anyone can stop him, the little bugger squirms his way into this green-black portal - uh oh! <span style='font-size:1.3em;font-weight:bold;color:#9333ea'>Here we go again!</span>"}
];

// Custom slide handler for statue slotting
window.firstVictorySlideAction = (action, slideIndex, callback) => {
if(action === 'statue_slotting') {
// Show pedestal after this slide, then continue cutscene
showFirstVictoryPedestal(() => {
callback();
});
return true; // Handled
}
return false; // Not handled
};

slides.onComplete = () => {
window.firstVictorySlideAction = null;
showChampionsMenu();
};

showNarrativeSlide(slides, 0);
}

function showFirstVictoryPedestal(onComplete) {
// Show a simplified pedestal UI during the first victory cutscene
const v = document.getElementById('gameView');
const heroes = ['Warrior', 'Tank', 'Mage', 'Healer'];
const heroIcons = {'Warrior': '‚öî', 'Tank': 'üõ°', 'Mage': 'üìñ', 'Healer': '‚úö'};
const stats = ['POW', 'HP'];

// Build slot grid
let slotsHTML = '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:1rem;margin:1rem 0">';
stats.forEach((stat, rowIdx) => {
heroes.forEach((hero, colIdx) => {
const slotted = S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
const isSlotted = !!slotted;

slotsHTML += `
<div style="background:${isSlotted ? 'rgba(251,191,36,0.3)' : 'rgba(255,255,255,0.1)'};border:2px solid ${isSlotted ? '#fbbf24' : 'rgba(255,255,255,0.3)'};border-radius:8px;padding:1rem;text-align:center;cursor:pointer" onclick="${isSlotted ? `removeFirstVicFigurine('${hero}','${stat}')` : `slotFirstVicFigurine('${hero}','${stat}')`}">
<div style="font-size:1.5rem">${heroIcons[hero]}</div>
<div style="font-size:0.8rem;font-weight:bold">${hero}</div>
<div style="font-size:0.7rem;color:#94a3b8">${stat === 'POW' ? '+1 POW' : '+5 HP'}</div>
${isSlotted ? '<div style="color:#fbbf24;font-size:0.8rem;margin-top:0.5rem">‚úì Slotted</div>' : '<div style="color:#64748b;font-size:0.8rem;margin-top:0.5rem">Click to slot</div>'}
</div>`;
});
});
slotsHTML += '</div>';

const slotsUsed = S.pedestal.filter(p => p.mode === S.gameMode).length;

v.innerHTML = `
<div style="max-width:800px;margin:0 auto;padding:2rem;background:linear-gradient(135deg,#1e1b4b 0%,#312e81 100%);border-radius:12px;border:3px solid #fbbf24;color:#fff">
<h2 style="text-align:center;margin-bottom:1rem;color:#fbbf24">‚ö±Ô∏è Slot Your Figurines!</h2>
<p style="text-align:center;margin-bottom:1rem;font-size:0.95rem">Place figurines on the pedestal to permanently boost your heroes. Each hero can have up to 2 figurines per mode.</p>
<p style="text-align:center;margin-bottom:1rem;font-size:0.85rem;color:#94a3b8">Slots used: ${slotsUsed}/8</p>
${slotsHTML}
<div style="text-align:center;margin-top:1.5rem">
<button class="btn" onclick="window.firstVicPedestalComplete()" style="padding:1rem 2rem;font-size:1.1rem">Continue Story</button>
</div>
</div>`;

window.firstVicPedestalComplete = onComplete;
}

function slotFirstVicFigurine(hero, stat) {
if(S.pedestal.find(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode)) {
toast('Slot already filled!');
return;
}
const slotsUsed = S.pedestal.filter(p => p.mode === S.gameMode).length;
if(slotsUsed >= 8) {
toast('All 8 slots filled! Remove a figurine first.');
return;
}
const existingCount = S.pedestal.filter(p => p.hero === hero && p.mode === S.gameMode).length;
if(existingCount >= 2) {
toast(`${hero} already has 2 figurines in ${S.gameMode} mode!`, 1800);
return;
}
S.pedestal.push({hero, stat, mode: S.gameMode, source: 'hero'});
savePermanent();
toast(`${hero} ${stat} figurine placed!`, 1200);
showFirstVictoryPedestal(window.firstVicPedestalComplete);
}

function removeFirstVicFigurine(hero, stat) {
const idx = S.pedestal.findIndex(p => p.hero === hero && p.stat === stat && p.mode === S.gameMode);
if(idx >= 0) {
S.pedestal.splice(idx, 1);
savePermanent();
toast(`${hero} ${stat} figurine removed!`);
showFirstVictoryPedestal(window.firstVicPedestalComplete);
}
}

function showFUVictoryCredits() {
const v = document.getElementById('gameView');

// Check if this is a Tapo victory (gated behind beating FU with Tapo)
const tapoInParty = S.heroes.some(h => h.n === 'Tapo');

v.innerHTML = `
<div style="max-width:600px;margin:2rem auto;padding:2rem;background:linear-gradient(135deg,#1e1b4b 0%,#7c2d12 100%);border-radius:12px;border:3px solid #22c55e;color:#fff">
<h1 style="text-align:center;margin-bottom:2rem;font-size:2.5rem">üî• FROGGED UP MODE CONQUERED! üî•</h1>

<div style="text-align:center;margin-bottom:2rem;font-size:1.2rem;line-height:1.8">
<p>Holy frog. You defeated the ${tapoInParty ? '(second) ' : ''}hardest challenge in FROGGLE.</p>
<p style="margin-top:1rem">Thank you for playing. No other thank yous really matter - <strong>YOU</strong>, the Player, deserve all the thanks in the world.</p>
${!tapoInParty ? `<p style="margin-top:1.5rem;font-style:italic;color:#fbbf24">Now, think you can beat the FROGGED UP Flydra with Tapo in your party?</p>` : ''}
<p style="font-size:2rem;margin:2rem 0">‚ù§Ô∏è</p>
</div>

<div style="background:rgba(0,0,0,0.3);padding:1.5rem;border-radius:8px;margin:2rem 0">
<h3 style="text-align:center;margin-bottom:1rem;color:#22c55e">FROGGLE</h3>
<div style="text-align:center;font-size:0.9rem;line-height:2;opacity:0.9">
<p><strong>A DubsPubs game by Preston Wesley Evans</strong></p>
<p>Design, Art, & Code: Preston + Claude</p>
<p>Playtesting: Michael Griffin, Charlie Schmidt, Carolyn Powell, Matt Sutz, Ryan Evertz</p>
<p>Inspiration: Inscryption, Slay the Spire, Balatro, and too much coffee</p>
<p>Sanity: Erin Keif, Adal Rfai, JPC, Odell Brewing</p>
<p>Support: Lisa Evans</p>
</div>
</div>

<div style="background:rgba(251,191,36,0.2);padding:1.5rem;border-radius:8px;margin:2rem 0;border:2px solid #22c55e">
<h3 style="text-align:center;margin-bottom:1rem">üéâ TAPO UNLOCKED! üéâ</h3>
<img src="assets/tapo.png" style="max-width:200px;height:auto;display:block;margin:1rem auto;border-radius:8px">
<p style="text-align:center;margin-top:1rem">Tapo the Tadpole is now available as a playable hero!</p>
<p style="text-align:center;font-size:0.9rem;opacity:0.8;margin-top:0.5rem">Stats: 1 POW, 1 HP ‚Ä¢ Has access to ALL sigils in the Sigilarium</p>
<p style="text-align:center;font-size:0.85rem;opacity:0.6;margin-top:0.5rem;font-style:italic">(Glass cannon mode activated)</p>
</div>

<div style="text-align:center">
<button class="btn safe" onclick="showStatueRoom()" style="padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem">Place Figurines</button>
<button class="btn" onclick="title()" style="padding:1rem 2rem;font-size:1.1rem">Play Again</button>
</div>
</div>`;
}

function showTapoVictoryMessage() {
const v = document.getElementById('gameView');
v.innerHTML = `
<style>
@keyframes tapoSignatureVictory {
  /* Double jump RIGHT */
  0% { transform: translateY(0) scaleX(1); }
  10% { transform: translateY(-30px) scaleX(1); }
  20% { transform: translateY(0) scaleX(1); }
  30% { transform: translateY(-40px) scaleX(1); }
  40% { transform: translateY(0) scaleX(1); }
  /* Flip to LEFT */
  45% { transform: translateY(-15px) scaleX(0); }
  50% { transform: translateY(0) scaleX(-1); }
  /* Double jump LEFT */
  60% { transform: translateY(-30px) scaleX(-1); }
  70% { transform: translateY(0) scaleX(-1); }
  80% { transform: translateY(-40px) scaleX(-1); }
  90% { transform: translateY(0) scaleX(-1); }
  /* Flip back to RIGHT */
  95% { transform: translateY(-15px) scaleX(0); }
  100% { transform: translateY(0) scaleX(1); }
}
</style>
<div style="max-width:700px;margin:2rem auto;padding:3rem;background:linear-gradient(135deg,#22c55e 0%,#10b981 50%,#059669 100%);border-radius:16px;border:4px solid #3b82f6;color:#fff;box-shadow:0 8px 32px rgba(0,0,0,0.3)">
<h1 style="text-align:center;margin-bottom:2rem;font-size:3rem;text-shadow:2px 2px 4px rgba(0,0,0,0.3)">üèÜ VICTORY! üèÜ</h1>

<div style="text-align:center;margin:2rem 0">
<div style="display:inline-block;animation:tapoSignatureVictory 4.8s ease-in-out infinite">
<img src="assets/tapo-nobg.png" style="max-width:250px;height:auto;display:block;margin:0 auto 2rem auto">
</div>
</div>

<div style="background:rgba(0,0,0,0.2);padding:2rem;border-radius:12px;margin:2rem 0;border:2px solid rgba(251,191,36,0.5)">
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
Holy frog. I can't believe you put this much time into my silly little game.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;margin-bottom:1.5rem;font-weight:500">
From the bottom of my heart, thank you for playing.
</p>
<p style="text-align:center;font-size:1.3rem;line-height:2;font-weight:500">
I hope you had fun!
</p>
<p style="text-align:center;font-size:1.1rem;margin-top:2rem;font-style:italic;opacity:0.9">
-Preston
</p>
</div>

<div style="text-align:center;font-size:2.5rem;margin:2rem 0">
‚ù§Ô∏èüê∏‚ù§Ô∏è
</div>

<div style="text-align:center;margin-top:2rem">
${window.earnedFigurines && window.earnedFigurines.length > 0 ?
  '<button class="btn" onclick="showStatueRoom()" style="background:#3b82f6;color:#000;padding:1rem 2rem;font-size:1.1rem;margin-bottom:1rem;font-weight:bold">Place Figurines</button><br>' :
  ''}
<button class="btn" onclick="title()" style="background:#fff;color:#22c55e;padding:1rem 2rem;font-size:1.1rem;font-weight:bold">Play Again</button>
</div>
</div>`;
}

function showStatueRoom() {
// This redirects to the existing Pedestal UI
showTutorialPop('pedestal_first_placement', "Welcome to the Pedestal! Figurines are rewards for heroes who survive to victory. Place them here to permanently boost that hero's stats. Each hero can earn up to 2 figurines per difficulty mode.", () => {
showPedestal();
});
}

function showSimpleVictoryScreen() {
const v = document.getElementById('gameView');
let html = `
<h1 style="text-align:center;margin:2rem 0;font-size:2.5rem">üèÜ VICTORY! üèÜ</h1>`;

if(S.gameMode === 'fu') {
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1.2rem">You conquered the Frogged Up realm once again!<br>Impressive.</p>`;
} else {
html += `<img src="assets/tapo.png" style="max-width:100%;height:auto;max-width:400px;margin:1rem auto;display:block;border-radius:8px;border:3px solid #000">`;
html += `<p style="text-align:center;margin-bottom:1rem;font-size:1.2rem;font-weight:bold">You saved Tapo the Tadpole!</p>`;

// Check if they've explored FU mode and show conditional text
const hasExploredFU = (S.pondHistory || []).some(r => r.gameMode === 'fu');
if(hasExploredFU) {
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1rem;color:#22c55e">Ready to try FROGGED UP mode again?</p>`;
} else {
html += `<p style="text-align:center;margin-bottom:2rem;font-size:1rem;color:#64748b">Have you explored the green portal in the statue room yet?</p>`;
}
}

if(window.earnedFigurines && window.earnedFigurines.length > 0) {
html += `<div style="background:rgba(251,191,36,0.1);padding:1rem;border-radius:8px;margin:1rem auto;max-width:500px">
<h3 style="text-align:center;margin-bottom:0.5rem">üèÜ Hero Figurines Earned! üèÜ</h3>
<p style="text-align:center">The following heroes can place figurines (Max 2 per frog):</p>
<ul style="list-style:none;padding:0;text-align:center">`;
window.earnedFigurines.forEach(name => {
html += `<li style="margin:0.5rem 0;font-weight:bold">${name}</li>`;
});
html += `</ul></div>`;
}

html += `<div style="text-align:center;margin-top:2rem">
<button class="btn" onclick="showStatueRoom()" style="padding:1rem 2rem;font-size:1.1rem;margin-right:1rem">Place Figurines</button>
<button class="btn secondary" onclick="showRibbleton()" style="padding:1rem 2rem;font-size:1.1rem">Return to Ribbleton</button>
</div>`;

v.innerHTML = html;
}

// ===== RIBBLETON HUB =====
function showRibbleton() {
// Show game header in Ribbleton with location label
S.inRibbleton = true;
const header = document.getElementById('gameHeader');
if(header) header.style.display = 'flex';
// JUICE: Ambient music for Ribbleton hub
ProceduralMusic.startAmbient();
upd(); // Update header to show "Ribbleton"

const v = document.getElementById('gameView');
const bluePortalUnlocked = S.hasReachedFloor20;

// Show tutorial for first-time visitors to Ribbleton hub
const isFirstVisit = !S.tutorialFlags.ribbleton_hub_intro;
if(isFirstVisit && !S.helpTipsDisabled) {
  showTutorialPop('ribbleton_hub_intro', "Welcome home to Ribbleton! This is your safe haven between adventures. Click the glowing red portal on the right to begin your next rescue mission and save Tapo!");
}

let html = `
<style>
@keyframes ribbleton-portal-pulse {
  0%, 100% { transform: scale(1); opacity: 0.9; box-shadow: 0 0 30px #dc2626; }
  50% { transform: scale(1.08); opacity: 1; box-shadow: 0 0 50px #dc2626; }
}
@keyframes ribbleton-portal-spin {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}
</style>
<div style="position:relative;width:100%;height:calc(100vh - 60px);overflow:hidden">
<!-- Full-page background image -->
<img src="assets/ribbleton.png" style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:0">

<!-- Title overlay at top -->
<div style="position:absolute;top:0;left:0;right:0;z-index:10;padding:1rem;background:linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.3) 70%, transparent 100%)">
<h1 style="text-align:center;margin:0;font-size:2rem;color:#22c55e;text-shadow:2px 2px 6px rgba(0,0,0,0.9), 0 0 20px rgba(34,197,94,0.5)">
üê∏ Welcome Home to Ribbleton! üê∏
</h1>
</div>

<!-- Portal area in bottom-right corner -->
<div style="position:absolute;bottom:1rem;right:1rem;z-index:10;display:flex;flex-direction:column;gap:0.75rem;align-items:flex-end">

<!-- Red Portal (Always Available) - Animated swirling portal -->
<div onclick="enterRedPortal()" style="cursor:pointer;transition:transform 0.2s;text-align:center"
     onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"
     title="Click to begin your adventure and save Tapo!">
  <div style="width:120px;height:120px;position:relative;border-radius:50%;background:radial-gradient(circle, #dc2626, #7c2d12);animation:ribbleton-portal-pulse 1s ease-in-out infinite;box-shadow:0 0 40px #dc2626">
    <div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:4rem;animation:ribbleton-portal-spin 2s linear infinite">üåÄ</div>
  </div>
  <p style="margin-top:0.5rem;font-size:1rem;font-weight:bold;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.9);background:rgba(220,38,38,0.8);padding:0.25rem 0.75rem;border-radius:6px;border:2px solid #dc2626">üê∏ Save Tapo!</p>
</div>

${bluePortalUnlocked ? `
<!-- Blue Portal (Unlocked after Floor 20) - Animated swirling portal -->
<div onclick="enterBluePortal()" style="cursor:pointer;transition:transform 0.2s;text-align:center"
     onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"
     title="Return to Floor 20 - Champions Hall">
  <div style="width:90px;height:90px;position:relative;border-radius:50%;background:radial-gradient(circle, #3b82f6, #1e3a8a);animation:ribbleton-portal-pulse 1.2s ease-in-out infinite;box-shadow:0 0 30px #3b82f6">
    <div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:3rem;animation:ribbleton-portal-spin 2.5s linear infinite">üåÄ</div>
  </div>
  <p style="margin-top:0.25rem;font-size:0.85rem;font-weight:bold;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.9);background:rgba(59,130,246,0.8);padding:0.2rem 0.5rem;border-radius:4px;border:2px solid #3b82f6">üèÜ Champions</p>
</div>
` : ''}

${S.pondHistory && S.pondHistory.length > 0 ? `
<button class="btn small" onclick="showPond()" style="background:linear-gradient(135deg,rgba(30,58,138,0.9),rgba(59,130,246,0.8));border:2px solid #60a5fa;font-size:0.9rem;padding:0.5rem 1rem;box-shadow:0 4px 12px rgba(0,0,0,0.5)">
ü™∑ The Pond
</button>
` : ''}
</div>
</div>`;

v.innerHTML = html;
}

function enterRedPortal() {
S.inRibbleton = false;
SoundFX.play('portal');
toast('Preparing to enter the dungeon...', 1200);
setTimeout(() => transitionScreen(title), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}

function enterBluePortal() {
if(!S.hasReachedFloor20) {
toast('The Blue Portal is locked!');
SoundFX.play('error');
return;
}
S.inRibbleton = false;
SoundFX.play('portal');
toast('Entering the Blue Portal...', 1200);
setTimeout(() => transitionScreen(showChampionsMenu), T(ANIMATION_TIMINGS.ACTION_COMPLETE));
}


// ===== DEBUG MODE =====
function toggleDebugMode(enabled) {
S.debugMode = enabled;
toast(enabled ? 'Debug Mode ON' : 'Debug Mode OFF', 1200);
// Update debug button visibility in header
const debugBtn = document.getElementById('debugBtn');
if(debugBtn) debugBtn.style.display = enabled ? 'block' : 'none';
// Refresh settings menu if open to show/hide debug tools button
const settingsMenu = document.querySelector('[style*="z-index:30000"]');
if(settingsMenu) {
closeSettingsMenu();
showSettingsMenu();
}
}

function toggleOopsAll20s(enabled) {
S.oopsAll20s = enabled;
toast(enabled ? 'üé≤ Oops All 20s: ON (All D20 rolls = 20!)' : 'üé≤ Oops All 20s: OFF', 1500);
// Refresh debug menu to update checkbox
const debugMenu = document.querySelector('[style*="z-index:30000"]');
if(debugMenu && debugMenu.textContent.includes('DEBUG MENU')) {
closeDebugMenu();
showDebugMenu();
}
}

function showDebugMenu() {
const inCombat = S.enemies && S.enemies.length > 0;
const v = document.getElementById('gameView');
const allSigils = ['Attack', 'Shield', 'Heal', 'D20', 'Expand', 'Grapple', 'Ghost', 'Asterisk', 'Star', 'Alpha'];
const heroNames = S.heroes.map((h, i) => ({name: h.n, idx: i}));

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">üõ†Ô∏è DEBUG MENU üõ†Ô∏è</h2>

<h3 class="modal-section-title green">Resources</h3>
<button class="btn" onclick="debugAddGold()" style="margin-bottom:0.5rem;background:#22c55e">+100 Gold</button>
<button class="btn" onclick="debugAddXP()" style="margin-bottom:0.5rem;background:#22c55e">+100 XP</button>

<h3 class="modal-section-title green">Navigation</h3>
<div style="margin:0.5rem 0">
<label style="color:white;font-size:0.9rem">Jump to Floor:</label>
<input type="number" id="debugFloorInput" min="1" max="19" value="${S.floor}" style="width:60px;padding:0.25rem;margin:0 0.5rem;font-size:1rem">
<button class="btn" onclick="debugJumpFloor()" style="display:inline-block;width:auto;padding:0.5rem 1rem;margin:0;font-size:0.9rem;min-height:auto">Go</button>
</div>

<h3 class="modal-section-title green">Sigil Levels</h3>
<div style="margin:0.5rem 0">
<select id="debugSigilSelect" style="padding:0.25rem;margin-right:0.5rem;font-size:0.9rem">
${allSigils.map(sig => `<option value="${sig}">${sig} (L${S.sig[sig] || 0})</option>`).join('')}
</select>
<input type="number" id="debugSigilLevel" min="0" max="5" value="1" style="width:50px;padding:0.25rem;margin:0 0.5rem;font-size:1rem">
<button class="btn" onclick="debugSetSigilLevel()" style="display:inline-block;width:auto;padding:0.5rem 1rem;margin:0;font-size:0.9rem;min-height:auto">Set</button>
</div>

${heroNames.length > 0 ? `
<h3 class="modal-section-title green">Hero Stats</h3>
<div style="margin:0.5rem 0">
<select id="debugHeroSelect" style="padding:0.25rem;margin-bottom:0.5rem;font-size:0.9rem;width:100%">
${heroNames.map(h => `<option value="${h.idx}">${h.name} (POW:${S.heroes[h.idx].p}, HP:${S.heroes[h.idx].h}/${S.heroes[h.idx].m})</option>`).join('')}
</select>
<div style="display:flex;gap:0.5rem;margin-bottom:0.5rem">
<div style="flex:1">
<label style="color:white;font-size:0.85rem;display:block">POW:</label>
<input type="number" id="debugHeroPOW" min="1" max="20" value="1" style="width:100%;padding:0.25rem;font-size:1rem">
</div>
<div style="flex:1">
<label style="color:white;font-size:0.85rem;display:block">Max HP:</label>
<input type="number" id="debugHeroMaxHP" min="1" max="50" value="5" style="width:100%;padding:0.25rem;font-size:1rem">
</div>
</div>
<button class="btn" onclick="debugSetHeroStats()" style="background:#3b82f6;margin-bottom:0.5rem">Update Hero Stats</button>
</div>
` : ''}

${inCombat ? `
<h3 class="modal-section-title green">Combat</h3>
<button class="btn danger" onclick="debugDealDamage()">Deal 50 DMG to Enemy</button>
` : ''}

<h3 class="modal-section-title blue">Cheats</h3>
<label class="modal-checkbox-label" style="background:rgba(251,191,36,0.2)">
<input type="checkbox" ${S.oopsAll20s ? 'checked' : ''} onchange="toggleOopsAll20s(this.checked)">
<span>üé≤ Oops All 20s (Auto-succeed D20 rolls)</span>
</label>

<button class="btn" onclick="closeDebugMenu()" style="margin-top:1rem;background:#888">Close</button>
</div>
<div class="modal-overlay" onclick="closeDebugMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeDebugMenu() {
// Remove debug menu elements
const menus = document.querySelectorAll('.modal-container, .modal-overlay, [style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

// ===== SETTINGS MENU =====
function showSettingsMenu() {
const v = document.getElementById('gameView');
const inGame = S.heroes && S.heroes.length > 0 && S.floor > 0;
const inRibbleton = S.inRibbleton;

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">‚öôÔ∏è SETTINGS ‚öôÔ∏è</h2>

${inGame ? `
<button class="btn" onclick="manualSave()" style="margin-bottom:0.5rem;background:#22c55e">üíæ Save Game</button>
<button class="btn" onclick="restartLevel()" style="margin-bottom:0.5rem;background:#f97316">üîÑ Restart Level</button>
` : ''}

<div style="margin-top:0.5rem;display:flex;flex-direction:column;gap:0.5rem">
<button class="btn" onclick="showGameplaySettings()" style="background:#6366f1">üéÆ Gameplay</button>
<button class="btn" onclick="showDisplaySettings()" style="background:#8b5cf6">üñ•Ô∏è Display</button>
<button class="btn" onclick="showControllerSettings()" style="background:#0ea5e9">üïπÔ∏è Controller</button>
</div>

${inGame ? `
<button class="btn danger" onclick="confirmQuitToRibbleton()" style="margin-top:1rem;background:#dc2626">üö™ Quit to Ribbleton</button>
` : inRibbleton ? `
<button class="btn" onclick="confirmExitGame()" style="margin-top:1rem;background:#dc2626">üö™ Quit Game</button>
` : ''}

<button class="settings-back-btn" onclick="closeSettingsMenu()">Back <span style="opacity:0.6;font-size:0.85em">(B)</span></button>
</div>
<div class="modal-overlay" onclick="closeSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

// ===== GAMEPLAY SETTINGS SUBMENU =====
function showGameplaySettings() {
closeSettingsMenu();
const v = document.getElementById('gameView');

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">üéÆ GAMEPLAY</h2>

<h3 class="modal-section-title green">Animation Speed</h3>
<div style="display:flex;gap:0.5rem;flex-wrap:wrap;margin-bottom:0.5rem">
<button class="btn ${S.animationSpeed === 1 ? 'selected' : ''}" onclick="setAnimationSpeed(1, true)" style="flex:1;min-width:60px;padding:0.5rem;font-size:0.9rem;${S.animationSpeed === 1 ? 'background:#22c55e;border-color:#16a34a' : 'background:#374151'}">üê∏ Normal</button>
<button class="btn ${S.animationSpeed === 2 ? 'selected' : ''}" onclick="setAnimationSpeed(2, true)" style="flex:1;min-width:60px;padding:0.5rem;font-size:0.9rem;${S.animationSpeed === 2 ? 'background:#22c55e;border-color:#16a34a' : 'background:#374151'}">üê∏üí® 2x</button>
<button class="btn ${S.animationSpeed === 4 ? 'selected' : ''}" onclick="setAnimationSpeed(4, true)" style="flex:1;min-width:60px;padding:0.5rem;font-size:0.9rem;${S.animationSpeed === 4 ? 'background:#22c55e;border-color:#16a34a' : 'background:#374151'}">üê∏üí®üí® 4x</button>
<button class="btn ${S.animationSpeed === 0 ? 'selected' : ''}" onclick="setAnimationSpeed(0, true)" style="flex:1;min-width:60px;padding:0.5rem;font-size:0.9rem;${S.animationSpeed === 0 ? 'background:#f97316;border-color:#ea580c' : 'background:#374151'}">‚ö° Instant</button>
</div>

<h3 class="modal-section-title green">Sound</h3>
<label class="modal-checkbox-label">
<input type="checkbox" ${SoundFX.enabled ? 'checked' : ''} onchange="toggleSoundFX(this.checked)">
<span>üîä Sound Effects</span>
</label>

<h3 class="modal-section-title blue">Debug</h3>
<label class="modal-checkbox-label">
<input type="checkbox" ${S.debugMode ? 'checked' : ''} onchange="toggleDebugMode(this.checked)">
<span>üõ†Ô∏è Enable Debug Mode</span>
</label>
${S.debugMode ? `<button class="btn" onclick="closeSettingsMenu();showDebugMenu()" style="margin-bottom:0.5rem;background:#3b82f6">üõ†Ô∏è Open Debug Tools</button>` : ''}

<button class="settings-back-btn" onclick="closeSettingsMenu();showSettingsMenu()">Back <span style="opacity:0.6;font-size:0.85em">(B)</span></button>
</div>
<div class="modal-overlay" onclick="closeSettingsMenu();showSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

// ===== DISPLAY SETTINGS SUBMENU =====
function showDisplaySettings() {
closeSettingsMenu();
const v = document.getElementById('gameView');

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">üñ•Ô∏è DISPLAY</h2>

<label class="modal-checkbox-label">
<input type="checkbox" ${S.toastLogVisible ? 'checked' : ''} onchange="toggleToastLogVisibility(this.checked)">
<span>üìú Show Toast Log</span>
</label>
<label class="modal-checkbox-label">
<input type="checkbox" ${!S.helpTipsDisabled ? 'checked' : ''} onchange="toggleHelpTips(this.checked)">
<span>üí° Show Help/Tips</span>
</label>
<p style="font-size:0.75rem;opacity:0.6;margin:-0.25rem 0 0.5rem 0.5rem;padding-left:0.5rem">Turning this on resets all tutorial popups</p>
<label class="modal-checkbox-label">
<input type="checkbox" ${!S.tooltipsDisabled ? 'checked' : ''} onchange="toggleTooltips(this.checked)">
<span>üîç Show Sigil Tooltips</span>
</label>

<button class="settings-back-btn" onclick="closeSettingsMenu();showSettingsMenu()">Back <span style="opacity:0.6;font-size:0.85em">(B)</span></button>
</div>
<div class="modal-overlay" onclick="closeSettingsMenu();showSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

// ===== CONTROLLER SETTINGS SUBMENU =====
function showControllerSettings() {
closeSettingsMenu();
const v = document.getElementById('gameView');

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1.5rem">üïπÔ∏è CONTROLLER</h2>

<label class="modal-checkbox-label">
<input type="checkbox" ${!S.controllerDisabled ? 'checked' : ''} onchange="toggleControllerSupport(this.checked)">
<span>üéÆ Controller Support</span>
</label>
<button class="btn" onclick="showControlsGuide()" style="margin-bottom:0.5rem;background:#6366f1">üéÆ Controls Guide</button>
<button class="btn" onclick="forceReinitController()" style="margin-bottom:0.5rem;background:#22c55e;font-size:0.9rem">üîÑ Re-Init Controller</button>
<button class="btn" onclick="toggleControllerDebug()" style="margin-bottom:0.5rem;background:#f59e0b;font-size:0.9rem">üîç Input Overlay</button>

<button class="settings-back-btn" onclick="closeSettingsMenu();showSettingsMenu()">Back <span style="opacity:0.6;font-size:0.85em">(B)</span></button>
</div>
<div class="modal-overlay" onclick="closeSettingsMenu();showSettingsMenu()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeSettingsMenu() {
const menus = document.querySelectorAll('.modal-container, .modal-overlay, [style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

function manualSave() {
saveGame();
toast('Game Saved!', 1200);
closeSettingsMenu();
}

function restartLevel() {
showConfirmModal('Restart this floor? All progress on this floor will be lost.', () => {
closeSettingsMenu();
toast('Restarting floor...', 1200);
setTimeout(() => {
if(S.floor % 2 === 1) {
// Odd floor = combat
combat(S.floor);
} else {
// Even floor = neutral
startFloor(S.floor);
}
}, 500);
});
}

function confirmQuitToRibbleton() {
showConfirmModal('Quit to Ribbleton? Your progress is saved at the start of each floor. Any progress on the current floor will be lost.', () => {
closeSettingsMenu();
toast('Returning to Ribbleton...', 1200);
// Reset game state but preserve permanent progression
S.heroes = [];
S.floor = 0;
S.round = 0;
S.enemies = [];
S.recruits = [];
S.combatXP = 0;
S.combatGold = 0;
S.inRibbleton = true;
setTimeout(() => {
showRibbleton();
}, 500);
});
}

function confirmExitGame() {
showConfirmModal('Exit to title screen? Your permanent progress (gold, sigil upgrades, etc.) is always saved.', () => {
closeSettingsMenu();
toast('Returning to title...', 1200);
// Reset ALL game state
S.heroes = [];
S.floor = 0;
S.round = 0;
S.enemies = [];
S.recruits = [];
S.combatXP = 0;
S.combatGold = 0;
S.inRibbleton = false;
S.inTutorial = false;
// Save permanent progress
savePermanent();
setTimeout(() => {
mainTitlePage();
}, 500);
});
}


function toggleHelpTips(enabled) {
S.helpTipsDisabled = !enabled;
// If turning ON, reset all tutorial flags so they show again
if(enabled) {
S.tutorialFlags = {};
toast('Help/Tips enabled! All tips reset and will show again.', 2000);
// Re-trigger current screen to show relevant popups immediately
if(typeof render === 'function') {
try { render(); } catch(e) { /* render() not applicable in current state */ }
}
// If in Ribbleton hub, re-show to trigger ribbleton_hub_intro popup
if(document.querySelector('h1')?.textContent?.includes('Welcome Home to Ribbleton')) {
setTimeout(() => showRibbleton(), 100);
}
} else {
toast('Help/Tips disabled. No more popups!', 1200);
}
savePermanent();
}

function toggleTooltips(enabled) {
S.tooltipsDisabled = !enabled;
if(enabled) {
toast('Sigil tooltips enabled!', 1200);
} else {
toast('Sigil tooltips disabled!', 1200);
}
savePermanent();
}

function toggleSoundFX(enabled) {
SoundFX.enabled = enabled;
if(enabled) {
SoundFX.init();
SoundFX.play('select');
toast('Sound effects enabled!', 1200);
} else {
toast('Sound effects disabled!', 1200);
}
}

function setAnimationSpeed(speed, fromSubmenu = false) {
S.animationSpeed = speed;
const labels = {0: '‚ö° Instant', 1: 'üê∏ Normal', 2: 'üê∏üí® 2x', 4: 'üê∏üí®üí® 4x'};
toast(`Animation speed: ${labels[speed]}`, 1200);
SoundFX.play('hop');
savePermanent();
// Refresh gameplay settings submenu to update button states
closeSettingsMenu();
if (fromSubmenu) {
showGameplaySettings();
} else {
showSettingsMenu();
}
}

function toggleControllerSupport(enabled) {
S.controllerDisabled = !enabled;
if(enabled) {
toast('üéÆ Controller support enabled! Connect a gamepad to use.', 2000);
// Restart polling interval if it was stopped
if(!GamepadController.pollInterval) {
GamepadController.pollInterval = setInterval(() => GamepadController.poll(), 16);
console.log('[GAMEPAD] Restarted polling loop after re-enable');
}
// Restart gamepad check interval if it was stopped
if(!GamepadController.gamepadCheckInterval) {
GamepadController.gamepadCheckInterval = setInterval(() => GamepadController.checkForGamepads(), 500);
console.log('[GAMEPAD] Restarted gamepad check interval after re-enable');
}
// Re-initialize controller if a gamepad is connected
if(navigator.getGamepads) {
const gamepads = navigator.getGamepads();
for(const gp of gamepads) {
if(gp) {
GamepadController.gamepadIndex = gp.index;
GamepadController.activateControllerMode();
break;
}
}
}
} else {
toast('Controller support disabled.', 1200);
GamepadController.deactivateControllerMode();
GamepadController.gamepadIndex = null;
if(GamepadController.pollInterval) {
clearInterval(GamepadController.pollInterval);
GamepadController.pollInterval = null;
}
if(GamepadController.gamepadCheckInterval) {
clearInterval(GamepadController.gamepadCheckInterval);
GamepadController.gamepadCheckInterval = null;
}
}
savePermanent();
}

function forceReinitController() {
console.log('[GAMEPAD] Force re-initializing controller...');
// Clear any existing state
S.controllerDisabled = false;
GamepadController.gamepadIndex = null;
GamepadController.active = false;
GamepadController.buttonStates = {};
// Clear and restart intervals
if(GamepadController.pollInterval) {
clearInterval(GamepadController.pollInterval);
GamepadController.pollInterval = null;
}
if(GamepadController.gamepadCheckInterval) {
clearInterval(GamepadController.gamepadCheckInterval);
GamepadController.gamepadCheckInterval = null;
}
// Start fresh polling
GamepadController.pollInterval = setInterval(() => GamepadController.poll(), 16);
GamepadController.gamepadCheckInterval = setInterval(() => GamepadController.checkForGamepads(), 500);
// Check for connected gamepads
if(navigator.getGamepads) {
const gamepads = navigator.getGamepads();
for(let i = 0; i < gamepads.length; i++) {
const gp = gamepads[i];
if(gp) {
console.log('[GAMEPAD] Found gamepad at index', i, ':', gp.id);
GamepadController.gamepadIndex = i;
GamepadController.activateControllerMode();
toast(`üéÆ Controller found: ${gp.id.substring(0,30)}...`, 2500);
savePermanent();
closeSettingsMenu();
return;
}
}
}
toast('üéÆ Controller polling restarted. Press any button on your controller.', 2500);
savePermanent();
closeSettingsMenu();
}

// Live controller debug overlay - shows input in real-time on screen
function toggleControllerDebug() {
const existing = document.getElementById('controller-debug-overlay');
if (existing) {
existing.remove();
toast('Controller debug disabled', 1200);
closeSettingsMenu();
return;
}

const overlay = document.createElement('div');
overlay.id = 'controller-debug-overlay';
overlay.style.cssText = 'position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.9);color:#0f0;font-family:monospace;font-size:12px;padding:10px;border-radius:8px;z-index:99999;max-width:300px;border:2px solid #0f0';
overlay.innerHTML = `
<div style="font-weight:bold;margin-bottom:5px;color:#fff">üéÆ CONTROLLER DEBUG</div>
<div id="debug-gamepad-status">Checking...</div>
<div id="debug-buttons" style="margin-top:5px"></div>
<div id="debug-axes" style="margin-top:5px"></div>
<div id="debug-keyboard" style="margin-top:5px;color:#ff0">Last key: none</div>
<div id="debug-key-count" style="font-size:10px;color:#888">Keys pressed: 0</div>
<div style="margin-top:8px;font-size:10px;color:#888">Tap here to close</div>
`;
overlay.onclick = () => overlay.remove();
document.body.appendChild(overlay);

// Track keyboard input - use capture to catch ALL key events
let keyCount = 0;
const keyHandler = (e) => {
keyCount++;
const keyEl = document.getElementById('debug-keyboard');
const countEl = document.getElementById('debug-key-count');
if (keyEl) keyEl.innerHTML = `Last key: <span style="color:#0f0;font-weight:bold">${e.key}</span> (${e.code})`;
if (countEl) countEl.innerHTML = `Keys pressed: <span style="color:#0f0">${keyCount}</span>`;
};
document.addEventListener('keydown', keyHandler, true); // capture phase

// Update loop
const updateDebug = () => {
if (!document.getElementById('controller-debug-overlay')) {
document.removeEventListener('keydown', keyHandler);
return;
}

const statusEl = document.getElementById('debug-gamepad-status');
const buttonsEl = document.getElementById('debug-buttons');
const axesEl = document.getElementById('debug-axes');

const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
let found = false;

for (let i = 0; i < gamepads.length; i++) {
const gp = gamepads[i];
if (gp) {
found = true;
statusEl.innerHTML = `<span style="color:#0f0">‚úì FOUND:</span> ${gp.id.substring(0,30)}...`;

// Show pressed buttons
const pressed = [];
for (let b = 0; b < gp.buttons.length; b++) {
if (gp.buttons[b].pressed || gp.buttons[b].value > 0.5) {
pressed.push(b);
}
}
buttonsEl.innerHTML = pressed.length > 0
? `Buttons: <span style="color:#0f0">${pressed.join(', ')}</span>`
: 'Buttons: none';

// Show axes
const axes = gp.axes.map((a, i) => Math.abs(a) > 0.2 ? `${i}:${a.toFixed(1)}` : null).filter(Boolean);
axesEl.innerHTML = axes.length > 0
? `Axes: <span style="color:#0f0">${axes.join(', ')}</span>`
: 'Axes: centered';
break;
}
}

if (!found) {
statusEl.innerHTML = '<span style="color:#f00">‚úó NO GAMEPAD DETECTED</span>';
buttonsEl.innerHTML = 'Try pressing a button...';
axesEl.innerHTML = '';
}

requestAnimationFrame(updateDebug);
};
updateDebug();

toast('Controller debug enabled - overlay shown', 1500);
closeSettingsMenu();
}


function showControlsGuide() {
closeSettingsMenu();
const v = document.getElementById('gameView');

const controls = [
{ section: 'Navigation', items: [
  { btn: 'D-Pad / Left Stick', desc: 'Navigate menus and UI elements' },
  { btn: 'Right Stick', desc: 'Cycle through characters (up/down)' },
  { btn: 'A', desc: 'Confirm / Select' },
  { btn: 'B', desc: 'Back / Cancel action' },
  { btn: 'START (‚ò∞)', desc: 'Open Settings menu' }
]},
{ section: 'Combat', items: [
  { btn: 'D-Pad Up/Down', desc: 'Cycle through heroes and enemies' },
  { btn: 'D-Pad Left/Right', desc: 'Cycle through sigils on focused unit' },
  { btn: 'LB / RB', desc: 'Previous / Next character' },
  { btn: 'LT / RT', desc: 'Previous / Next sigil (with tooltip)' },
  { btn: 'Y', desc: 'Toggle sigil tooltip' },
  { btn: 'X', desc: 'Switch sides (jump to opposite side of board)' },
  { btn: 'SELECT', desc: 'Auto-target (smart targeting for current action)' }
]},
{ section: 'Keyboard Fallback', items: [
  { btn: 'Arrow Keys / WASD', desc: 'Navigate' },
  { btn: 'Enter / Space', desc: 'Confirm / Select' },
  { btn: 'Escape / Backspace', desc: 'Back / Cancel' },
  { btn: 'Tab', desc: 'Cycle through elements' }
]}
];

let html = `
<div class="modal-container dark">
<h2 class="modal-title blue" style="margin-bottom:1rem">üéÆ CONTROLS GUIDE üéÆ</h2>
`;

controls.forEach(section => {
html += `<h3 class="modal-section-title green" style="margin-top:1rem">${section.section}</h3>`;
html += `<div style="display:flex;flex-direction:column;gap:0.4rem">`;
section.items.forEach(item => {
html += `
<div style="display:flex;align-items:center;gap:0.75rem;padding:0.4rem 0.5rem;background:rgba(255,255,255,0.05);border-radius:6px">
<span style="min-width:140px;font-weight:bold;color:#60a5fa;font-size:0.9rem">${item.btn}</span>
<span style="color:#e5e7eb;font-size:0.85rem">${item.desc}</span>
</div>`;
});
html += `</div>`;
});

html += `
<div style="margin-top:1.5rem;padding:1rem;background:rgba(99,102,241,0.15);border:2px solid #6366f1;border-radius:8px">
<h4 style="color:#a5b4fc;margin:0 0 0.5rem 0;font-size:0.95rem">üí° Pro Tips</h4>
<ul style="margin:0;padding-left:1.25rem;color:#c7d2fe;font-size:0.85rem;line-height:1.5">
<li><strong>Auto-Target (SELECT)</strong> picks the smartest targets: lowest HP enemies for attacks, most damaged heroes for heals</li>
<li><strong>Switch Sides (X)</strong> is great for quickly jumping between your hero and the enemy across from them</li>
<li><strong>Sigil cycling (LT/RT)</strong> automatically shows tooltips as you browse</li>
</ul>
</div>

<button class="btn" onclick="closeControlsGuide()" style="margin-top:1.5rem;background:#888">Close</button>
</div>
<div class="modal-overlay" onclick="closeControlsGuide()"></div>
`;

v.insertAdjacentHTML('beforeend', html);
}

function closeControlsGuide() {
const menus = document.querySelectorAll('.modal-container, .modal-overlay');
menus.forEach(m => m.remove());
}

function showFAQ() {
const v = document.getElementById('gameView');

const faqItems = [
{
q: "What are sigils?",
a: `Sigils are your heroes' special abilities! Each hero has sigils they can use in combat to attack enemies, defend the team, or perform special actions.<br><br>
<strong>Basic Sigils:</strong><br>
‚Ä¢ <strong>Attack</strong> - Deal damage to enemies<br>
‚Ä¢ <strong>Shield</strong> - Protect heroes from damage<br>
‚Ä¢ <strong>Heal</strong> - Restore HP to heroes<br>
‚Ä¢ <strong>D20</strong> - Roll the dice for risky gambit actions<br><br>
You can see your sigils at the bottom of your hero card during combat. Hover / long-press any sigil icon to see what it does!`
},
{
q: "How do I level up sigils?",
a: `There are two ways to upgrade sigils:<br><br>
<strong>1. Level-Up Menu (Odd Floors - 1, 3, 5...)</strong><br>
‚Ä¢ Spend XP earned from battles<br>
‚Ä¢ Choose to upgrade a sigil, boost stats, or add new sigils<br>
‚Ä¢ These upgrades reset when you die<br><br>
<strong>2. Shop (Even Floors - 2, 4, 6...)</strong><br>
‚Ä¢ Spend Gold<br>
‚Ä¢ Permanently upgrade sigils that persist across all runs<br>
‚Ä¢ This is your long-term progression!<br><br>
Your total sigil level = Permanent (Gold) + Temporary (XP) upgrades.`
},
{
q: "Why does Attack show as L1 when I haven't upgraded it?",
a: `Active sigils (Attack, Shield, Heal, Grapple, Ghost, D20, Alpha) always display with a minimum level of 1 when equipped, even if their permanent storage level is 0. This is because they work at "Level 1" effectiveness when you first get them.<br><br>
<strong>Example:</strong> Attack storage level 0 = displays as L1 (1 attack per action)<br>
Attack storage level 1 = displays as L2 (2 attacks per action)<br><br>
The upgrade cost is based on <em>storage level</em>, not display level. So upgrading from display L1 to L2 costs the price for storage level 0‚Üí1.`
},
{
q: "What happens if I run out of enemies before using all my Expand targets?",
a: `If you have Expand and select targets for multi-instance actions (Attack, Shield, Heal), you might run out of valid targets mid-instance. When this happens, you'll see a "wasted targets" message.<br><br>
<strong>Example:</strong> You have Attack L2 with Expand L1 (3 total targets). There are only 2 enemies left. You can attack both enemies, but the 3rd target slot is wasted - you still get both attacks, but you can't use the extra Expand slot.<br><br>
This is intentional! Plan your actions carefully.`
},
{
q: "How does Last Stand work and how long does it last?",
a: `When a hero reaches 0 HP (and has no Ghost charges), they enter <strong>Last Stand</strong> instead of dying immediately. In Last Stand:<br><br>
‚Ä¢ They can ONLY use D20 gambits (no other actions)<br>
‚Ä¢ Each turn in Last Stand increases D20 difficulty by +1 DC (caps at +4)<br>
‚Ä¢ If healed, they revive with the healed HP amount<br>
‚Ä¢ After ~5 turns, DC penalties make success nearly impossible<br><br>
<strong>Last Stand Turn counter:</strong><br>
Turn 1: DC +0 (CONFUSE is DC 16)<br>
Turn 2: DC +1 (CONFUSE is DC 17)<br>
Turn 5: DC +4 (CONFUSE is DC 20 - nat 20 required!)<br><br>
You have a few turns to heal your Last Stand heroes before they become useless!`
},
{
q: "How many recruits can I have? What happens to them?",
a: `Recruits are enemies you've converted to your side via D20 RECRUIT (DC 20):<br><br>
‚Ä¢ Each hero can have <strong>1 recruit</strong> (recruiting another replaces the first)<br>
‚Ä¢ Recruits persist between battles until killed<br>
‚Ä¢ Recruits fight in their hero's lane and attack enemies<br>
‚Ä¢ Recruits can gain sigils and act during enemy turns<br><br>
<strong>How they work:</strong> Recruits stand behind their hero and attack enemies during the "Recruit Phase" of the enemy turn. They're powerful allies but can die permanently!`
},
{
q: "Do shields carry over between battles?",
a: `<strong>Yes!</strong> Shields persist between battles and cap at max HP.<br><br>
This means you can "shield farm" by using Shield sigils on the last enemy of a floor to enter the next floor with full shields. Combined with Asterisk or Alpha, this can make you nearly invincible!<br><br>
<strong>Strategy tip:</strong> Before finishing a floor, use any remaining actions to shield up your team. The shields will carry over!`
},
{
q: "What's the difference between XP upgrades and Gold upgrades?",
a: `There are TWO types of sigil upgrades:<br><br>
<strong>1. Permanent (Gold) Upgrades</strong><br>
‚Ä¢ Purchased at the Death Screen after dying<br>
‚Ä¢ Persist through death and across all runs<br>
‚Ä¢ These are your long-term progression!<br><br>
<strong>2. Temporary (XP) Upgrades</strong><br>
‚Ä¢ Purchased during Level Ups (after combat)<br>
‚Ä¢ Reset when you die or start a new run<br>
‚Ä¢ These boost you during a single run only<br><br>
<strong>Your displayed sigil level = Permanent + Temporary upgrades combined</strong>`
},
{
q: "What are Star and Asterisk sigils?",
a: `<strong>Star:</strong> Passive XP multiplier. Each hero with Star adds +0.5√ó XP bonus per Star level.<br>
‚Ä¢ 2 heroes with Star L1 = +1.0√ó bonus = 2√ó total XP<br>
‚Ä¢ Star is extremely powerful for long-term scaling!<br><br>
<strong>Asterisk:</strong> PASSIVE - Next action triggers +X times! Resets after each battle.<br>
‚Ä¢ Asterisk L1: First action triggers √ó2<br>
‚Ä¢ Asterisk L4: First action triggers √ó5<br>
‚Ä¢ Works with ANY action: Attack, Shield, Heal, D20 gambits, etc.<br>
‚Ä¢ No activation needed - happens automatically on your first action<br>
‚Ä¢ Can be combined with Alpha for devastating combos!`
}
];

let html = `
<div class="modal-container faq">
<h2 class="modal-title orange">‚ùì Frequently Asked Questions ‚ùì</h2>

<div style="background:rgba(147,51,234,0.1);border:2px solid #9333ea;border-radius:12px;padding:1.5rem;margin-bottom:1.5rem">
<h3 style="text-align:center;font-size:1.2rem;margin:0 0 0.5rem 0;color:#9333ea">üê∏ FROGGLE</h3>
<p style="text-align:center;font-size:0.95rem;line-height:1.5;margin-bottom:1rem">Gain and upgrade powerful sigils to advance through the dungeon and save Tapo the tadpole! On death, you'll have a chance to spend gold you've earned to make your team permanently stronger!</p>

<div style="background:white;border-radius:8px;padding:1rem;margin-top:1rem">
<h4 style="color:#2c63c7;margin:0 0 0.75rem 0;font-size:1rem">‚öîÔ∏è HOW LEVEL-UPS WORK</h4>
<p style="font-size:0.9rem;margin:0 0 0.5rem 0">After combat, you can spend XP in 3 ways:</p>

<div style="margin-left:1rem;font-size:0.9rem;line-height:1.6">
<p style="margin:0.5rem 0"><strong>1Ô∏è‚É£ UPGRADE A SIGIL</strong> (makes it stronger everywhere!)</p>
<div style="margin-left:1rem;margin-bottom:0.75rem">
<p style="margin:0.25rem 0"><strong style="color:#9333ea">Passive Sigils</strong> (Expand, Asterisk, Star):</p>
<ul style="margin:0.25rem 0;padding-left:1.5rem">
<li>Start at Level 0 (inactive)</li>
<li>Spend XP to upgrade to Level 1 to activate for ALL heroes automatically</li>
<li>Work automatically in battle - no action needed</li>
</ul>
<p style="margin:0.5rem 0 0.25rem 0"><strong style="color:#2c63c7">Active Sigils</strong> (Attack, Shield, Heal, D20, etc.):</p>
<ul style="margin:0.25rem 0;padding-left:1.5rem">
<li>Start at Level 1 effectiveness</li>
<li>Upgrading makes them stronger on every hero who has them</li>
<li>Example: Attack L1‚ÜíL2 means attack twice instead of once!</li>
</ul>
</div>

<p style="margin:0.5rem 0"><strong>2Ô∏è‚É£ ADD A SIGIL TO A HERO</strong></p>
<ul style="margin:0.25rem 0 0.75rem 1.5rem;padding-left:1.5rem">
<li>All heroes can learn any sigil by spending XP!</li>
<li>Active sigils use your hero's 1 action per turn</li>
<li>Choose abilities that complement your strategy</li>
</ul>

<p style="margin:0.5rem 0"><strong>3Ô∏è‚É£ UPGRADE HERO STATS</strong></p>
<ul style="margin:0.25rem 0;padding-left:1.5rem">
<li>Spend XP for +1 POW (increases damage/healing/shields)</li>
<li>Spend XP for +5 Max HP (and heal if in Last Stand)</li>
</ul>
</div>
</div>

<div style="background:rgba(34,197,94,0.1);border:2px solid #22c55e;border-radius:8px;padding:1rem;margin-top:1rem">
<h4 style="color:#15803d;margin:0 0 0.5rem 0;font-size:0.95rem">üí° PRO TIPS</h4>
<ul style="margin:0;padding-left:1.5rem;font-size:0.85rem;line-height:1.5">
<li><strong>Mage & Healer Start Stronger:</strong> They get +1 Expand built-in, so their actions hit 1 extra target from the start!</li>
<li><strong>Shields Persist:</strong> Before winning a battle, use remaining actions to shield your team - they carry over to the next fight!</li>
<li><strong>D20 Gambits:</strong> Higher D20 sigil levels = better success rates. Hover over D20 in battle to see all 5 effects and their difficulty.</li>
</ul>
</div>
</div>

<p style="text-align:center;font-size:0.85rem;opacity:0.7;margin-bottom:1.5rem">Tap a question below to expand/collapse the answer</p>
<div style="display:flex;flex-direction:column;gap:0.75rem;margin-bottom:1.5rem">
`;

faqItems.forEach((item, index) => {
html += `
<div style="background:white;border:3px solid #000;border-radius:12px;overflow:hidden;box-shadow:0 2px 6px rgba(0,0,0,0.15)">
<div onclick="toggleFAQItem(${index})" style="padding:1rem;cursor:pointer;user-select:none;display:flex;justify-content:space-between;align-items:center;background:linear-gradient(135deg, #f0f9ff, #e0f2fe);transition:background 0.2s">
<strong style="font-size:0.95rem;color:#1e40af">${item.q}</strong>
<span id="faq-arrow-${index}" style="font-size:1.2rem;transition:transform 0.3s;color:#1e40af">‚ñº</span>
</div>
<div id="faq-answer-${index}" style="display:none;padding:1rem;font-size:0.9rem;line-height:1.6;border-top:2px solid #ddd;background:rgba(0,0,0,0.02)">
${item.a}
</div>
</div>
`;
});

html += `
</div>
<button class="btn secondary" onclick="closeFAQ()" style="margin-top:0.5rem">Close</button>
</div>
<div class="modal-overlay" onclick="closeFAQ()"></div>
`;

v.insertAdjacentHTML('beforeend', html);
}

function toggleFAQItem(index) {
const answer = document.getElementById(`faq-answer-${index}`);
const arrow = document.getElementById(`faq-arrow-${index}`);

if (answer.style.display === 'none') {
answer.style.display = 'block';
arrow.style.transform = 'rotate(180deg)';
arrow.textContent = '‚ñ≤';
} else {
answer.style.display = 'none';
arrow.style.transform = 'rotate(0deg)';
arrow.textContent = '‚ñº';
}
}

function closeFAQ() {
const overlays = document.querySelectorAll('.modal-container, .modal-overlay, [style*="z-index:30000"], [style*="z-index:29999"]');
overlays.forEach(el => el.remove());
}

function showSigilarium() {
closeSettingsMenu();
const v = document.getElementById('gameView');
const coreSigils = ['Attack', 'Shield', 'Heal', 'D20'];
const advancedSigils = ['Ghost', 'Alpha', 'Grapple'];
const passiveSigils = ['Expand', 'Asterisk', 'Star'];

const getLevelColor = (level) => {
if(level === 0) return '#666';
if(level === 1) return '#000';
if(level === 2) return '#0d9488';
if(level === 3) return '#9333ea';
if(level === 4) return '#d97706';
return '#ff0080'; // L5 gradient
};

let html = `
<div class="modal-container light">
<h2 class="modal-title purple">üìñ SIGILARIUM üìñ</h2>
<p style="text-align:center;font-size:0.9rem;opacity:0.8;margin-bottom:1.5rem">All Sigils and Their Permanent Upgrade Levels</p>

<!-- Core Sigils -->
<h3 style="color:#2c63c7;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #2c63c7;padding-bottom:0.25rem">‚öîÔ∏è Core Sigils</h3>
<div style="display:grid;gap:0.75rem;margin-bottom:1.5rem">
`;

coreSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const displayLevel = permLevel + 1; // Actives display +1 higher (perm 0 = L1)
const cl = permLevel===0?'l1':permLevel===1?'l2':permLevel===2?'l3':permLevel===3?'l4':permLevel===4?'l5':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(displayLevel);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl}" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Level: <span style="color:${levelColor};font-weight:bold">L${displayLevel}</span></div>
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>

<!-- Advanced Sigils -->
<h3 style="color:#f97316;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #f97316;padding-bottom:0.25rem">üî• Advanced Sigils</h3>
<div style="display:grid;gap:0.75rem;margin-bottom:1.5rem">
`;

advancedSigils.forEach(sig => {
const permLevel = S.sig[sig] || 0;
const displayLevel = permLevel + 1; // Actives display +1 higher (perm 0 = L1)
const cl = permLevel===0?'l1':permLevel===1?'l2':permLevel===2?'l3':permLevel===3?'l4':permLevel===4?'l5':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(displayLevel);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl}" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Level: <span style="color:${levelColor};font-weight:bold">L${displayLevel}</span></div>
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>

<!-- Passive Sigils -->
<h3 style="color:#9333ea;margin-bottom:0.75rem;font-size:1rem;border-bottom:2px solid #9333ea;padding-bottom:0.25rem">‚ú® Passive Sigils</h3>
<div style="display:grid;gap:0.75rem">
`;

passiveSigils.forEach(sig => {
const level = S.sig[sig] || 0;
const cl = level===0?'l0':level===1?'l1':level===2?'l2':level===3?'l3':level===4?'l4':'l5';
const desc = SIGIL_DESCRIPTIONS[sig] || 'No description available';
const levelColor = getLevelColor(level);

html += `
<div style="background:rgba(0,0,0,0.05);border:2px solid #000;border-radius:8px;padding:1rem">
<div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
<span class="sigil ${cl} passive" style="font-size:1.2rem;padding:8px 12px">${sigilIconOnly(sig)}</span>
<div>
<div style="font-weight:bold;font-size:1.1rem">${sig}</div>
<div style="font-size:0.85rem;opacity:0.8">Permanent Level: <span style="color:${levelColor};font-weight:bold">L${level}</span></div>
</div>
</div>
<div style="font-size:0.9rem;line-height:1.4;color:#4b5563">${desc}</div>
</div>
`;
});

html += `
</div>
<button class="btn" onclick="closeSigilarium()" style="margin-top:1.5rem;background:#9333ea;width:100%">Close</button>
</div>
<div class="modal-overlay" onclick="closeSigilarium()"></div>
`;
v.insertAdjacentHTML('beforeend', html);
}

function closeSigilarium() {
const menus = document.querySelectorAll('.modal-container, .modal-overlay, [style*="z-index:30000"], [style*="z-index:29999"]');
menus.forEach(m => m.remove());
}

function debugAddGold() {
S.gold += 100;
upd();
toast('Added 100 Gold!', 1200);
closeDebugMenu();
}

function debugAddXP() {
S.xp += 100;
upd();
toast('Added 100 XP!', 1200);
closeDebugMenu();
}

function debugJumpFloor() {
const input = document.getElementById('debugFloorInput');
const targetFloor = parseInt(input.value);
if(targetFloor < 1 || targetFloor > 19 || isNaN(targetFloor)) {
toast('Invalid floor! Must be 1-19', 1200);
return;
}
closeDebugMenu();
S.floor = targetFloor;
upd();
startFloor(targetFloor);
toast(`Jumped to Floor ${targetFloor}!`, 1200);
}

function debugDealDamage() {
if(!S.enemies || S.enemies.length === 0) {
toast('No enemies in combat!', 1200);
return;
}
// Deal 50 damage to first enemy
const enemy = S.enemies[0];
enemy.h -= 50;
if(enemy.h < 0) enemy.h = 0;
upd();
toast(`Dealt 50 damage to ${getEnemyDisplayName(enemy)}!`, 1200);
closeDebugMenu();
// Check if combat is over
setTimeout(() => checkCombatEnd(), 100);
}

function debugSetSigilLevel() {
const sigilSelect = document.getElementById('debugSigilSelect');
const levelInput = document.getElementById('debugSigilLevel');
const sigil = sigilSelect.value;
const newLevel = parseInt(levelInput.value);

if(isNaN(newLevel) || newLevel < 0 || newLevel > 5) {
toast('Invalid level! Must be 0-5', 1200);
return;
}

S.sig[sigil] = newLevel;
savePermanent();
upd();
toast(`Set ${sigil} to Level ${newLevel}!`, 1200);
closeDebugMenu();
}

function debugSetHeroStats() {
const heroSelect = document.getElementById('debugHeroSelect');
const powInput = document.getElementById('debugHeroPOW');
const maxHPInput = document.getElementById('debugHeroMaxHP');
const heroIdx = parseInt(heroSelect.value);
const newPOW = parseInt(powInput.value);
const newMaxHP = parseInt(maxHPInput.value);

if(isNaN(newPOW) || newPOW < 1 || newPOW > 20) {
toast('Invalid POW! Must be 1-20', 1200);
return;
}
if(isNaN(newMaxHP) || newMaxHP < 1 || newMaxHP > 50) {
toast('Invalid Max HP! Must be 1-50', 1200);
return;
}

const hero = S.heroes[heroIdx];
hero.p = newPOW;
hero.m = newMaxHP;
// Also set current HP to max HP for convenience
hero.h = newMaxHP;
saveGame();
upd();
toast(`Updated ${hero.n}: POW=${newPOW}, HP=${newMaxHP}!`, 1200);
closeDebugMenu();
render();
}



// ===== STEAM DECK / CONTROLLER SUPPORT SYSTEM =====
const GamepadController = {
  // State
  active: false,
  gamepadIndex: null,
  focusedElement: null,
  focusableElements: [],
  lastInputTime: 0,
  inputCooldown: 150, // ms between inputs to prevent rapid-fire
  axisDeadzone: 0.5,
  pollInterval: null,
  buttonStates: {},
  contextStack: [], // Stack for nested menus/modals
  tooltipVisible: false, // Track if tooltip is showing via controller
  tooltipElement: null, // Element with active tooltip
  currentUnitIndex: 0, // Current unit (hero/enemy) index for LB/RB cycling
  currentSigilIndex: 0, // Current sigil index for LT/RT cycling
  lastFocusedId: null, // For focus restoration after render
  lastMouseX: null, // For tracking mouse movement delta
  lastMouseY: null, // For tracking mouse movement delta
  pollCount: 0, // Debug: count poll cycles
  lastPollLog: 0, // Debug: timestamp of last poll log
  mouseMovementThreshold: 15, // Minimum pixels to move before switching to mouse mode

  // Button indices (standard gamepad mapping)
  BUTTONS: {
    A: 0,        // Bottom button (confirm/select)
    B: 1,        // Right button (back/cancel)
    X: 2,        // Left button
    Y: 3,        // Top button (tooltip toggle)
    LB: 4,       // Left bumper (prev unit)
    RB: 5,       // Right bumper (next unit)
    LT: 6,       // Left trigger (prev sigil)
    RT: 7,       // Right trigger (next sigil)
    SELECT: 8,   // Back/Select
    START: 9,    // Start/Menu
    L3: 10,      // Left stick click
    R3: 11,      // Right stick click
    DPAD_UP: 12,
    DPAD_DOWN: 13,
    DPAD_LEFT: 14,
    DPAD_RIGHT: 15
  },

  // Initialize controller system
  init() {
    console.log('[GAMEPAD] ========================================');
    console.log('[GAMEPAD] Initializing controller support...');
    console.log('[GAMEPAD] S defined:', typeof S !== 'undefined');
    console.log('[GAMEPAD] S.controllerDisabled:', typeof S !== 'undefined' ? S.controllerDisabled : 'N/A');

    // Check if controller support is disabled
    if (typeof S !== 'undefined' && S.controllerDisabled) {
      console.log('[GAMEPAD] Controller support disabled by user setting');
      return;
    }

    // ALWAYS set up keyboard fallback (works even if gamepad API unavailable)
    this.initKeyboardFallback();
    console.log('[GAMEPAD] Keyboard fallback initialized');

    // Check if gamepad API is available
    if (!navigator.getGamepads) {
      console.log('[GAMEPAD] Gamepad API not available in this browser');
      console.log('[GAMEPAD] Keyboard fallback is active (Arrow keys, Enter, Escape)');
      return;
    }
    console.log('[GAMEPAD] Gamepad API available');

    // Listen for gamepad connections
    window.addEventListener('gamepadconnected', (e) => {
      console.log('[GAMEPAD] *** gamepadconnected event fired! ***');
      console.log('[GAMEPAD] Event gamepad:', e.gamepad);
      this.onGamepadConnected(e);
    });
    window.addEventListener('gamepaddisconnected', (e) => this.onGamepadDisconnected(e));
    console.log('[GAMEPAD] Event listeners registered');

    // Check for already-connected gamepads (Steam Deck may have controller pre-connected)
    const gamepads = navigator.getGamepads();
    console.log('[GAMEPAD] Initial gamepad check - slots:', gamepads.length);
    let foundGamepad = false;
    for (let i = 0; i < gamepads.length; i++) {
      const gp = gamepads[i];
      console.log('[GAMEPAD] Slot', i, ':', gp ? `${gp.id} (${gp.buttons.length} buttons, ${gp.axes.length} axes)` : 'empty');
      if (gp && !foundGamepad) {
        console.log('[GAMEPAD] *** Found pre-connected gamepad! ***');
        this.onGamepadConnected({ gamepad: gp });
        foundGamepad = true;
      }
    }

    // CRITICAL: Steam Deck fix - Start continuous polling regardless of event
    // Steam Deck's gamepad may not fire 'gamepadconnected' event but still be available
    // Poll every 500ms to check for newly available gamepads
    this.gamepadCheckInterval = setInterval(() => this.checkForGamepads(), 500);
    console.log('[GAMEPAD] Started continuous gamepad check interval (500ms)');

    // Also start the main polling loop immediately - it will no-op if no gamepad
    if (!this.pollInterval) {
      this.pollInterval = setInterval(() => this.poll(), 16);
      console.log('[GAMEPAD] Started main polling loop (16ms/60fps)');
    }

    // Delayed status check - report state after 3 seconds
    // Also show helpful setup prompt if no gamepad detected (likely Steam Deck Gaming Mode)
    setTimeout(() => {
      console.log('[GAMEPAD] ========== STATUS CHECK (3s) ==========');
      console.log('[GAMEPAD] active:', this.active);
      console.log('[GAMEPAD] gamepadIndex:', this.gamepadIndex);
      console.log('[GAMEPAD] pollInterval running:', !!this.pollInterval);
      console.log('[GAMEPAD] focusableElements:', this.focusableElements.length);
      const gps = navigator.getGamepads ? navigator.getGamepads() : [];
      let foundGamepad = false;
      for (let i = 0; i < gps.length; i++) {
        if (gps[i]) {
          console.log('[GAMEPAD] Active gamepad at', i, ':', gps[i].id);
          foundGamepad = true;
        }
      }
      console.log('[GAMEPAD] =========================================');

      // If no gamepad detected and user hasn't dismissed this before, show setup help
      // This helps Steam Deck users in Gaming Mode
      if (!foundGamepad && !this.active && typeof S !== 'undefined' && !S.tutorialFlags.steam_controller_setup) {
        this.showSteamControllerSetupHelp();
      }
    }, 3000);

    // Watch for DOM changes to update focusable elements (screen transitions)
    this.domObserver = new MutationObserver((mutations) => {
      // Only update if controller mode is active and we have significant DOM changes
      if (this.active) {
        let significantChange = false;
        for (const mutation of mutations) {
          if (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0) {
            // Check if added/removed nodes contain buttons or interactive elements
            for (const node of mutation.addedNodes) {
              if (node.nodeType === 1 && (node.classList?.contains('btn') || node.querySelector?.('.btn'))) {
                significantChange = true;
                break;
              }
            }
            if (significantChange) break;
          }
        }
        if (significantChange) {
          setTimeout(() => {
            this.updateFocusableElements();
            // Re-establish focus if lost - use smart default
            if (this.focusableElements.length > 0 && !document.body.contains(this.focusedElement)) {
              const bestFocus = this.findBestDefaultFocus();
              this.setFocus(bestFocus || this.focusableElements[0]);
            }
          }, 100);
        }
      }
    });
    this.domObserver.observe(document.getElementById('gameView') || document.body, {
      childList: true,
      subtree: true
    });
    console.log('[GAMEPAD] DOM observer initialized for focus management');

    // Switch to mouse mode on significant sustained mouse movement
    // NOTE: Don't deactivate on click - Steam Deck touchscreen generates clicks
    // and we want controller mode to persist even when occasionally tapping screen
    document.addEventListener('mousemove', (e) => {
      // Only deactivate on significant mouse movement (not just hover or small jitter)
      if (this.lastMouseX === null) {
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        return;
      }
      const dx = Math.abs(e.clientX - this.lastMouseX);
      const dy = Math.abs(e.clientY - this.lastMouseY);
      // Require more significant movement (50px) before switching to mouse mode
      if (dx > 50 || dy > 50) {
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        this.deactivateControllerMode();
      }
    });
    // Don't deactivate on click - let controller mode persist
  },

  // Keyboard fallback for when gamepad isn't detected (Steam mapping to keyboard, etc.)
  initKeyboardFallback() {
    console.log('[GAMEPAD] Initializing keyboard fallback...');

    // Use capture phase to catch events before they're stopped
    document.addEventListener('keydown', (e) => {
      console.log('[KEYBOARD] Key event:', e.key, 'code:', e.code, 'target:', e.target.tagName);

      // Skip if controller support is disabled
      if (typeof S !== 'undefined' && S.controllerDisabled) {
        console.log('[KEYBOARD] Skipped - controller disabled');
        return;
      }

      // Skip if typing in an input field
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        console.log('[KEYBOARD] Skipped - input field focused');
        return;
      }

      // Check for blocking overlays - handle specially
      const blocking = this.isBlockingOverlayVisible();
      if (blocking === 'tutorial') {
        // Only Enter/Space dismisses tutorial
        if (e.key === 'Enter' || e.key === ' ') {
          const tutorialBtn = document.querySelector('.tutorial-modal button, .tutorial-modal .btn');
          if (tutorialBtn) {
            if (typeof SoundFX !== 'undefined' && SoundFX.play) SoundFX.play('click');
            tutorialBtn.click();
            e.preventDefault();
            e.stopPropagation();
          }
        }
        return;
      }
      if (blocking === 'suspend') {
        // Any key resumes
        if (typeof resumeGame === 'function') resumeGame();
        e.preventDefault();
        return;
      }

      // Check for navigation keys
      let handled = false;
      let action = '';

      switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          action = 'up';
          this.activateControllerMode();
          this.onDirection('up');
          handled = true;
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          action = 'down';
          this.activateControllerMode();
          this.onDirection('down');
          handled = true;
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          action = 'left';
          this.activateControllerMode();
          this.onDirection('left');
          handled = true;
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          action = 'right';
          this.activateControllerMode();
          this.onDirection('right');
          handled = true;
          break;
        case 'Enter':
        case ' ': // Space
          action = 'confirm (A)';
          this.activateControllerMode();
          this.confirmSelection();
          handled = true;
          break;
        case 'Escape':
        case 'Backspace':
          action = 'back (B/START)';
          this.activateControllerMode();
          this.goBack();
          handled = true;
          break;
        // X button - switch sides
        case 'x':
        case 'X':
          action = 'switch sides (X)';
          this.activateControllerMode();
          this.switchSides();
          handled = true;
          break;
        // Y button - toggle tooltip
        case 't':
        case 'T':
          action = 'toggle tooltip (Y)';
          this.activateControllerMode();
          this.toggleSigilTooltip();
          handled = true;
          break;
        // LB - previous character
        case 'q':
        case 'Q':
          action = 'prev char (LB)';
          this.activateControllerMode();
          this.onButtonPress(this.BUTTONS.LB);
          handled = true;
          break;
        // RB - next character
        case 'e':
        case 'E':
          action = 'next char (RB)';
          this.activateControllerMode();
          this.onButtonPress(this.BUTTONS.RB);
          handled = true;
          break;
        // LT - previous sigil
        case 'z':
        case 'Z':
          action = 'prev sigil (LT)';
          this.activateControllerMode();
          this.onButtonPress(this.BUTTONS.LT);
          handled = true;
          break;
        // RT - next sigil
        case 'c':
        case 'C':
          action = 'next sigil (RT)';
          this.activateControllerMode();
          this.onButtonPress(this.BUTTONS.RT);
          handled = true;
          break;
        // SELECT - auto-target
        case 'r':
        case 'R':
        case '`':
          action = 'auto-target (SELECT)';
          this.activateControllerMode();
          this.autoTarget();
          handled = true;
          break;
        case 'Tab':
          action = 'tab';
          // Tab cycles through focusable elements
          this.activateControllerMode();
          this.updateFocusableElements();
          if (this.focusableElements.length > 0) {
            const currentIdx = this.focusableElements.indexOf(this.focusedElement);
            const nextIdx = e.shiftKey
              ? (currentIdx - 1 + this.focusableElements.length) % this.focusableElements.length
              : (currentIdx + 1) % this.focusableElements.length;
            this.setFocus(this.focusableElements[nextIdx]);
          }
          handled = true;
          break;
      }

      if (handled) {
        console.log('[KEYBOARD] Handled action:', action, 'active:', this.active, 'focused:', this.focusedElement?.textContent?.substring(0,20));
        e.preventDefault();
        e.stopPropagation();
      }
    }, true); // Use capture phase

    console.log('[GAMEPAD] Keyboard fallback initialized:');
    console.log('[GAMEPAD]   Navigation: Arrow keys / WASD');
    console.log('[GAMEPAD]   A (confirm): Enter / Space');
    console.log('[GAMEPAD]   B (back): Escape / Backspace');
    console.log('[GAMEPAD]   X (switch sides): X key');
    console.log('[GAMEPAD]   Y (tooltip): T key');
    console.log('[GAMEPAD]   LB/RB (prev/next char): Q / E');
    console.log('[GAMEPAD]   LT/RT (prev/next sigil): Z / C');
    console.log('[GAMEPAD]   SELECT (auto-target): R key');
  },

  // Continuously check for gamepads (Steam Deck fix)
  checkForGamepads() {
    if (this.gamepadIndex !== null) return; // Already have a gamepad

    const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
    for (let i = 0; i < gamepads.length; i++) {
      const gp = gamepads[i];
      if (gp && gp.connected) {
        console.log('[GAMEPAD] Found gamepad via polling at index', i, ':', gp.id);
        console.log('[GAMEPAD] Buttons:', gp.buttons.length, 'Axes:', gp.axes.length);
        this.gamepadIndex = i;
        this.activateControllerMode();
        toast('üéÆ Controller detected! Use D-pad to navigate.', 2500);
        return;
      }
    }
  },

  onGamepadConnected(e) {
    console.log('[GAMEPAD] Controller connected!');
    console.log('[GAMEPAD] ID:', e.gamepad.id);
    console.log('[GAMEPAD] Index:', e.gamepad.index);
    console.log('[GAMEPAD] Buttons:', e.gamepad.buttons.length);
    console.log('[GAMEPAD] Axes:', e.gamepad.axes.length);

    // Check if controller support is disabled
    if (typeof S !== 'undefined' && S.controllerDisabled) {
      console.log('[GAMEPAD] Controller connected but support is disabled by user');
      return;
    }

    this.gamepadIndex = e.gamepad.index;
    this.activateControllerMode();

    // Start polling loop
    if (!this.pollInterval) {
      this.pollInterval = setInterval(() => this.poll(), 16); // ~60fps
      console.log('[GAMEPAD] Started polling loop');
    }

    toast('üéÆ Controller connected! Use D-pad to navigate, START for menu.', 2500);
  },

  onGamepadDisconnected(e) {
    debugLog('[GAMEPAD] Disconnected:', e.gamepad.id);
    if (e.gamepad.index === this.gamepadIndex) {
      this.gamepadIndex = null;
      this.deactivateControllerMode();

      // Check for other connected gamepads
      const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
      for (const gp of gamepads) {
        if (gp) {
          this.gamepadIndex = gp.index;
          this.activateControllerMode();
          return;
        }
      }

      // No gamepads left
      if (this.pollInterval) {
        clearInterval(this.pollInterval);
        this.pollInterval = null;
      }
    }
  },

  activateControllerMode() {
    if (this.active) return;
    this.active = true;
    document.body.classList.add('controller-active');
    this.updateFocusableElements();
    if (this.focusableElements.length > 0 && !this.focusedElement) {
      // Use smart default focus instead of just the first element
      const bestFocus = this.findBestDefaultFocus();
      this.setFocus(bestFocus || this.focusableElements[0]);
    }
    this.updatePrompts();
    debugLog('[GAMEPAD] Controller mode activated');
  },

  deactivateControllerMode() {
    if (!this.active) return;
    this.active = false;
    document.body.classList.remove('controller-active');
    this.clearFocus();
    debugLog('[GAMEPAD] Controller mode deactivated (mouse input detected)');
  },

  // Check if a blocking modal/overlay is visible that should capture all input
  isBlockingOverlayVisible() {
    // Tutorial modals block everything except dismissal
    const tutorialBackdrop = document.querySelector('.tutorial-modal-backdrop');
    if (tutorialBackdrop) return 'tutorial';

    // Confirm modals block everything except Yes/No
    const confirmModal = document.querySelector('.confirm-modal');
    if (confirmModal) return 'confirm';

    // Suspend overlay blocks everything
    const suspendOverlay = document.getElementById('suspend-overlay');
    if (suspendOverlay) return 'suspend';

    return null;
  },

  // Determine current navigation context
  getNavigationContext() {
    // First check for blocking overlays
    const blocking = this.isBlockingOverlayVisible();
    if (blocking) return blocking;

    // Check if we're in targeting mode
    if (typeof S !== 'undefined' && S.pending) {
      return 'targeting';
    }
    // Check if we're in combat (heroes and enemies present)
    if (typeof S !== 'undefined' && S.heroes && S.heroes.length > 0 && S.enemies && S.enemies.length > 0) {
      return 'combat';
    }
    // Check if there's a modal
    if (document.querySelector('.modal-container')) {
      return 'modal';
    }
    return 'menu';
  },

  // Main polling loop
  poll() {
    this.pollCount++;
    let now = Date.now();
    // Log every 5 seconds
    if (now - this.lastPollLog > 5000) {
      console.log('[GAMEPAD] Poll status - count:', this.pollCount, 'active:', this.active, 'gamepadIndex:', this.gamepadIndex);
      this.lastPollLog = now;
    }

    // Skip if game is suspended (but still allow button to resume)
    if (typeof S !== 'undefined' && S.suspended) {
      // Check for any button press to resume
      const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
      for (let i = 0; i < gamepads.length; i++) {
        const gp = gamepads[i];
        if (gp) {
          for (let b = 0; b < gp.buttons.length; b++) {
            if (gp.buttons[b].pressed && !this.buttonStates[b]) {
              if (typeof resumeGame === 'function') resumeGame();
              this.buttonStates[b] = true;
              return;
            }
            this.buttonStates[b] = gp.buttons[b].pressed;
          }
        }
      }
      return;
    }

    // Try to find a gamepad if we don't have one
    if (this.gamepadIndex === null) {
      const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
      for (let i = 0; i < gamepads.length; i++) {
        if (gamepads[i] && gamepads[i].connected) {
          this.gamepadIndex = i;
          console.log('[GAMEPAD] Poll found gamepad at index', i);
          this.activateControllerMode();
          break;
        }
      }
      if (this.gamepadIndex === null) return;
    }

    const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
    const gp = gamepads[this.gamepadIndex];
    if (!gp) {
      // Gamepad disconnected
      this.gamepadIndex = null;
      return;
    }

    // Refresh timestamp for input timing
    now = Date.now();

    // Check buttons ALWAYS (don't skip due to cooldown - we need to track state)
    for (let i = 0; i < gp.buttons.length; i++) {
      const pressed = gp.buttons[i].pressed || gp.buttons[i].value > 0.5;
      const wasPressed = this.buttonStates[i] || false;

      if (pressed && !wasPressed) {
        // Only process if cooldown elapsed
        if (now - this.lastInputTime >= this.inputCooldown) {
          this.onButtonPress(i);
          this.lastInputTime = now;
        }
      }

      this.buttonStates[i] = pressed;
    }

    // Check analog sticks
    const leftX = gp.axes[0] || 0;
    const leftY = gp.axes[1] || 0;
    const rightX = gp.axes[2] || 0;
    const rightY = gp.axes[3] || 0;

    // Check for blocking overlays before processing stick input
    const blocking = this.isBlockingOverlayVisible();
    if (blocking === 'tutorial' || blocking === 'suspend') {
      return; // Don't process stick input during blocking overlays
    }

    // Left stick: Navigate (context-aware)
    if (Math.abs(leftX) > this.axisDeadzone || Math.abs(leftY) > this.axisDeadzone) {
      if (now - this.lastInputTime >= this.inputCooldown) {
        if (Math.abs(leftX) > Math.abs(leftY)) {
          this.onLeftStick(leftX > 0 ? 'right' : 'left');
        } else {
          this.onLeftStick(leftY > 0 ? 'down' : 'up');
        }
        this.lastInputTime = now;
      }
    }

    // Right stick: Context-aware navigation
    // - In combat: up/down cycles units, left/right cycles sigils on current unit
    // - In menus: same as d-pad navigation
    if (Math.abs(rightX) > this.axisDeadzone || Math.abs(rightY) > this.axisDeadzone) {
      if (now - this.lastInputTime >= this.inputCooldown) {
        this.onRightStick(rightX, rightY);
        this.lastInputTime = now;
      }
    }
  },

  // Right stick handler
  onRightStick(x, y) {
    const context = this.getNavigationContext();

    // Block input during blocking overlays
    if (context === 'tutorial' || context === 'suspend') {
      return;
    }

    // Determine primary direction
    const isHorizontal = Math.abs(x) > Math.abs(y);

    if (context === 'combat' || context === 'targeting') {
      // In combat: up/down cycles units, left/right cycles sigils
      if (isHorizontal) {
        this.cycleSigil(x > 0 ? 'next' : 'prev');
      } else {
        this.cycleUnit(y > 0 ? 'next' : 'prev');
      }
    } else {
      // In menus: same as d-pad navigation
      if (isHorizontal) {
        this.onDirection(x > 0 ? 'right' : 'left');
      } else {
        this.onDirection(y > 0 ? 'down' : 'up');
      }
    }
  },

  // Left stick handler (context-aware)
  onLeftStick(dir) {
    const context = this.getNavigationContext();

    // Block input during blocking overlays
    if (context === 'tutorial' || context === 'suspend') {
      return;
    }

    if (context === 'targeting') {
      // In targeting mode: cycle through valid targets
      this.cycleTargets(dir === 'right' || dir === 'down' ? 'next' : 'prev');
    } else if (context === 'combat') {
      // In combat: up/down cycles units, left/right cycles sigils
      if (dir === 'up' || dir === 'down') {
        this.cycleUnit(dir === 'down' ? 'next' : 'prev');
      } else {
        this.cycleSigil(dir === 'right' ? 'next' : 'prev');
      }
    } else {
      // In menus: standard spatial navigation
      this.onDirection(dir);
    }
  },

  onButtonPress(buttonIndex) {
    console.log('[GAMEPAD] Button pressed:', buttonIndex, '- Name:', Object.keys(this.BUTTONS).find(k => this.BUTTONS[k] === buttonIndex) || 'unknown');

    // Activate controller mode on any button press
    if (!this.active) {
      console.log('[GAMEPAD] Activating controller mode from button press');
      this.activateControllerMode();
    }

    const context = this.getNavigationContext();
    console.log('[GAMEPAD] Context:', context);

    // Handle blocking overlays - only allow specific actions
    // START button should ALWAYS open menu (except during suspend)
    if (buttonIndex === this.BUTTONS.START && context !== 'suspend') {
      this.openMenu();
      return;
    }

    if (context === 'tutorial') {
      // Tutorial modal: only A button works to dismiss
      if (buttonIndex === this.BUTTONS.A) {
        const tutorialBtn = document.querySelector('.tutorial-modal button, .tutorial-modal .btn');
        if (tutorialBtn) {
          if (typeof SoundFX !== 'undefined' && SoundFX.play) SoundFX.play('click');
          tutorialBtn.click();
        }
      }
      return; // Block all other input
    }

    if (context === 'confirm') {
      // Confirm modal: A for Yes, B for No, D-pad to navigate
      if (buttonIndex === this.BUTTONS.A) {
        const yesBtn = document.querySelector('.confirm-btn-yes');
        if (yesBtn) {
          if (typeof SoundFX !== 'undefined' && SoundFX.play) SoundFX.play('click');
          yesBtn.click();
        }
        return;
      }
      if (buttonIndex === this.BUTTONS.B) {
        const noBtn = document.querySelector('.confirm-btn-no');
        if (noBtn) {
          if (typeof SoundFX !== 'undefined' && SoundFX.play) SoundFX.play('click');
          noBtn.click();
        }
        return;
      }
      // Allow D-pad to navigate between Yes/No
      if (buttonIndex >= this.BUTTONS.DPAD_UP && buttonIndex <= this.BUTTONS.DPAD_RIGHT) {
        const yesBtn = document.querySelector('.confirm-btn-yes');
        const noBtn = document.querySelector('.confirm-btn-no');
        if (this.focusedElement === yesBtn) {
          this.setFocus(noBtn);
        } else {
          this.setFocus(yesBtn);
        }
        if (typeof SoundFX !== 'undefined' && SoundFX.play) SoundFX.play('click');
      }
      return; // Block all other input
    }

    if (context === 'suspend') {
      // Any button resumes from suspend
      if (typeof resumeGame === 'function') resumeGame();
      return;
    }

    switch (buttonIndex) {
      case this.BUTTONS.A:
        this.confirmSelection();
        break;
      case this.BUTTONS.START:
        // START always opens settings menu
        this.openMenu();
        break;
      case this.BUTTONS.B:
        this.goBack();
        break;
      case this.BUTTONS.Y:
        this.toggleTooltip();
        break;
      case this.BUTTONS.DPAD_UP:
      case this.BUTTONS.DPAD_DOWN:
      case this.BUTTONS.DPAD_LEFT:
      case this.BUTTONS.DPAD_RIGHT:
        // D-pad behavior depends on context
        const dir = buttonIndex === this.BUTTONS.DPAD_UP ? 'up' :
                    buttonIndex === this.BUTTONS.DPAD_DOWN ? 'down' :
                    buttonIndex === this.BUTTONS.DPAD_LEFT ? 'left' : 'right';
        if (context === 'targeting') {
          this.cycleTargets(dir === 'right' || dir === 'down' ? 'next' : 'prev');
        } else if (context === 'combat') {
          // D-pad up/down cycles characters, left/right cycles sigils
          if (dir === 'up' || dir === 'down') {
            this.cycleUnit(dir === 'down' ? 'next' : 'prev');
          } else {
            this.cycleSigil(dir === 'right' ? 'next' : 'prev');
          }
        } else {
          this.onDirection(dir);
        }
        break;
      case this.BUTTONS.LB:
        if (context === 'targeting') {
          this.cycleTargets('prev');
        } else if (context === 'combat') {
          this.cycleUnit('prev');
        } else {
          // Page scroll up in modals/scrollable areas
          this.pageScroll('up');
        }
        break;
      case this.BUTTONS.RB:
        if (context === 'targeting') {
          this.cycleTargets('next');
        } else if (context === 'combat') {
          this.cycleUnit('next');
        } else {
          // Page scroll down in modals/scrollable areas
          this.pageScroll('down');
        }
        break;
      case this.BUTTONS.LT:
        this.cycleSigil('prev');
        break;
      case this.BUTTONS.RT:
        this.cycleSigil('next');
        break;
      case this.BUTTONS.X:
        this.switchSides();
        break;
      case this.BUTTONS.SELECT:
        this.autoTarget();
        break;
      case this.BUTTONS.L3:
        // Left stick click: Toggle tooltip on current unit/element
        this.toggleTooltip();
        break;
      case this.BUTTONS.R3:
        // Right stick click: Quick switch sides in combat
        this.switchSides();
        break;
    }
  },

  // Cycle through valid targets (enemies or heroes depending on action)
  cycleTargets(direction) {
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    // Hide tooltip when cycling
    this.hideActiveTooltip();

    // Determine what we're targeting
    let targetCards = [];
    if (typeof S !== 'undefined' && S.pending) {
      if (['Attack', 'Grapple', 'D20_TARGET'].includes(S.pending)) {
        // Targeting enemies
        targetCards = Array.from(document.querySelectorAll('.card.enemy.targetable, .card.enemy:not(.dead)'));
      } else if (['Heal', 'Shield', 'Alpha'].includes(S.pending)) {
        // Targeting heroes
        targetCards = Array.from(document.querySelectorAll('.card.hero.targetable, .card.hero:not(.dead)'));
      }
    }

    if (targetCards.length === 0) {
      // Fallback to all cards
      targetCards = Array.from(document.querySelectorAll('.card.targetable, .card:not(.dead)'));
    }

    if (targetCards.length === 0) return;

    // Find current target
    let currentIdx = targetCards.findIndex(el =>
      el === this.focusedElement || el.contains(this.focusedElement)
    );

    if (currentIdx === -1) {
      currentIdx = 0;
    } else {
      if (direction === 'next') {
        currentIdx = (currentIdx + 1) % targetCards.length;
      } else {
        currentIdx = (currentIdx - 1 + targetCards.length) % targetCards.length;
      }
    }

    this.setFocus(targetCards[currentIdx]);
  },

  onDirection(dir) {
    if (!this.active) {
      this.activateControllerMode();
      return;
    }

    // Block navigation during blocking overlays (except confirm modal navigation handled elsewhere)
    const blocking = this.isBlockingOverlayVisible();
    if (blocking === 'tutorial' || blocking === 'suspend') {
      return; // Don't navigate behind blocking modals
    }

    this.updateFocusableElements();

    // If no focusable elements, try scrolling instead
    if (this.focusableElements.length === 0) {
      if (dir === 'up' || dir === 'down') {
        this.scrollContainer(dir);
      }
      return;
    }

    // Play navigation sound
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    if (!this.focusedElement || !document.body.contains(this.focusedElement)) {
      // No focus or element removed - focus first element if available
      if (this.focusableElements.length > 0) {
        this.setFocus(this.focusableElements[0]);
      }
      return;
    }

    // Find next element in direction using spatial navigation
    const next = this.findNextElement(dir);
    if (next) {
      this.setFocus(next);
    } else if (dir === 'up' || dir === 'down') {
      // No element found in direction - try scrolling
      this.scrollContainer(dir);
    }
  },

  findNextElement(dir) {
    if (!this.focusedElement) return this.focusableElements.length > 0 ? this.focusableElements[0] : null;

    const current = this.focusedElement.getBoundingClientRect();
    const currentCenter = {
      x: current.left + current.width / 2,
      y: current.top + current.height / 2
    };

    let bestCandidate = null;
    let bestScore = Infinity;

    for (const el of this.focusableElements) {
      if (el === this.focusedElement) continue;

      const rect = el.getBoundingClientRect();
      const elCenter = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };

      // Calculate direction vector
      const dx = elCenter.x - currentCenter.x;
      const dy = elCenter.y - currentCenter.y;

      // Check if element is in the right direction
      let inDirection = false;
      let primaryDist = 0;
      let secondaryDist = 0;

      switch (dir) {
        case 'up':
          inDirection = dy < -10;
          primaryDist = Math.abs(dy);
          secondaryDist = Math.abs(dx);
          break;
        case 'down':
          inDirection = dy > 10;
          primaryDist = Math.abs(dy);
          secondaryDist = Math.abs(dx);
          break;
        case 'left':
          inDirection = dx < -10;
          primaryDist = Math.abs(dx);
          secondaryDist = Math.abs(dy);
          break;
        case 'right':
          inDirection = dx > 10;
          primaryDist = Math.abs(dx);
          secondaryDist = Math.abs(dy);
          break;
      }

      if (!inDirection) continue;

      // Score: prefer closer elements, with penalty for off-axis distance
      const score = primaryDist + secondaryDist * 2;

      if (score < bestScore) {
        bestScore = score;
        bestCandidate = el;
      }
    }

    // If no element in direction, wrap around
    if (!bestCandidate) {
      const idx = this.focusableElements.indexOf(this.focusedElement);
      if (dir === 'down' || dir === 'right') {
        bestCandidate = this.focusableElements[(idx + 1) % this.focusableElements.length];
      } else {
        bestCandidate = this.focusableElements[(idx - 1 + this.focusableElements.length) % this.focusableElements.length];
      }
    }

    return bestCandidate;
  },

  setFocus(el) {
    this.clearFocus();
    if (!el) return;

    this.focusedElement = el;
    el.classList.add('controller-focus');

    // Scroll into view if needed
    el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
  },

  clearFocus() {
    if (this.focusedElement) {
      this.focusedElement.classList.remove('controller-focus');
    }
    this.focusedElement = null;
  },

  confirmSelection() {
    // Cooldown after tutorial popup dismissal to prevent click-through
    if (window.tutorialDismissTime && Date.now() - window.tutorialDismissTime < 200) {
      console.log('[GAMEPAD] Ignoring confirm - tutorial popup just dismissed');
      return;
    }

    // If we have targets selected, confirm them directly
    // D20_TARGET uses S.targets, other actions use S.currentInstanceTargets
    const hasD20Targets = typeof S !== 'undefined' && S.pending === 'D20_TARGET' && S.targets && S.targets.length > 0;
    const hasInstanceTargets = typeof S !== 'undefined' && S.pending && S.currentInstanceTargets && S.currentInstanceTargets.length > 0;
    if (hasD20Targets || hasInstanceTargets) {
      if (typeof SoundFX !== 'undefined' && SoundFX.play) {
        SoundFX.play('click');
      }
      if (typeof confirmTargets === 'function') {
        confirmTargets();
      }
      return;
    }

    // If no focused element, try to find and click an obvious primary action
    if (!this.focusedElement) {
      const primaryBtn = this.findPrimaryAction();
      if (primaryBtn) {
        if (typeof SoundFX !== 'undefined' && SoundFX.play) {
          SoundFX.play('click');
        }
        primaryBtn.click();
        setTimeout(() => this.updateFocusableElements(), 100);
        return;
      }
      // No primary action found, just focus first element
      this.updateFocusableElements();
      if (this.focusableElements.length > 0) {
        this.setFocus(this.focusableElements[0]);
      }
      return;
    }

    // Play confirm sound
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    // Trigger click on focused element
    this.focusedElement.click();

    // Update focus after action (DOM might have changed)
    setTimeout(() => {
      this.updateFocusableElements();
      if (this.focusableElements.length > 0 && !document.body.contains(this.focusedElement)) {
        // Use smart default focus instead of just the first element
        const bestFocus = this.findBestDefaultFocus();
        this.setFocus(bestFocus || this.focusableElements[0]);
      }
      this.updatePrompts();
    }, 100);
  },

  goBack() {
    // Play back sound
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    // Check for confirm modal (B button cancels)
    if (typeof confirmModalCallback === 'function') {
      confirmModalCallback();
      return;
    }

    // Check for modal/menu close buttons
    const closeBtn = document.querySelector('.modal-container .btn[onclick*="close"]') ||
                     document.querySelector('.modal-container .btn[onclick*="Close"]') ||
                     document.querySelector('[onclick*="closeSettingsMenu"]') ||
                     document.querySelector('[onclick*="closeDebugMenu"]') ||
                     document.querySelector('[onclick*="closeFAQ"]') ||
                     document.querySelector('[onclick*="closeSigilarium"]');

    if (closeBtn) {
      closeBtn.click();
      setTimeout(() => this.updateFocusableElements(), 100);
      return;
    }

    // Check for any visible "Back" or "Close" button
    const backBtn = document.querySelector('.btn[onclick*="Back"]') ||
                    document.querySelector('.btn[onclick*="back"]') ||
                    document.querySelector('.btn.secondary[onclick]') ||
                    document.querySelector('[onclick*="mainTitlePage"]') ||
                    document.querySelector('[onclick*="showRibbleton"]');

    if (backBtn && backBtn.offsetParent !== null) {
      backBtn.click();
      setTimeout(() => this.updateFocusableElements(), 100);
      return;
    }

    // Hero selection - go back to Ribbleton
    if (document.getElementById('hero-select-container')) {
      if (typeof showRibbleton === 'function') {
        showRibbleton();
        return;
      }
    }

    // Death screen - go to Ribbleton (with confirmation if gold remaining)
    const deathScreen = document.querySelector('[onclick*="purchaseSigilUpgrade"]');
    if (deathScreen) {
      const ribbletonBtn = document.querySelector('[onclick*="showRibbleton"]');
      if (ribbletonBtn) {
        ribbletonBtn.click();
        return;
      }
    }

    // If in combat with pending action, call cancelAction
    if (typeof S !== 'undefined' && S.pending && typeof cancelAction === 'function') {
      cancelAction();
      setTimeout(() => this.updateFocusableElements(), 100);
      return;
    }

    // Neutral encounter - look for continue or skip button
    const neutralContinue = document.querySelector('.neutral-content .btn:not(.secondary)');
    if (neutralContinue && neutralContinue.offsetParent !== null) {
      // Don't auto-click continue on neutral, just focus it
      this.setFocus(neutralContinue);
      return;
    }
  },

  openMenu() {
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    if (typeof showSettingsMenu === 'function') {
      showSettingsMenu();
      setTimeout(() => {
        this.updateFocusableElements();
        if (this.focusableElements.length > 0) {
          this.setFocus(this.focusableElements[0]);
        }
      }, 100);
    }
  },

  // Helper to hide any active tooltip
  hideActiveTooltip() {
    if (this.tooltipVisible) {
      if (typeof hideTooltip === 'function') hideTooltip();
      if (this.tooltipElement) {
        this.tooltipElement.classList.remove('controller-tooltip-active');
      }
      this.tooltipVisible = false;
      this.tooltipElement = null;
    }
  },

  // Show tooltip for a sigil element
  showSigilTooltip(sigilEl) {
    if (!sigilEl) return;

    const mouseEnter = sigilEl.getAttribute('onmouseenter');
    if (mouseEnter) {
      const match = mouseEnter.match(/showTooltip\('([^']+)'/);
      if (match && typeof showTooltip === 'function') {
        const sigilName = match[1];
        const levelMatch = mouseEnter.match(/,\s*(\d+)\)/);
        const level = levelMatch ? parseInt(levelMatch[1]) : undefined;
        showTooltip(sigilName, sigilEl, level);
        this.tooltipVisible = true;
        this.tooltipElement = sigilEl;
        sigilEl.classList.add('controller-tooltip-active');
      }
    }
  },

  // Toggle tooltip on focused element (Y button)
  toggleTooltip() {
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    // If tooltip is already visible, hide it
    if (this.tooltipVisible) {
      this.hideActiveTooltip();
      return;
    }

    // Try to show tooltip for focused element
    if (!this.focusedElement) return;

    // Check if focused element is a sigil
    const sigilEl = this.focusedElement.classList.contains('sigil') ? this.focusedElement :
                    this.focusedElement.querySelector('.sigil');

    if (sigilEl) {
      this.showSigilTooltip(sigilEl);
    }
  },

  // Cycle between units: heroes and enemies (LB/RB/D-pad left/right)
  cycleUnit(direction) {
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    // Hide any active tooltip when switching units
    this.hideActiveTooltip();

    // Collect all unit cards (heroes first, then enemies)
    const heroCards = Array.from(document.querySelectorAll('.card.hero'));
    const enemyCards = Array.from(document.querySelectorAll('.card.enemy'));
    const allUnits = [...heroCards, ...enemyCards];

    if (allUnits.length === 0) return;

    // Find current focused unit
    let currentIdx = allUnits.findIndex(el =>
      el === this.focusedElement || el.contains(this.focusedElement)
    );

    if (currentIdx === -1) {
      // Not on a unit, start with first
      currentIdx = 0;
    } else {
      // Move to next/prev
      if (direction === 'next') {
        currentIdx = (currentIdx + 1) % allUnits.length;
      } else {
        currentIdx = (currentIdx - 1 + allUnits.length) % allUnits.length;
      }
    }

    this.currentUnitIndex = currentIdx;
    this.currentSigilIndex = 0; // Reset sigil index when changing units
    this.setFocus(allUnits[currentIdx]);
  },

  // Cycle through sigils on the currently focused unit (LT/RT)
  cycleSigil(direction) {
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    // Find the card containing the focused element or focus a card first
    let card = this.focusedElement;
    if (!card) return;

    // If focused element is not a card, find parent card
    if (!card.classList.contains('card')) {
      card = card.closest('.card');
    }
    if (!card) return;

    // Get all sigils in this card
    const sigils = Array.from(card.querySelectorAll('.sigil'));
    if (sigils.length === 0) return;

    // Find current sigil index
    let currentIdx = sigils.findIndex(el =>
      el === this.focusedElement || el.classList.contains('controller-tooltip-active')
    );

    if (currentIdx === -1) {
      currentIdx = 0;
    } else {
      if (direction === 'next') {
        currentIdx = (currentIdx + 1) % sigils.length;
      } else {
        currentIdx = (currentIdx - 1 + sigils.length) % sigils.length;
      }
    }

    this.currentSigilIndex = currentIdx;
    const targetSigil = sigils[currentIdx];

    // Hide previous tooltip
    if (this.tooltipVisible && this.tooltipElement) {
      if (typeof hideTooltip === 'function') hideTooltip();
      this.tooltipElement.classList.remove('controller-tooltip-active');
    }

    // Show tooltip for new sigil
    const mouseEnter = targetSigil.getAttribute('onmouseenter');
    if (mouseEnter) {
      const match = mouseEnter.match(/showTooltip\('([^']+)'/);
      if (match && typeof showTooltip === 'function') {
        const sigilName = match[1];
        const levelMatch = mouseEnter.match(/,\s*(\d+)\)/);
        const level = levelMatch ? parseInt(levelMatch[1]) : undefined;
        showTooltip(sigilName, targetSigil, level);
        this.tooltipVisible = true;
        this.tooltipElement = targetSigil;
        targetSigil.classList.add('controller-tooltip-active');
      }
    }

    // If the sigil is clickable, focus it
    if (targetSigil.classList.contains('clickable') || targetSigil.hasAttribute('onclick')) {
      this.setFocus(targetSigil);
    }
  },

  // Switch sides: jump to the unit across from current selection (X button)
  switchSides() {
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    // Hide tooltip when switching
    this.hideActiveTooltip();

    const context = this.getNavigationContext();
    if (context !== 'combat' && context !== 'targeting') return;

    // Find current focused card
    let currentCard = this.focusedElement;
    if (!currentCard) return;
    if (!currentCard.classList.contains('card')) {
      currentCard = currentCard.closest('.card');
    }
    if (!currentCard) return;

    const isHero = currentCard.classList.contains('hero');
    const isEnemy = currentCard.classList.contains('enemy');

    if (!isHero && !isEnemy) return;

    // Get all cards on both sides
    const heroCards = Array.from(document.querySelectorAll('.card.hero'));
    const enemyCards = Array.from(document.querySelectorAll('.card.enemy'));

    if (isHero) {
      // Currently on hero, switch to enemy across or nearest
      const heroIdx = heroCards.indexOf(currentCard);
      if (enemyCards.length === 0) return;
      // Try to find enemy at same lane index, or nearest
      const targetIdx = Math.min(heroIdx, enemyCards.length - 1);
      this.setFocus(enemyCards[targetIdx]);
    } else {
      // Currently on enemy, switch to hero across or nearest
      const enemyIdx = enemyCards.indexOf(currentCard);
      if (heroCards.length === 0) return;
      // Try to find hero at same lane index, or nearest
      const targetIdx = Math.min(enemyIdx, heroCards.length - 1);
      this.setFocus(heroCards[targetIdx]);
    }
  },

  // Auto target: automatically select targets using AI logic (SELECT button)
  // Press once to auto-select, press again to confirm
  autoTarget() {
    if (typeof SoundFX !== 'undefined' && SoundFX.play) {
      SoundFX.play('click');
    }

    // Only works when we have a pending action that needs targets
    if (typeof S === 'undefined' || !S.pending) {
      toast('No action selected - choose a sigil first!', 1500);
      return;
    }

    // If targets are already selected, confirm them on second press
    if (S.currentInstanceTargets && S.currentInstanceTargets.length > 0) {
      if (typeof confirmTargets === 'function') {
        confirmTargets();
      }
      return;
    }

    // Show first-time tutorial
    if (typeof showTutorialPop === 'function' && typeof S !== 'undefined' && !S.tutorialFlags.auto_target_intro) {
      S.tutorialFlags.auto_target_intro = true;
      if (typeof savePermanent === 'function') savePermanent();
      toast('Press SELECT again to confirm, or ‚í∑ to cancel', 2500);
    }

    const pending = S.pending;
    const heroIdx = S.activeIdx;
    const hero = S.heroes[heroIdx];
    if (!hero) return;

    // Determine how many targets we need
    let targetsNeeded = 1;
    if (S.instancesRemaining > 0) {
      // Multi-instance action, need targets for current instance
      targetsNeeded = 1; // Usually 1 per instance for expand
    }

    // Calculate total targets based on expand
    // Use getTargetsPerInstance if available (respects Mage/Healer bonus properly)
    let totalTargets = 1;
    if (typeof getTargetsPerInstance === 'function') {
      totalTargets = getTargetsPerInstance(pending, heroIdx);
    } else {
      // Fallback: manually calculate (shouldn't normally be needed)
      const expandLevel = typeof getLevel === 'function' ? getLevel('Expand', heroIdx) : 0;
      totalTargets = 1 + expandLevel;
    }
    const targetsNeeded = Math.max(1, totalTargets - (S.currentInstanceTargets ? S.currentInstanceTargets.length : 0));

    // Different targeting logic based on action type
    if (['Attack', 'Grapple', 'D20_TARGET'].includes(pending)) {
      // Target enemies - prioritize lowest HP, then by lane proximity
      const aliveEnemies = S.enemies.filter(e => e.h > 0);
      if (aliveEnemies.length === 0) {
        toast('No valid enemy targets!', 1500);
        return;
      }

      // Sort by HP (lowest first), then by lane proximity to acting hero
      aliveEnemies.sort((a, b) => {
        if (a.h !== b.h) return a.h - b.h; // Lowest HP first
        // If same HP, prefer enemies in same lane
        const aLaneDist = Math.abs((a.li !== undefined ? a.li : 0) - heroIdx);
        const bLaneDist = Math.abs((b.li !== undefined ? b.li : 0) - heroIdx);
        return aLaneDist - bLaneDist;
      });

      // Click targets up to targetsNeeded
      const toTarget = aliveEnemies.slice(0, targetsNeeded);
      S.autoSelectInProgress = true; // Prevent auto-confirm during auto-select
      for (const enemy of toTarget) {
        const card = document.getElementById(enemy.id);
        if (card) {
          card.click();
        }
      }
      S.autoSelectInProgress = false;

      if (toTarget.length > 0) {
        toast(`Auto-targeted ${toTarget.length} enem${toTarget.length === 1 ? 'y' : 'ies'}!`, 1200);
      }

    } else if (['Heal', 'Shield', 'Alpha'].includes(pending)) {
      // Target heroes - prioritize based on action
      let aliveHeroes = S.heroes.filter(h => h.h > 0 || h.ls); // Include Last Stand heroes for heal

      if (aliveHeroes.length === 0) {
        toast('No valid hero targets!', 1500);
        return;
      }

      if (pending === 'Heal') {
        // For heal: prioritize Last Stand heroes, then lowest HP ratio
        aliveHeroes.sort((a, b) => {
          // Last Stand heroes first
          if (a.ls && !b.ls) return -1;
          if (!a.ls && b.ls) return 1;
          // Then by HP ratio (most damaged first)
          const aRatio = a.h / a.m;
          const bRatio = b.h / b.m;
          return aRatio - bRatio;
        });
      } else if (pending === 'Shield') {
        // For shield: prioritize lowest current shield, then lowest HP
        aliveHeroes.sort((a, b) => {
          const aShield = a.sh || 0;
          const bShield = b.sh || 0;
          if (aShield !== bShield) return aShield - bShield; // Lowest shield first
          return a.h - b.h; // Then lowest HP
        });
      } else if (pending === 'Alpha') {
        // For Alpha: prioritize highest POW heroes (for multiplying damage)
        aliveHeroes.sort((a, b) => b.p - a.p);
      }

      // Click targets up to targetsNeeded
      const toTarget = aliveHeroes.slice(0, targetsNeeded);
      S.autoSelectInProgress = true; // Prevent auto-confirm during auto-select
      for (const hero of toTarget) {
        const card = document.getElementById(hero.id);
        if (card) {
          card.click();
        }
      }
      S.autoSelectInProgress = false;

      if (toTarget.length > 0) {
        toast(`Auto-targeted ${toTarget.length} hero${toTarget.length === 1 ? '' : 'es'}!`, 1200);
      }

    } else {
      toast('Auto-target not available for this action', 1500);
    }
  },

  // Save focus state before DOM updates
  saveFocusState() {
    if (this.focusedElement) {
      this.lastFocusedId = this.focusedElement.id || null;
      // Also try to save a descriptor for non-id elements
      if (!this.lastFocusedId && this.focusedElement.classList.contains('card')) {
        const heroId = this.focusedElement.id;
        if (heroId) this.lastFocusedId = heroId;
      }
    }
  },

  // Restore focus after DOM updates
  restoreFocusState() {
    if (!this.active) return;

    // Always hide tooltips on DOM changes to prevent persistence issues
    this.hideActiveTooltip();

    setTimeout(() => {
      this.updateFocusableElements();

      // Try to restore by ID
      if (this.lastFocusedId) {
        const el = document.getElementById(this.lastFocusedId);
        if (el && this.focusableElements.includes(el)) {
          this.setFocus(el);
          this.updatePrompts();
          return;
        }
      }

      // Use smart default focus instead of just the first element
      if (this.focusableElements.length > 0) {
        const bestFocus = this.findBestDefaultFocus();
        this.setFocus(bestFocus || this.focusableElements[0]);
      }

      this.updatePrompts();
    }, 50);
  },

  updateFocusableElements() {
    // Find all focusable elements in order of appearance
    const selectors = [
      // Buttons
      '.btn:not(.disabled)',
      // Choice options
      '.choice',
      // Clickable cards (heroes, enemies)
      '.card[onclick]',
      '.card.hero:not(.acted)',
      '.card.enemy.targetable',
      '.card.hero.targetable',
      // Clickable sigils
      '.sigil.clickable',
      '.sigil[onclick]',
      // Modal checkboxes
      '.modal-checkbox-label',
      // Header buttons
      '.header button',
      // Generic clickable elements
      '[onclick]:not(script)',
      // Links
      'a[href]'
    ];

    const elements = new Set();

    for (const selector of selectors) {
      document.querySelectorAll(selector).forEach(el => {
        // Check if element is visible and not in rotate prompt or modal overlay
        if (el.offsetParent !== null &&
            !el.closest('#rotatePrompt') &&
            !el.classList.contains('disabled') &&
            !el.classList.contains('modal-overlay') &&
            !el.classList.contains('confirm-modal-overlay') &&
            el.style.display !== 'none' &&
            el.style.visibility !== 'hidden') {
          elements.add(el);
        }
      });
    }

    // Sort by visual position (top-to-bottom, left-to-right)
    this.focusableElements = Array.from(elements).sort((a, b) => {
      const rectA = a.getBoundingClientRect();
      const rectB = b.getBoundingClientRect();

      // Group by approximate rows (within 30px vertical)
      const rowDiff = Math.abs(rectA.top - rectB.top);
      if (rowDiff > 30) {
        return rectA.top - rectB.top;
      }
      return rectA.left - rectB.left;
    });
  },

  // Find the best element to focus by default based on context
  // This prevents focusing emoji buttons and other decorative elements
  findBestDefaultFocus() {
    const context = this.getNavigationContext();

    // For blocking overlays, focus the appropriate button
    if (context === 'tutorial') {
      // Focus the "Got it!" button in tutorial modal
      const tutorialBtn = document.querySelector('.tutorial-modal button, .tutorial-modal .btn');
      if (tutorialBtn) return tutorialBtn;
    }

    if (context === 'confirm') {
      // Focus the Yes button in confirm modal
      const yesBtn = document.querySelector('.confirm-btn-yes');
      if (yesBtn) return yesBtn;
    }

    // For combat, focus the first hero's first clickable sigil or the hero card itself
    if (context === 'combat' || context === 'targeting') {
      // First, try to find the first hero card
      const heroCards = document.querySelectorAll('.card.hero:not(.acted)');
      if (heroCards.length > 0) {
        // Try to find a clickable sigil on the first hero
        const firstHero = heroCards[0];
        const clickableSigil = firstHero.querySelector('.sigil.clickable, .sigil[onclick]');
        if (clickableSigil) return clickableSigil;
        // Otherwise focus the hero card itself
        return firstHero;
      }
      // Fallback to any hero card
      const anyHero = document.querySelector('.card.hero');
      if (anyHero) return anyHero;
    }

    // For modals (sigilarium, FAQ, etc), skip emoji buttons and header icons
    if (context === 'modal') {
      const modal = document.querySelector('.modal-container');
      if (modal) {
        // Look for primary action buttons first (not emoji, not header)
        const primaryBtns = modal.querySelectorAll('.btn:not(.emoji-btn):not([style*="position:absolute"])');
        for (const btn of primaryBtns) {
          const text = btn.textContent || '';
          // Skip buttons that are just emojis or single characters
          if (text.length > 2 && !/^[\u{1F300}-\u{1F9FF}]$/u.test(text.trim())) {
            return btn;
          }
        }
        // Try to find any non-emoji button
        const anyBtn = modal.querySelector('.btn:not(.emoji-btn)');
        if (anyBtn) return anyBtn;
      }
    }

    // For menu screens, look for primary action
    const primaryAction = this.findPrimaryAction();
    if (primaryAction) return primaryAction;

    // Filter out emoji-only buttons and header icons from default focus
    for (const el of this.focusableElements) {
      const text = (el.textContent || '').trim();
      // Skip elements that are:
      // - Just emojis (1-2 characters that are emoji)
      // - In the header
      // - Position absolute (usually close buttons)
      const isEmojiOnly = text.length <= 2 && /^[\u{1F300}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]+$/u.test(text);
      const isHeader = el.closest('.header, .modal-header, [style*="position:absolute"]');
      const isCloseBtn = el.classList.contains('close-btn') || text === '‚úï' || text === '√ó';

      if (!isEmojiOnly && !isHeader && !isCloseBtn) {
        return el;
      }
    }

    // Last resort: return first focusable
    return this.focusableElements[0];
  },

  // Find an obvious primary action button (Continue, Next, OK, PLAY, etc.)
  findPrimaryAction() {
    // Priority order of selectors to find primary action
    const primarySelectors = [
      // Title screen PLAY button
      '.title-play-btn',
      // Save slot continue/new game buttons
      '[onclick*="continueSlot"]',
      '[onclick*="createNewSlot"]',
      // Hero selection start button
      '#start',
      '[onclick*="start()"]',
      // Narrative continue buttons
      '[onclick*="continueNarrative"]',
      '[onclick*="transitionToPortalInvasion"]',
      // Next floor / level up
      '[onclick*="nextFloor"]',
      '[onclick*="levelUp"]',
      // Ribbleton portal
      '[onclick*="showRibbleton"]',
      // Common advancement buttons by text content
      'button.btn:not(.secondary)',
      '.btn:not(.secondary):not(.title-credits-btn)',
    ];

    // Common action text patterns
    const actionPatterns = [
      /continue/i,
      /next\s*floor/i,
      /^play$/i,
      /start/i,
      /delve/i,
      /begin/i,
      /^ok$/i,
      /^\s*‚ñ∂/,  // Play icon
      /place\s*figurine/i,
      /return/i,
    ];

    // First try specific selectors
    for (const selector of primarySelectors) {
      const btn = document.querySelector(selector);
      if (btn && btn.offsetParent !== null && !btn.classList.contains('disabled')) {
        // For generic .btn selector, check text content matches action patterns
        if (selector.includes(':not')) {
          const text = btn.textContent || '';
          for (const pattern of actionPatterns) {
            if (pattern.test(text)) {
              return btn;
            }
          }
        } else {
          return btn;
        }
      }
    }

    // Try finding any visible button with action text
    const allBtns = document.querySelectorAll('.btn:not(.disabled):not(.secondary), button:not(.disabled)');
    for (const btn of allBtns) {
      if (btn.offsetParent === null) continue; // Not visible
      const text = btn.textContent || '';
      for (const pattern of actionPatterns) {
        if (pattern.test(text)) {
          return btn;
        }
      }
    }

    return null;
  },

  // Find the nearest scrollable container
  findScrollableContainer() {
    // Check for modal containers first (FAQ, Sigilarium, etc.)
    const modal = document.querySelector('.modal-container');
    if (modal && modal.scrollHeight > modal.clientHeight) {
      return modal;
    }

    // Check neutral-left panel
    const neutralLeft = document.querySelector('.neutral-left');
    if (neutralLeft && neutralLeft.scrollHeight > neutralLeft.clientHeight) {
      return neutralLeft;
    }

    // Check game area
    const gameArea = document.querySelector('.game-area');
    if (gameArea && gameArea.scrollHeight > gameArea.clientHeight) {
      return gameArea;
    }

    return null;
  },

  // Scroll a container
  scrollContainer(direction, amount = 100) {
    const container = this.findScrollableContainer();
    if (!container) return false;

    const scrollAmount = direction === 'up' ? -amount : amount;
    const beforeScroll = container.scrollTop;
    container.scrollBy({ top: scrollAmount, behavior: 'smooth' });

    // Return true if we actually scrolled
    return true;
  },

  // Page scroll (larger amount for LB/RB)
  pageScroll(direction) {
    const container = this.findScrollableContainer();
    if (!container) return false;

    const pageAmount = container.clientHeight * 0.8; // 80% of visible height
    return this.scrollContainer(direction, pageAmount);
  },

  updatePrompts() {
    const promptsEl = document.getElementById('controllerPrompts');
    if (!promptsEl) return;

    // Determine screen context
    const hasModal = document.querySelector('.modal-container');
    const inCombat = typeof S !== 'undefined' && S.heroes && S.heroes.length > 0 && S.enemies && S.enemies.length > 0;
    const hasPending = typeof S !== 'undefined' && S.pending;
    const hasCards = document.querySelectorAll('.card').length > 0;
    const isTitleScreen = !!document.querySelector('.title-screen');
    const isHeroSelect = !!document.getElementById('hero-select-container');
    const isDeathScreen = !!document.querySelector('[onclick*="purchaseSigilUpgrade"]');
    const isNeutralScreen = !!document.querySelector('.neutral-content');
    const isLevelUp = !!document.querySelector('[onclick*="levelUpMenu"]') || !!document.querySelector('[onclick*="nextFloor"]');

    let prompts = [];

    // Title screen - simple prompts
    if (isTitleScreen) {
      prompts = [
        { btn: 'a', label: 'Play' },
        { btn: 'dpad', label: 'Navigate' }
      ];
    }
    // Hero selection
    else if (isHeroSelect) {
      prompts = [
        { btn: 'dpad', label: 'Select Hero' },
        { btn: 'a', label: 'Toggle' },
        { btn: 'b', label: 'Back' },
        { btn: 'start', label: 'Start Game' }
      ];
    }
    // Combat
    else if (inCombat && !hasModal) {
      if (hasPending) {
        prompts = [
          { btn: 'dpad', label: 'Target' },
          { btn: 'a', label: 'Confirm' },
          { btn: 'b', label: 'Cancel' },
          { btn: 'select', label: 'Auto' }
        ];
      } else {
        prompts = [
          { btn: 'dpad', label: 'Navigate' },
          { btn: 'a', label: 'Select' },
          { btn: 'lb', label: '‚ÜëHero' },
          { btn: 'rb', label: 'Hero‚Üì' },
          { btn: 'x', label: 'Switch' },
          { btn: 'y', label: 'Info' }
        ];
      }
    }
    // Death screen
    else if (isDeathScreen) {
      prompts = [
        { btn: 'dpad', label: 'Browse' },
        { btn: 'a', label: 'Purchase' },
        { btn: 'b', label: 'Leave' },
        { btn: 'y', label: 'Info' }
      ];
    }
    // Neutral encounters
    else if (isNeutralScreen) {
      prompts = [
        { btn: 'dpad', label: 'Choose' },
        { btn: 'a', label: 'Select' },
        { btn: 'b', label: 'Skip' }
      ];
    }
    // Level up
    else if (isLevelUp) {
      prompts = [
        { btn: 'dpad', label: 'Choose' },
        { btn: 'a', label: 'Select' },
        { btn: 'b', label: 'Skip' }
      ];
    }
    // Modal/popup (FAQ, Sigilarium, etc.)
    else if (hasModal) {
      const isScrollable = hasModal.scrollHeight > hasModal.clientHeight;
      prompts = [
        { btn: 'dpad', label: 'Navigate' },
        { btn: 'a', label: 'Confirm' },
        { btn: 'b', label: 'Close' }
      ];
      if (isScrollable) {
        prompts.push({ btn: 'lb', label: '‚ÜëScroll' });
        prompts.push({ btn: 'rb', label: 'Scroll‚Üì' });
      }
    }
    // Default
    else {
      prompts = [
        { btn: 'dpad', label: 'Navigate' },
        { btn: 'a', label: 'Select' },
        { btn: 'b', label: 'Back' },
        { btn: 'start', label: 'Menu' }
      ];
    }

    // Build HTML
    promptsEl.innerHTML = prompts.map(p => {
      const displayLabel = {
        'dpad': '‚úö',
        'lb': 'LB',
        'rb': 'RB',
        'lt': 'LT',
        'rt': 'RT',
        'start': '‚ò∞',
        'x': 'X',
        'y': 'Y',
        'select': '‚ä°',
        'a': '‚í∂',
        'b': '‚í∑'
      }[p.btn] || p.btn.toUpperCase();

      return `<div class="controller-prompt"><span class="controller-btn ${p.btn}">${displayLabel}</span> ${p.label}</div>`;
    }).join('');
  },

  // Show helpful setup guide for Steam Deck users when no gamepad is detected
  showSteamControllerSetupHelp() {
    // Check if this looks like it might be Steam Deck or similar (touch events available)
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    if (!isTouchDevice) {
      console.log('[GAMEPAD] Not showing setup help - not a touch device');
      return;
    }

    const overlay = document.createElement('div');
    overlay.className = 'tutorial-modal-backdrop';
    overlay.innerHTML = `
<div class="tutorial-modal" style="max-width:450px">
<h2 style="font-size:1.4rem;margin-bottom:1rem;text-align:center;color:#f59e0b">üéÆ Controller Detected</h2>
<p style="font-size:0.95rem;line-height:1.5;margin-bottom:1rem;text-align:center">
Controller support is enabled! Use your gamepad to navigate menus and play.
</p>
<p style="font-size:0.85rem;text-align:center;opacity:0.8;margin-bottom:1rem">
Check <strong>Gameplay Settings ‚Üí Controls Guide</strong> for button mappings.
</p>
<div style="display:flex;gap:0.75rem;justify-content:center">
<button class="btn" onclick="dismissSteamSetupHelp()" style="background:#22c55e;padding:0.6rem 1.2rem">Got it!</button>
</div>
</div>`;
    document.body.appendChild(overlay);
  }
};

// Global function to dismiss the Steam setup help
function dismissSteamSetupHelp() {
  const overlay = document.querySelector('.tutorial-modal-backdrop');
  if (overlay) overlay.remove();

  // Mark as shown so it doesn't appear again
  if (typeof S !== 'undefined') {
    S.tutorialFlags.steam_controller_setup = true;
    if (typeof savePermanent === 'function') savePermanent();
  }
}


// ===== INIT =====
window.onload = () => {
debugLog('[FROGGLE] window.onload fired');
// Check for last used slot
const lastSlot = localStorage.getItem('froggle8_current_slot');
if(lastSlot) {
const slot = parseInt(lastSlot);
debugLog('[FROGGLE] Found last used slot:', slot);
// Try to load slot-specific permanent data
const permData = localStorage.getItem(`froggle8_permanent_slot${slot}`);
if(permData) {
try {
const j = JSON.parse(permData);
S.gold = j.gold || 0;
S.goingRate = j.goingRate || 1;
S.startingXP = j.startingXP || 0;
S.sig = j.sig || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.sigUpgradeCounts = j.sigUpgradeCounts || {Attack:0, Shield:0, Heal:0, D20:0, Expand:0, Grapple:0, Ghost:0, Asterisk:0, Star:0, Alpha:0};
S.ancientStatueDeactivated = j.ancientStatueDeactivated || false;
S.ghostBoysConverted = j.ghostBoysConverted || false;
S.pedestal = j.pedestal || [];
S.hasReachedFloor20 = j.hasReachedFloor20 || false;
S.fuUnlocked = j.fuUnlocked || false;
S.tapoUnlocked = j.tapoUnlocked || false;
S.runNumber = j.runNumber || 1;
S.runsAttempted = j.runsAttempted || 0;
S.helpTipsDisabled = j.helpTipsDisabled || false;
S.tooltipsDisabled = j.tooltipsDisabled || false;
S.usedDeathQuotes = j.usedDeathQuotes || [];
S.controllerDisabled = j.controllerDisabled || false;
if(j.tutorialFlags) Object.assign(S.tutorialFlags, j.tutorialFlags);
S.currentSlot = slot;
debugLog('[FROGGLE] Loaded slot-specific permanent data');
} catch(e) {
console.warn('[FROGGLE] Failed to parse slot permanent data:', e);
loadPermanent(); // Fallback to old format
}
} else {
loadPermanent(); // No slot data, use old format
}
} else {
loadPermanent(); // No last slot, use old format
}
debugLog('[FROGGLE] loadPermanent complete, S.runNumber:', S.runNumber, 'S.helpTipsDisabled:', S.helpTipsDisabled);
initToastLog(); // Initialize toast log UI
initSuspendSystem(); // Initialize autosave and suspend/resume system
GamepadController.init(); // Initialize Steam Deck / controller support
mainTitlePage();
debugLog('[FROGGLE] mainTitlePage called');
};

// Global error handler for image loading failures
window.addEventListener('error', (e) => {
if(e.target && e.target.tagName === 'IMG') {
console.error('[FROGGLE] IMAGE LOAD FAILED:', e.target.src);
console.error('[FROGGLE] Current location:', window.location.href);
console.error('[FROGGLE] Image path:', e.target.getAttribute('src'));
} else if(e.message) {
console.error('[FROGGLE] JAVASCRIPT ERROR:', e.message);
console.error('[FROGGLE] File:', e.filename, 'Line:', e.lineno, 'Col:', e.colno);
console.error('[FROGGLE] Stack:', e.error ? e.error.stack : 'No stack trace');
}
}, true);

// Catch unhandled promise rejections
window.addEventListener('unhandledrejection', (e) => {
console.error('[FROGGLE] UNHANDLED PROMISE REJECTION:', e.reason);
});

</script>
</body>
</html>